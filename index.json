[{"categories":["é—²æ‰¯"],"content":"è¿™ä¸ªä¸œè¥¿å¾ˆå¤æ‚ï¼Œä¼¼ä¹ä¹Ÿä¸å¥½æ‰¾åˆ°ã€Œæ°å¥½è¶³å¤Ÿã€çš„èµ„æ–™ï¼Œè¦ä¹ˆè®²å¾—å¤ªæµ…ï¼Œè¦ä¹ˆå°±åªèƒ½å»ç¿»ç¡¬ä»¶æ–‡æ¡£ã€‚ä½†æ˜¯ä»…ä»…ä¸ºäº†ä¸€ä¸ªè¦æ±‚æ¨¡ç³Šè€Œä¸”å¹¶ä¸å¥½ç©çš„ä½œä¸šåšåˆ°é‚£ç§åœ°æ­¥ç¡®å®æ˜¯æœ‰ç‚¹æ²¡æ„æ€ï¼Œä¸è¿‡è¿˜å¥½å®ƒè§£ç­”äº†æˆ‘çš„ç–‘é—®ã€‚ä¸‹é¢è¿™äº›å†…å®¹ç›®çš„åªæ˜¯ç»™æˆ‘è¶³å¤Ÿçš„åº•æ°”å»å¤„ç†ä½œä¸šä¸­å¹¶ä¸æ˜ç¡®çš„éƒ¨åˆ†ã€‚æ›´åŠ è¯¦ç»†æˆ–è€…ç²—ç•¥çš„å†…å®¹åœ¨ç½‘ä¸Šæœ‰å¾ˆå¤šä»‹ç»ï¼Œè‡³å°‘çŸ­æœŸå†…ä¸ä¼šå‡ºç°åœ¨è¿™é‡Œã€‚ ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:0:0","tags":null,"title":"ç”±å†…å­˜åˆ†é¡µçœ‹CPUç³»ç»Ÿç•Œé¢","uri":"/2020/05/paging-introduction/"},{"categories":["é—²æ‰¯"],"content":"åˆ†é¡µ ç°ä»£CPUåŸºæœ¬ä¸Šåªæ”¯æŒåˆ†é¡µå¼çš„å†…å­˜ç®¡ç†æ–¹å¼äº†ã€‚å…·ä½“ä¸ºå°†å†…å­˜åˆ’åˆ†ä¸ºå¤§å°ç›¸åŒçš„å—ï¼Œå¯¹äºä¸€ä¸ªâ€œè¿›ç¨‹â€çš„è™šæ‹Ÿåœ°å€ï¼Œç»´æŠ¤å…¶ï¼ˆè¿ç»­çš„ï¼‰æ¯å—è™šæ‹Ÿåœ°å€åˆ°ï¼ˆå¯èƒ½å¹¶ä¸è¿ç»­ï¼‰ç‰©ç†åœ°å€çš„è½¬æ¢è¡¨ã€‚è¿™å¼ è¡¨æ˜¾ç„¶è¶³å¤Ÿå¤§ï¼Œå°±ä¹Ÿå­˜åœ¨å†…å­˜é‡Œã€‚ é‚£ä¹ˆé—®é¢˜å°±æ˜¯ï¼Œåœ¨è¿™æ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œåˆ°åº•ä»å“ªä¸€éƒ¨åˆ†å¼€å§‹æ˜¯æ“ä½œç³»ç»Ÿçš„äº‹æƒ…ã€‚äº‹å®ä¸Šï¼Œè™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢ä»¥åŠåç»­çš„è®¿é—®ã€è¯»å–/å†™å…¥æ˜¯ç¡¬ä»¶çš„å·¥ä½œï¼Œå†…å­˜åˆ†é…ã€é¡µè¡¨å­˜å‚¨æ˜¯æ“ä½œç³»ç»Ÿçš„äº‹ã€‚è¿æ¥è¿™ä¸¤è€…çš„æ¡¥æ¢æ˜¯é¡µè¡¨æ ¼å¼çš„çº¦å®šå’Œä¸€ä¸ªç‰¹æ®Šçš„å¯„å­˜å™¨ã€‚æ“ä½œç³»ç»Ÿåœ¨è°ƒåº¦è¿›ç¨‹è¿è¡Œå‰ï¼Œå°†é¡µè¡¨çš„åœ°å€é€ç»™ç‰¹æ®Šå¯„å­˜å™¨ï¼Œç”±ç¡¬ä»¶ç›´æ¥æŒ‰çº¦å®šå¥½çš„æ ¼å¼è¯»å–é¡µè¡¨å®Œæˆåç»­å·¥ä½œã€‚ è¿™ç§åŠæ³•ä¸æ˜¯ç»å¯¹çš„ï¼Œè‡³å°‘X86æ¶æ„æ˜¯è¿™ä¹ˆåšçš„ã€‚æ®µå¼å­˜å‚¨ç­–ç•¥ç±»ä¼¼ï¼Œå…¶å­˜æœ‰ç‰¹æ®Šå¯„å­˜å™¨ä½œä¸ºåç§»é‡ï¼Œä¹Ÿç”±ç³»ç»Ÿå…ˆå°†åç§»é‡è£…å…¥å¯„å­˜å™¨å†æŠŠæ§åˆ¶æƒäº¤å‡ºå»ã€‚ ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:1:0","tags":null,"title":"ç”±å†…å­˜åˆ†é¡µçœ‹CPUç³»ç»Ÿç•Œé¢","uri":"/2020/05/paging-introduction/"},{"categories":["é—²æ‰¯"],"content":"é—®é¢˜ ä¸è¿‡è¿™é‡Œä¼¼ä¹æœ‰ä¸ªå¥—å¨ƒé—®é¢˜ã€‚æˆ‘çš„ç³»ç»Ÿä»£ç ä¹Ÿæ˜¯è¿è¡Œåœ¨è™šæ‹Ÿåœ°å€ä¸‹çš„ï¼Œç³»ç»Ÿä»ä½•çŸ¥æ™“ç‰©ç†åœ°å€çš„äº‹æƒ…ã€‚å®é™…ä¸Šï¼ŒCPUä¹ŸçœŸçš„ä¸å…è®¸ç³»ç»Ÿçæã€‚åœ¨è¿™é‡Œï¼ŒåŠæ³•æ˜¯ã€Œæå‰ã€å°†é¡µè¡¨çš„åœ°å€äº‹å…ˆæ˜ å°„åˆ°è™šæ‹Ÿå†…å­˜åœ°å€ä¸Šã€‚â€¦â€¦æ“ä½œç³»ç»Ÿè®©CPUä»é¡µè¡¨é‡Œç¿»è¯‘åˆ°é¡µè¡¨çš„ç‰©ç†åœ°å€ï¼Œæ„Ÿè§‰æ€ªæ€ªçš„ã€‚ã€Œæå‰ã€æ˜¯æŒ‡è¿™ä¸ªè¿‡ç¨‹ä¸€èˆ¬åœ¨æ›´åº•å±‚çš„ä»£ç å®Œæˆï¼Œä¾‹å¦‚booté˜¶æ®µï¼Œå› ä¸ºç³»ç»Ÿæ— æ³•è‡ªè¡Œè®¿é—®åˆ°è‡ªå·±çš„é¡µè¡¨ï¼Œå¥—å¨ƒæ˜¯ä¸å­˜åœ¨çš„ã€‚ ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:1:1","tags":null,"title":"ç”±å†…å­˜åˆ†é¡µçœ‹CPUç³»ç»Ÿç•Œé¢","uri":"/2020/05/paging-introduction/"},{"categories":["é—²æ‰¯"],"content":"å¼‚å¸¸å¤„ç† ä¸è¿‡ç³»ç»Ÿæ˜¯é€šè¿‡ä»€ä¹ˆçŸ¥é“è¯¥åšä»€ä¹ˆçš„ï¼Œæ—¢ç„¶å†…å­˜ç”±ç³»ç»Ÿåˆ†é…ï¼Œæ§åˆ¶æƒäº¤ç»™äº†è½¯ä»¶ï¼Œé‚£ä¹ˆç³»ç»Ÿæ˜¯å¦‚ä½•åœ¨å¿…è¦æ—¶ä¸ºè½¯ä»¶åˆ†é…å†…å­˜ã€‚è¿™å…¶å®æ˜¯åˆ«çš„ä¸œè¥¿ã€‚ ä¾‹å¦‚å¼‚å¸¸å¤„ç†ã€‚å¸¸è§çš„æ®µé”™è¯¯ã€é™¤0é”™è¯¯ã€‚è¿™é‡Œåˆæ˜¯ä¸€æ³¢CPUå’Œæ“ä½œç³»ç»Ÿçš„çº¦å®šã€‚CPUä¼šåœ¨å‡ºç°å¼‚å¸¸æƒ…å†µæ—¶ï¼Œå°†å¼‚å¸¸åŸå› è£…å…¥å¯„å­˜å™¨ï¼Œå°†å½“å‰è¿è¡Œåˆ°çš„ä»£ç åœ°å€ä¿å­˜ï¼Œè·³è½¬åˆ°äº‹å…ˆçº¦å®šå¥½çš„å¼‚å¸¸å¤„ç†ä»£ç åœ°å€ï¼Œä»è€Œå¯åŠ¨ç”±ç³»ç»Ÿè‡ªå®šä¹‰çš„å¼‚å¸¸å¤„ç†æµç¨‹ã€‚è€Œå†…å­˜çš„åˆ†é…ä¸€èˆ¬ä¹Ÿæ˜¯é€šè¿‡è¿™ç§å½¢å¼å®Œæˆã€‚å®šä¹‰ä¸€ç§ç‰¹æ®Šçš„å¼‚å¸¸syscallï¼Œè½¯ä»¶æŠŠå‚æ•°ä¼ ç»™å¯„å­˜å™¨åå»è§¦å‘ä¸­æ–­æŠŠæ§åˆ¶æƒäº¤å‡ºå»ï¼Œç³»ç»Ÿåˆ†é…å®Œå†…å­˜å†retå›å»å›å½’åˆ°è½¯ä»¶çš„æ­£å¸¸è¿è¡Œæµç¨‹ã€‚ä¸è¿‡ç°ä»£CPUä¼¼ä¹ç”¨äº†æ›´å¿«é€Ÿçš„æ–¹å¼ã€‚ è¿™é‡Œè¿˜æŒºæœ‰æ„æ€çš„ï¼Œè¿™ç§å¼‚å¸¸å¤„ç†æ–¹å¼æ³¨å®šäº†å®ƒå¼‚å¸¸å¤„ç†è¿‡ç¨‹å¯èƒ½å†å‘ç”Ÿå¼‚å¸¸ã€‚ç„¶è€Œä¹Ÿä¸èƒ½æ— é™å¥—å¨ƒã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œç¬¬ä¸€æ¬¡å¼‚å¸¸å°†è¿›å…¥å¼‚å¸¸å¤„ç†æµç¨‹ï¼Œå¼‚å¸¸å¤„ç†è§¦å‘å¼‚å¸¸å°†è¿›å…¥äºŒæ¬¡å¼‚å¸¸å¤„ç†ï¼Œä¸€èˆ¬äºŒæ¬¡å¼‚å¸¸å¤„ç†æ“ä½œç³»ç»Ÿä¼šåˆå§‹åŒ–è½¯ä»¶ï¼Œå› ä¸ºå…ˆå‰çš„è¿è¡ŒçŠ¶æ€æ— æ³•å†ç»´æŒäº†ï¼ˆä¼¼ä¹ï¼Ÿï¼‰ã€‚äºŒæ¬¡å¼‚å¸¸è¿‡ç¨‹å¦‚æœå†æ¬¡å‘ç”Ÿå¼‚å¸¸ï¼Œç¡¬ä»¶å°†ç›´æ¥é‡å¯ã€‚ ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:2:0","tags":null,"title":"ç”±å†…å­˜åˆ†é¡µçœ‹CPUç³»ç»Ÿç•Œé¢","uri":"/2020/05/paging-introduction/"},{"categories":["é—²æ‰¯"],"content":"å†…æ ¸æ€/ç”¨æˆ·æ€ åœ¨è¿™ä¹‹ä¸­æ€»ä¼šæ„Ÿè§‰ç¼ºäº†ç‚¹ä»€ä¹ˆã€‚å¦‚æœè¯´æ“ä½œç³»ç»Ÿä¹Ÿåªæ˜¯ä¸€æ®µä»£ç ï¼Œé‚£ä¹ˆæ“ä½œç³»ç»Ÿä¸æ™®é€šè½¯ä»¶çš„åŒºåˆ«åœ¨å“ªï¼ŒæŠŠæ“ä½œç³»ç»Ÿåˆ†é…å†…å­˜çš„ä»£ç æ‹¿è¿‡æ¥ä¸ä¹…ä¸éœ€è¦å®ƒäº†ã€‚ è¿™æ¶‰åŠåˆ°äº†å†…æ ¸æ€/ç”¨æˆ·æ€çš„é—®é¢˜ã€‚æ“ä½œç³»ç»Ÿè¿è¡Œåœ¨å†…æ ¸æ€ï¼Œåªæœ‰å†…æ ¸æ€å¯ä»¥è®¿é—®å…³é”®èµ„æºï¼Œæ‰€ä»¥æ“ä½œç³»ç»Ÿä»£ç ä¸ä¸€èˆ¬è½¯ä»¶ä»£ç æœ‰åœ°ä½ä¸Šçš„å·®åˆ«ã€‚ä½†è¿™è¿˜ä¸å¤Ÿï¼Œä¸ºä»€ä¹ˆæ“ä½œç³»ç»Ÿå¯ä»¥è¿è¡Œåœ¨å†…æ ¸æ€ã€‚å…¶å®è¿™æ˜¯CPUæä¾›çš„åŠŸèƒ½ã€‚CPUæ‰€æä¾›çš„åˆ†çº§ä¿æŠ¤åŸŸæ¦‚å¿µï¼Œä½¿å¾—æ“ä½œç³»ç»Ÿåœ¨å æ®é«˜ç‰¹æƒåèƒ½å¤Ÿè‡ªç”±å†³å®šæ¥ä¸‹æ¥è¿è¡Œä»£ç çš„æƒé™ã€‚è¿™ç§æœºåˆ¶è¯ç”Ÿäº†æ‰€è°“ç‰¹æƒæŒ‡ä»¤ï¼Œå³åªæœ‰åœ¨é«˜æƒé™ä¸‹æ‰èƒ½è¿è¡Œçš„æŒ‡ä»¤ï¼Œä¸€èˆ¬ç”¨äºè®¿é—®å…³é”®èµ„æºã€‚æ‰€ä»¥ï¼Œç”¨æˆ·è½¯ä»¶å¿…é¡»é€šè¿‡ä¸­æ–­ï¼Œè®©ç³»ç»Ÿæ¥ä¸ºå…¶å‡†å¤‡éœ€è¦çš„èµ„æºã€‚ æ‰€ä»¥ç›®å‰ä¸€ä¸ªç»“è®ºæ˜¯ï¼Œå¦‚æœæ²¡æœ‰ã€Œç³»ç»Ÿã€ï¼Œæˆ‘ä»¬æ ¹æœ¬å°±æ— ä»è°ˆèµ·è½¯ä¸­æ–­å’Œã€Œç‰¹æƒæŒ‡ä»¤ã€çš„æ¦‚å¿µï¼Œä¹Ÿå¾ˆéš¾å®ç°ä¸€èˆ¬æ„ä¹‰ä¸Šçš„å¼‚å¸¸å¤„ç†å’Œå†…å­˜ç®¡ç†ã€‚ è€Œå¦‚æœæƒ³æŠŠç¼–è¯‘å™¨ç¼–è¯‘çš„ç¨‹åºç›´æ¥è·‘åœ¨ä¸€ä¸ªè™šæ‹Ÿæœºä¸Šâ€”â€”æˆ‘ä»¬å…ˆä¸è°ˆå®ç°è¿™ä¸ªçœŸæ­£çš„ç°ä»£CPUæ¨¡æ‹Ÿå™¨çš„å·¥ä½œé‡â€”â€”å°±ç®—ç›´æ¥ç»™ä½ ä¸€ä¸ªç°æˆçš„æ¨¡æ‹Ÿå™¨ï¼Œå•å•æ˜¯å‡†å¤‡è¿™ä¸ªèƒ½å¤Ÿç›´æ¥è·‘åœ¨è™šæ‹Ÿæœºä¸Šçš„ç¨‹åºä¹Ÿæ˜¯ä¸€ä»¶éº»çƒ¦çš„äº‹æƒ…ã€‚è¿™æ„å‘³ç€ä½ è¦åœ¨ä¸€ä¸ªæ²¡æœ‰ç³»ç»Ÿçš„ç°ä»£CPUä¸Šè·‘ç¨‹åº ç¬¬ä¸€ï¼Œè½¯ä»¶ä¸èƒ½ä¾èµ–æ ‡å‡†åº“ï¼Œå› ä¸ºæ ‡å‡†åº“å¹³å°ç›¸å…³ã€‚è¿™æ˜¯æœ€ç›´æ¥çš„éš¾é¢˜ã€‚å¹³æ—¶å¸¸ç”¨çš„printf/scanf/cin/coutç»Ÿç»ŸGGï¼Œå½“ç„¶è¿™è¿˜æ˜¯æœ€è¡¨é¢çš„ï¼Œä½ è¿˜ä¼šå‘ç°ä¸€äº›ä½ æœ¬æ¥ä»¥ä¸ºæ˜¯è¯­è¨€ç‰¹æ€§çš„ä¸œè¥¿å±…ç„¶æ˜¯å¹³å°ç›¸å…³çš„ï¼Œæ¯”å¦‚ä½ ç†Ÿæ‚‰çš„mainä¸ç®¡ç”¨äº†ï¼Œç”šè‡³å †æ ˆçš„å¤„ç†éƒ½å‡ºç°éº»çƒ¦ã€‚ ç¬¬äºŒï¼Œä½ è¦ç†Ÿæ‚‰ä»£ç çš„çœŸå®åŠ è½½æµç¨‹ã€‚ç¬¬ä¸€ä¸ªé—®é¢˜ï¼ŒJavaæ˜¯æœ‰è¿è¡Œæ—¶çš„æˆ‘ä»¬éƒ½çŸ¥é“ï¼ŒCæœ‰å—ï¼Ÿå¦‚æœå›ç­”æ˜¯æ²¡æœ‰çš„è¯ï¼Œé‚£ä½ å°±æœ‰ç‚¹éº»çƒ¦äº†ã€‚Cæœ‰è¿è¡Œæ—¶ï¼Œè¿è¡Œæ—¶è´Ÿè´£ä¸ºåç»­ä»£ç å‡†å¤‡ç¯å¢ƒï¼Œå¹¶ä¸”è°ƒèµ·mainã€‚æ²¡æœ‰è¿è¡Œæ—¶æ„å‘³ç€ä½ å¿…é¡»ç›´é¢æ•´ä¸ªåŠ è½½æµç¨‹ï¼Œä¸ºä½ çš„ä»£ç å‡†å¤‡ç”±æ›´ã€Œåº•å±‚ã€çš„ä»£ç ç›´æ¥è°ƒèµ·çš„å…¥å£å‡½æ•°ã€‚ ç¬¬ä¸‰ï¼Œä½ è¦ç†Ÿæ‚‰tool chainçš„é…ç½®ã€‚å¦‚æœä½ ç†Ÿæ‚‰ä»£ç çš„çœŸå®åŠ è½½æµç¨‹äº†ï¼Œå°±çŸ¥é“å®é™…ä¸Šä¸€ä¸ªä¸ªå¯æ‰§è¡Œæ–‡ä»¶çš„æ ¼å¼æ˜¯ç³»ç»Ÿç›¸å…³çš„ã€‚ä½ å¿…é¡»è®©linkeråˆ›å»ºç›´æ¥æœºå™¨ç›¸å…³çš„ä»£ç ã€‚ ç¬¬å››ï¼Œä½ è¦ç›´æ¥æ¥æ‰‹å’Œå…¶ä»–ç¡¬ä»¶çš„äº¤äº’ã€‚æƒ³åœ¨å±å¹•ä¸Šè¾“å‡ºä¸€è¡Œã€Œhello, worldã€ä¹Ÿä¼šå¾ˆéº»çƒ¦ã€‚ æˆ‘ä¸æ˜¯å¾ˆæ¸…æ¥šæ•´ä¸ªæµç¨‹ï¼Œä¹Ÿè®¸ç†æƒ³æƒ…å†µä¸‹äº‹æƒ…å°±åˆ°æ­¤ä¸ºæ­¢äº†ï¼Œåªè¦ä½ è‚¯è‡ªå·±å®ç°CPUè€Œä¸”åˆç†çš„å·æ‡’â€¦ä¸è¿‡å£å—¨å°šä¸”å†™è¿™ä¹ˆå¤šå­—ï¼ŒçœŸè¦è½å®åˆ°ä»£ç ä¸Šæˆ‘ä¹Ÿä¸çŸ¥é“ä¼šå‘ç”Ÿä»€ä¹ˆã€‚ ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:3:0","tags":null,"title":"ç”±å†…å­˜åˆ†é¡µçœ‹CPUç³»ç»Ÿç•Œé¢","uri":"/2020/05/paging-introduction/"},{"categories":null,"content":"é£˜å¿½ä¸å®šã€‚ ","date":"2020-05-03","objectID":"/about/:0:0","tags":null,"title":"å…³äº","uri":"/about/"},{"categories":null,"content":" è¢«æ‰“ä¸Šã€ŒçŸ³ä¹å¿—ã€æ ‡ç­¾çš„æ–‡ç« æ˜¯å½»åº•å±äºâ€œé—²æ‰¯â€çš„å­˜åœ¨ æ„Ÿè§‰æ—¶é—´è¿‡å»è¶³å¤Ÿé•¿äº†ï¼ŒæŠŠä¹‹å‰ç³Šæ¦‚ç‡ä½œä¸šçš„å°ç©æ„æ‹¿å‡ºæ¥ã€‚å®é™…ä¸Šä¸œè¥¿ä¸å¤šï¼Œä½†æ˜¯ä¼—æ‰€å‘¨çŸ¥ï¼Œä½œä¸šèƒ½ç³Šå¤šé•¿å’Œå¹²è´§é‡æ²¡æœ‰å¤šå¤§å…³ç³»ï¼Œå’Œä½œä¸šæˆç»©å…³ç³»å°±æ›´ä¸å¤§äº†ã€‚ åœ¨Wçš„æ± å­å¼€å‰ç®—ä¸€æ³¢æ¦‚ç‡ã€‚ è®¾$A_n$è¡¨ç¤ºç¬¬$n$æ¬¡æŠ½åˆ°6æ˜Ÿï¼Œ$B_n$è¡¨ç¤ºå‰$n-1$æ¬¡éƒ½æ²¡æœ‰å…­æ˜Ÿã€‚å¾—$P(A_n|B_n)$ã€‚ $$P(A_n|B_n)=\\begin{cases} 0.02,\\quad 0\\leq n \\leq 50 \\\\ 0.02+0.02(n-50),\\quad 50 åŒæ—¶ $$ \\begin{aligned} P(\\overline {A_n}|B_n)\u0026=1-P(A_n|B_n) \\\\ \\end{aligned} $$ çœç•¥ä¸€äº›æ²¡å¿…è¦å‡‘å­—æ•°çš„å¥—å¨ƒæ“ä½œä¹‹åèƒ½å¾—åˆ°é€’æ¨å¼ $$ P(B_n)=P(B_{n-1})-P(A_{n-1}B_{n-1}) $$ åŒæ—¶æœ‰åˆå§‹$P(B_1)=1$ã€‚ é‚£ä¹ˆï¼ŒXæŠ½æ°å¥½æŠ½åˆ°6æ˜Ÿçš„æ¦‚ç‡ä¸º $$ P\\{X=k\\}=P(A_kB_k)=P(A_k|B_k)P(B_k) $$ å·²æœ‰å…¬å¼æ„æˆé€’æ¨ $$ \\begin{aligned} P\\{X=k\\}\u0026=P(A_kB_k)=P(A_k|B_k)P(B_k) \\\\ P(B_n)\u0026=P(B_{n-1})-P\\{X=k-1\\} \\end{aligned} $$ å½“å‡ºç°6æ˜Ÿæ—¶ï¼ŒæŠ½åˆ°Wçš„æ¦‚ç‡ä¸º$35\\%$ã€‚è®¾æŠ½åˆ°Wçš„æ¦‚ç‡ä¸º$P_s$èƒ½å¤Ÿå¾—åˆ°é€’æ¨å¼ $$ \\begin{aligned} P_s(n)\u0026=\\sum_{1\\leq k\\leq n}P\\{X=k\\}(0.35+(1-0.35)P_s(n-k))\\\\ P_s(0)\u0026=0 \\end{aligned} $$ ç›´æ¥å¥—ä¸ŠCASç³»ç»Ÿç®—ã€‚ æŠŠWæ¥ä¸Šå²›çš„æ¦‚ç‡æŠŠWæ¥ä¸Šå²›çš„æ¦‚ç‡ \" æŠŠWæ¥ä¸Šå²›çš„æ¦‚ç‡ è¿™ä¸ªå›¾â€¦è¯´å®è¯æˆ‘è§‰å¾—æ²‰åº•äº†å®Œå…¨æœ‰å¯èƒ½â€¦âš ï¸å±âš ï¸ å™«ï¼Œå¥½ï¼Œæˆ‘å‡ºäº†ï¼Œè¿™æ¸¸æˆåˆå¯ä»¥ç»§ç»­ç©äº†ã€‚ è¯´çœŸçš„ï¼Œå•åœ¨æ‰‹æ¸¸çš„èŒƒå›´å†…è®¨è®ºï¼Œmrfzçš„è´¨é‡å¯ä»¥è¯´æ˜¯ä½¼ä½¼è€…äº†ã€‚ä¸è¿‡ä½•æ—¶èƒ½è„±ç¦»å•ä¸€çš„æ‰‹æ¸¸æ¨¡å¼ï¼Œåšç‚¹åˆ«çš„å‘¢ã€‚ å‰§æƒ…æ€æˆ‘ã€‚ ","date":"2020-04-30","objectID":"/2020/04/pulling-w/:0:0","tags":["çŸ³ä¹å¿—"],"title":"å¦‚ä½•æŠŠWæ¥ä¸Šå²›","uri":"/2020/04/pulling-w/"},{"categories":["code"],"content":"C. Emergency Evacuation å½“æ²¡æœ‰äººç¢°åœ¨ä¸€èµ·æ—¶ï¼Œè€—æ—¶å°±æ˜¯ç¦»é—¨æœ€è¿œçš„äººéœ€è¦çš„è€—æ—¶ã€‚å½“æœ‰äººç¢°åœ¨ä¸€èµ·æ—¶ï¼Œæ‰ä¼šå‘ç”Ÿå…¶ä»–æƒ…å†µã€‚ äººç¢°åœ¨ä¸€èµ·çš„æ¡ä»¶æ˜¯ä»–ä»¬è·ç¦»é—¨çš„è·ç¦»ä¸€æ ·ï¼Œå¯ä»¥è®©äººåç€è·‘çœ‹å‡ºæ¥ã€‚å½“ç¢°åœ¨ä¸€èµ·æ—¶ï¼Œå¿…å®šä¼šæœ‰ä¸€ä¸ªäººç­‰å¾…ä¸€ç§’ã€‚è€Œè¿™ä¸ªç­‰çš„äººåˆ°åº•æ˜¯è°å¹¶æ²¡æœ‰åŒºåˆ«ï¼ŒåŸæœ¬ä¼šåœ¨ä¸‹ä¸€ç§’åˆ°è¾¾è¯¥æ ¼å­çš„äººæ€»æ˜¯ä¼šè¢«ç­‰å¾…çš„äººå¡ä½ã€‚ç„¶åå°±ä½ å¡æˆ‘ï¼Œæˆ‘å¡ä»–ï¼Œä»–å†å¡åé¢çš„äººã€‚ å°†é€ƒè·‘éœ€è¦æ—¶é—´ç›¸åŒçš„äººå¾€ååŒ€ã€‚æ—¶é—´çš„å€¼åŸŸä¸å¤§æ‰€ä»¥ç›´æ¥ç”¨æ¡¶ã€‚ ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:1:0","tags":["äºŒåˆ†","åŠ¨æ€è§„åˆ’","æ€ç»´","å•è°ƒæ ˆ"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"D. Shortest Common Non-Subsequence è¡¥ å…ˆè€ƒè™‘æ€ä¹ˆæ„é€ ä¸€ä¸ªå­—ç¬¦ä¸²çš„æœ€å°éå­åºåˆ—ã€‚ç”¨ç±»ä¼¼äºåºåˆ—è‡ªåŠ¨æœºçš„æ–¹æ³•æ„é€ ã€‚ ä¸ºå­—ç¬¦ä¸²æ·»åŠ èµ·å§‹èŠ‚ç‚¹ï¼Œä»¤$f(i,x)$è¡¨ç¤ºåœ¨è¯¥è‡ªåŠ¨æœºä¸Šç¬¬içŠ¶æ€å¡«xå¾—åˆ°çš„æœ€çŸ­éå­åºåˆ—é•¿åº¦ã€‚è½¬ç§»æ˜¯ $$ f(i,x)=\\min \\{f(\\text{next}(i,x),y)|y\\}+1 $$ å…¶ä¸­$\\text{next}(i,x)$ä¸ºç¬¬iä½åæœ€è¿‘çš„xçš„ä½ç½®ã€‚åªè¦æœ€çŸ­é•¿åº¦æ—¶ï¼Œæ‰”æ‰xä¹Ÿæ— æ‰€è°“ $$ f(i)=min\\{f(\\text{next}(i,x))|x\\}+1 $$ åˆå§‹çŠ¶æ€ä¸º$f(n+1)=0$ã€‚ æ”¹é€ ä¸ºè¯¥é¢˜ï¼Œè®¾çŠ¶æ€$f(i,j)$ä¸ºåœ¨ä¿©è‡ªåŠ¨æœºä¸Šè·‘åˆ°$i,j$çŠ¶æ€çš„æœ€çŸ­XXé•¿åº¦ï¼Œæœ‰ $$ f(i,j)=\\min\\{f(n_1(i,x),n_2(j,x))|x\\}+1 $$ åˆå§‹çŠ¶æ€æœ‰$f(n_1+1,n_2+1)=0$ã€‚ æ„Ÿè§‰æœ‰ä¸€ä¸ªå€¼å¾—æ€è€ƒçš„é—®é¢˜æ˜¯æœ€é•¿å…¬å…±å­ä¸²çš„å†™æ³•â€¦æ¯•ç«Ÿè½¬ç§»æ–¹ç¨‹çœ‹èµ·æ¥å‡ ä¹ä¸€æ ·æ¥ç€â€¦ $$ f(i,j)=\\max\\{f(n_1(i,x),n_2(j,x))|x\\}+1 $$ é‚£é‡ç‚¹å°±åªèƒ½åœ¨äºåˆå§‹çŠ¶æ€äº†ã€‚ çœ‹èµ·æ¥åº”è¯¥æ˜¯$f(n_1+1,n_2+1)=-\\infty,f(n_1, * )=f( * ,n_2)=0$ï¼Œä¸»è¦è€ƒè™‘çš„ ä¸èƒ½è½¬ç§»åˆ°ä¸å­˜åœ¨n+1çŠ¶æ€ï¼Œè¿™æ„å‘³ç€å¡«å†™çš„å­—æ¯ä¸å­˜åœ¨ã€‚ nçŠ¶æ€æ— å­—ç¬¦ï¼Œ0ã€‚ ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:2:0","tags":["äºŒåˆ†","åŠ¨æ€è§„åˆ’","æ€ç»´","å•è°ƒæ ˆ"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"E. Eulerian Flight Tour â€¦â€¦ çœ‹èµ·æ¥æ˜¯æŠŠè¾¹é€‰/ä¸é€‰å¯¹åº¦é€ æˆçš„å½±å“æŠ½è±¡æˆæ–¹ç¨‹ç»„æ¥è§£ã€‚å¤æ‚åº¦çœ‹èµ·æ¥æ²¡é—®é¢˜ï¼Œä¼°è®¡è§£å®Œè¿˜è¦å†å¤„ç†ä¸€å †ä¸œè¥¿â€¦å›å¤´å†è¯´ã€‚ ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:3:0","tags":["äºŒåˆ†","åŠ¨æ€è§„åˆ’","æ€ç»´","å•è°ƒæ ˆ"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"K. Sixth Sense ç®—æœ€å¤§å¾—åˆ†å¯ä»¥è´ªå¿ƒã€‚å¯¹æ–¹å’Œè‡ªå·±çš„ç‰Œå‡åºæ’åºåï¼Œæ‹¿æ­£å¥½èƒ½å¯¹æŠ—çš„ç‰Œå»å’Œå¯¹æ–¹ç‰Œä¸€ä¸€æ‰“ã€‚ å‰©ä¸‹çš„æ˜¯æ€ä¹ˆæ±‚å­—å…¸åºæœ€å¤§çš„ç­”æ¡ˆã€‚èƒ½å¤Ÿå‘ç°ï¼Œå½“å½“å‰è¿™å¼ ç‰Œæ‰“å¾—å¤ªå¤§æ—¶ï¼Œå°±å¯èƒ½å¯¼è‡´åç»­æŸä¸€è½®ç‰Œè¾“æ‰ï¼Œè®©æ€»æ¯”åˆ†å‡å°‘ã€‚è¿™çœ‹èµ·æ¥å¯ä»¥äºŒåˆ†ã€‚ä¸è¿‡å†™ç€å†™ç€æŠŠæ ·ä¾‹3ç»™waäº†ã€‚ ä¹‹åæ„è¯†åˆ°è¿™ä¸ªä¸œè¥¿å¹¶ä¸æ˜¯æ•´ä¸ªåŒºé—´å•è°ƒï¼Œéœ€è¦åœ¨å¾—åˆ†å’Œè¾“åˆ†çš„ä¸¤ä¸ªå‡ºç‰ŒåŒºé—´åˆ†åˆ«åšä¸¤æ¬¡ã€‚ #include \u003ccstdio\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cunordered_map\u003e#include \u003cvector\u003e#include \u003cmap\u003e#include \u003ccmath\u003e#include \u003ciostream\u003eusing namespace std; const int XN=5050; int my[XN],you[XN]; int myrnk[XN],yournk[XN]; int used[XN]; int n; int maxans=0; //ä»ç¬¬nè½®å¼€å§‹ int check(int round){ int ptr=1; while(ptr\u003c=n \u0026\u0026 yournk[ptr]\u003cround)ptr++; if(ptr\u003en)return 0; int res=0; for(int i=1;i\u003c=n;i++){ if(used[i])continue; if(ptr\u003en)break; if(my[myrnk[i]]\u003eyou[yournk[ptr]]){ res++; ptr++; while(ptr\u003c=n \u0026\u0026yournk[ptr]\u003cround)ptr++; } } return res; } vector\u003cint\u003e rest; int main(){ ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); cin\u003e\u003en; for(int i=1;i\u003c=n;i++){ cin\u003e\u003eyou[i]; } for(int i=1;i\u003c=n;i++){ cin\u003e\u003emy[i]; } for(int i=1;i\u003c=n;i++)myrnk[i]=yournk[i]=i; sort(myrnk+1,myrnk+1+n,[](auto a,auto b){ return my[a]\u003cmy[b]; }); sort(yournk+1,yournk+1+n,[](auto a,auto b){ return you[a]\u003cyou[b]; }); for(int i=1;i\u003c=n;i++)rest.push_back(i); maxans=check(1); int app=0; for(int i=1;i\u003c=n;i++){ //èµ¢çš„ { int l=0,r=rest.size(); while(l\u003cr \u0026\u0026 my[myrnk[rest[l]]]\u003c=you[i])l++; while(l+1\u003cr){ int mid=(l+r)/2; int chosen=rest[mid]; used[chosen]=1; if(app+1+check(i+1)\u003e=maxans)l=mid; else r=mid; used[chosen]=0; } if(l\u003cr){ used[rest[l]]=1; if(app+1+check(i+1)\u003e=maxans){ cout\u003c\u003cmy[myrnk[rest[l]]]\u003c\u003c\" \"; rest.erase(rest.begin()+l); app++; continue; }else{ used[rest[l]]=0; } } } { int l=0,r=(int)rest.size()-1; while(l\u003cr \u0026\u0026 my[myrnk[rest[r]]]\u003eyou[i])r--; r++; while(l+1\u003cr){ int mid=(l+r)/2; int chosen=rest[mid]; used[chosen]=1; if(app+check(i+1)\u003e=maxans)l=mid; else r=mid; used[chosen]=0; } used[rest[l]]=1; cout\u003c\u003cmy[myrnk[rest[l]]]\u003c\u003c\" \"; rest.erase(rest.begin()+l); } } cout\u003c\u003cendl; return 0; } ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:4:0","tags":["äºŒåˆ†","åŠ¨æ€è§„åˆ’","æ€ç»´","å•è°ƒæ ˆ"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"Extra åœ¨ç¾¤é‡Œçœ‹åˆ°ä¸€é“é¢˜ï¼Œåœ¨$1 \\leq x \\leq m$çš„nä¸ªæ•°ä¸­æ‰¾åˆ°ä¸€ä¸ªå­—å…¸åºæœ€å°çš„åºåˆ—ä¸”ä¸º1-mçš„ä¸€ä¸ªæ’åˆ—ã€‚ æœ€å¼€å§‹æƒ³ç»´æŠ¤æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°ï¼Œç„¶åä»ç¬¬ä¸€ä½å¼€å§‹å‘åæ‰«ï¼Œå½“å‰æ•°å­—æ­£å¥½æ˜¯è¿˜ç¼ºå°‘çš„æœ€å°æ•°å­—æˆ–è€…æ­¤åå†ä¹Ÿæ²¡æœ‰è¯¥æ•°å­—å‡ºç°çš„è¯å°±è¾“å‡ºã€‚åé¢çš„æ¡ä»¶æ˜¯å¯¹çš„ï¼Œçš„ç¡®å½“åæ–¹æ²¡æœ‰æ•°å­—æ—¶ï¼Œå°±ä¸å¾—ä¸åœ¨è¯¥ä½è¾“å‡ºï¼Œä½†æ˜¯å‰é¢çš„æ¡ä»¶æœ‰äº›é—®é¢˜ã€‚å¦‚æœä¸€ä¸ªæ›´å¤§çš„æ•°å­—ç»“æŸçš„æ¯”å°æ•°å­—æ›´å¿«ï¼Œä¸”ä¸‹ä¸€ä¸ªç¼ºå°‘çš„æœ€å°æ•°å­—å¹¶éâ€œå°æ•°å­—â€ï¼Œå°±ä¼šç¿»è½¦ã€‚æ­¤æ—¶çš„æƒ…å†µæœ€ä¼˜åº”è¯¥æ˜¯ä»¥ä¸å¾—ä¸è¾“å‡ºçš„ä½ç½®å¼€å§‹ï¼Œåˆ’åˆ†ä¸ºä¸¤ä¸ªé—®é¢˜ï¼Œå‰é¢å°½å¯èƒ½æ‰¾å­—å…¸åºå°çš„ä¸€æ®µã€‚ ç»´æŠ¤å•è°ƒæ ˆï¼Œå½“æ–°åŠ å…¥çš„æ•°å­—æ¯”å‰ä¸€ä¸ªæ›´ä¼˜ï¼ˆå­—å…¸åºå°ï¼‰æ—¶ï¼Œå¦‚æœå‰ä¸€ä¸ªæ•°å­—åœ¨åé¢è¿˜æœ‰ï¼Œå°±å¯ä»¥æŠŠå®ƒè¸¢æ‰ï¼Œå¦åˆ™å‰é¢çš„ç­”æ¡ˆå°±å®šäº†ï¼Œè¾“å‡ºç­”æ¡ˆåå†ä»è¯¥ä½é‡æ–°å¼€å§‹ã€‚ #include\u003ccstdio\u003e#include\u003ccmath\u003e#include\u003calgorithm\u003e#include\u003cunordered_map\u003e#include \u003cvector\u003e#include \u003cmap\u003e#include \u003ccmath\u003e#include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cdeque\u003eusing namespace std; const int XN=30; int cnt[XN]; bool used[XN]; deque\u003cchar\u003e q; int main(){ string inp;cin\u003e\u003einp; for(auto chr:inp)cnt[chr-'a']++; for(auto chr:inp){ cnt[chr-'a']--; if(used[chr-'a'])continue; while(!q.empty() \u0026\u0026 q.back()\u003echr \u0026\u0026 cnt[q.back()-'a']\u003e0){ used[q.back()-'a']=0; q.pop_back(); } q.push_back(chr); used[chr-'a']=1; if(cnt[chr-'a']==0){ while(!q.empty()){ cout\u003c\u003cq.front(); q.pop_front(); } } } while(!q.empty()){ cout\u003c\u003cq.front(); q.pop_front(); } cout\u003c\u003cendl; return 0; } ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:5:0","tags":["äºŒåˆ†","åŠ¨æ€è§„åˆ’","æ€ç»´","å•è°ƒæ ˆ"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"Little Mishka enjoys programming. Since her birthday has just passed, her friends decided to present her with array of non-negative integers a1,â€‰a2,â€‰â€¦,â€‰an of n elements! Mishka loved the array and she instantly decided to determine its beauty value, but she is too little and canâ€™t process large arrays. Right because of that she invited you to visit her and asked you to process m queries. Each query is processed in the following way: Two integers l and r (1â€‰â‰¤â€‰lâ€‰â‰¤â€‰râ€‰â‰¤â€‰n) are specified â€” bounds of query segment. Integers, presented in array segment [l,â€‰r] (in sequence of integers al,â€‰alâ€‰+â€‰1,â€‰â€¦,â€‰ar) even number of times, are written down. XOR-sum of written down integers is calculated, and this value is the answer for a query. Formally, if integers written down in point 2 are x1,â€‰x2,â€‰â€¦,â€‰xk, then Mishka wants to know the value , where â€” operator of exclusive bitwise OR. Since only the little bears know the definition of array beauty, all you are to do is to answer each of queries presented. ","date":"2020-04-10","objectID":"/2020/04/cf703d-mishka-and-interesting-sum/:0:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"[CF703D] Mishka and Interesting Sum","uri":"/2020/04/cf703d-mishka-and-interesting-sum/"},{"categories":["code"],"content":"åˆ†æ è¢«å¤§å“¥ä»¬ç§’åˆ‡äº†â€¦éƒ½æ²¡æ¥å¾—åŠæƒ³ğŸ’” åˆ©ç”¨äº†å¼‚æˆ–çš„æ€§è´¨ã€‚ æƒ³æ‰¾åˆ°ä¸€ä¸ªåŒºé—´å†…å‡ºç°å¥‡æ•°æ¬¡çš„æ•°çš„å¼‚æˆ–å’Œéå¸¸ç®€å•ï¼Œåªè¦ç»´æŠ¤ä¸€ä¸ªå‰ç¼€å’Œå°±å¯ä»¥äº†ã€‚é‚£ä¹ˆçŸ¥é“äº†å¥‡æ•°æ¬¡çš„æ•°å­—ï¼Œå°±èƒ½ä»æ‰€æœ‰æ•°å­—çš„å¼‚æˆ–ä¸­æ±‚åˆ°è¡¥â€”â€”å‡ºç°å¶æ•°æ¬¡çš„æ•°çš„å¼‚æˆ–ã€‚ å€¼å¾—ä¸€å†™çš„æ˜¯æ±‚æŸåŒºé—´å†…ä¸åŒå…ƒç´ ç›¸å…³ä¿¡æ¯çš„ä¸€ä¸ªæ€è·¯ã€‚ä¹‹å‰æœ‰å¥½å‡ é“é¢˜éƒ½æ˜¯è¿™ä¹ˆå¹²çš„ï¼ˆä¸€ä¸ªé’¥åŒ™çš„é¢˜ï¼Œä¸€ä¸ªä¹¦çš„é¢˜ï¼‰ã€‚å³ç»´æŠ¤å…ƒç´ çš„ä¸‹ä¸€æ¬¡å‡ºç°ä½ç½®ï¼Œå°†å·¦åŒºé—´æ’åºåï¼Œä½¿ç”¨æ•°æ®ç»“æ„æŸ¥è¯¢å³ç«¯ç‚¹ã€‚å½“å·¦ç«¯ç‚¹è¶Šè¿‡äº†æŸæ•°åï¼Œå°±å°†å…¶ä¸‹ä¸€æ¬¡å‡ºç°çš„ä½ç½®åŠ å…¥åˆ°ç»“æ„ä¸­ã€‚æ•´ä½“ä¸º$O(n\\lg n)$ã€‚ å¦‚æœé¢˜ç›®çš„èŒƒå›´å°ä¸€ç‚¹ï¼Œå¯ä»¥è«é˜Ÿã€‚ ","date":"2020-04-10","objectID":"/2020/04/cf703d-mishka-and-interesting-sum/:1:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"[CF703D] Mishka and Interesting Sum","uri":"/2020/04/cf703d-mishka-and-interesting-sum/"},{"categories":["code"],"content":"ä»£ç  æ²¡ä¸Šå¿«è¯»Täº†å‘ã€‚ #include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e#include \u003cstack\u003e#include \u003cunordered_map\u003eusing namespace std; const int XN=1000010; const int FTXN=4000010; namespace IO { const int IN=1e6; char in[IN],*ip=in,*ie=in; #define getchar() (ip==ie \u0026\u0026 (ie=(ip=in)+fread(in,1,IN,stdin),ip==ie)?EOF:*ip++) struct Istream { template \u003cclass T\u003e Istream \u0026operator \u003e\u003e(T \u0026x) { static char ch;static bool neg; for(ch=neg=0;ch\u003c'0' || '9'\u003cch;neg|=ch=='-',ch=getchar()); for(x=0;'0'\u003c=ch \u0026\u0026 ch\u003c='9';(x*=10)+=ch-'0',ch=getchar()); x=neg?-x:x; return *this; } }fin; const int OUT=1e6; char out[OUT],*op=out,*oe=out+OUT; #define flush() fwrite(out,1,op-out,stdout) #define putchar(x) ((op==oe?(flush(),op=out,*op++):*op++)=(x)) struct Ostream { ~Ostream() { flush(); } template \u003cclass T\u003e Ostream \u0026operator \u003c\u003c(T x) { x\u003c0 \u0026\u0026 (putchar('-'),x=-x); static char stack[233];static int top; for(top=0;x;stack[++top]=x%10+'0',x/=10); for(top==0 \u0026\u0026 (stack[top=1]='0');top;putchar(stack[top--])); return *this; } Ostream \u0026operator \u003c\u003c(char ch) { putchar(ch); return *this; } }fout; } using IO::fin; using IO::fout; int ft[FTXN]; int lowbit(int x){ return x\u0026-x; } void ftadd(int pos,int x){ for(;pos\u003cFTXN;pos+=lowbit(pos)){ ft[pos]^=x; } } int ftget(int pos){ int res=0; for(;pos;pos-=lowbit(pos))res^=ft[pos]; return res; } int num[XN]; int xo[XN]; struct Q{ int l,r; int i; } qs[XN]; int ans[XN]; unordered_map\u003cint,int\u003e curpos; int nxt[XN]; int main(){ int n;fin\u003e\u003en; //cout\u003c\u003c\"st\"\u003c\u003cendl; for(int i=1;i\u003c=n;i++)fin\u003e\u003enum[i]; for(int i=0;i\u003c=n;i++)xo[i]=xo[i-1]^num[i]; //cout\u003c\u003c\"done\"\u003c\u003cendl; for(int i=n;i\u003e=1;i--){ nxt[i]=curpos[num[i]]; curpos[num[i]]=i; } // for(int i=1;i\u003c=n;i++){ // cout\u003c\u003cnxt[i]\u003c\u003c\" \"; // } // cout\u003c\u003cendl; int qlen;fin\u003e\u003eqlen; for(int i=0;i\u003cqlen;i++){ fin\u003e\u003eqs[i].l\u003e\u003eqs[i].r; qs[i].i=i; } for(auto [x,pos]:curpos){ ftadd(pos,x); } sort(qs,qs+qlen,[](const Q \u0026a,const Q \u0026b){ return a.l\u003cb.l; }); int la=1; //cout\u003c\u003c\"done\"\u003c\u003cendl; for(int i=0;i\u003cqlen;i++){ Q \u0026q=qs[i]; while(q.l\u003ela){ ftadd(la,num[la]); //cout\u003c\u003c\"remove \"\u003c\u003cla\u003c\u003cendl; if(nxt[la]){ ftadd(nxt[la],num[la]); //cout\u003c\u003c\"add \"\u003c\u003cnxt[la]\u003c\u003cendl; } la++; } ans[q.i]=ftget(q.r)^(xo[q.r]^xo[q.l-1]); } for(int i=0;i\u003cqlen;i++)fout\u003c\u003cans[i]\u003c\u003c'\\n'; return 0; } ","date":"2020-04-10","objectID":"/2020/04/cf703d-mishka-and-interesting-sum/:2:0","tags":["æ ‘çŠ¶æ•°ç»„"],"title":"[CF703D] Mishka and Interesting Sum","uri":"/2020/04/cf703d-mishka-and-interesting-sum/"},{"categories":["code"],"content":"ç»™ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç°æœ‰è¿™ä¹ˆä¸€ç§æ“ä½œï¼Œå°†å­—ç¬¦ä¸²å†…æ¯ä¸€ä¸ªå­—æ¯æ›¿æ¢æˆä¸€ç»™å®šå­—ç¬¦ä¸²ã€‚ä¾‹å¦‚$T_a=abc,T_b=ee$ï¼Œé‚£ä¹ˆ$ab$å°±ä¼šè¢«æ›¿æ¢æˆ$abcee$ã€‚ ç»™å‡ºåˆå§‹çš„å­—ç¬¦ä¸²$S$ï¼Œå’Œ26ä¸ªå­—æ¯æ‰€å¯¹åº”çš„å­—ç¬¦ä¸²$T_i$ï¼Œåº”ç”¨æ“ä½œ$K$æ¬¡ï¼Œè¯¢é—®ç¬¬$i$ä¸ªä½ç½®çš„å­—ç¬¦ã€‚ $$|S| \\leq 1000000$$ $$2 \\leq |T_i| \\leq 50,K \\leq 10^{15}$$ ","date":"2020-04-08","objectID":"/2020/04/kattis-prolonged-password/:0:0","tags":["å€å¢"],"title":"Prolonged Password","uri":"/2020/04/kattis-prolonged-password/"},{"categories":["code"],"content":"åˆ†æ å¤´ç§ƒã€‚å¼€å§‹ä»¥ä¸ºå…³é”®æ˜¯åœ¨äºæ•°å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ç»è¿‡Kæ¬¡æ“ä½œåè¾¾åˆ°çš„é•¿åº¦ï¼Œç„¶åç„¶åç”¨ç±»ä¼¼äºäºŒåˆ†çš„æ–¹æ³•å»é€’å½’åœ°åˆ†å±‚æ‰¾åˆ°éœ€è¦çš„ä½ç½®ã€‚äºæ˜¯å°±ç»Ÿè®¡æ¯ä¸ªå­—æ¯çš„æ•°ç›®ï¼Œç”¨çŸ©é˜µå¿«é€Ÿå¹‚æ‹¿åˆ°é•¿åº¦â€¦â€¦ ç°åœ¨çœ‹ç€è¿‡äºæ™ºéšœã€‚è¿™1e15çš„æŒ‡æ•°å’Œ1e15çš„ä¸‹æ ‡ï¼Œä½ æ€ä¹ˆæ•¢å¿«é€Ÿå¹‚ã€‚ ç”±æ›¿æ¢å­—ç¬¦ä¸²çš„é•¿åº¦å¯ä»¥å¾—åˆ°ï¼Œè¿™ç§æ“ä½œé¡¶å¤šæ‰§è¡Œ50æ¬¡ï¼ˆ$2^{50}$ï¼‰ã€‚å› æ­¤å­—ç¬¦ä¸²çš„é•¿åº¦éƒ¨åˆ†è®¡ç®—å®é™…ä¸Šä¸å å¤§å¤´ï¼Œç”¨ä¸ªå€å¢å°±èƒ½å¤„ç†å‡ºæ¥ã€‚ ç°åœ¨å‰©ä¸‹çš„é—®é¢˜æ˜¯æ“ä½œæ¬¡æ•°$K$è¿‡å¤§ã€‚æ–¹æ³•ä»ç„¶æ˜¯åŸºäº50æ¬¡ã€‚ä¸€ä¸ªå­—ç¬¦æ‰©å±•50æ¬¡ï¼Œå°±è¶³å¤ŸæŠŠæ‰€æœ‰çš„è¯¢é—®åŒ…å«åœ¨å†…ã€‚å› æ­¤è¦è®¡ç®—å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦æ›¿æ¢çš„å¾ªç¯èŠ‚ï¼Œå°†æ“ä½œæ¬¡æ•°é™åˆ°æ¥è¿‘50ã€‚æ­¤åé€šè¿‡å€å¢æ³•å»ä¸€å±‚å±‚å®šä½è¯¢é—®ä¸‹æ ‡æ‰€å¤„çš„ä½ç½®ã€‚ æœ€å¼€å§‹æ–¹å‘é”™äº†æ˜¯ä¸€ç äº‹â€¦æ„Ÿè§‰Kçš„èŒƒå›´ä¹ŸæŒºæ— èŠçš„â€¦ä»£ç ç­‰åˆ°ä¹‹åå†è¡¥ä¸Šã€‚ ","date":"2020-04-08","objectID":"/2020/04/kattis-prolonged-password/:1:0","tags":["å€å¢"],"title":"Prolonged Password","uri":"/2020/04/kattis-prolonged-password/"},{"categories":["code"],"content":"ä»£ç  å®é™…å®ç°æ—¶ï¼Œé™Kå¯èƒ½æµ®åŠ¨26å·¦å³ï¼Œæ‰€ä»¥å¤šå¤„ç†è¿™ä¹ˆä¸€ç‚¹ã€‚ #include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e#include \u003cstack\u003e#include \u003ccstring\u003e#include \u003ccassert\u003eusing namespace std; using ll=long long; const int MAXN=30; string inp; ll K; string rep[30]; ll f[26][81]; void upd(ll \u0026a,ll b){ if(a==-1)return; if(b==-1){ a=-1; return; } a+=b; if(a\u003e1e15)a=-1; } char reduceK(){ //æ‰¾åˆ°å¾ªç¯èŠ‚ char chr=inp[0]; bool vis[30]; stack\u003cchar\u003e st; memset(vis,0,sizeof(vis)); while(!vis[chr-'a']){ st.push(chr); vis[chr-'a']=1; chr=rep[chr-'a'][0]; } int cycle=1; while(st.top()!=chr){ cycle++; st.pop(); } st.pop(); int pre=st.size(); //å°†Kå‰Šåˆ°54-80 if(K\u003c=54)return '\\0'; if(K-pre\u003c=54)return '\\0'; K-=pre; K=K-(K-54)/cycle*cycle; return chr; } char solve(ll idx,string str,int p){ if(p==0){ return str[idx-1]; } for(int i=0;i\u003cstr.size();i++) { if (f[str[i] - 'a'][p] == -1 || f[str[i] - 'a'][p] \u003e= idx)return solve(idx, rep[str[i] - 'a'],p-1); idx-=f[str[i] - 'a'][p]; } //ä¸è¯¥å‡ºç°è¿™ç§æƒ…å†µ assert(false); } int main(){ ios::sync_with_stdio(false); cin\u003e\u003einp;// for(int i=0;i\u003c26;i++){ cin\u003e\u003erep[i]; f[i][1]=rep[i].size(); } for(int i=0;i\u003c26;i++)f[i][0]=1; cin\u003e\u003eK; for(int p=2;p\u003c=80;p++){ for(int i=0;i\u003c26;i++){ for(int k=0;k\u003crep[i].size();k++){ upd(f[i][p],f[rep[i][k]-'a'][p-1]); } } } char start=reduceK(); int qlen;cin\u003e\u003eqlen; while(qlen--){ ll idx;cin\u003e\u003eidx; if(start=='\\0')cout\u003c\u003csolve(idx,inp,K)\u003c\u003cendl; else cout\u003c\u003csolve(idx,rep[start-'a'],K-1)\u003c\u003cendl;//-1 } } ","date":"2020-04-08","objectID":"/2020/04/kattis-prolonged-password/:2:0","tags":["å€å¢"],"title":"Prolonged Password","uri":"/2020/04/kattis-prolonged-password/"},{"categories":["é—²æ‰¯"],"content":" æˆ‘å†æ¢blogçš„åç«¯æˆ‘å°±æ˜¯ç‹—ã€‚ Tiddlywikiæ˜¯æˆ‘åœ¨å¯»æ‰¾Mediawikiçš„æ›¿ä»£å“æ—¶æ„å¤–å‘ç°çš„ä¸œè¥¿ã€‚èµ·åˆæˆ‘è¿˜æ˜¯åªæƒŠè‰³äºå®ƒçš„ç‰¹æ®Šçš„ç»„ç»‡æ–¹å¼å’Œé½å…¨çš„åŠŸèƒ½ï¼Œæ•´ä¸ªè½¯ä»¶åªæœ‰ä¸€ä¸ªhtmlæ–‡ä»¶ï¼Œé€»è¾‘ã€æ•°æ®å…¨éƒ¨ä¿å­˜åœ¨é‡Œé¢ã€‚åæ¥ï¼Œåœ¨æˆ‘æ·±å…¥è¿™å¥—è½¯ä»¶çš„æ¨¡æ¿åŠŸèƒ½æ—¶ï¼Œäº†è§£åˆ°äº†å®ƒçš„å“²å­¦ã€‚ Tiddlywikiä»æœ€åˆå°±æ‰“ç®—ä¸ºç”¨æˆ·å‡†å¤‡ä¸€ä¸ªæç«¯ç¨³å®šä¸”ç‹¬ç«‹çš„éçº¿æ€§æ–‡å­—ç¬”è®°ç³»ç»Ÿã€‚å…¶ç¬¬ä¸€ä¸ªç‰ˆæœ¬åœ¨2004å¹´å‘å¸ƒï¼Œç›´åˆ°ç°åœ¨ä»ç„¶åœ¨ç¨³å®šçš„è¿è¡Œã€‚ä¸ºäº†åšåˆ°ä¸Šé¢çš„è¦æ±‚ï¼Œwikiæ‰é‡‡ç”¨äº†å•æ–‡ä»¶æ–¹å¼ï¼Œä¸è¿½æ±‚ä»»ä½•æ—¶é«¦æŠ€æœ¯ï¼Œå°½å¯èƒ½ä¸ä¾èµ–ä»»ä½•ç°å­˜çš„å…¶ä»–è½¯ä»¶ï¼Œå°½å¯èƒ½åšåˆ°å…¼å®¹ï¼Œç”šè‡³ä»£ç ä¹Ÿå®Œå…¨åŸºäºvanillaå’Œhtml5ã€‚è€Œè¿™ä¹ˆåšçš„åŸå› å¤§æ¦‚å°±æ˜¯è¦è¾¾åˆ°ä¸€ç‚¹è¦æ±‚ï¼šåœ¨æä¾›è¶³å¤ŸåŠŸèƒ½çš„å‰æä¸‹ï¼Œä¿è¯ç³»ç»Ÿçš„ç‹¬ç«‹å’Œåœ¨å¾ˆé•¿ä¸€æ®µæ—¶é—´å†…çš„å¯é ï¼Œä»è€Œç»´æŒæ•°æ®çš„ç‹¬ç«‹ã€‚ ä¸ºä½•è¿™ä¹ˆå¼ºè°ƒæ•°æ®çš„ç‹¬ç«‹ï¼Ÿå› ä¸ºæ•°æ®æ˜¾ç„¶æ¯”å‡­ä¾çš„è®°å½•æ‰‹æ®µæ›´æœ‰ä»·å€¼ã€‚è¯•æƒ³å¦‚æœï¼ˆå¦‚æœï¼ï¼‰æœ‰ä¸€å¤©OneNoteè¢«ç æ‰äº†ï¼Œæˆ‘è§‰å¾—ä¸ä¼šæœ‰ç”¨æˆ·ä¼šå…ˆäºè‡ªå·±çš„ç¬”è®°å»æ‹…å¿§å·¨ç¡¬çš„æ˜å¤©ï¼Œç”¨æˆ·ç¬¬ä¸€è€ƒè™‘çš„è¯¥æ˜¯å¦‚ä½•å°†è‡ªå·±æ²‰ç§¯å¤šå¹´çš„ç¬”è®°ç»Ÿç»Ÿè½¬ç§»å‡ºæ¥ã€‚è¿™å¾ˆéš¾ï¼Œå³ä½¿è½¬ç§»å‡ºæ¥ï¼Œææ€•ä¹Ÿæ— æ³•è·å¾—åŒæ ·çš„ç¼–è¾‘ä½“éªŒã€‚ åœ¨è¿™é‡Œï¼Œç¼…æ€€ä¸€ä¸‹è¢«è°·å§ç æ‰çš„readerâ€¦ æ•°æ®å…·æœ‰æ›´é«˜çš„ä»·å€¼ï¼Œæ•°æ®åº”è¯¥å°½å¯èƒ½é¿å…å¯¹ç‰¹å®šç³»ç»Ÿçš„ä¾èµ–ã€‚ åœ¨è¿‡å»çš„ä¸€æ®µæ—¶é—´é‡Œï¼Œæˆ‘åˆå¤šæ¬¡çœ‹åˆ°äº†è¿™ç§æ„è§ã€‚æœ‰äººåœ¨è®¨è®ºNASæ—¶æŒæœ‰è¿™ç§è§‚ç‚¹ï¼Œè®¤ä¸ºè¦è¿œç¦»ä¸é è°±çš„ç½‘ç›˜ï¼Œæ•°æ®å’Œå¤„ç†æ•°æ®çš„å·¥å…·åº”è¯¥åˆ†ç¦»ï¼›åœ¨vnoteçš„issueä¸­çœ‹åˆ°ä½œè€…å¦å®šä½¿ç”¨sqliteä¿å­˜æ•°æ®æ—¶ä¹Ÿå¦‚æ˜¯è¯´ï¼Œä¸ä½¿ç”¨ç§æœ‰æ ¼å¼ï¼Œè¦ä¸ºç”¨æˆ·ç•™è¶³è½¬ç§»ç¬”è®°çš„ç©ºé—´ã€‚ ä¸è¿‡ï¼Œä¿æŒæ•°æ®æ›´é«˜çš„ç‹¬ç«‹æ€§ä¹Ÿå¹¶éå¥½äº‹ï¼Œè¿™ä¸€èˆ¬æ„å‘³ç€æ— æ³•å¾—åˆ°æ›´å¤šçš„åŠŸèƒ½ã€‚æƒ³è¦è§£å†³ä¹Ÿæœ‰ç‚¹æ€è·¯ï¼Œè¦ä¹ˆæŠŠç³»ç»Ÿç¨³å®šæ€§åšåˆ°æè‡´ï¼Œåˆ«æœ‰äº‹æ²¡äº‹å¨èƒæ•°æ®å®‰å…¨ï¼Œè¦ä¹ˆæŠŠæ ¼å¼åšæˆæ ‡å‡†ï¼Œå¤§å®¶é€šç”¨ï¼Œç»™æ•°æ®ç•™è¶³åè·¯ã€‚ æ‰€ä»¥æ‰¯äº†è¿™ä¹ˆå¤šåºŸè¯ï¼Œç»“è®ºå°±æ˜¯æˆ‘åˆå›åˆ°é™æ€åšå®¢äº†ï¼Œé¡ºä¾¿ä½“éªŒäº†ä¸€éä»æ•°æ®åº“è½¬ç§»åˆ°æ–‡ä»¶çš„ç—›è‹¦ã€‚å…ˆæŠŠæ•°æ®åº“å¯¼å‡ºjsonï¼Œå†æ‹¿pythonè½¬æ¢æ ¼å¼ï¼Œè¿˜è¦è«åå…¶å¦™å†è½¬ä¹‰ä¸€éæ–‡ä»¶é‡Œçš„dosæ¢è¡Œç¬¦ã€‚å•§ï¼Œå³ä½¿æ˜¯æœ€é€šç”¨çš„æ–‡æœ¬æ–‡ä»¶ï¼Œç…§æ ·ä¸åŒå¹³å°é—´ç§»æ¤ä¼šæœ‰ä»£ä»·ã€‚Â¯\\(ãƒ„)/Â¯ æˆ‘å†ä¹Ÿä¸æŠ˜è…¾äº†ï¼Œå†æŠ˜è…¾æˆ‘å°±æ˜¯ç‹—ã€‚ ","date":"2020-04-07","objectID":"/2020/04/info-dependence/:0:0","tags":[],"title":"ç”±Tiddywikiè¯´èµ·","uri":"/2020/04/info-dependence/"},{"categories":["å­¦ä¹ "],"content":"ç›®å‰ï¼Œé’ˆå¯¹å›¾ç‰‡ï¼Œè§†é¢‘ï¼Œæˆ‘ä»¬æœ‰é€šè¿‡åœ¨é¢‘åŸŸä¸Šä¹±æçš„æ–¹å¼ä¸ºå…¶æ·»åŠ ä¸å¯è§æ°´å°ã€‚è¿™ç§æŠ€æœ¯ä¸»è¦ä¾é çš„å°±æ˜¯äºŒç»´å‚…ç«‹å¶å˜æ¢ã€‚ $$ \\hat g(f)=\\int{g(t)e^{-2\\pi i ft}dt} $$ è¿™ä¸ªæ˜¯ä¸€ç»´çš„å‚…ç«‹å¶å˜æ¢ã€‚é‚£ä¹ˆï¼Œå¦‚æœç°åœ¨æœ‰ä¸€ä¸ªäºŒç»´ä¿¡å·$g(t_1,t_2)$ï¼Œæ˜¯ä¸æ˜¯å¯ä»¥ç®€å•çš„æŠŠä¸Šå¼æ”¹ä¸º $$ \\hat g(f_1,f_2)=\\int\\int{g(t_1,t_2)e^{-2\\pi i (f_1t_1+f_2t_2)}dt_1dt_2} $$ äº‹å®ä¸Šæ˜¯çš„ã€‚è€Œé€†å˜æ¢ä¸º $$ g(t_1,t_2)=\\frac{1}{4 \\pi^2}\\int\\int\\hat g(f_1,f_2)e^{2\\pi i (t_1f_1+t_2f_2)}df_1df_2 $$ å¦‚æœå†™æˆç¦»æ•£å½¢å¼ï¼Œä¹Ÿæ˜¯ä¸€ç§å¥—è·¯ã€‚ $$ \\hat g(f_1,f_2)=\\sum\\sum{g(t_1,t_2)e^{-2\\pi i (f_1t_1+f_2t_2)}} $$ $$ g(t_1,t_2)=\\frac{1}{4 \\pi^2}\\sum\\sum\\hat g(f_1,f_2)e^{2\\pi i (t_1f_1+t_2f_2)} $$ äºŒç»´çš„å‚…ç«‹å¶å˜æ¢ä»ç„¶æ˜¯å°†ä¿¡å·åˆ†è§£ä¸ºå¤šä¸ªæˆåˆ†ï¼Œåªä¸è¿‡è¿™é‡Œæˆäº†å¹³é¢æ„ä¹‰ä¸Šçš„æ³¢ï¼Œè€Œä¸”å¤šäº†ä¸€ä¸ªæ–¹å‘ã€‚è¿™é‡Œçš„æ–¹å‘æˆ‘ä»¬ç›´æ¥æŠŠ$f_1,f_2$ç»˜åˆ¶åˆ°ä¸­å¿ƒç‚¹ä¸º$(0,0)$çš„åæ ‡ç³»ä¸Šï¼Œä»è€Œèƒ½å¤Ÿå½¢æˆä¸€å¼ é™„å¸¦å…¨éƒ¨ä¿¡æ¯çš„é¢‘åŸŸå›¾ã€‚ å¯¹äºäºŒç»´å‚…ç«‹å¶å˜æ¢çš„ç»“æœï¼Œä¹Ÿå’Œä¸€ç»´çš„ç»“æœåˆç±»ä¼¼å«ä¹‰ã€‚ä¸€ä¸ªä¸€å…ƒå‡½æ•°çš„é«˜é¢‘ä½é¢‘æ„å‘³ç€å…¶å˜åŒ–å¿«ä¸æ…¢çš„æˆåˆ†ï¼Œä¸€ä¸ªå£°éŸ³çš„é«˜é¢‘ä½é¢‘æ„å‘³ç€å…¶é«˜éŸ³å’Œä½éŸ³éƒ¨åˆ†ï¼Œè€Œä¸€ä¸ªäºŒç»´å˜æ¢çš„ç»“æœé«˜é¢‘ä½é¢‘ä¹Ÿæ„å‘³ç€è¯¥æ•°æ®å˜åŒ–å¿«ä¸æ…¢çš„éƒ¨åˆ†ã€‚ æ—¢ç„¶èƒ½å¤Ÿä»éŸ³é¢‘é¢‘åŸŸä¸Šæ‘˜æ‰å¯¹å£°éŸ³æœ‰æ„ä¹‰çš„é¢‘ç‡ï¼ˆä¾‹å¦‚åˆ æ‰ä¸äººå£°ç›¸å…³çš„é¢‘ç‡ï¼‰ï¼Œé‚£å°±ä¹Ÿå¯ä»¥åœ¨å›¾ç‰‡é¢‘åŸŸä¸­å åŠ å¯¹äººæœ‰æ„ä¹‰çš„é¢‘ç‡ã€‚æ‰€è°“å›¾ç‰‡ä¸è§†é¢‘çš„éšå†™æœ¯å°±æ˜¯å°†å¯¹äººçœ¼æœ‰æ„ä¹‰çš„é¢‘ç‡å åŠ åˆ°é¢‘åŸŸä¸­å†è¿›è¡Œé€†å˜æ¢çš„ç»“æœã€‚åŒ…æ‹¬éŸ³é¢‘ä¹Ÿå¯ä»¥è¿™ä¹ˆå¹²ï¼Œåˆ©ç”¨çŸ­æ—¶è·å‚…ç«‹å¶å˜æ¢åœ¨é¢‘åŸŸä¸Šç”»ä¸€ç‚¹æœ‰æ„ä¹‰çš„å›¾åƒå†é€†å˜æ¢å›å»ï¼Œå°±èƒ½å½“ä½œæ›´é«˜çº§ä¸€ç‚¹çš„éŸ³é¢‘æ°´å°ã€‚ä¸è¿‡å®é™…æµ‹è¯•èµ·æ¥ï¼Œåœ¨éŸ³é¢‘é¢‘åŸŸä¸Šæå¾—å¤ªè¿‡å¤´çš„è¯å¬æ„Ÿå½±å“æŒºå¤§çš„ã€‚ è¿™ç§æŠ€æœ¯ç›¸æ¯”ç›´æ¥æ‰“æ°´å°æœ‰å¾ˆå¤šå¥½å¤„ï¼Œåˆ©ç”¨é¢‘ç‡çš„ç‰¹æ€§æ„å‘³ç€å®ƒå¯ä»¥å¯¹æŠ—å¾ˆå¤šä¸€èˆ¬çš„æ”»å‡»æ–¹å¼ã€‚ä¸è¿‡ä¸€æ—¦æ”»å‡»èƒ½å¤Ÿå½±å“é¢‘ç‡ï¼Œä¾‹å¦‚å†æ¬¡æ‹æ‘„/å½•éŸ³è¿™ç§ï¼Œè‡³å°‘æœ´ç´ çš„éšå†™å°±åŸºæœ¬ä¸Šggäº†ã€‚ æ‰€ä»¥çœ‹åˆ°æœ‰äººæ‹¿è¿™ä¸ªç©æ„å»æ°´å¤§åˆ›å°±æœ‰ç‚¹å¥½å¥‡ï¼Œé—®äº†é—®èƒ½å¦è¯†åˆ«æˆ‘ç°æ‹çš„ç…§ç‰‡ï¼Œå¾—åˆ°çš„ç­”å¤æ˜¯ä¸è¡Œâ€¦â€¦è¿˜ä»¥ä¸ºä¼šæœ‰å¹²è´§ï¼Œç¨å¾®æœ‰äº›å¤±æœ›ã€‚ ","date":"2020-03-27","objectID":"/2020/03/a-little-2d-fft/:0:0","tags":["FFT"],"title":"ä¸€ç‚¹ç‚¹äºŒç»´å‚…ç«‹å¶å˜æ¢","uri":"/2020/03/a-little-2d-fft/"},{"categories":["å­¦ä¹ "],"content":"ä»Šå¤©ä»ç„¶æ˜¯è¢«åŠèµ·æ¥æ‰“çš„ä¸€å¤©ã€‚ ç‚¹åˆ†æ²»æ˜¯ä¸€ç§ç”¨äºè§£å†³æ ‘ä¸Šè·¯å¾„é—®é¢˜çš„æ€è·¯ã€‚å®ƒçš„å…³é”®å°±æ˜¯é€‰ä¸­ä¸€ç‚¹ï¼Œç»Ÿè®¡ç»è¿‡è¯¥ç‚¹çš„ç­”æ¡ˆååˆ é™¤ç‚¹ï¼Œå†é€’å½’åˆ°ä¸¤ä¸ªå­æ ‘ä¸­è¿›è¡ŒåŒæ ·çš„æ“ä½œã€‚ åˆ é™¤çš„ç‚¹è¿å¸¦åˆ é™¤äº†ä¸€äº›å·²ç»è®¡ç®—è¿‡çš„è·¯å¾„ã€‚ å½“æ¯æ¬¡é€‰æ‹©é‡å¿ƒä½œä¸ºæ ¹æ—¶ï¼Œèƒ½ä¿è¯ç‚¹åˆ†æ²»çš„å¤æ‚åº¦æœ¬èº«ä¸º$O(n \\log n)$ã€‚å½“ç„¶ä½ å¾—ä¿è¯$O(n)$åšå®Œä½ çš„äº‹æƒ…ï¼ŒåŒæ ·æ¸…æ•°ç»„æ—¶ä¹Ÿå¿…é¡»åªæ¸…ç”¨åˆ°çš„ã€‚ å°è±¡é‡Œä¹‹å‰æœ‰é“æ ‘ä¸ŠDPçš„é¢˜ï¼Œè‡ªå·±yyçç³Šçš„ç®—æ³•å†™çš„éš¾çœ‹åˆéš¾è°ƒï¼Œå°±æœ‰ç‚¹è¿™ç§æ„Ÿè§‰ã€‚ä¸è¿‡é‚£ä¸ªæ˜¯$O(n)$çš„ï¼Œå¤§æ¦‚æ³›ç”¨ä¸Šä¸å¦‚è¿™ä¸ªã€‚ ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:0:0","tags":null,"title":"ä¸€ç‚¹ç‚¹ç‚¹åˆ†æ²»","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["å­¦ä¹ "],"content":"èªèªå¯å¯ èªèªå’Œå¯å¯æ˜¯å…„å¼Ÿä¿©ï¼Œä»–ä»¬ä¿©ç»å¸¸ä¸ºäº†ä¸€äº›çäº‹æ‰“èµ·æ¥ï¼Œä¾‹å¦‚å®¶ä¸­åªå‰©ä¸‹æœ€åä¸€æ ¹å†°æ£è€Œä¸¤äººéƒ½æƒ³åƒã€ä¸¤ä¸ªäººéƒ½æƒ³ç©å„¿ç”µè„‘ï¼ˆå¯æ˜¯ä»–ä»¬å®¶åªæœ‰ä¸€å°ç”µè„‘ï¼‰â€¦â€¦é‡åˆ°è¿™ç§é—®é¢˜ï¼Œä¸€èˆ¬æƒ…å†µä¸‹çŸ³å¤´å‰ªåˆ€å¸ƒå°±å¥½äº†ï¼Œå¯æ˜¯ä»–ä»¬å·²ç»ç©å„¿è…»äº†è¿™ç§ä½æ™ºå•†çš„æ¸¸æˆã€‚ ä»–ä»¬çš„çˆ¸çˆ¸å¿«è¢«ä»–ä»¬çš„äº‰åµçƒ¦æ­»äº†ï¼Œæ‰€ä»¥ä»–å‘æ˜äº†ä¸€ä¸ªæ–°æ¸¸æˆï¼šç”±çˆ¸çˆ¸åœ¨çº¸ä¸Šç”» nn ä¸ªâ€œç‚¹â€ï¼Œå¹¶ç”¨ n-1nâˆ’1 æ¡â€œè¾¹â€æŠŠè¿™ nn ä¸ªâ€œç‚¹â€æ°å¥½è¿é€šï¼ˆå…¶å®è¿™å°±æ˜¯ä¸€æ£µæ ‘ï¼‰ã€‚å¹¶ä¸”æ¯æ¡â€œè¾¹â€ä¸Šéƒ½æœ‰ä¸€ä¸ªæ•°ã€‚æ¥ä¸‹æ¥ç”±èªèªå’Œå¯å¯åˆ†åˆ«éšå³é€‰ä¸€ä¸ªç‚¹ï¼ˆå½“ç„¶ä»–ä»¬é€‰ç‚¹æ—¶æ˜¯çœ‹ä¸åˆ°è¿™æ£µæ ‘çš„ï¼‰ï¼Œå¦‚æœä¸¤ä¸ªç‚¹ä¹‹é—´æ‰€æœ‰è¾¹ä¸Šæ•°çš„å’ŒåŠ èµ·æ¥æ°å¥½æ˜¯ 33 çš„å€æ•°ï¼Œåˆ™åˆ¤èªèªèµ¢ï¼Œå¦åˆ™å¯å¯èµ¢ã€‚ èªèªéå¸¸çˆ±æ€è€ƒé—®é¢˜ï¼Œåœ¨æ¯æ¬¡æ¸¸æˆåéƒ½ä¼šä»”ç»†ç ”ç©¶è¿™æ£µæ ‘ï¼Œå¸Œæœ›çŸ¥é“å¯¹äºè¿™å¼ å›¾è‡ªå·±çš„è·èƒœæ¦‚ç‡æ˜¯å¤šå°‘ã€‚ç°è¯·ä½ å¸®å¿™æ±‚å‡ºè¿™ä¸ªå€¼ä»¥éªŒè¯èªèªçš„ç­”æ¡ˆæ˜¯å¦æ­£ç¡®ã€‚ ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:1:0","tags":null,"title":"ä¸€ç‚¹ç‚¹ç‚¹åˆ†æ²»","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ ç»Ÿè®¡è·¯å¾„ã€‚ä½†æ˜¯è¿™é¢˜dpçš„è¯èƒ½è½¬ç§»ã€‚ ä½†æ˜¯è¿˜æ˜¯ç”¨ç‚¹åˆ†æ²»ã€‚ æšä¸¾ä¸€ä¸ªç‚¹åï¼Œè®¾$f(u,j)$è¡¨ç¤ºåˆ°$u$ç‚¹æ¨¡3ä¸º$j$çš„è·¯å¾„æ•°æœ‰å¤šå°‘ã€‚è½¬ç§»å¾ˆæ˜æ˜¾ï¼Œç»Ÿè®¡ä¹Ÿå¾ˆæ˜¾ç„¶ã€‚ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003cqueue\u003e#include \u003ccstring\u003eusing namespace std; const int XV=20010; using pii=pair\u003cint,int\u003e; using ll=long long; vector\u003cpii\u003e g[XV]; bool vis[XV]; int sz[XV]; int dfs1(int u,int fa){ sz[u]=1; for(auto [v,w]:g[u]){ if(vis[v] || v==fa)continue; sz[u]+=dfs1(v,u); } return sz[u]; } int SZ; int rt; int maxsz[XV]; queue\u003cint\u003e ready_to_clear; void getroot(int u,int fa){ sz[u]=1; ready_to_clear.push(u); for(auto [v,w]:g[u]){ if(vis[v] || v==fa)continue; getroot(v,u); sz[u]+=sz[v]; maxsz[u]=max(maxsz[u],sz[v]); } maxsz[u]=max(maxsz[u],SZ-sz[u]); if(rt==0 || maxsz[u]\u003cmaxsz[rt])rt=u; } ll ans=0; ll f[XV][3]; void cal(int u,int fa){ for(auto [v,w]:g[u]){ if(vis[v] || v==fa)continue; cal(v,u); int t[3]; for(int i=0;i\u003c3;i++){ t[(i+w)%3]=f[v][i]; } t[w%3]++;//ç”±vç›´æ¥å‡ºå‘ if(u==rt){ //ä»è¯¥å­æ ‘åˆ°ä¹‹å‰æ‰€æœ‰çš„å­æ ‘ ans+=t[0]*f[u][0]; ans+=t[1]*f[u][2]; ans+=t[2]*f[u][1]; } for(int i=0;i\u003c3;i++){ f[u][i]+=t[i]; } } if(u==rt)ans+=f[u][0]; } void solve(int u){ vis[u]=1; while(!ready_to_clear.empty()){ int u=ready_to_clear.front();ready_to_clear.pop(); f[u][0]=f[u][1]=f[u][2]=0; maxsz[u]=0; } cal(u,0); //cout\u003c\u003c\"after\"\u003c\u003cu\u003c\u003c\",ans=\"\u003c\u003cans\u003c\u003cendl; for(auto [v,w]:g[u]){ if(vis[v])continue; SZ=sz[v];rt=0; getroot(v,0); solve(rt); } } ll gcd(ll a,ll b){ return !b?a:gcd(b,a%b); } int main(){ ios::sync_with_stdio(false); int nlen;cin\u003e\u003enlen; for(int i=1;i\u003c=nlen-1;i++){ int u,v,w;cin\u003e\u003eu\u003e\u003ev\u003e\u003ew; g[u].emplace_back(v,w); g[v].emplace_back(u,w); } memset(vis,0,sizeof(vis)); SZ=nlen; rt=0;getroot(1,0); solve(rt); ll win=ans*2+nlen; ll all=1LL*nlen*nlen; ll g=gcd(win,all); cout\u003c\u003cwin/g\u003c\u003c\"/\"\u003c\u003call/g\u003c\u003cendl; } ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:1:1","tags":null,"title":"ä¸€ç‚¹ç‚¹ç‚¹åˆ†æ²»","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["å­¦ä¹ "],"content":"[HDU6643] yts1999 Doesnâ€™t Like This Problem Mr. Bread has a tree T with n vertices, labeled by 1,2,â€¦,n. Each vertex of the tree has a positive integer value wi. The value of a non-empty tree T is equal to w1Ã—w2Ã—â‹¯Ã—wn. A subtree of T is a connected subgraph of T that is also a tree. Please write a program to calculate the number of non-empty subtrees of T whose values are not larger than a given number m. ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:2:0","tags":null,"title":"ä¸€ç‚¹ç‚¹ç‚¹åˆ†æ²»","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ è™½ç„¶æˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆå°±æ˜¾ç„¶ç‚¹åˆ†æ²»äº†ï¼Œä½†æ˜¯ä»–ä»¬è¯´æ˜¯ã€‚è¦DPè¿˜æ˜¯å®¹æ˜“çœ‹å‡ºæ¥çš„ã€‚ ç‚¹åˆ†æ²»èƒ½å¤Ÿè§£å†³è·¯å¾„é—®é¢˜ï¼Œè¿™ç§è¿é€šæ€§é—®é¢˜ä¹Ÿå¯ä»¥è§£å†³ã€‚ä¹Ÿæ˜¯æšä¸¾ä¸€ä¸ªç‚¹åï¼Œç»Ÿè®¡åŒ…æ‹¬è¿™ä¸ªç‚¹çš„è¿é€šå—çš„ç­”æ¡ˆã€‚ é€‰ä¸­è¯¥ç‚¹åï¼Œè¿›è¡ŒDPã€‚ç„¶åæ˜¯ä»–ä»¬è¯´çš„éå¸¸å¥—è·¯çš„åˆ©ç”¨dfsåºå°†æ ‘æ˜ å°„åˆ°åºåˆ—ä¸Šçš„åšæ³•ã€‚ä»¥$f(i,j)$è¡¨ç¤ºåœ¨$i$ç‚¹å¤„å€¼ä¸º$j$çš„æ–¹æ¡ˆæ•°ã€‚ é€‰ä¸­$i$ï¼š $$f(i,ja)+=f(i+1,a)$$ ä¸é€‰$i$ï¼Œé‚£ä¹ˆåŒæ—¶è¦è·³è¿‡içš„æ•´ä¸ªå­æ ‘ï¼š $$f(i,j)+=f(i+\\text{sz}(i),j)$$ å¦å¤–æ˜¯è¿™é“é¢˜çš„$j$èŒƒå›´å¤ªå¤§ã€‚çœ‹åˆ°ä¸€ä¸ªå¾ˆéªšçš„å†™æ³•æ˜¯å­˜æˆ$j$å’Œ$M/j$ï¼Œç„¶åæ¯ä¸ªéƒ½åªæœ‰$\\sqrt M$è¿™ä¹ˆå¤§â€¦æˆ‘å¯»æ€ä½ å†ç»™æˆ‘ä¸€éè¿™ä¸ªé¢˜æˆ‘ä¹Ÿyyä¸å‡ºæ¥è¿™ç§å­˜æ³•ã€‚ æ€»ä¹‹æœ‰ä¸¤ä¸ªä¸œè¥¿å¯ä»¥æ³¨æ„ä¸€ä¸‹ï¼š å¯¹æ ‘ä¸Šæ¶‰åŠä¾èµ–å…³ç³»çš„DPå¯ä»¥è€ƒè™‘ä½¿ç”¨dfsåºæ˜ å°„ã€‚ æˆ‘ä¸çŸ¥é“è¿™ä¸ªå¤„ç†jçš„åŠæ³•æœ‰æ²¡æœ‰æ³›ç”¨æ€§ã€‚ ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:2:1","tags":null,"title":"ä¸€ç‚¹ç‚¹ç‚¹åˆ†æ²»","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  ä»£ç ä¸­çš„é‡å¿ƒã€ç‚¹åˆ†æ²»çš„solveåº”è¯¥å½¢æˆè¾ƒä¸ºå›ºå®šçš„å†™æ³•ã€‚ origin /// copied #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccmath\u003e using namespace std; using ll=long long; const int XN=2010; vector\u003cint\u003e g[XN]; int dfn[XN],sz[XN],tick=0; int re[XN]; int vis[XN]; int wage[XN]; int m; int square; int dfs(int u,int fa) { sz[u] = 1; dfn[u] = ++tick; re[tick] = u; for (auto v:g[u]) { if (vis[v] || v==fa)continue; sz[u] += dfs(v, u); } return sz[u]; } int SZ; int maxsz[XN],root=0; void getroot(int u,int fa) { sz[u] = 1; maxsz[u] = 0; for (auto v:g[u]) { if (vis[v] || v == fa)continue; getroot(v, u); sz[u] += sz[v]; maxsz[u] = max(maxsz[u], sz[v]); } maxsz[u] = max(maxsz[u], SZ - maxsz[u]); if (root == 0 || maxsz[u] \u003c maxsz[root])root = u; } const int MOD=1000000007; int M(int \u0026x) { return x %= MOD; } int f[XN][XN],f2[XN][XN]; int cal() { //é»˜è®¤é€‰ä¸­root int res = 0; for (int i = 0; i \u003c= tick + 1; i++) { memset(f[i], 0, sizeof(f[i])); memset(f2[i], 0, sizeof(f2[i])); } f[tick + 1][1] = 1; for (int i = tick; i \u003e= 1; i--) { int w = wage[re[i]]; for (int j = 1; j \u003c= min(m / w, square); j++) { int to = w * j; if (to \u003c= square)M(f[i][to] += f[i + 1][j]); else M(f2[i][m / to] += f[i + 1][j]); } for (int j = w; j \u003c= square; j++) { M(f2[i][j / w] += f2[i + 1][j]); } //ä¸é€‰jï¼Œé‚£ä¹ˆè¦è·³è¿‡æ•´ä¸ªå­æ ‘ for (int j = 1; j \u003c= square; j++)M(f[i][j] += f[i + sz[re[i]]][j]); for (int j = 1; j \u003c= square; j++)M(f2[i][j] += f2[i + sz[re[i]]][j]); } for (int i = 1; i \u003c= square; i++)M(res += f[1][i]); for (int i = 1; i \u003c= square; i++)M(res += f2[1][i]); //å»æ‰ä¸é€‰rootçš„æƒ…å†µ res--; return M(res += MOD); } int ans=0; void solve(int u) { vis[u] = 1; tick = 0; dfs(u, 0); M(ans += cal()); for (auto v:g[u]) { if (vis[v])continue; SZ = sz[v]; root = 0; getroot(v, 0); solve(root); } } int main() { int kase; cin \u003e\u003e kase; while (kase--) { int n; cin \u003e\u003e n \u003e\u003e m; square = sqrt(m); for (int i = 1; i \u003c= n; i++)g[i].clear(); memset(vis,0,sizeof(vis)); tick = 0; ans = 0; for (int i = 1; i \u003c= n; i++)cin \u003e\u003e wage[i]; for (int i = 1; i \u003c= n - 1; i++) { int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v); g[v].push_back(u); } root = 0; SZ = n; getroot(1, 0); solve(root); cout \u003c\u003c ans \u003c\u003c endl; } } ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:2:2","tags":null,"title":"ä¸€ç‚¹ç‚¹ç‚¹åˆ†æ²»","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["å­¦ä¹ "],"content":"è‰¹äº†å¤©å¤©éƒ½è¢«ä¸çŸ¥é“çš„çŸ¥è¯†ç‚¹æ•™è‚²ï¼ŒçŸ¥é“çš„åˆåšä¸å‡ºæ¥ã€‚ :lei: åœ¨åŠ¨æ€è§„åˆ’ä¸­ï¼Œå†³ç­–å•è°ƒæ€§æŒ‡å¯¹äº$j \u003c j'$ï¼Œ$f(jâ€™)$çš„æœ€ä½³è½¬ç§»$f(iâ€™)$ä½ç½®$i'$ä¸€å®šä¸å°äº$f(j)$çš„$i$ã€‚ å‡è®¾ $$f(r)=\\min{f(k-1)+w(k,r)}$$ ä¸ºäº†è¯æ˜è¿™ä¸€ç‚¹ï¼Œé¦–å…ˆå‡è®¾ $$f(r)=f(k-1)+w(k,r)$$ æ­¤æ—¶æˆ‘ä»¬æœ‰$\\forall i \u003c k$ï¼Œ $$f(k-1)+w(k,r) æ­¤åï¼Œå°†råæŒª1ã€‚æˆ‘ä»¬å¿…é¡»è¦è¯æ˜$\\forall i \u003c k$ï¼Œ $$f(k-1)+w(k,r+1) ä¹Ÿå°±æ˜¯è¯æ˜å¯¹äºä¸¤è¾¹çš„ä¸¤ä¸ªå¢é‡$\\Delta$æœ‰ $$w(k,r+1) - w(k,r) ","date":"2020-03-23","objectID":"/2020/03/juece-dandiao/:0:0","tags":null,"title":"ä¸€ç‚¹ç‚¹å†³ç­–å•è°ƒæ€§","uri":"/2020/03/juece-dandiao/"},{"categories":["å­¦ä¹ "],"content":"ä½¿ç”¨åˆ†æ²» ä¸€æ—¦æœ‰å†³ç­–å•è°ƒæ€§äº†ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ä¼˜äº$n^2$çš„æ€»å¤æ‚åº¦å®Œæˆè§„åˆ’ã€‚ ä¾‹å¦‚ä½¿ç”¨åˆ†æ²»ã€‚å½“æˆ‘ä»¬æ‰¾åˆ°åŒºé—´$[ l, r ]$çš„ä¸­ç‚¹$m$çš„å†³ç­–ç‚¹$p$æ—¶ï¼Œé‚£ä¹ˆ$[l, m-1]$åŒºé—´åªèƒ½ä»ä¸æ™šäº$p$è½¬ç§»ï¼Œ$[m+1, r]$åªèƒ½ä»ä¸æ—©äº$p$è½¬ç§»ã€‚ lå’Œræ˜¯å½“å‰è¦å†³ç­–çš„åŒºé—´ï¼ŒLå’ŒRæ˜¯è½¬ç§»ä½ç½®ã€‚ void solve(int l,int r,int L,int R) { if(l\u003er)return; int mid=(l+r)/2; int p=0; for(int i=L;i\u003c=min(mid,R);i++){ //è¿™é‡Œçš„ä¸‹æ ‡å†™æ³•è¦å’Œæ–¹ç¨‹é…å¥— if(f[i-1]+w[i,mid]\u003cf[mid]){ f[mid]=f[i-1]+w[i,mid]; p=i; } } solve(l,mid-1,L,p); solve(mid+1,r,p,R); } ","date":"2020-03-23","objectID":"/2020/03/juece-dandiao/:1:0","tags":null,"title":"ä¸€ç‚¹ç‚¹å†³ç­–å•è°ƒæ€§","uri":"/2020/03/juece-dandiao/"},{"categories":["å­¦ä¹ "],"content":"ã€CF868Fã€‘yts1999 Doing Minimization You are given an array of n integers a1â€¦ an. The cost of a subsegment is the number of unordered pairs of distinct indices within the subsegment that contain equal elements. Split the given array into k non-intersecting non-empty subsegments so that the sum of their costs is minimum possible. Each element should be present in exactly one subsegment. ","date":"2020-03-23","objectID":"/2020/03/juece-dandiao/:2:0","tags":null,"title":"ä¸€ç‚¹ç‚¹å†³ç­–å•è°ƒæ€§","uri":"/2020/03/juece-dandiao/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ è®¾$f(i,j)$è¡¨ç¤ºå‰jä¸ªåˆ†iæ®µã€‚ è¿™ä¸ªé¢˜ç›®å°±æ»¡è¶³å†³ç­–å•è°ƒã€‚ä¸€ä¸ªæ›´é•¿çš„åŒºé—´+1ä¹‹ååªæœ‰å¯èƒ½æ¯”çŸ­çš„åŒºé—´å¢åŠ æ›´å¤šçš„ä»£ä»·ã€‚ æ¥ä¸‹æ¥çš„é—®é¢˜æ˜¯æ€ä¹ˆç®—è¿™é“é¢˜é‡Œçš„$w(i,j)$ã€‚$n^2$æ˜¾ç„¶ä¸è¡Œã€‚çœ‹åˆ°æœ‰äººæ•´äº†ä¸ªç±»ä¼¼è«é˜Ÿçš„ä¸œè¥¿ï¼Œä¸è¿‡æˆ‘è¿˜æ²¡å¤ªå¼„æ˜ç™½è¿™ä¸ªå¤æ‚åº¦æ˜¯æ€ä¹ˆç®—çš„ï¼Œçœ‹èµ·æ¥æ˜¯å’Œåˆ†æ²»çš„å†…å±‚å¾ªç¯ä¸€è‡´æ‰€ä»¥å°±å¯¹å¤æ‚åº¦æ²¡æœ‰æ›´å¤šçš„è´¡çŒ®äº†ã€‚ ä¸€å…±è¿›è¡Œkè½®åˆ†æ²»ï¼Œ$O(kn\\log n)$ #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003eusing namespace std; using ll=long long; const int XN=100010; ll f[30][XN]; ll wage; int cl,cr; int num[XN]; ll cnt[XN]; void jump(int l,int r){ while(cl\u003cl){ cnt[num[cl]]--; wage-=cnt[num[cl]]; cl++; } while(l\u003ccl){ cl--; wage+=cnt[num[cl]]; cnt[num[cl]]++; } while(r\u003ccr){ cnt[num[cr]]--; wage-=cnt[num[cr]]; cr--; } while(cr\u003cr){ cr++; wage+=cnt[num[cr]]; cnt[num[cr]]++; } } void solve(int l,int r,int L,int R,int k) { if(l\u003er)return; int mid=(l+r)/2; int p=0; for(int i=L;i\u003c=min(mid,R);i++){ jump(i,mid); if(f[k-1][i-1]+wage\u003cf[k][mid]){ f[k][mid]=f[k-1][i-1]+wage; p=i; } } solve(l,mid-1,L,p,k); solve(mid+1,r,p,R,k); } int main(){ ios::sync_with_stdio(false); int n,kk;cin\u003e\u003en\u003e\u003ekk; for(int i=1;i\u003c=n;i++)cin\u003e\u003enum[i]; memset(f,0x3f,sizeof(f)); for(auto \u0026 i : f)i[0]=0; for(int i=1;i\u003c=n;i++){ wage+=cnt[num[i]]; cnt[num[i]]++; f[1][i]=wage; } // for(int i=1;i\u003c=n;i++){ // cout\u003c\u003cf[1][i]\u003c\u003c\u0026#039; \u0026#039;; // } // cout\u003c\u003cendl; wage=0;cl=1;cr=0; memset(cnt,0,sizeof(cnt)); for(int i=2;i\u003c=kk;i++){ solve(1,n,1,n,i); } cout\u003c\u003cf[kk][n]\u003c\u003cendl; } ","date":"2020-03-23","objectID":"/2020/03/juece-dandiao/:2:1","tags":null,"title":"ä¸€ç‚¹ç‚¹å†³ç­–å•è°ƒæ€§","uri":"/2020/03/juece-dandiao/"},{"categories":["code"],"content":"Patrick Star bought a bookshelf, he named it ZYG !! Patrick Star has N book . The ZYG has K layers (count from 1 to K) and there is no limit on the capacity of each layer ! Now Patrick want to put all N books on ZYG : Assume that the i-th layer has cnti(0â‰¤cntiâ‰¤N) books finally. Assume that f[i] is the i-th fibonacci number (f[0]=0,f[1]=1,f[2]=1,f[i]=f[iâˆ’2]+f[iâˆ’1]). Define the stable value of i-th layers stablei=f[cnti]. Define the beauty value of i-th layers beautyi=2stableiâˆ’1. Define the whole beauty value of ZYG score=gcd(beauty1,beauty2,â€¦,beautyk)(Note: gcd(0,x)=x). Patrick Star wants to know the expected value of score if Patrick choose a distribute method randomly ! ","date":"2020-03-21","objectID":"/2020/03/hdu-6363-bookshelf/:0:0","tags":null,"title":"[HDU 6363] bookshelf","uri":"/2020/03/hdu-6363-bookshelf/"},{"categories":["code"],"content":"åˆ†æ æˆ‘tmè¿™è¾ˆå­å­¦ä¸ä¼šæ•°è®ºäº†ã€‚ å…ˆæ˜¯ä¸¤ä¸ªã€â€”â€”ã€‘ç»“è®º $\\gcd(2^a-1,2^b-1)=2^{\\gcd(a,b)}-1$ $\\gcd(\\text{fib}(a),\\text{fib}(b))=\\text{fib}(\\gcd(a),\\gcd(b))$ ç„¶ååŸé¢˜çš„scoreå°±å˜æˆ $$2^{\\text{fib}(\\gcd(a_1,a_2,\\cdots))}-1$$ æ¥ä¸‹æ¥æ‰æœ‰æœºä¼šçæã€‚æšä¸¾gcdï¼Œ$d|n$ï¼Œ$a$çš„åˆ†é…æ–¹å¼æœ‰$C^{n/d+k-1}{k-1}$ç§ã€‚è¿™ç§åˆ†é…åŒ…æ‹¬äº†dâ€™æ˜¯dçš„å€æ•°çš„æ‰€æœ‰æƒ…å†µçš„å¯èƒ½ã€‚ä»¤$F(d)=C^{n/d+k-1}{k-1}$ï¼Œ$f(d)$ä¸ºçœŸæ­£çš„æ•°ç›®ï¼Œäºæ˜¯æœ‰ $$F(d)=\\sum_{d|d'}f(d')$$ ä¾ç…§è«æ¯”ä¹Œæ–¯åæ¼”ï¼Œæœ‰ $$f(d)=\\sum_{d|d'}\\mu(\\frac{d'}{d})F(d')$$ äºæ˜¯åŸé¢˜å¾—ä»¥è§£å†³ã€‚ ","date":"2020-03-21","objectID":"/2020/03/hdu-6363-bookshelf/:1:0","tags":null,"title":"[HDU 6363] bookshelf","uri":"/2020/03/hdu-6363-bookshelf/"},{"categories":["å­¦ä¹ "],"content":"æŠ„èµ·æˆ‘çš„æ··å‡åœŸæ•°å­¦ï¼Œå¤ä¹ äº†ä¼šä¸Šå‡ä¸‹é™ç§¯åˆ†ï¼Œçœ‹äº†çœ‹æ–¯ç‰¹æ—æ•°å’Œä¼¯åŠªåˆ©æ•°ã€‚ç»“æœè¯¯æŠŠä¼¯åŠªåˆ©æ•°çš„é€’æ¨å¼çœ‹æˆäº†$O(n)$çš„ï¼Œæ”¹äº†åŠå¤©ä¸€åˆ°3æ¬¡æ–¹ä»¥ä¸Šå°±ç¿»è½¦ï¼Œè¿™æ‰ååº”è¿‡æ¥ã€‚ 8ä¼šå•Šâ€¦æ‰¾äº†å¾ˆé•¿æ—¶é—´æ‰çŸ¥é“æ˜¯æ‹‰æ ¼æœ—æ—¥æ’å€¼ã€‚ æœ‰è¿™ä¹ˆä¸€æ¡å®šç†ã€‚ å¹³é¢ä¸Šçš„n+1ä¸ªç‚¹å¯ä»¥ç¡®å®šä¸€ä¸ªnæ¬¡å¤šé¡¹å¼ã€‚ è€Œ$\\sum i^p$æ˜¯ä¸€ä¸ª$p+1$æ¬¡å¤šé¡¹å¼ï¼Œå†µä¸”åœ¨$p \\leq 1000000$çš„å‰æä¸‹å¾ˆå®¹æ˜“æ‰¾åˆ°å‰$p+1$ä¸ªç‚¹ã€‚å¦‚æœæˆ‘ä»¬æ‰¾åˆ°ä¸€ç§æ–¹å¼å»æ„é€ è¿™æ ·ä¸€ä¸ªå¤šé¡¹å¼é—®é¢˜å°±è§£å†³äº†ã€‚ æ‹‰æ ¼æœ—æå‡ºäº†è¿™ä¹ˆä¸€ç§æ–¹æ³•ã€‚ ","date":"2020-03-19","objectID":"/2020/03/lagrange-polynomial/:0:0","tags":null,"title":"ä¸€ç‚¹ç‚¹æ‹‰æ ¼æœ—æ—¥æ’å€¼","uri":"/2020/03/lagrange-polynomial/"},{"categories":["å­¦ä¹ "],"content":"æ„é€  è®¾å‡½æ•° $$\\ell_j(x)=\\prod_{k \\neq j} \\frac{x-x_k}{x_j-x_k}$$ æ³¨æ„å…¶ç‰¹æ€§ $x_j$è¢«å¸¦å…¥æ—¶ï¼Œå…¶ä¸º$1$ å…¶ä»–ä»»ä½•$x$è¢«å¸¦å…¥æ—¶ï¼Œä¼šå‡ºç°$0$é¡¹ã€‚ å› æ­¤è¿™ä¸ªä¸œè¥¿å°±å¯ä»¥ä¸ºä»»ä½•ä¸€ä¸ªç‚¹å¯¹åˆ›å»ºåœ¨å¤šé¡¹å¼ä¸­çš„å•å…ƒ$y_j \\ell_j(x_j)$ã€‚å‰©ä¸‹çš„é—®é¢˜æ˜¯å¦‚ä½•å¿«é€Ÿæ±‚è§£ã€‚ å½“æˆ‘ä»¬åªæ±‚å•ç‚¹ï¼ˆç‡å…ˆå¸¦å…¥ç‚¹ï¼‰ï¼Œä¸”æ•´æ•°xè¿ç»­å–å€¼æ—¶ï¼Œè§‚å¯Ÿåˆ°åˆ†æ¯å’Œåˆ†å­éƒ½å˜ä¸ºé˜¶ä¹˜å½¢å¼ï¼Œä¸”åˆ†å¼çš„æ„æˆå…ƒç´ åœ¨å‰åä¸¤é¡¹ä¹‹é—´å…·æœ‰é€’æ¨çš„å…³ç³»ã€‚ $$ \\ell_j(x)=\\frac{(x-1)(x-2)\\cdots (x-(j-1))(x-(j+1))\\cdots (x-n)}{(j-1)(j-2) \\cdots (j-(j-1))(j-(j+1)) \\cdots (j-n))} $$ å¯ä»¥çœ‹åˆ°ï¼Œåˆ†å­å’Œåˆ†æ¯é¡¹éƒ½èƒ½å¤Ÿæ‹†åˆ†ä¸ºå·¦å³ä¸¤ä¸ªéƒ¨åˆ†ã€‚åˆ†åˆ«ç»´æŠ¤å‰ç¼€åç¼€ä¸é˜¶ä¹˜é€†å…ƒå³å¯ã€‚ é˜¶ä¹˜å¹¶ä¸éœ€è¦å…¨éƒ¨çš„ï¼Œä»…ä»…æ˜¯å·¦ä¾§å’Œå³ä¾§çš„ä¸€å°éƒ¨åˆ†ã€‚ ","date":"2020-03-19","objectID":"/2020/03/lagrange-polynomial/:1:0","tags":null,"title":"ä¸€ç‚¹ç‚¹æ‹‰æ ¼æœ—æ—¥æ’å€¼","uri":"/2020/03/lagrange-polynomial/"},{"categories":["å­¦ä¹ "],"content":"æ¿å­ å«–çš„ï¼Œè‡ªå·±çš„å†™çˆ†äº†è€Œä¸”å·¨ä¸‘ã€‚ int lagrange(int n,int *x,int *y,int k) { int ans=0; for(int i=1;i\u003c=n;++i) { int f=1,g=1; for(int j=1;j\u003c=n;++j) if(i!=j) { f=1LL*f*(k-x[j]+mod)%mod; g=1LL*g*(x[i]-x[j]+mod)%mod; } upd(ans,1LL*y[i]*f%mod*inv(g)%mod); } return ans; } int lagrange(int n,int *y,int k) { int ans=0; pre[0]=suf[n+1]=1; for(int i=1;i\u003c=n;++i) pre[i]=1LL*pre[i-1]*(k-i)%mod; for(int i=n;i\u003e=1;--i) suf[i]=1LL*suf[i+1]*(k-i)%mod; for(int i=1;i\u003c=n;++i) { int a=1LL*pre[i-1]*suf[i+1]%mod*inv[i-1]%mod*inv[n-i]%mod; if((n-i)\u00261) a=mod-a; upd(ans,1LL*a*y[i]%mod); } return ans; } ","date":"2020-03-19","objectID":"/2020/03/lagrange-polynomial/:2:0","tags":null,"title":"ä¸€ç‚¹ç‚¹æ‹‰æ ¼æœ—æ—¥æ’å€¼","uri":"/2020/03/lagrange-polynomial/"},{"categories":["å­¦ä¹ "],"content":"é”™è¯¯çš„ä»£ç  è¿™ä»½çœ‹é”™äº†ä¼¯åŠªåˆ©æ•°çš„é€’æ¨å¤æ‚åº¦ #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cset\u003e#include \u003ccmath\u003e#include \u003cmap\u003eusing namespace std; using ll=long long; const int MAXN=1000010; const int mod=1e9+7; ll inv[MAXN]; double B[MAXN]; double C[MAXN]; void init(int n){ //niyuan inv[1]=1; for(int i=2;i\u003c=n+1;i++) { inv[i] = inv[mod % i] * (mod - mod / i) % mod; } //C C[0]=1; for(int i=1;i\u003c=n+1;i++){ // C[i]=C[i-1]*(n+1-i+1)%mod*inv[i]%mod; C[i]=C[i-1]*(n+1-i+1)/i; } //WRONG //ä¼¯åŠªåˆ©æ•°çš„é€’æ¨æ˜¯n^2çº§åˆ«çš„ï¼Œç†è§£å¼å­ä¸Šå‡ºç°äº†å¤±è¯¯ã€‚ B[0]=1; double s=C[0]; for(int i=1;i\u003c=n;i++){ // B[i]=-inv[i+1]*s%mod; // s=(s+B[i]*C[i]%mod)%mod; B[i]=-s/(i+1); s=(s+B[i]*C[i]); } } ll n2[MAXN]; int main(){ ll n,m;cin\u003e\u003en\u003e\u003em; init(m); for(int i=0;i\u003c=m;i++)cout\u003c\u003cC[i]\u003c\u003c\" \"; cout\u003c\u003cendl; for(int i=0;i\u003c=m;i++)cout\u003c\u003cB[i]\u003c\u003c\" \"; cout\u003c\u003cendl; n2[0]=1; for(int i=1;i\u003c=m+1;i++){ n2[i]=n2[i-1]*n%mod; } for(int i=0;i\u003c=m+1;i++)cout\u003c\u003cn2[i]\u003c\u003c\" \"; cout\u003c\u003cendl; double ans=0; for(int i=0;i\u003c=m;i++){ // ans=(ans+C[i]*B[i]%mod*n2[m+1-i]%mod)%mod; ans=(ans+C[i]*B[i]*n2[m+1-i]); } // (ans*=inv[m+1])%=mod; ans=ans/(m+1); cout\u003c\u003cans\u003c\u003cendl; } è¿™ä»½è‡ªå·±yyçš„æ‹‰æ ¼æœ—æ—¥æ’å€¼åœ¨é˜¶ä¹˜çš„æ±‚æ³•ä¸Šæœ‰é—®é¢˜ã€‚ #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cset\u003e#include \u003ccmath\u003e#include \u003cmap\u003eusing namespace std; using ll=long long; const int MAXN=1000010; const int mod=1e9+7; ll fac[MAXN]; ll facinv[MAXN]; ll inv[MAXN]; ll qpow(ll a,ll b,ll p=mod){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%p){ if(b\u00261){ res=res*a%p; } } return res; } inline ll get_inv(ll a,ll p=mod){ return qpow(a,p-2,p); } inline ll Fac(int n,bool pos=true){ int flg=1; if(!pos \u0026\u0026 n%2==1)flg=-1; return fac[n]*flg; } inline ll Invfac(int n,bool pos=true){ int flg=1; if(!pos \u0026\u0026 n%2==1)flg=-1; return facinv[n]*flg; } void init(int n){ fac[0]=1; for(int i=1;i\u003c=n;i++)fac[i]=fac[i-1]*i%mod; facinv[n]=get_inv(fac[n]); for(int i=n-1;i\u003e=1;i--){ facinv[i]=facinv[i+1]*(i+1)%mod; } facinv[0]=1; inv[1]=1; for(int i=2;i\u003c=n;i++) inv[i] = inv[mod % i] * (mod-mod/i) % mod; } ll ans=0; ll yy[MAXN]; int main(){ int n,m;cin\u003e\u003en\u003e\u003em; int M=m+2; init(max(n,M)); for(int i=1;i\u003c=M;i++){ yy[i]=qpow(i,m); } for(int i=1;i\u003c=M;i++){ yy[i]=(yy[i]+yy[i-1])%mod; } for(int i=1;i\u003c=M;i++)cout\u003c\u003cyy[i]\u003c\u003c\" \"; cout\u003c\u003cendl; if(n\u003c=M){ cout\u003c\u003cyy[n]\u003c\u003cendl; return 0; } for(int i=1;i\u003c=M;i++){ ll cell=yy[i]*Fac(n-1)%mod*Invfac(n-M-1)%mod*inv[n-i]%mod; (cell*=Invfac(i-1))%=mod; (cell*=Invfac(abs(i-M),false))%=mod; (ans+=cell)%=mod; // ll cell=yy[i]*Fac(n-1)/Fac(n-M-1)/(n-i); // cell/=Fac(i-1); // cell/=Fac(abs(i-M),false); // ans+=cell; } cout\u003c\u003c(ans+mod)%mod\u003c\u003cendl; } ","date":"2020-03-19","objectID":"/2020/03/lagrange-polynomial/:3:0","tags":null,"title":"ä¸€ç‚¹ç‚¹æ‹‰æ ¼æœ—æ—¥æ’å€¼","uri":"/2020/03/lagrange-polynomial/"},{"categories":["code"],"content":"HDU6319 Ascending Rating Before the start of contest, there are n ICPC contestants waiting in a long queue. They are labeled by 1 to n from left to right. It can be easily found that the i-th contestantâ€™s QodeForces rating is ai. Little Q, the coach of Quailty Normal University, is bored to just watch them waiting in the queue. He starts to compare the rating of the contestants. He will pick a continous interval with length m, say [l,l+mâˆ’1], and then inspect each contestant from left to right. Initially, he will write down two numbers maxrating=âˆ’1 and count=0. Everytime he meets a contestant k with strictly higher rating than maxrating, he will change maxrating to ak and count to count+1. Little T is also a coach waiting for the contest. He knows Little Q is not good at counting, so he is wondering what are the correct final value of maxrating and count. Please write a program to figure out the answer. ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:1:0","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"åˆ†æ ä¸€å¼€å§‹æƒ³ç€ä»å·¦åˆ°å³æ»‘åŠ¨çª—å£ç»´æŠ¤ä¸€ä¸ªå•è°ƒé˜Ÿåˆ—ï¼Œç»“æœå‘ç°æ²¡æ³•ç»Ÿè®¡countã€‚ åå‘æ»‘åŠ¨å°±å¥½äº†ï¼Œæˆ‘è¿˜æ²¡å¤ªååº”è¿‡æ¥ä¸ºå•¥ã€‚å”¯ä¸€æ‰ä½çš„ä¸€ç‚¹æƒ³æ³•æ˜¯â€œæ•°æ®æ— ç”¨â€çš„æ—¶åˆ»ã€‚åœ¨æ­£å‘ç»´æŠ¤æ—¶ï¼Œåæƒ³åŠ å…¥ä½†æ˜¯æœªè¢«åŠ å…¥çš„å…ƒç´ å¯èƒ½å› ä¸ºå‰è€…popæ‰è€Œæ¼æ‰ï¼Œä½†æ˜¯åå‘ç»´æŠ¤æ—¶åªä¼šå¼¹å‡ºå·²ç»ä½¿ç”¨çš„æ— ç”¨å…ƒç´ ï¼Œä»»ä½•æ—¶å€™æ–°å…ƒç´ éƒ½ä¼šè¢«åŠ å…¥ã€‚ ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:1:1","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"HDU6331 Walking Plan There are n intersections in Bytetown, connected with m one way streets. Little Q likes sport walking very much, he plans to walk for q days. On the i-th day, Little Q plans to start walking at the si-th intersection, walk through at least ki streets and finally return to the ti-th intersection. Little Qâ€™s smart phone will record his walking route. Compared to stay healthy, Little Q cares the statistics more. So he wants to minimize the total walking length of each day. Please write a program to help him find the best route. ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:2:0","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"åˆ†æ â€¦â€¦æœç„¶è¿˜æ˜¯èœï¼Œåˆ«äººè¿‡å¾—åƒé£ä¸€æ ·ã€‚å…ˆæ˜¯è¯»é”™äº†é¢˜ï¼ŒæŠŠki streetsç†è§£æˆäº†è·¯å¾„æƒçš„é™åˆ¶ï¼Œå°±ç¿»äº†è½¦ã€‚åå‘ç°æ˜¯kæ¡ä¹‹åï¼ŒçŒœäº†å‘æ˜¯ä¸æ˜¯å€å¢ï¼Œåˆäº‰æ‰§äº†å¾ˆä¹…åˆ°åº•æœ€çŸ­è·¯èƒ½ä¸èƒ½è¹¦ã€‚æœ€åç»“è®ºæ˜¯å¤§æ¦‚å¯ä»¥è¹¦ã€‚ï¼ˆæ—¢ç„¶è¿‡äº†é‚£å°±ä¹Ÿæ˜¯äº†ï¼‰ ç»“æœå‘ç°å€å¢çš„è¯ç­”æ¡ˆæ²¡æ³•ç»Ÿè®¡ã€‚å¤§å“¥ä»¬è¯´åˆ†å—ï¼Œæ‰ç»ˆäºçœ‹åˆ°äº†ä¸€ç‚¹å¸Œæœ›ã€‚waäº†æ•°å‘æ‰è¿‡ã€‚ ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:2:1","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"HDU6325 Interstellar Travel After trying hard for many years, Little Q has finally received an astronaut license. To celebrate the fact, he intends to buy himself a spaceship and make an interstellar travel. Little Q knows the position of n planets in space, labeled by 1 to n. To his surprise, these planets are all coplanar. So to simplify, Little Q put these n planets on a plane coordinate system, and calculated the coordinate of each planet (xi,yi). Little Q plans to start his journey at the 1-th planet, and end at the n-th planet. When he is at the i-th planet, he can next fly to the j-th planet only if xi\u003cxj, which will cost his spaceship xiÃ—yjâˆ’xjÃ—yi units of energy. Note that this cost can be negative, it means the flight will supply his spaceship. Please write a program to help Little Q find the best route with minimum total cost. ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:3:0","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"åˆ†æ è¿™é¢˜å¦‚æœä½ åœ¨aå’Œbä¸¤ç‚¹ä¹‹é—´æ‰¾ç¬¬ä¸‰ç‚¹ï¼Œç„¶åè®¡ç®—ä»£ä»·å·®ï¼Œå°±ä¼šå‘ç°æœ€ç»ˆçš„ä»£ä»·é‡Œå‡ºç°äº†aåˆ°bçš„ç›´çº¿æ–¹ç¨‹ã€‚ä»£ä»·å˜æˆäº†è¯¥ç›´çº¿ä¸Šç¬¬ä¸‰ç‚¹çš„å€¼å’ŒçœŸå®å€¼çš„å·®ï¼Œ å¯æ˜¯è§é¬¼äº†è¿™æ˜¯æ€ä¹ˆå‘ç°çš„ã€‚ ç»“è®ºæ˜¯ä¸€ä¸ªç‚¹åœ¨ç›´çº¿ä¹‹ä¸Šï¼Œå°±è¦è¿›è¡Œä¸­è½¬ã€‚æ‰€ä»¥æœ€ç»ˆç­”æ¡ˆå¤§æ–¹å‘æ˜¯æ±‚ä¸€ä¸ªå‡¸åŒ…ã€‚ ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:3:1","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"HDU6321 Dynamic Graph Matching In the mathematical discipline of graph theory, a matching in a graph is a set of edges without common vertices. You are given an undirected graph with n vertices, labeled by 1,2,â€¦,n. Initially the graph has no edges. There are 2 kinds of operations : u v, add an edge (u,v) into the graph, multiple edges between same pair of vertices are allowed. u v, remove an edge (u,v), it is guaranteed that there are at least one such edge in the graph. Your task is to compute the number of matchings with exactly k edges after each operation for k=1,2,3,â€¦,n2. Note that multiple edges between same pair of vertices are considered different. ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:4:0","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"åˆ†æ æ•°æ®èŒƒå›´èƒ½å¤ŸçŠ¶å‹ã€‚ ç”¨$f(i,state)$è¡¨ç¤ºæ­¤æ¬¡æ“ä½œå®Œåï¼Œå·²ç»é€‰æ‹©çš„ç‚¹æœ‰stateæ‰€èƒ½æ„æˆçš„æ–¹æ¡ˆæ•°ã€‚å¯¹äºåŠ è¾¹uvï¼Œå°±æœ‰å¦‚ä¸‹è½¬ç§»ã€‚è¡¨ç¤ºåœ¨æœªé€‰æ‹©uvçš„å·²åŒ¹é…çŠ¶æ€é‡Œå†é€‰ä¸Šuvæ„æˆæ–°stateã€‚ $$f(i,s)=\\sum f(i-1,s-\\{u,v\\})$$ è¡¨ç¤ºåœ¨åˆ é™¤uvæ—¶ï¼Œä»æ–¹æ¡ˆä¸­å†æ¬¡æ‰£å»è¿™äº›çŠ¶æ€ã€‚ $$f(i,s)-=f(i,s-\\{u,v\\})$$ æŠŠç¬¬ä¸€ç»´æ»šåŠ¨æ‰ï¼Œè¿™ä¸¤ä¸ªå…¬å¼å¯¹è½¬ç§»é¡ºåºæ²¡æœ‰è¦æ±‚ï¼Œæ¯æ¬¡æ›´æ–°éƒ½ä¸ä¼šæ›´æ–°è¢«ç”¨æ¥è½¬ç§»çš„çŠ¶æ€ï¼Œçæ°å†™ã€‚ ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:4:1","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"Alice æƒ³è¦å¾—åˆ°ä¸€ä¸ªé•¿åº¦ä¸º n çš„åºåˆ—ï¼Œåºåˆ—ä¸­çš„æ•°éƒ½æ˜¯ä¸è¶…è¿‡ m çš„æ­£æ•´æ•°ï¼Œè€Œä¸”è¿™ n ä¸ªæ•°çš„å’Œæ˜¯ p çš„å€æ•°ã€‚ Alice è¿˜å¸Œæœ›ï¼Œè¿™ n ä¸ªæ•°ä¸­ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªæ•°æ˜¯è´¨æ•°ã€‚ Alice æƒ³çŸ¥é“ï¼Œæœ‰å¤šå°‘ä¸ªåºåˆ—æ»¡è¶³å¥¹çš„è¦æ±‚ã€‚ $$1 \\leq n \\leq 10 ^ 9, 1 \\leq m \\leq 2 \\times 10 ^ 7, 1 \\leq p \\leq 100$$ ","date":"2020-03-18","objectID":"/2020/03/builds-sequences/:0:0","tags":["å¿«é€Ÿå¹‚"],"title":"[???] Builds Sequences","uri":"/2020/03/builds-sequences/"},{"categories":["code"],"content":"åˆ†æ è¿™é¢˜åšå¾—å¾ˆçˆ½â€¦ é¦–å…ˆæ˜¯ä¸€ä¸ªå¥—è·¯ï¼Œç»´æŠ¤å€æ•°å¯ä»¥è½¬ä¸ºç»´æŠ¤å½“å‰å’Œçš„æ¨¡ã€‚å› æ­¤å¦‚æœé€’æ¨çš„è¯ï¼Œåªéœ€è¦100ä¸ªçŠ¶æ€ï¼Œçœ‹èµ·æ¥æ˜¯å¯åšçš„ã€‚ä½†æ˜¯è¿™ä¸ªnçš„èŒƒå›´å®åœ¨æ˜¯æœ‰ç‚¹ï¼Œå…ˆåˆ—ä¸€ä¸‹å†è¯´ã€‚ æŠŠ2e7ä¸ªæ•°å­—å…¨éƒ¨æ¨¡å®Œï¼Œå®ƒä»¬å¯¹ç­”æ¡ˆçš„è´¡çŒ®åªå’Œå‰©ä½™ç±»æœ‰å…³ã€‚è¿™æ ·æˆ‘ä»¬å°±èƒ½çŸ¥é“åœ¨å’Œçš„æ¨¡ä¸ºaæ—¶æœ‰å¤šå°‘ç§æ–¹æ¡ˆèƒ½å¤Ÿå‡‘åˆ°bäº†ã€‚å¾—å‡ºé€’æ¨æ–¹ç¨‹ $$ f(i,j)=\\sum_{0 \\leq k å…¶ä¸­$c(k)$æ˜¯æ¨¡ä¸ºkçš„æ•°æœ‰å¤šå°‘ä¸ªã€‚ è‡³å°‘æœ‰ä¸€ä¸ªè´¨æ•°çš„æ¡ä»¶è½¬ä¸ºæ— è´¨æ•°ï¼Œä»æ‰€æœ‰çš„cä¸­æ‰£å»è´¨æ•°åå†ç®—ä¸€éæ–¹æ¡ˆæ•°ï¼ŒäºŒè€…ç›¸å‡ã€‚ æœ€åï¼Œå…³äºnï¼Œè¿™ä¸ªå…¬å¼èƒ½å¤Ÿç”¨å¿«é€Ÿå¹‚åŠ é€Ÿã€‚ ","date":"2020-03-18","objectID":"/2020/03/builds-sequences/:1:0","tags":["å¿«é€Ÿå¹‚"],"title":"[???] Builds Sequences","uri":"/2020/03/builds-sequences/"},{"categories":["code"],"content":"ä»£ç  #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cset\u003e#include \u003ccmath\u003e#include \u003cmap\u003eusing namespace std; using pii=pair\u003cint,int\u003e; using ll=long long; const int MAXN=110; const int MAXM=20000010; const int MOD=20170408; bool isnp[MAXM]; vector\u003cint\u003e primes; void init(int n){ isnp[1]=1; for(int i=2;i\u003c=n;i++){ if(!isnp[i]){ primes.push_back(i); } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=n;j++){ isnp[i*primes[j]]=1; if(i%primes[j]==0){ break; } } } } struct Mat{ ll a[MAXN][MAXN]; Mat(){ memset(a,0,sizeof(a)); } Mat operator*(const Mat \u0026other){ Mat res; for(int i=1;i\u003cMAXN;i++){ for(int j=1;j\u003cMAXN;j++){ for(int k=1;k\u003cMAXN;k++){ res.a[i][j]=(res.a[i][j]+a[i][k]*other.a[k][j]%MOD)%MOD; } } } return res; } void debug(){ for(int i=1;i\u003cMAXN;i++){ for(int j=1;j\u003cMAXN;j++){ cout\u003c\u003ca[i][j]\u003c\u003c\" \"; } cout\u003c\u003cendl; } } void normalize(){ for(int i=1;i\u003cMAXN;i++) { a[i][i] = 1; } } }; Mat qpow(Mat a,int b){ Mat res; res.normalize(); for(;b;b\u003e\u003e=1,a=a*a){ if(b\u00261)res=res*a; } return res; } Mat base; int pool[MAXN],nopool[MAXN]; Mat incprime,noprime; int main() { ios::sync_with_stdio(false); int n,m,p;cin\u003e\u003en\u003e\u003em\u003e\u003ep; for(int i=1;i\u003c=m;i++){ pool[i%p]++; nopool[i%p]++; } init(m); for(auto it:primes){ nopool[it%p]--; } // for(auto it:nopool){ // cout\u003c\u003cit\u003c\u003c\" \"; // } // cout\u003c\u003cendl; for(int j=1;j\u003c=p;j++){ for(int i=1;i\u003c=p;i++){ //cout\u003c\u003c((i-1-(j-1))%p+p)%p\u003c\u003cendl; incprime.a[i][j]=pool[((j-1-(i-1))%p+p)%p]; noprime.a[i][j]=nopool[((j-1-(i-1))%p+p)%p]; } } base.a[1][1]=1; incprime=base*qpow(incprime,n); // incprime.debug(); noprime=base*qpow(noprime,n); // noprime.debug(); cout\u003c\u003c((incprime.a[1][1]-noprime.a[1][1])%MOD+MOD)%MOD\u003c\u003cendl; return 0; } ","date":"2020-03-18","objectID":"/2020/03/builds-sequences/:2:0","tags":["å¿«é€Ÿå¹‚"],"title":"[???] Builds Sequences","uri":"/2020/03/builds-sequences/"},{"categories":["code"],"content":"Wu got hungry after an intense training session, and came to a nearby store to buy his favourite instant noodles. After Wu paid for his purchase, the cashier gave him an interesting task. You are given a bipartite graph with positive integers in all vertices of the right half. For a subset ğ‘† of vertices of the left half we define ğ‘(ğ‘†) as the set of all vertices of the right half adjacent to at least one vertex in ğ‘†, and ğ‘“(ğ‘†) as the sum of all numbers in vertices of ğ‘(ğ‘†). Find the greatest common divisor of ğ‘“(ğ‘†) for all possible non-empty subsets ğ‘† (assume that GCD of empty set is 0). Wu is too tired after his training to solve this problem. Help him! ","date":"2020-03-08","objectID":"/2020/03/cf-1322c-instant-noodles/:0:0","tags":null,"title":"[CF 1322C] Instant Noodles","uri":"/2020/03/cf-1322c-instant-noodles/"},{"categories":["code"],"content":"åˆ†æ è¿™é“é¢˜çš„èŒƒå›´æœ‰500000ä¹‹å¤§ï¼Œæ‰€ä»¥å®åœ¨æ˜¯æ— æ³•ä»å­é›†æœ¬èº«å…¥æ‰‹ï¼Œåªèƒ½è€ƒè™‘ä¸€ä¸‹gcdæ˜¯å¦å­˜åœ¨æ€§è´¨ã€‚ å‡è®¾ç°åœ¨æœ‰ä¸€ä¸ªå­é›†$a$ï¼Œå½“æˆ‘ä»¬ä¸ºå…¶åŠ ä¸Šä¸€ä¸ª$\\Delta$åï¼Œè¿™ä¸¤ä¸ªç»“æœéƒ½ä¼šå‚ä¸gcdçš„è®¡ç®—ï¼Œæ›´ç›¸å‡æŸåè¡¨ç°ä¸º$\\Delta$å‚ä¸gcdè®¡ç®—ã€‚ è¿™ä¸ª$\\Delta$çš„å¢é‡ç›´æ¥è´¡çŒ®ç­”æ¡ˆçš„ç‰¹æ€§å¯èƒ½æ˜¯é‡è¦çš„ä¸€ç¯ã€‚æ¯”èµ›æ—¶å› ä¸ºæ—¶é—´ä¹Ÿå¥½ï¼Œåˆ«çš„ä¹Ÿç½¢ï¼Œè¢«å¡åœ¨è¿™è‡ªé—­ä¸ä¼šäº†ã€‚ æ¥ä¸‹æ¥ç¡®å®šå¢é‡æ˜¯ä»€ä¹ˆã€‚ æ˜¯å¦æ˜¯å•ç‹¬çš„ä¸€ä¸ªå…ƒç´ ï¼šå¯¹äºä¸€ä¸ªå³èŠ‚ç‚¹$v$ï¼Œæ˜¯å¦å­˜åœ¨æ·»åŠ ä¸€ä¸ªå·¦èŠ‚ç‚¹ååªå¢åŠ å…¶ä¸€ä¸ªçš„æƒ…å†µã€‚å¹²è„†æŠŠå…¨éƒ¨çš„å·¦èŠ‚ç‚¹å…¨éƒ¨é€‰ä¸­ï¼Œç„¶ååˆ æ‰åŒ…å«$v$çš„ã€‚æ¥ä¸‹æ¥ï¼Œè§‚å¯Ÿæ˜¯å¦å­˜åœ¨ä¸€ä¸ªå·¦èŠ‚ç‚¹åªå¢åŠ $v$ã€‚è¿™æ˜¾ç„¶ä¼šæœ‰ä¸å­˜åœ¨çš„æƒ…å†µã€‚ åœ¨ä¸å­˜åœ¨çš„æƒ…å†µæ—¶ï¼Œæˆ‘ä»¬æœ‰è¿™äº›ç»“è®ºã€‚å‡è®¾è¿™ä¸ªæ£ä¹±çš„èŠ‚ç‚¹æ˜¯$v'$ $v'$ç”±äºåˆ é™¤æ‰€æœ‰åŒ…å«$v$çš„èŠ‚ç‚¹è€Œè¢«å…±åŒåˆ é™¤ã€‚ $v'$æ— æ³•è¢«ä¸åŒ…å«$v$çš„å…¶ä»–èŠ‚ç‚¹å¢åŠ ï¼Œé‚£ä¹ˆèƒ½å¢åŠ $v'$çš„èŠ‚ç‚¹å®šåŒ…å«$v$ã€‚ æ­¤æ—¶æœ‰ä¸¤ç§æƒ…å†µã€‚ æ‰€æœ‰æ·»åŠ vçš„èŠ‚ç‚¹å‡åŒ…å«$v'$ã€‚é‚£ä¹ˆäºŒè€…å…±è¿›é€€ï¼Œè¡¨ç°ä¸ºæ†ç»‘åœ¨ä¸€èµ·çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¹¶ä¸æ˜¯æ‰€æœ‰æ·»åŠ vçš„èŠ‚ç‚¹å‡åŒ…å«$v'$ã€‚é‚£ä¹ˆï¼Œæˆ‘ä»¬å°±èƒ½é€šè¿‡æ·»åŠ åˆ«çš„èŠ‚ç‚¹ç‡å…ˆåŠ ä¸Švï¼Œä»è€Œèƒ½å¤Ÿå•ç‹¬æ·»åŠ vâ€™ï¼Œä»è€Œèƒ½å¤Ÿå•ç‹¬æ·»åŠ vã€‚ æ‰€ä»¥ï¼Œè¿™ä¸ªå¢é‡ä¸æ˜¯å•ä¸ªå…ƒç´ ï¼Œè€Œæ˜¯è¿™ä¹ˆä¸€ä¸ªä¸œè¥¿ï¼šé‚»åŸŸç›¸åŒçš„å…ƒç´ ã€‚ å¯ä»¥åšäº†ï¼Ÿâ€¦â€¦å¤ªèœï¼Œæä¸æ˜ç™½è¿™æ€ä¹ˆåœ¨æ¯”èµ›æœŸé—´çŸ­æœŸæŠ˜è…¾å‡ºæ¥ã€‚ ","date":"2020-03-08","objectID":"/2020/03/cf-1322c-instant-noodles/:1:0","tags":null,"title":"[CF 1322C] Instant Noodles","uri":"/2020/03/cf-1322c-instant-noodles/"},{"categories":["code"],"content":"Roma is playing a new expansion for his favorite game World of Darkraft. He made a new character and is going for his first grind. Roma has a choice to buy exactly one of ğ‘› different weapons and exactly one of ğ‘š different armor sets. Weapon ğ‘– has attack modifier ğ‘ğ‘– and is worth ğ‘ğ‘ğ‘– coins, and armor set ğ‘— has defense modifier ğ‘ğ‘— and is worth ğ‘ğ‘ğ‘— coins. After choosing his equipment Roma can proceed to defeat some monsters. There are ğ‘ monsters he can try to defeat. Monster ğ‘˜ has defense ğ‘¥ğ‘˜, attack ğ‘¦ğ‘˜ and possesses ğ‘§ğ‘˜ coins. Roma can defeat a monster if his weaponâ€™s attack modifier is larger than the monsterâ€™s defense, and his armor setâ€™s defense modifier is larger than the monsterâ€™s attack. That is, a monster ğ‘˜ can be defeated with a weapon ğ‘– and an armor set ğ‘— if ğ‘ğ‘–\u003eğ‘¥ğ‘˜ and ğ‘ğ‘—\u003eğ‘¦ğ‘˜. After defeating the monster, Roma takes all the coins from them. During the grind, Roma can defeat as many monsters as he likes. Monsters do not respawn, thus each monster can be defeated at most one. Thanks to Romaâ€™s excessive donations, we can assume that he has an infinite amount of in-game currency and can afford any of the weapons and armor sets. Still, he wants to maximize the profit of the grind. The profit is defined as the total coins obtained from all defeated monsters minus the cost of his equipment. Note that Roma must purchase a weapon and an armor set even if he can not cover their cost with obtained coins. Help Roma find the maximum profit of the grind. ","date":"2020-03-08","objectID":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/:0:0","tags":null,"title":"[CF 1320C] World of Darkraft: Battle for Azathoth","uri":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/"},{"categories":["code"],"content":"åˆ†æ è¿™é¢˜ä»£è¡¨äº†ä¸€ç±»åŸºæœ¬çš„æ€è·¯ã€‚æšä¸¾å…¶ä¸­ä¸€ç»´ï¼Œç”¨æ•°æ®ç»“æ„ç»´æŠ¤å¦ä¸€ç»´ã€‚ å‡è®¾æˆ‘ä»¬æšä¸¾æ­¦å™¨æ”»å‡»åŠ›ï¼Œé¦–å…ˆèƒ½å¤ŸæŒ‘å‡ºæ‰€æœ‰è¢«å‡»æ€çš„æ€ªç‰©ã€‚å½“æˆ‘ä»¬çš„é˜²å…·ä¸ºkæ—¶ï¼Œæ‰€æœ‰æ”»å‡»åŠ›å°äºkçš„éƒ½å¯ä»¥è®¡ç®—æ”¶ç›Šã€‚åè¿‡æ¥è¯´ï¼Œå¯¹äºæ”»å‡»åŠ›ä¸ºkçš„æ€ªç‰©ï¼Œåªè¦æˆ‘ä»¬çš„é˜²å…·å¤§äºkï¼Œå°±å¯ä»¥è®¡ç®—æ”¶ç›Šã€‚ æ‰€ä»¥æ¯æšä¸¾ä¸€ä¸ªä¸»è§’æ”»å‡»åŠ›ï¼Œæˆ‘ä»¬æŠŠæ€ªç‰©æŒ‰ç…§å…¶æ”»å‡»åŠ›ä¸ºä¸‹æ ‡ä½œæ”¶ç›Šå‰ç¼€å’Œï¼Œå°±å¯ä»¥è·å–åˆ°å½“ä¸»è§’é˜²å…·ä¸ºkæ—¶æ‰€èƒ½å¾—åˆ°çš„æ”¶ç›Šã€‚ä¸ºäº†è®¡ç®—å…¥é˜²å…·çš„èŠ±è´¹ï¼Œé¢„å¤„ç†æ¯ä¸ªé˜²å…·ç­‰çº§kæ‰€éœ€è¦çš„æœ€å°‘çš„é’±ï¼Œé¢„å…ˆåœ¨ç›¸åº”ä¸‹æ ‡æ‰£é™¤ã€‚æ­¤æ—¶è¿˜éœ€è¦ä¸€ä¸ªç»“æ„æ¥æ±‚å»æ‰€æœ‰å‰ç¼€å’Œä¸­æœ€å¤§ã€‚è¿™äº›æ“ä½œéƒ½å¯ä»¥ç”¨çº¿æ®µæ ‘å®Œæˆã€‚ ","date":"2020-03-08","objectID":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/:1:0","tags":null,"title":"[CF 1320C] World of Darkraft: Battle for Azathoth","uri":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/"},{"categories":["code"],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003climits\u003eusing namespace std; using ll=long long; const int MAXN=1000100*4; int idx=0; int lc[MAXN],rc[MAXN]; ll award[MAXN]; int cost[MAXN]; ll flag[MAXN]; int root; int wlen,alen,mlen; struct Weapon { int rnk, cost; bool operator\u003c(const Weapon \u0026b) const { //if (rnk == b.rnk)return cost \u003c b.cost;å®é™…æ²¡ç”¨ return rnk \u003c b.rnk; } } weapons[MAXN]; struct Armor { int rnk, cost; bool operator\u003c(const Armor \u0026b) const { if (rnk == b.rnk)return cost \u003c b.cost; return rnk \u003c b.rnk; } } armors[MAXN]; void collect(int n){ award[n]=max(award[lc[n]],award[rc[n]]); } void pushdown(int n){ if(flag[n]){ flag[lc[n]]+=flag[n]; flag[rc[n]]+=flag[n]; award[lc[n]]+=flag[n]; award[rc[n]]+=flag[n]; flag[n]=0; } } //æšä¸¾æ­¦å™¨ï¼Œç»´æŠ¤é˜²å…· void build(int \u0026n,int l,int r,int init=-0x3f3f3f3f) { if (!n)n = ++idx; if (l == r) { award[n]=-cost[l]; return; } int mid = (l + r) / 2; build(lc[n], l, mid,init); build(rc[n], mid + 1, r,init); collect(n); } void modify(ll x,int l,int r,int L,int R,int n) { if (l \u003c= L \u0026\u0026 R \u003c= r) { flag[n] += x; award[n] += x; return; } pushdown(n); int mid = (L + R) / 2; if (l \u003c= mid)modify(x, l, r, L, mid, lc[n]); if (mid \u003c r)modify(x, l, r, mid + 1, R, rc[n]); collect(n); } ll query(){ return award[root]; } ll query(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ return award[n]; } pushdown(n); ll res=-numeric_limits\u003cll\u003e::max(); int mid=(L+R)/2; if(l\u003c=mid)res=max(res,query(l,r,L,mid,lc[n])); if(mid\u003cr)res=max(res,query(l,r,mid+1,R,rc[n])); return res; } struct Monster{ int att,de; int cost; } monsters[MAXN]; void debug(int n){ for(int i=1;i\u003c=n;i++){ cout\u003c\u003cquery(i,i,1,n,root)\u003c\u003c\" \"; } cout\u003c\u003cendl; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e wlen \u003e\u003e alen \u003e\u003e mlen; int vallim = 0; for (int i = 0; i \u003c wlen; i++)cin \u003e\u003e weapons[i].rnk \u003e\u003e weapons[i].cost; for(int i=0;i\u003calen;i++)cin\u003e\u003earmors[i].rnk\u003e\u003earmors[i].cost; for(int i=0;i\u003cmlen;i++)cin\u003e\u003emonsters[i].de\u003e\u003emonsters[i].att\u003e\u003emonsters[i].cost; sort(weapons,weapons+wlen); sort(monsters,monsters+mlen,[](auto a,auto b){ return a.de\u003cb.de; }); fill(cost,cost+MAXN,numeric_limits\u003cint\u003e::max()); int maxarm=0; for(int i=0;i\u003calen;i++){ cost[armors[i].rnk]=min(cost[armors[i].rnk],armors[i].cost); maxarm=max(maxarm,armors[i].rnk); } for(int i=maxarm-1;i\u003e=1;i--){ cost[i]=min(cost[i],cost[i+1]); } build(root,1,maxarm); //debug(maxarm); ll ans=-numeric_limits\u003cll\u003e::max(); int ptr=0; for(int i=0;i\u003cwlen;i++){ while(ptr\u003cmlen \u0026\u0026 monsters[ptr].de\u003cweapons[i].rnk){ if(monsters[ptr].att\u003cmaxarm){ modify(monsters[ptr].cost,monsters[ptr].att+1,maxarm,1,maxarm,root); } ptr++; } ans=max(ans,query()-weapons[i].cost); } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-03-08","objectID":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/:2:0","tags":null,"title":"[CF 1320C] World of Darkraft: Battle for Azathoth","uri":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/"},{"categories":["code"],"content":"æ²¡æ³¨æ„åˆ°æ•°æ®èŒƒå›´æ˜¯100ã€‚ You are given a string ğ‘  consisting of lowercase Latin letters. Let the length of ğ‘  be |ğ‘ |. You may perform several operations on this string. In one operation, you can choose some index ğ‘– and remove the ğ‘–-th character of ğ‘  (ğ‘ ğ‘–) if at least one of its adjacent characters is the previous letter in the Latin alphabet for ğ‘ ğ‘–. For example, the previous letter for b is a, the previous letter for s is r, the letter a has no previous letters. Note that after each removal the length of the string decreases by one. So, the index ğ‘– should satisfy the condition 1â‰¤ğ‘–â‰¤|ğ‘ | during each operation. For the character ğ‘ ğ‘– adjacent characters are ğ‘ ğ‘–âˆ’1 and ğ‘ ğ‘–+1. The first and the last characters of ğ‘  both have only one adjacent character (unless |ğ‘ |=1). Consider the following example. Let ğ‘ = bacabcab. During the first move, you can remove the first character ğ‘ 1= b because ğ‘ 2= a. Then the string becomes ğ‘ = acabcab. During the second move, you can remove the fifth character ğ‘ 5= c because ğ‘ 4= b. Then the string becomes ğ‘ = acabab. During the third move, you can remove the sixth character ğ‘ 6='bâ€™ because ğ‘ 5= a. Then the string becomes ğ‘ = acaba. During the fourth move, the only character you can remove is ğ‘ 4= b, because ğ‘ 3= a (or ğ‘ 5= a). The string becomes ğ‘ = acaa and you cannot do anything with it. Your task is to find the maximum possible number of characters you can remove if you choose the sequence of operations optimally. ","date":"2020-03-02","objectID":"/2020/03/cf-1321c-remove-adjacent/:0:0","tags":null,"title":"[CF 1321C] Remove Adjacent æ‹“å±•","uri":"/2020/03/cf-1321c-remove-adjacent/"},{"categories":["code"],"content":"åˆ†æ æ¢ä¸ªè§†è§’æ¥çœ‹æ¶ˆé™¤ï¼Œå½“æœ‰bæ—¶ï¼Œæˆ‘ä»¬å°±èƒ½ä¿è¯æ‰€æœ‰èƒ½æ¥è§¦åˆ°è¿™ä¸ªbçš„cè¢«æ¶ˆé™¤ã€‚ æ‰€ä»¥ä»å¤§å¾€å°äº†åšï¼Œæšä¸¾æ¯ä¸€ä¸ªå­—æ¯$s$ï¼Œç„¶åæšä¸¾sçš„ä½ç½®å»æŸ¥è¯¢å®ƒå·¦å³æ˜¯å¦æœ‰èƒ½å¤Ÿç¢°åˆ°å®ƒçš„$s+1$ã€‚ æ¥ä¸‹æ¥æ˜¯å¦‚ä½•ç»´æŠ¤ä¿¡æ¯ã€‚å½“ä¸Šä¸€ä¸ªå­—æ¯ä½¿å¾—ä¸Šä¸Šä¸ªå­—æ¯èƒ½å¤Ÿè¢«æ¶ˆé™¤åï¼Œå°±æœ‰å¯èƒ½ä½¿å¾—åŸæœ¬æ— æ³•æ¥è§¦åˆ°æœ¬æ¬¡å­—æ¯çš„ä¸Šä¸€ä¸ªå­—æ¯è½¬è€Œèƒ½å¤Ÿæ¥è§¦åˆ°è¯¥å­—æ¯ã€‚ä½¿ç”¨å¹¶æŸ¥é›†æ¥åšè¿™ç§äº‹æƒ…ï¼Œå¹¶æŸ¥é›†ç»´æŠ¤è¿ç»­æ¶ˆé™¤çš„åŒºé—´lå’Œrï¼Œä»¥åŠè¿™ä¸ªåŒºé—´å­˜åœ¨å­—æ¯ï¼ˆintçŠ¶å‹å³å¯ï¼‰ã€‚ ","date":"2020-03-02","objectID":"/2020/03/cf-1321c-remove-adjacent/:1:0","tags":null,"title":"[CF 1321C] Remove Adjacent æ‹“å±•","uri":"/2020/03/cf-1321c-remove-adjacent/"},{"categories":["code"],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cmap\u003eusing namespace std; using pii=pair\u003cint,int\u003e; using ll=long long; const int MAXN=1000; struct UT { int fa[MAXN]; int dat[MAXN]; int l[MAXN], r[MAXN]; UT() { for (int i = 0; i \u003c MAXN; i++)fa[i] = i; for (int i = 0; i \u003c MAXN; i++)l[i] = r[i] = i; } int find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); } void con(int u, int v) { int uf = find(u), vf = find(v); dat[vf] |= dat[uf]; l[vf] = min(l[vf], l[uf]); r[vf] = max(r[vf], r[uf]); fa[uf] = vf; } bool isc(int u, int v) { return find(u) == find(v); } }; string inp; vector\u003cint\u003e pos[30]; UT ut; bool vis[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int nlen; cin \u003e\u003e nlen; cin \u003e\u003e inp; inp = \" \" + inp; for (int i = 1; i \u003c= nlen; i++) pos[inp[i] - \u0026#039;a\u0026#039;].push_back(i); for (int i = 1; i \u003c= nlen; i++) ut.dat[i] |= (1 \u003c\u003c (inp[i] - \u0026#039;a\u0026#039;)); for (int i = 25; i \u003e= 0; i--) { for (auto p:pos[i]) { if (p - 1 \u003e= 1) { if ((ut.dat[ut.find(p - 1)] \u0026 (1 \u003c\u003c (i + 1))) || (ut.dat[ut.find(p - 1)] \u0026 (1 \u003c\u003c i))) { ut.con(p - 1, p); } } if (p + 1 \u003c= inp.size()) { if ((ut.dat[ut.find(p + 1)] \u0026 (1 \u003c\u003c (i + 1))) || (ut.dat[ut.find(p + 1)] \u0026 (1 \u003c\u003c i))) { ut.con(p, p + 1); } } } } int ans = 0; for (int i = 1; i \u003c= nlen; i++) { int uf = ut.find(i); if (!vis[uf]) { vis[uf] = 1; int minn = 0; for (int i = 0; i \u003c 26; i++) { if (ut.dat[uf] \u0026 (1 \u003c\u003c i)) { minn = i; break; } } int off = 0; for (int i = ut.l[uf]; i \u003c= ut.r[uf]; i++) { off += (inp[i] == \u0026#039;a\u0026#039; + minn); } ans += max(0, ut.r[uf] - ut.l[uf] + 1 - off); } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-03-02","objectID":"/2020/03/cf-1321c-remove-adjacent/:2:0","tags":null,"title":"[CF 1321C] Remove Adjacent æ‹“å±•","uri":"/2020/03/cf-1321c-remove-adjacent/"},{"categories":["code"],"content":"Extra è¿™åœºæ¯”èµ›çš„Bé¢˜æŒºå¥½ç©çš„â€¦è¦æ±‚é€‰å‡ºçš„æ•°å­—æ»¡è¶³ $$c_i-c_{i+1}=p_{c_i}-p_{c_{i+1}}$$ â€¦ä¸€ä¸Šæ¥å‚»äº†ä¸çŸ¥é“å’‹åšï¼Œå…¶å®åªè¦æŠŠå…¬å¼å·¦å³äº¤æ¢ä¸€ä¸‹å°±å®Œäº‹äº†ã€‚ ","date":"2020-03-02","objectID":"/2020/03/cf-1321c-remove-adjacent/:3:0","tags":null,"title":"[CF 1321C] Remove Adjacent æ‹“å±•","uri":"/2020/03/cf-1321c-remove-adjacent/"},{"categories":["code"],"content":"You are given a permutation ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (an array where each integer from 1 to ğ‘› appears exactly once). The weight of the ğ‘–-th element of this permutation is ğ‘ğ‘–. At first, you separate your permutation into two non-empty sets â€” prefix and suffix. More formally, the first set contains elements ğ‘1,ğ‘2,â€¦,ğ‘ğ‘˜, the second â€” ğ‘ğ‘˜+1,ğ‘ğ‘˜+2,â€¦,ğ‘ğ‘›, where 1â‰¤ğ‘˜\u003cğ‘›. After that, you may move elements between sets. The operation you are allowed to do is to choose some element of the first set and move it to the second set, or vice versa (move from the second set to the first). You have to pay ğ‘ğ‘– dollars to move the element ğ‘ğ‘–. Your goal is to make it so that each element of the first set is less than each element of the second set. Note that if one of the sets is empty, this condition is met. For example, if ğ‘=[3,1,2] and ğ‘=[7,1,4], then the optimal strategy is: separate ğ‘ into two parts [3,1] and [2] and then move the 2-element into first set (it costs 4). And if ğ‘=[3,5,1,6,2,4], ğ‘=[9,1,9,9,1,9], then the optimal strategy is: separate ğ‘ into two parts [3,5,1] and [6,2,4], and then move the 2-element into first set (it costs 1), and 5-element into second set (it also costs 1). Calculate the minimum number of dollars you have to spend. ","date":"2020-02-28","objectID":"/2020/02/cf-1295e-permutation-separation/:0:0","tags":null,"title":"[CF 1295E] Permutation Separation","uri":"/2020/02/cf-1295e-permutation-separation/"},{"categories":["code"],"content":"åˆ†æ é¦–å…ˆè¦è§£å†³çš„é—®é¢˜æ˜¯å¦‚ä½•æ–­å¼€ã€‚æšä¸¾æ’åˆ—çš„æŸä¸ªä½ç½®æ–­å¼€ï¼Œä¼¼ä¹æ²¡æœ‰ä»€ä¹ˆå¥½åŠæ³•è½¬ç§»ï¼Œæšä¸¾æ•°å€¼ä¸Šæ–­å¼€çš„ä½ç½®æ˜¾å¾—æ›´å¯é ä¸€äº›ã€‚ä¸è¿‡æ–­å¼€æ•°å€¼åï¼Œä»ç„¶æ²¡æœ‰ä»€ä¹ˆå¥½åŠæ³•å»ç›´æ¥æ±‚å¾—ä»æ’åˆ—çš„ä½•å¤„æ–­å¼€ã€‚ è€ƒè™‘å†æ¬¡æšä¸¾æ’åˆ—çš„æ–­å¼€ä½ç½®ã€‚å½“ç¡®å®šæ’åˆ—çš„ä¸€ä¸ªæ–­ç‚¹åï¼Œç”±äºå·²ç»çŸ¥é“ä¸¤ä¸ªå­é›†æ‰€åŒ…å«çš„æ•°ï¼Œå¯ä»¥$O(N)$ç®—å‡ºåˆ°è¾¾ç›®æ ‡çŠ¶æ€éœ€è¦çš„ä»£ä»·ï¼Œåœ¨æ­¤ä»¥å·¦ä¾§å°å³ä¾§å¤§ä¸ºå‡†ã€‚å½“å‘å³ç§»åŠ¨æ–­ç‚¹åï¼Œæ³¨æ„åˆ°å·¦ä¾§åŸæœ‰çš„éœ€è¦ç§»åŠ¨æ•°å­—ä»ç„¶éœ€è¦ç§»åŠ¨ã€‚äºæ˜¯ï¼Œé’ˆå¯¹ä¸€ä¸ªå­é›†çš„åˆ†å‰²ï¼Œèƒ½å¤Ÿç”¨é€šè¿‡çº¿æ®µæ ‘$O(n\\lg n)$æ¥æ±‚å‡ºåœ¨æ’åˆ—ä»»ä½•ä¸€ä¸ªä½ç½®æ–­å¼€çš„ä»£ä»·ã€‚ æ¥ä¸‹æ¥è€ƒè™‘æ•°å€¼ä¸Šçš„æ–­ç‚¹ç§»åŠ¨åæ˜¯å¦èƒ½å¤Ÿç»´æŠ¤ä»£ä»·å˜åŒ–ã€‚å½“ä¸€ä¸ªæ–°çš„æ•°å­—$a$è¢«ä»å¤§é›†åˆåˆ’å½’åˆ°å°é›†åˆåï¼Œåœ¨æ’åˆ—ä¸­ï¼Œä»¥è¯¥æ•°å­—$a$ä½ç½®ï¼Œå·¦ä¾§æ‰€æœ‰çš„æ–­ç‚¹éƒ½éœ€è¦ä»˜å‡ºé¢å¤–çš„ä»£ä»·å°†è¯¥æ•°æŒªåˆ°å·¦ä¾§ï¼Œè€Œå³ä¾§æ‰€æœ‰çš„æ–­ç‚¹éƒ½ä¸å†éœ€è¦æ”¯ä»˜ä»£ä»·æ¥å°†è¯¥æ•°æŒªåˆ°å³ä¾§ã€‚äºæ˜¯ï¼Œè¿™ä¸ªä»£ä»·ä¹Ÿæ˜¯å¯ä»¥ç»´æŠ¤çš„ã€‚ ","date":"2020-02-28","objectID":"/2020/02/cf-1295e-permutation-separation/:1:0","tags":null,"title":"[CF 1295E] Permutation Separation","uri":"/2020/02/cf-1295e-permutation-separation/"},{"categories":["code"],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003climits\u003eusing namespace std; using ll=long long; const int MAXN=200010; int lc[MAXN*4],rc[MAXN*4]; ll flag[MAXN*4],dmin[MAXN*4]; int idx=0; void build(int \u0026n,int l,int r){ if(!n)n=++idx; if(l==r){ flag[n]=dmin[n]=0; return; } int mid=(l+r)/2; build(lc[n],l,mid); build(rc[n],mid+1,r); } void pushdown(int n){ if(!flag[n])return; flag[lc[n]]+=flag[n]; flag[rc[n]]+=flag[n]; dmin[lc[n]]+=flag[n]; dmin[rc[n]]+=flag[n]; flag[n]=0; } void collect(int n){ dmin[n]=min(dmin[lc[n]],dmin[rc[n]]); } void modify(ll x,int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ flag[n]+=x; dmin[n]+=x; return; } pushdown(n); int mid=(L+R)/2; if(l\u003c=mid)modify(x,l,r,L,mid,lc[n]); if(mid\u003cr)modify(x,l,r,mid+1,R,rc[n]); collect(n); } ll query(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ return dmin[n]; } pushdown(n); int mid=(L+R)/2; ll res=numeric_limits\u003cll\u003e::max(); if(l\u003c=mid)res=min(res,query(l,r,L,mid,lc[n])); if(mid\u003cr)res=min(res,query(l,r,mid+1,R,rc[n])); return res; } int root=0; int permu[MAXN]; ll wage[MAXN]; int pos[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int nlen;cin\u003e\u003enlen; for(int i=1;i\u003c=nlen;i++)cin\u003e\u003epermu[i]; for(int i=1;i\u003c=nlen;i++)pos[permu[i]]=i; for(int i=1;i\u003c=nlen;i++)cin\u003e\u003ewage[i]; int ptr=0; if(nlen==1){ cout\u003c\u003c0\u003c\u003cendl; return 0; } //init //ä»¥ç¬¬iä½åˆ‡å‰²ï¼Œå‰iä¸ªä¸ºä¸€ä¸ªé›†åˆ build(root,1,nlen); for(int i=1;i\u003c=nlen-1;i++){ modify(wage[i],i,nlen-1,1,nlen,root); } ll ans=numeric_limits\u003cll\u003e::max(); while(ptr\u003c=nlen){ ans=min(ans,query(1,nlen-1,1,nlen,root)); ptr++; if(pos[ptr]-1\u003e=1) modify(wage[pos[ptr]],1,pos[ptr]-1,1,nlen,root); if(pos[ptr]\u003c=nlen-1) modify(-wage[pos[ptr]],pos[ptr],nlen-1,1,nlen,root); } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-02-28","objectID":"/2020/02/cf-1295e-permutation-separation/:2:0","tags":null,"title":"[CF 1295E] Permutation Separation","uri":"/2020/02/cf-1295e-permutation-separation/"},{"categories":["å­¦ä¹ "],"content":"è¯´å®è¯,è¿™ä¸€å¥—ä¸œè¥¿ä¸œæ‹¼è¥¿å‡‘åˆ°å¤„å–ç»,ä¸è¿‡æœ‰äº›è¿˜æŒºé¦™çš„. ç›®å‰å¯¹äº14,17çš„ç‰¹æ€§,GCCå’ŒClangéƒ½å®Œæˆäº†å¾ˆå¥½çš„é€‚é….åœ¨C++20ä¸Š,ä¸‹é¢æåˆ°çš„ç‰¹æ€§éƒ½åœ¨æœ€æ–°çš„ç‰ˆæœ¬é‡Œå®Œæˆäº†ç»å¤§å¤šæ•°. æ ‡å‡†å®šå¾—çˆ½,åˆ°äº†å®ç°å°±å‡‰å‡‰. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:0:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"auto è¿™ä¸ªå…³é”®å­—â€¦æ˜¯çœŸçš„â€¦ç›¸ä¿¡ä¸ä¹…ä¹‹åc++åªéœ€è¦ä¸‹é¢ä¸€ä¸ªå‚æ•°. auto auto(auto...){ return auto; } è¿™ä¸ªä¸œè¥¿,å°±æ˜¯æŠŠå˜é‡ç±»å‹äº¤ç»™ç¼–è¯‘å™¨æ¥è€ƒè™‘.è¿™ä¸ªç‰¹æ€§å®é™…ä¸Šæ—©è¯¥æœ‰äº†,å› ä¸ºc++ç¼–è¯‘å™¨åŸæœ¬å°±ä¼šæ£€æŸ¥å³å€¼å’Œå·¦å€¼çš„ç±»å‹æ˜¯å¦åŒ¹é…,é‚£ä¹ˆé¡ºä¾¿å¡«ä¸€ä¸ªå·¦å€¼çš„ç±»å‹ä¹Ÿä¸ä¼šç´¯ç€å®ƒ. è¿™ä¸ªä¹ŸæŒºå¸¸ç”¨çš„.for(auto it=vec.begin();...è¿™ç§å†™æ³•çœäº†å¾ˆå¤§å·¥å¤«. å’Œå®ƒé…åˆå¾ˆå¥½çš„æ˜¯æ–°å¼•å…¥çš„è¯­æ³•ç³–for(auto item:var),å†™èµ·æ¥å¾ˆçˆ½.è¿™ç©æ„ä¹Ÿæ”¯æŒå¼•ç”¨.å¦å¤–ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„æ˜¯åœ¨C++17å,ç”±æ¨¡å¼ç»‘å®šåŠ æˆ,è¿™ç©æ„èƒ½è¿›ä¸€æ­¥å†™æˆfor(const auto\u0026 [key,value] : map). è¿˜æœ‰ä¸€ä¸ªä¸œè¥¿æ˜¯autoç”¨åœ¨å‡½æ•°ç­¾åçš„è¿”å›å€¼æ—¶éœ€è¦å°¾éšè¿”å›å€¼ç±»å‹. auto f() -\u003e ???{ } åœ¨C++14é‡Œä¸éœ€è¦å†å°¾éšè¿”å›å€¼ç±»å‹äº†.ä¸è¿‡å¦å¤–è¿˜æœ‰ä¸€ç§å†™æ³•decltype(auto),è¿™ä¸¤ä¸ªçš„åŒºåˆ«åœ¨äºåè€…èƒ½å¤Ÿä¿ç•™å¼•ç”¨çš„ç±»å‹ä¿¡æ¯.è¿™ä¸ªå°¾éšè¿”å›å€¼çš„ç”¨å¤„å°±å‰©ä¸‹åœ¨lambdaè¡¨è¾¾å¼é‡Œç”¨äº†.ä¸è¿‡,å°è¯•åœ¨ç­¾åé‡ŒåŸæœ¬çš„è¿”å›ç±»å‹ä½ç½®å†™auto,è½¬è€ŒæŠŠçœŸå®çš„è¿”å›ç±»å‹å°¾éš,è¿™ç§å†™æ³•è¶Šå‘åƒç°ä»£è¯­è¨€äº†. fn f()-\u003e i32 {} ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:1:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"Lambda è¡¨è¾¾å¼ å¥½ç”¨çš„ä¸œè¥¿. sort(vec.begin(),vec.end(),[](const Student \u0026a,const Student \u0026b){ return a.age\u003cb.age; }) å†ä¹Ÿä¸éœ€è¦cmp_1,cmp_2äº†. lambdaè¡¨è¾¾å¼ä½œä¸ºä¸€ä¸ªé—­åŒ…,éœ€è¦è€ƒè™‘å…¶å¯¹äºç¯å¢ƒå˜é‡çš„æ•æ‰ç±»å‹. æŒ‰å€¼æ•è· æŒ‰å¼•ç”¨æ•è· å°±å¦‚å®ƒä»¬å­—é¢ä¸Šçš„æ„æ€.å®é™…å®ç°æ—¶,å°†å…¶å†™åœ¨[]å†….ä¾‹å¦‚[=],[\u0026],[foo,\u0026bar].ä¸€ä¸ªè¦æ³¨æ„çš„é—®é¢˜æ˜¯,æŒ‰å€¼æ•è·æ—¶,æ•è·çš„å˜é‡å‡ä¸ºconst,ä¸èƒ½ä¿®æ”¹,åç¼€[]()mutable{}åå¯ä»¥ä¿®æ”¹,ä¸è¿‡è¿™ç§ä¿®æ”¹ä¸ä¼šå½±å“ç¯å¢ƒå˜é‡. åœ¨C++14ä¸­å¯ä»¥å€ŸåŠ©autoå®ç°lambdaå¤šæ€. auto func=[](auto a){return a+a;}; ç„¶åè¿™ä¸ªfuncå¯ä»¥ç›´æ¥ä¼ å¾ˆå¤šå‚æ•°. å¦ä¸€ä¸ªæ˜¯åœ¨æ•è·æ—¶è¿›è¡Œç¯å¢ƒå˜é‡åˆå§‹åŒ–,ä¾‹å¦‚[x=0].ä¸è¿‡è¿™ç©æ„æ˜¯å¦æœ‰é¢å¤–çš„è€ƒè™‘â€¦å¤§æ¦‚èƒ½å»çœ‹çœ‹RFC? åœ¨C++20ä¸­,lambdaå¯ä»¥æºå¸¦æ¨¡æ¿[]\u003ctypename T\u003e(){}. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:2:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"using ä»¥å‰,æˆ‘ä»¬å®šä¹‰llæœ‰è¿™ä¹ˆä¸¤æ´¾. #define ll long long typedef long long ll; ç°åœ¨,æ–°çš„ä¸€æ´¾åŠ å…¥äº†æˆ˜åœº. using ll=long long; è¿™å‡ ç§åŠæ³•å¦‚æœéè¦åˆ†å‡ºä¸ªé«˜ä½,é‚£å¤§æ¦‚è¦ä»ä¸‹é¢å‡ ä¸ªæ–¹é¢è¯´ defineæ˜¯ä¸€ç§æ›¿æ¢.å®ƒç›¸å¯¹äºå¦å¤–ä¸¤ç§æ¥è¯´,æœ‰äº›è¿‡äºå¼ºå¤§å’Œéšæ€§,å¯èƒ½ä¼šå¸¦æ¥é—®é¢˜. typedefæ˜¯Cé£æ ¼çš„. usingæ˜¯C++é£æ ¼çš„.å¦å¤–usingåœ¨å†…éƒ¨çš„å®ç°æ˜¯åŸºäºæ¨¡æ¿çš„.è¿™ä¸€ç‚¹æ˜¯å¦ä¼šå¸¦æ¥å¥½å¤„æˆ‘è¿˜æ²¡å¼„æ˜ç™½. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:3:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"nullptr èµ‹å€¼ç»™ç©ºæŒ‡é’ˆçš„æ–°å€¼,ç”¨æ¥å–ä»£NULL.è¿™ä¸ªå…³é”®å­—å¯¹äºå·¥ç¨‹çš„ç”¨å¤„æ›´é«˜.å®ƒç”¨äºå¤„ç†å’Œé‡è½½,æ³›å‹ç¼–ç¨‹æœ‰å…³çš„é—®é¢˜. ä¸€ä¸ªç©ºæŒ‡é’ˆåœ¨Cé£æ ¼ä¸­å®šä¹‰ä¸ºå®NULL,è¿™ä¸ªä¸œè¥¿,å®ƒæ˜¯0çš„åˆ«å.é‚£ä¹ˆ,ä¸€ä¸ªæ³›å‹å‡½æ•°åˆ°åº•è¯¥æŠŠå®ƒçœ‹ä½œintè¿˜æ˜¯æŒ‡é’ˆ?è¿™ä¹Ÿæ˜¯ä¸æ¨èç”¨defineå®šä¹‰æ–°ç±»å‹çš„ä¸€ä¸ªç†ç”±.è¯´ä¸å®šä»€ä¹ˆæ—¶å€™å°±è¸©è¿›å‘. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:4:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"decltype å¯¹ç±»å‹çš„è¿ç®—,ç”¨äºåœ¨ç¼–è¯‘æ—¶è·å–æŸä¸ªå€¼çš„ç±»å‹.ç®—æ˜¯ä¸ªå’Œautoé…å¥—çš„ä¸œè¥¿.å› ä¸ºautoäº†,ä½ ä¹Ÿä¸çŸ¥é“å®ƒåˆ°åº•æ˜¯ä¸ªä»€ä¹ˆ,æ­¤æ—¶å°±å¯ä»¥ auto a=/*something weired*/; decltype(a) b=a; æ€ä¹ˆè¯´å‘¢â€¦æœ‰äº†ä¸€ç§åŠ¨æ€è¯­è¨€çš„è°ƒè°ƒ. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:5:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"ç”¨ä»¥ä¸Šè¿™äº›ä¸œè¥¿,å°±èƒ½å†™å‡ºè¿™ç§ä»£ç . //å½“ç„¶è¿™æ®µä»£ç æ˜¯æ²¡å•¥æ„ä¹‰çš„,åªæ˜¯ç”¨ä¸€ä¸‹æ–°çš„ç‰¹æ€§ template \u003ctypename T\u003e auto func(string type)-\u003efunction\u003cT(T,T)\u003e{ if(type==\"add\"){ return [](auto x,auto y){ return x+y; }; }else{ return [](auto x,auto y){ return x-y; }; } } //å¯å˜å‚æ•° template \u003ctypename... T\u003e decltype(auto) reduce(auto f,const T... args){ const auto vec={args...}; auto res=*vec.begin(); for(auto ne=vec.begin()+1;ne!=vec.end();ne++){ res=f(res,*ne); } return res; } int main() { cout\u003c\u003creduce(func\u003cint\u003e(\"add\"),1,2,3)\u003c\u003cendl; return 0; } ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:6:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"constexpr å¥½äº†,ç°åœ¨å¯¹äº const int MAXN=10; int a[MAXN]; æˆ‘ä»¬æœ‰äº†æ–°çš„å†™æ³•. constexpr int MAXN=10; int a[MAXN]; å®é™…ä¸Š,ä¸‹é¢çš„å†™æ³•æ‰æ˜¯å¯¹çš„.ä¸Šé¢çš„å†™æ³•æŒ‰ç…§æ ‡å‡†åº”è¯¥æ˜¯æ— æ³•é€šè¿‡ç¼–è¯‘çš„,åªä¸è¿‡å®ƒå¤ªå¸¸ç”¨,ç¼–è¯‘å™¨çŸ¥é“ä½ æƒ³å¹²å˜›,æ‰€ä»¥é»˜é»˜å®Œæˆäº†æ“ä½œ,æ²¡æœ‰äººæŠ±æ€¨,å¯å–œå¯è´º. constexprç”¨äºåœ¨ç¼–è¯‘é˜¶æ®µè¿›è¡Œæ±‚å€¼.ä¹Ÿå¯ä»¥ç”¨åœ¨å‡½æ•°.ä»¥å¾€æœ‰äº›äººåœ¨æ¨¡æ¿ä¸Šç©èŠ±,åœ¨ç¼–è¯‘é˜¶æ®µå°±è®©ç¼–è¯‘å™¨ç‡å…ˆå®Œæˆç±»ä¼¼äºæ‰“è¡¨ä¹‹ç±»çš„æ“ä½œ,ä»¥è‡³äºè¯„æµ‹å™¨é™†ç»­å…¨éƒ¨å®Œå–„äº†ç¼–è¯‘æ—¶é™åˆ¶æ—¶é—´.ç°åœ¨å†æƒ³ç©è¿™äº›æ“ä½œ,å¯ä»¥ç›´æ¥ä½¿ç”¨constexpräº†.ä¸è¿‡å¯æƒœçš„æ˜¯å®ƒè¿˜C++11é‡Œæ¯”è¾ƒèœ,ä¸èƒ½å®Œæˆå¤æ‚è¿ç®—.ç›´åˆ°åœ¨C++14é‡Œ,constexprèƒ½å¤Ÿæ”¯æŒifç”šè‡³é€’å½’äº†. åœ¨C++14é‡Œ,constexprèƒ½å¤Ÿå’Œtemplateé…åˆå®ç°å¯¹ä¸åŒç±»å‹å¸¸é‡çš„åˆå§‹åŒ–.è¿™ä¸€ç‚¹åŸºæœ¬ä¸Šå°±æŠŠ#define PI 3.1415926535897932385æ‰“çˆ†.æ¨èä½¿ç”¨#defineå®šä¹‰PIçš„åŸå› å°±åœ¨äºå®ƒçš„æ›¿æ¢è¡Œä¸ºèƒ½å¤Ÿå…å»åœ¨å¸¸é‡å®šä¹‰è¿‡ç¨‹ä¸­è¢«ç±»å‹ç²¾åº¦å½±å“. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:7:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"å³å€¼å¼•ç”¨ è¿™ç©æ„çš„å­˜åœ¨æ„ä¹‰ä¸»è¦æ˜¯æ¶ˆé™¤ä¸å¿…è¦æ‹·è´ï¼Œå¹¶ç»™æ³›å‹ç¼–ç¨‹å¸¦æ¥ä¾¿åˆ©ã€‚ ä¸€èˆ¬æ¥è®²ï¼Œå½“æˆ‘ä»¬æ‰§è¡Œå¦‚ä¸‹çš„ä»£ç  Student student; student = Student(\u0026#039;Tiansuo Li\u0026#039;,24); ç¬¬äºŒè¡Œçš„èµ‹å€¼è¿‡ç¨‹ä¸­å‘ç”Ÿäº†å†…å­˜çš„å¤åˆ¶å’Œé”€æ¯ã€‚å¯¹â€¦â€¦è¿™ä¸ªå­¦ç”Ÿçš„ä¿¡æ¯å¹¶æ²¡æœ‰ç›´æ¥ç»™studentã€‚ æ®è¯´ç°ä»£ç¼–è¯‘å™¨èƒ½å¤Ÿé’ˆå¯¹è¿™ç§æƒ…å†µè¿›è¡Œä¼˜åŒ–äº†ã€‚ å³å€¼æœ‰è¿™ä¹ˆä¸€ä¸ªç‰¹æ€§ï¼Œåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ã€‚è¿™æ˜¯éå¸¸é‡è¦çš„ä¸€ä¸ªç‰¹æ€§ï¼Œä¾‹å¦‚å­—ç¬¦ä¸²ã€å¸¸é‡ï¼Œè¿™äº›ä¸œè¥¿é™¤äº†åœ¨ä½œä¸ºå³å€¼èµ‹å€¼ç»™å·¦å€¼çš„ä¸€ç¬é—´ï¼Œå…¶ä»–æ—¶å€™å†æ— ç”¨å¤„ã€‚é‚£ä¹ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»ç„¶å¯¹æ­¤ç±»å³å€¼æ‰§è¡Œå¤åˆ¶å°±æ˜¾å¾—å¾ˆç´¯èµ˜ã€‚å³å€¼å¼•ç”¨å°±æ˜¯ç”¨äºè§£å†³æ­¤ç±»é—®é¢˜çš„ã€‚ å³å€¼å¼•ç”¨ä½¿ç”¨\u0026\u0026æ ‡æ³¨ã€‚ ä¸ºStudentå®ç°ä»¥ä¸‹å³å€¼å¼•ç”¨è¯­ä¹‰ Student\u0026 operator=(Student \u0026\u0026stu){ if(this !=\u0026str){ name=stu.name; age=stu.age; stu.name=\"\"; stu.age=0; } return *this; } å½“ç„¶å¤åˆ¶ä¸€ä¸ªåå­—ä»€ä¹ˆçš„è¿˜æ²¡æœ‰è¿™ä¹ˆå¤§åŒºåˆ«ã€‚ std::moveè¿™ä¸ªå…³é”®å­—å’Œä¸Šé¢çš„å³å€¼å¼•ç”¨æœ‰ç‚¹å…³ç³»ã€‚å®ƒæŒ‡æ˜å¯¹è±¡çš„èµ‹å€¼å¸¦æœ‰èµ„æºçš„è½¬ç§»ï¼Œä¹Ÿå°±æ˜¯å¼ºåˆ¶è¿›è¡Œå³å€¼å¼•ç”¨å’Œèµ„æºç§»åŠ¨ï¼ˆæ¯”å¦‚ä¸Šä¾‹ä¸­å­¦ç”Ÿåå­—çš„ç§»åŠ¨ï¼‰ã€‚ è¿™ç§æ„Ÿè§‰æ˜¯ä¸æ˜¯å’Œrustæœ‰ç‚¹ç›¸ä¼¼ï¼Ÿä¸è¿‡å¾ˆå¯æƒœè¿™ä¸æ˜¯ä¸€ç§ä¸œè¥¿ã€‚è‡³å°‘å®ƒåœ¨æœ€åˆè®¾è®¡ä¸Šä¸æ˜¯ã€‚ä½†æ˜¯å½“å’Œä¸€äº›æ™ºèƒ½æŒ‡é’ˆä¾‹å¦‚unique_pträ¸€åŒä½¿ç”¨æ—¶ï¼Œç¡®å®è¾¾åˆ°äº†ä¸€ç§æ‰€æœ‰æƒç§»åŠ¨çš„æ„Ÿè§‰ã€‚ å¤§å®¶æƒ³çš„éƒ½æ˜¯å·®ä¸å¤šçš„å˜›ã€‚ å¦å¤–std::forwardä¹Ÿæ˜¯åŸºäºå¼•ç”¨ç»™å‡ºçš„å·¥å…·ã€‚ç”¨æ¥æŠŠæ•°æ®æŒ‰åŸæ ·è¿”å›ã€‚å·¦å€¼å¼•ç”¨å½’å·¦å€¼å¼•ç”¨ï¼Œå³å€¼çš„å½’å³å€¼ã€‚ ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:8:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"æ™ºèƒ½æŒ‡é’ˆ è¿™ä¸ªå¯¹æˆ‘æ¥è¯´ä¸æ˜¯å¾ˆå¸¸ç”¨. std::unique_ptræ˜¯æ— æ³•å¤åˆ¶ä½†æ˜¯å¯ä»¥ç§»åŠ¨çš„æ™ºèƒ½æŒ‡é’ˆ,åˆšæ‰å·²ç»è¯´äº†. std::shared_ptræ˜¯å¯ä»¥åœ¨ä¸åŒä»£ç æˆ–è€…çº¿ç¨‹é—´å…±äº«çš„æŒ‡é’ˆ,æ˜¯å’Œä¸Šé¢çš„ç›¸å¯¹è€Œè¨€çš„.ä¸è¿‡å®ƒä¸ä¿è¯å…¶å†…éƒ¨ä¿ç®¡çš„å¯¹è±¡ä¹Ÿå¯ä»¥çº¿ç¨‹å®‰å…¨â€¦è¿™è®©æˆ‘æƒ³èµ·æ¥rustçš„Arc\u003cMutex\u003c...\u003e\u003e. ä¸shared_ptré…å¥—ä½¿ç”¨çš„è¿˜æœ‰make_shared. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:9:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"å†…å­˜æ¨¡å‹ è¯´å®è¯,è¿™ä¸ªå¤§æ¦‚æ‰æ˜¯é‡ç‚¹,ä¸è¿‡å¯¹æˆ‘æ¥è¯´ä¸å¸¸ç”¨. è¿™æ„å‘³ç€c++æ ‡å‡†åº“å°†æä¾›æ— å…³å¹³å°çš„ä¸€ç³»åˆ—çº¿ç¨‹æ“ä½œ,åŒ…æ‹¬çº¿ç¨‹,é”,åŸå­æ“ä½œ,å¼‚æ­¥ç­‰. std::thread æ¥è‡ªæ ‡å‡†åº“çš„çº¿ç¨‹ std::async c++ä¹Ÿä»c#é‚£é‡Œæ¬æ¥äº†asyncå’Œawaité‚£å¥—å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:10:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"å¯å˜å‚æ•° ä¹Ÿä¸å¸¸ç”¨â€¦ æƒ³çŸ¥é“åœ¨æ²¡æœ‰å¯å˜å‚æ•°çš„æ—¶å€™,printfæ˜¯æ€ä¹ˆå®ç°çš„å—?é‚£ä¸ªæ¨¡æ¿åµŒå¥—æ˜¯çœŸçš„ææ€–.ç›´åˆ°ä»Šå¤©C++ä¹Ÿæœ‰å¯å˜å‚æ•°äº†.å…¶è¯­æ³•ä¸Šæ˜¯... è¿™ç©æ„æ˜¯ç”¨åœ¨æ¨¡æ¿é‡Œçš„ template \u003ctypename... T\u003e void printf(const char *pattern, const T... args){ //bula bula } æ—¢ç„¶æœ‰äº†å¯å˜å‚æ•°,å°±èƒ½æœ‰å…ƒç»„.ä¸å…¶åŒæ—¶è€Œæ¥çš„è¿˜æœ‰std::tie,ç”¨äºè§£æ„å…ƒç»„. tie(name, age)=make_tuple(\"Tiansuo Li\",24); C++17é‡Œ,è¿™ç§è§£æ„è¢«è¿›ä¸€æ­¥æå‡ä¸ºç»“æ„ç»‘å®š. const auto [x, y]=make_tuple(\"Tiansuo Li\",24); ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:11:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"å’Œé¢å‘å¯¹è±¡æœ‰å…³çš„ ç›®å‰åˆæ˜¯ä¸å¸¸ç”¨çš„ä¸œè¥¿. æ˜¾å¼æ–¹æ³•é‡è½½.è¿™ä¸ªæ˜¯é¢å‘å¯¹è±¡é‡Œçš„æ¦‚å¿µ.å…·ä½“å°±æ˜¯åœ¨é‡å†™è™šå‡½æ•°æ—¶åœ¨å‡½æ•°ç­¾åæœ€åæ³¨æ˜override,ç¼–è¯‘å™¨å°±ä¼šæ ¹æ®å®é™…æƒ…å†µç»™å‡ºæ›´å¤šçš„æç¤ºå’Œå¸®åŠ©. finalå°é—­æ–¹æ³•.è¿™ä¸ªä¹Ÿæ˜¯é¢å‘å¯¹è±¡æ¦‚å¿µ.ç”¨äºå°†ä¸€ä¸ªè™šå‡½æ•°å°é—­,ä¸å†è®©å­ç±»é‡å†™. =defaulté»˜è®¤æ–¹æ³•.è¿™ä¸ªä»ç„¶æ˜¯é¢å‘å¯¹è±¡æ¦‚å¿µ.æ˜¾å¼çš„å†™æ˜ä½¿ç”¨é»˜è®¤å®ç°. =deleteåˆ é™¤æ–¹æ³•â€¦.è¿˜æ˜¯.æ˜¾å¼çš„æ³¨æ˜ä»ç±»ä¸­åˆ é™¤æŸä¸ªæ–¹æ³•(ä¾‹å¦‚é»˜è®¤æ–¹æ³•),é˜²æ­¢ä»–äººè°ƒç”¨. å…è®¸éé™æ€æˆå‘˜å˜é‡è‡ªè¡Œåˆå§‹åŒ–. æ–¹æ³•é‡è½½èƒ½å¤Ÿæ³¨æ˜å·¦å³å€¼çš„åŒºåˆ†. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:12:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"array ä¸å¯å˜é•¿çš„æ•°ç»„,éœ€è¦åœ¨å£°æ˜æ—¶å°±ç»™å‡ºå¤§å°.è¿™ç©æ„å¾ˆå¸¸ç”¨æ‰€ä»¥ä¹Ÿæå‡ºæ¥. ä¸æ­¤ç›¸å…³çš„ä¿¡æ¯æ˜¯vectorçš„ç©ºé—´å ç”¨,è¿™ä¸ªä¸œè¥¿çš„è¡Œä¸ºæœ‰å¦‚ä¸‹ä¸¤ä¸ªç‰¹ç‚¹ å½“éœ€è¦æ–°ç©ºé—´æ—¶,å°†é‡æ–°ç”³è¯·åŸæ¥ä¸¤å€çš„ç©ºé—´. å°†æ•°æ®å¤åˆ¶åˆ°æ–°ç©ºé—´. å¦‚æœç¡®å®šæ•°æ®çš„å¤§å°,arrayæ˜¾ç„¶æ˜¯ä¸ªæ›´å¥½çš„é€‰æ‹©. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:13:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"std::optional å¤© ä¸‹ å¤§ åŒ. è¿™ç©æ„å’Œrustçš„Optionæ˜¯ä¸€ä¸ªä¸œè¥¿.ä½ å®¶C++ä¹Ÿè¦å˜æˆunwrap,unwrap,unwrap,unwrap,unwrapäº†. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:14:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"Concepts å¤© ä¸‹ å¤§ åŒ x 2. è¿™ç©æ„ç”¨äºé™å®šæ¨¡æ¿ä¸­çš„ç±»å‹.ç±»ä¼¼äºrustå†…çš„+æè¿°. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:15:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"å…¶ä»–ä¿¡æ¯ std::chrono æ¥è‡ªæ ‡å‡†åº“çš„æ—¶é—´è®¡ç®— unordered_xxx åŸºäºå“ˆå¸Œçš„æ— åºå®¹å™¨,è¿™ä¸ªå·²ç»å¾ˆå¸¸ç”¨äº†å§ std::begin/end â€¦è¿™ä¸ªç®—æ˜¯å¡«å‘?è™½ç„¶å„ä¸ªå®¹å™¨éƒ½æä¾›äº†ç±»ä¼¼çš„API,ä¸è¿‡åœ¨æ³›å‹ç¼–ç¨‹æ—¶,è¿˜æ˜¯éœ€è¦ä¸€ä¸ªè¿™ç§ä¸œè¥¿. å…è®¸æ¨¡æ¿åµŒå¥—æ—¶å³ä¾§å°–æ‹¬å·ç´§é .è¿™ä¸ªå…¶å®å¾ˆå¥½.ä»¥åŠä¹Ÿè¦æ³¨æ„è¿™ä¸ªç‰¹æ€§æ˜¯åœ¨C++11é‡Œä¿®è®¢çš„. noexcept æ”¾åœ¨å‡½æ•°ç­¾åé‡Œè¡¨ç¤ºä¸æŠ›å¼‚å¸¸ attribute ç”¨[[]]æ¥æ ‡æ³¨å±æ€§(æ³¨è§£),æœ‰ç‚¹åƒrustçš„#[[]]ä¸€ç±»çš„ä¸œè¥¿.åœ¨C++20é‡Œ,æœ‰ä¸€ä¸ªæ¯”è¾ƒæœ‰è¶£çš„æ³¨è§£likelyå¯ä»¥å‘ç¼–è¯‘å™¨å»ºè®®åˆ†æ”¯çš„é¢„æµ‹ç»“æœ,è¿™ä¸ªå’ŒCSAPPè¯¾ç¨‹ç›¸å…³æ€§å¾ˆå¼º. äºŒè¿›åˆ¶è¡¨ç¤º,åœ¨C++14ä¸­,è¿™æ²¡å•¥å¯è¯´çš„,0b010101. å¸¦åˆå§‹åŒ–çš„if.åœ¨C++17ä¸­,èƒ½å¤Ÿç”¨ç±»ä¼¼äºgolangä¸­çš„å¸¦åˆå§‹åŒ–ifäº†. å¸¦åˆå§‹åŒ–çš„rangefor.åœ¨C++20ä¸­,for(:)çš„ç©æ„èƒ½å¤Ÿè‡ªå¸¦åˆå§‹åŒ–è¯­å¥äº†. utf-8æ”¯æŒ.åœ¨C++17ä¸­,å­—ç¬¦å‰ç¼€u8èƒ½å¤Ÿè·å¾—utf-8çš„å­—ç¬¦äº†.åœ¨C++20ä¸­,å­˜åœ¨char8_tç”¨äºæ”¯æŒå­—ç¬¦ä¸². ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:16:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"å¯èƒ½å…³æ³¨çš„å…¶ä»–ä¸œè¥¿ popcount.C++20æä¾›çš„å‡½æ•°,å¯ä»¥æ•°äºŒè¿›åˆ¶æ•°ä¸­1çš„ä¸ªæ•°.å¦å¤–è¿˜æœ‰ä¸€äº›æ“ä½œ,ä½äº\u003cbit\u003eä¸­. æ•°å­¦å¸¸æ•°.ä¾‹å¦‚std::numbers::pi.ä¸è¿‡è¿™ä¸ªå€’æ— æ‰€è°“â€¦åº”è¯¥éƒ½çŸ¥é“acos(-1). ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:17:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["å­¦ä¹ "],"content":"C++èµ°åœ¨ç°ä»£åŒ–çš„è·¯ä¸Š å…ˆæä¸€ä¸ªé—®é¢˜.GCCå’ŒClangäºŒè€…æœ€æ–°ç‰ˆæœ¬çš„ç¼–è¯‘å™¨çš„å®‰è£…å¯èƒ½ä¼šç»™ä½ å¸¦æ¥éº»çƒ¦,å°¤å…¶æ˜¯Windowsç”¨æˆ·.MinGW,MinGW-w64,TDM-GCCéƒ½æ²¡æœ‰æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬.å¦‚æœå¸Œæœ›ä½¿ç”¨20æ ‡å‡†,ä¼¼ä¹æœ€ç®€å•çš„åŠæ³•æ˜¯å®‰è£…msys2. å…¶å®åœ¨ç¿»çœ‹å®Œè¿™äº›æ–°æ ‡å‡†å,æˆ‘è¶Šå‘è§‰å¾—æˆ‘åŸæ¥å­¦çš„C++å’Œç°åœ¨çš„C++æ˜¯ä¸åŒçš„è¯­è¨€.ä½ å¯ä»¥æŠŠC++å½“Cæ¥å†™,ä¹Ÿå¯ä»¥åœåœ¨11ä¹‹å‰çš„æ ‡å‡†æ¥å†™,ä¹Ÿå¯ä»¥å¤§è¸æ­¥æ¥åˆ°20.ä¸‰ç§é£æ ¼å†™å‡ºæ¥çš„ä»£ç å®Œå…¨ä¸æ˜¯ä¸€ä¸ªä¸œè¥¿. å¦å¤–,æˆ‘ä¸€ç›´æ²¡æœ‰æ³¨æ„æ™ºèƒ½æŒ‡é’ˆ,å³å€¼å¼•ç”¨å’Œç§»åŠ¨æ¦‚å¿µ,åœ¨äº†è§£Rustä¹‹åæ‰æ„è¯†åˆ°å®ƒä»¬çš„é‡è¦æ€§.é™¤äº†æ²¡æœ‰Rustä¸ç”Ÿä¿±æ¥çš„ç”Ÿå‘½å‘¨æœŸä»¥åŠæ‰€æœ‰æƒçš„é™æ€æ£€æŸ¥,C++æŠŠå…¶ä»–è¯¥æœ‰çš„ä¼¼ä¹å…¨æœ‰äº†.å€’ä¸å¦‚è¯´Rustä¹Ÿä»C++è¿™é‡Œå€Ÿé‰´äº†å¤§é‡ä¸œè¥¿,æ¯”å¦‚æ™ºèƒ½æŒ‡é’ˆ. è¯´å®è¯,åœ¨æ­¤æ—¶æˆ‘æœ‰ç‚¹æ›´å€¾å‘äºä½¿ç”¨C++äº†. C++çš„ç¼–è¯‘å™¨ä¹Ÿèƒ½åœ¨ç§»åŠ¨è¯­ä¹‰ä¸Šè¿›è¡Œè¾ƒä¸ºå®½æ¾çš„é™æ€æ£€æŸ¥,such as å·²ç»moveçš„å˜é‡å†æ¬¡ä½¿ç”¨ä¼šè¢«warning. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:18:0","tags":null,"title":"C++æ–°æ ‡å‡†ç‰¹æ€§åˆæ¢","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["é—²æ‰¯"],"content":"æœ¬æ¥è¿™ä¸æ˜¯æˆ‘ç°åœ¨è¯¥æƒ³çš„ä¸œè¥¿ï¼Œè¢«è¿«å› ä¸ºå»ºæ¨¡æ¯”èµ›çœ‹äº†ä¸€ç‚¹ã€‚æ‰€å­¦ä¸œè¥¿å¤ªè¿‡æ‚ä¹±ã€‚ ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:0:0","tags":null,"title":"ä½¿ç”¨Pythonåˆ†ææ•°æ®","uri":"/2020/02/python-in-data-processing/"},{"categories":["é—²æ‰¯"],"content":"ä¸ºä»€ä¹ˆä¸ç”¨Matlabã€Mathematica å› ä¸ºMathematicaè¢«æˆ‘å¸äº†ï¼ŒMatlabæ²¡å­¦è¿‡ï¼Œä¹Ÿä¸å–œæ¬¢ã€‚è¿™åªæ˜¯ä¸€ä¸ªæ’é™¤æ³•ï¼Œæˆ‘ä¸çŸ¥é“è¯¥æ€ä¹ˆä»ä¼˜åŠ¿ä¸Šæ¯”è¾ƒã€‚ Rè¯­è¨€æ²¡å­¦è¿‡ï¼ŒJuliaä¹Ÿæ²¡æœ‰ï¼Œæ‰€ä»¥å›å½’å·¥å…·é½å…¨çš„Pythonã€‚ ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:1:0","tags":null,"title":"ä½¿ç”¨Pythonåˆ†ææ•°æ®","uri":"/2020/02/python-in-data-processing/"},{"categories":["é—²æ‰¯"],"content":"Python æ•°æ®åˆ†æå¥—è£… å»ºè®®ç›®æ ‡å°±æ˜¯åˆ†ææ•°æ®çš„äººç›´æ¥å®‰è£…anacondaï¼Œä½¿ç”¨jupyter labï¼Œä¸æŠ˜è…¾ã€‚ å¯¹äºæ•°æ®è¯»å…¥å’Œæ¸…æ´—ï¼šPandas å¯¹äºçŸ©é˜µç­‰å‘é‡è¿ç®—ï¼šnumpy å¯¹äºè®¡ç®—æœºä»£æ•°è®¡ç®—ï¼šsympy ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:2:0","tags":null,"title":"ä½¿ç”¨Pythonåˆ†ææ•°æ®","uri":"/2020/02/python-in-data-processing/"},{"categories":["é—²æ‰¯"],"content":"ç»˜å›¾ ç»˜å›¾çš„åº“å°±å¾ˆå¤šäº†ã€‚Matplotlibï¼ŒPlotlyï¼ŒSeabornï¼ŒAltairè¿™å‡ ä¸ªè¿˜ä¸é”™ã€‚ç¬¬ä¸€ä¸ªæ¯”è¾ƒåº•å±‚ï¼Œæ˜¯ç›´æ¥å‚ç…§Matlabçš„APIè®¾è®¡çš„ï¼ŒSeabornæ˜¯åœ¨å…¶åŸºç¡€ä¸Šè®¾è®¡çš„æ›´é«˜å±‚çš„ç»˜å›¾åŒ…,æ‰€ä»¥ä½¿ç”¨ã€é…è‰²ã€æ’ç‰ˆä»€ä¹ˆçš„éƒ½ä¸é”™ã€‚Plotlyå’ŒAltairéƒ½æ˜¯å…·æœ‰ä¸€å®šäº¤äº’èƒ½åŠ›çš„ç»˜å›¾åŒ…ï¼Œåœ¨labé‡Œæ˜¯éœ€è¦å‰ç«¯jsé…åˆç»˜å›¾çš„ï¼ˆæ‰€ä»¥ä¸€æ—¦å›¾ç‰‡æ•°æ®å¤ªå¤šï¼Œä¼šå¡å¾—æµè§ˆå™¨ç—›ä¸æ¬²ç”Ÿï¼‰ã€‚ æˆ‘å°±èƒ¡ä¹±é€‰äº†ä¸ªPlotlyã€‚ä¸è¿‡ç°åœ¨çœ‹æ¥å¤§æ¦‚æ˜¯ä¸ªé”™è¯¯çš„å†³å®šã€‚ ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:2:1","tags":null,"title":"ä½¿ç”¨Pythonåˆ†ææ•°æ®","uri":"/2020/02/python-in-data-processing/"},{"categories":["é—²æ‰¯"],"content":"Plotlyåœ¨å›½å†…é…ç½®çš„å‘ çœ‹ç€npmå’Œyarnè¿™ä¸¤ä¸ªå­—çœ¼å°±å®³æ€•ç°åœ¨ã€‚jsé‚£ä¸€å †ä¹±ä¸ƒå…«ç³Ÿçš„å·¥å…·é“¾ï¼Œæ”¯æŒåº¦å„ä¸ç›¸åŒçš„æ ‡å‡†ï¼Œè¿™é‡Œå¯ä»¥importï¼Œé‚£é‡Œåˆä¼šceå¿…é¡»ç”¨requireï¼Œåˆletåˆvarï¼Œåˆ°ç°åœ¨ä¹Ÿæ•´ä¸æ¸…æ¥šçš„thiså’Œthatï¼Œæœ‰çš„åŒ…è¦æ±‚ä¼ æ­£ç¡®çš„lambdaè¡¨è¾¾å¼ï¼Œæœ‰çš„åˆå¿…é¡»ç”¨functionï¼Œè¿˜æœ‰ä¸€å †å‘â€¦â€¦çœ‹ç€å°±æƒ³èº²ç€èµ°ï¼Œç„¶è€Œè¿™plotlyçš„æ„å»ºæ˜¯éœ€è¦npmå’Œyarnçš„ã€‚ â€¦â€¦ä¸ºä»€ä¹ˆè¿™ç ´è¯­è¨€èƒ½ç”¨åˆ°ç°åœ¨ã€‚ åœ¨å®‰è£…Plotlyå‘Jupyter labçš„æ”¯æŒåº“æ—¶ï¼Œåˆ‡å‹¿åœ¨npmå’Œyarnä¸­ä½¿ç”¨é•œåƒã€‚é•œåƒå’Œæºä¹‹é—´æœ‰ä¸€å®šçš„æ›´æ–°å»¶è¿Ÿå¹¶ä¸”å­˜åœ¨åŒæ­¥é”™è¯¯è€Œè·³è¿‡æŸäº›åŒ…çš„é—®é¢˜ã€‚æˆ‘å°±æ­£å¥½å¡åœ¨äº†è¢«è·³è¿‡çš„åŒ…ä¸Šï¼Œå› ä¸ºè¿™ä¸ªé—®é¢˜æ­»æ´»ç¼–è¯‘ä¸è¿‡å»æµªè´¹äº†å¾ˆé•¿æ—¶é—´ã€‚ å…¶æ¬¡ï¼Œä½¿ç”¨Plotlyè¾“å‡º.pdfç­‰æ ¼å¼çš„å›¾ç‰‡æ–‡ä»¶æ—¶ï¼Œéœ€è¦å®‰è£…ocraï¼Œåœ¨æœåŠ¡å™¨ä¸Šé…ç½®æ—¶è¿˜éœ€è¦å®‰è£…xvfbï¼Œè¿™äº›éƒ½åœ¨å…¶æ–‡æ¡£ä¸­æœ‰å†™ï¼Œä¸è¿‡è§†ç³»ç»Ÿä¸åŒä»ç„¶éœ€è¦è‡ªå·±è¡¥é½å¾ˆå¤šæ”¯æŒåº“ã€‚ä»è¿™ä¸ªè§’åº¦ä¸Šæ¥è¯´ï¼Œä¼¼ä¹è¿˜æ˜¯é€‰æ‹©Seaborn+Matplotlabæ¯”è¾ƒå¥½ï¼Œé™¤éä½ æœ‰å·¥å…·äººï¼Œå¦åˆ™ä¸è¦æŠŠæ—¶é—´æµªè´¹åœ¨è«åå…¶å¦™çš„åœ°æ–¹ã€‚ ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:2:2","tags":null,"title":"ä½¿ç”¨Pythonåˆ†ææ•°æ®","uri":"/2020/02/python-in-data-processing/"},{"categories":["é—²æ‰¯"],"content":"åŸºæœ¬æ“ä½œ numpyå’Œpandaséƒ½æœ‰å¿«é€Ÿå…¥é—¨æ•™ç¨‹ï¼ŒèŠ±20åˆ†é’Ÿè¯»ä¸€è¯»ï¼Œç„¶åå‰©ä¸‹çš„éšç”¨éšæŸ¥å°±å¥½äº†ã€‚ è¿™é‡Œè®°å‡ ä¸ªå¸¸ç”¨ä½†æ˜¯ä¸å¤ªå¥½æ‰¾çš„ä¸œè¥¿ã€‚ ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:3:0","tags":null,"title":"ä½¿ç”¨Pythonåˆ†ææ•°æ®","uri":"/2020/02/python-in-data-processing/"},{"categories":["é—²æ‰¯"],"content":"å¦‚ä½•éå†æ•°æ®å¸§çš„æ‰€æœ‰è¡Œ æ ‡å‡†æ“ä½œæ˜¯apply df[\u0026#039;pass\u0026#039;]=df.apply(lambda a:a[\u0026#039;grade\u0026#039;]\u003e=60,axis=1) ä½†æ˜¯ï¼Œè¿™ç©æ„çš„å‘åœ¨äºä¼ ç»™å®ƒçš„å‡½æ•°å†…éƒ¨æ˜¯åªèƒ½getä¸èƒ½setçš„ã€‚å³ä½¿setä¹Ÿæ²¡æœ‰ä½œç”¨ã€‚ä¸è¿‡ä¸€èˆ¬ä¿®æ”¹å•åˆ—æ•°æ®ä¹Ÿæ²¡æœ‰é—®é¢˜ï¼Œå¯ä»¥åƒä¸Šé¢ä¸€è¡Œä¸€æ ·ã€‚ å¦å¤–æ—¶åˆ»è®°ä½ï¼Œç­›é€‰çš„æ•°æ®å¸§ç»“æœä¹Ÿæ˜¯ä¸èƒ½setçš„ã€‚è™½ç„¶ä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼Œä½†æ˜¯æˆ‘åœ¨è¸©è¿™ä¸ªå‘çš„æ—¶å€™ï¼Œæœ‰äº›æ—¶å€™ä¸ä½†ä¸ä¼šä¿®æ”¹è€Œä¸”è¿é”™è¯¯ä¹Ÿä¸ä¼šæŠ¥ã€‚ ä¸è¿‡å¦‚æœæ˜¯ä¿®æ”¹å¤šè¡Œæ•°æ®å‘¢ï¼Œä¸Šé¢çš„å‘½ä»¤æ˜¯ä¸èƒ½ç®€å•æ¨å¹¿çš„ã€‚å½“ç„¶å¯ä»¥ç”¨ä¸€äº›å¾ˆä¸‘é™‹çš„åšæ³•ï¼Œæ¯”å¦‚for i in range(df.shape[0])ï¼ˆå¯èƒ½æœ‰ç¨å¾®å¥½çœ‹ä¸€ç‚¹çš„å†™æ³•ï¼‰ç„¶åilocä¸€ä¸ªä¸ªçš„æ”¹æ‰ã€‚ä¸è¿‡å®é™…ä¸Šï¼Œä»ç„¶æœ‰ä½¿ç”¨applyçš„ä½™åœ°ã€‚ def fn(row): return math.sqrt(row[\u0026#039;è®¡ç®—æœºå¯¼â™‚è®º\u0026#039;])*10,math.sqrt(row[\u0026#039;é«˜ç­‰â™‚æ•°å­¦\u0026#039;])*10 df[\u0026#039;è®¡ç®—æœºå¯¼â™‚è®º\u0026#039;],df[\u0026#039;é«˜ç­‰â™‚æ•°å­¦\u0026#039;]=zip(*df.apply(fn,axis=1)) å¼€æ–¹ä¹˜åï¼Œæ ‡å‡†çš„æäººæ–¹æ³•è¦ä¸è¦äº†è§£ä¸€ä¸‹ã€‚ è¿™ç§æ–¹æ¡ˆå¯è¯»æ€§è¾ƒå·®ï¼Œä¸è¿‡å®æµ‹æ˜¯å¿«äºæ‰‹åŠ¨éå†çš„ã€‚å¬è¯´pythonä¸æƒ³è®©äººç®¡å¤æ‚åº¦ï¼Œäº‹å®å´ä¸å¤§è¡Œå•Šã€‚ ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:3:1","tags":null,"title":"ä½¿ç”¨Pythonåˆ†ææ•°æ®","uri":"/2020/02/python-in-data-processing/"},{"categories":["é—²æ‰¯"],"content":"Plotlyçš„æ•´ä½“è®¾è®¡ Plotlyçš„å®˜æ–¹æ–‡æ¡£å†™å¾—å¾ˆå¥½ï¼Œçœ‹å®Œæ¦‚è§ˆåè´¹ç‚¹åŠŸå¤«å°±èƒ½æ‰¾åˆ°è‡ªå·±æƒ³è¦çš„å›¾çš„ç”»æ³•ã€‚å†æƒ³è‡ªå®šä¹‰å°±å»ç¿»APIã€‚ æ€»ä½“æ¥çœ‹ï¼Œgraph_objectï¼ˆå¥½åƒæ˜¯è¿™ä¹ˆæ‹¼ï¼Ÿï¼‰æ˜¯æœ€åŸºç¡€çš„ç»˜å›¾å¯¹è±¡ï¼Œè®¾ç½®å¥½å›¾ä¾‹ååŠ å…¥åˆ°Figureé‡Œï¼Œå°±å¯ä»¥ä½œä¸ºæœ€ç»ˆç»“æœè¾“å‡ºã€‚expressæ˜¯ä¸€ä¸ªæ›´é«˜å±‚çš„å·¥å‚ï¼Œèƒ½å¤Ÿæ»¡è¶³ä¸€èˆ¬æƒ…å†µå¸¸ç”¨çš„å›¾çš„å¿«é€Ÿç»˜åˆ¶ã€‚æ‰€ä»¥ï¼Œå…ˆå»expressï¼Œæ»¡è¶³ä¸äº†å†å¾€ä¸‹æ‰¾ã€‚ å¦‚æœçœ‹å®Œæ¦‚è§ˆäº†ä¹‹åè¿˜èƒ½å‘ç°ä¸€ä¸ªå¾ˆé‡è¦çš„ä¿¡æ¯ã€‚è®¾ç½®å›¾ä¾‹å±æ€§æ—¶å¯èƒ½ä¼šé‡åˆ°åµŒå¥—å¤šå±‚å¯¹è±¡çš„é‚£ç§å‚æ•°ï¼Œè¿™æ—¶å€™å¯ä»¥ç›´æ¥ä½¿ç”¨_è¿æ¥å‚æ•°åï¼Œä¸éœ€è¦ä¸€å±‚å±‚æ„é€ ã€‚ çŸ¥é“è¿™äº›ä¹‹åéšä¾¿ç”»å°±æ˜¯äº†ã€‚ ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:3:2","tags":null,"title":"ä½¿ç”¨Pythonåˆ†ææ•°æ®","uri":"/2020/02/python-in-data-processing/"},{"categories":["é—²æ‰¯"],"content":"[music autoplay=\"0â€]40915181[/music] ä¸Šé¢è¿™ä¸ªæ”¹ç¼–çš„äº¤å“ä¹è¿˜ä¸é”™ï¼Œé¡ºä¾¿æµ‹è¯•ä¸€ä¸‹éŸ³ä¹ç›’ è¿™ä¸ªä¸»é¢˜è¿˜å¯ä»¥ï¼Œæœ‰ä¸€äº›æ¯”è¾ƒæ¯”è¾ƒæœ‰è¶£çš„ä¸œè¥¿ã€‚ å…¶å®æ˜¯è¿ç³»ç»Ÿéƒ½æ¢äº†â€¦â€¦ä¸æƒ³æŠ˜è…¾äº†ï¼Œè¿˜æ˜¯è¿™æ ·ç®—äº†ã€‚ ","date":"2020-02-21","objectID":"/2020/02/change-theme/:0:0","tags":null,"title":"æ¢ä¸ªä¸»é¢˜","uri":"/2020/02/change-theme/"},{"categories":["é—²æ‰¯"],"content":"ä¿®æ”¹çš„åœ°æ–¹ åœ¨headéƒ¨åˆ†æ·»åŠ äº†æµè§ˆç»Ÿè®¡ã€‚ åœ¨pjaxè°ƒç”¨çš„jqueryå°è£…æ’ä»¶å¤„æ·»åŠ äº†mathjaxçš„é‡æ–°æ¸²æŸ“ã€‚ è¿›ä¸€æ­¥å¯ç”¨äº†cdnä¸¥æ ¼æ¨¡å¼çš„SSL/TLSã€‚ å…³é—­äº†ä¸»é¢˜è‡ªå¸¦çš„ä»£ç é«˜äº®ï¼Œå¯ç”¨äº†Prismé«˜äº®ï¼Œå¹¶ä¸”é…ç½®åœ¨pjaxçš„é‡æ–°æ¸²æŸ“ã€‚(ä¿®æ”¹è®¾è®¡pjax.jså’Œä¸»é¢˜è‡ªèº«js,å…±ä¸¤å¤„;å¦å¤–csså†…æ ·å¼æœªå»é™¤) ä¿®æ”¹äº†å½’æ¡£é¡µé¢çš„éƒ¨åˆ†è¯­å¥â€¦â€¦è¿˜æœ‰404é¡µé¢çš„éƒ¨åˆ†è¯­å¥â€¦â€¦ï¼ˆå¸Œæœ›æ²¡æœ‰æ¼ç½‘çš„ å¦‚æœä½ çœ‹åˆ°æµè§ˆå™¨ä»ç„¶æç¤ºä¸å®‰å…¨ï¼Œæ˜¯å› ä¸ºç½‘ç«™å†…ä»ç„¶æœ‰ä¸€äº›å›¾ç‰‡ä½¿ç”¨äº†httpï¼Œä»€ä¹ˆæ—¶å€™é—²å¾—æ²¡äº‹å†æ¥ä¿®ã€‚å¦å¤–å›¾ç‰‡åŠ è½½è¿™ä¹ˆæ…¢æˆ‘ä¹Ÿæ²¡ä»€ä¹ˆåŠæ³•ï¼Œæ¯•ç«Ÿä¸–ç•Œä¸Šçš„äº’è”ç½‘åˆ†ä¸ºä¸¤éƒ¨åˆ†ã€‚ æœåŠ¡å™¨å¯¹ä¸­æ–‡urlçš„æ”¯æŒè²Œä¼¼ä¹Ÿæœ‰äº›é—®é¢˜ã€‚ ","date":"2020-02-21","objectID":"/2020/02/change-theme/:1:0","tags":null,"title":"æ¢ä¸ªä¸»é¢˜","uri":"/2020/02/change-theme/"},{"categories":["é—²æ‰¯"],"content":"å‡æœŸå°†è¿‡ å‡æœŸå°±è¿™ä¹ˆæ²¡äº†ã€‚å¤´ç§ƒã€‚ ","date":"2020-02-21","objectID":"/2020/02/change-theme/:2:0","tags":null,"title":"æ¢ä¸ªä¸»é¢˜","uri":"/2020/02/change-theme/"},{"categories":["å­¦ä¹ "],"content":"æ ‘é“¾å‰–åˆ†å¯ä»¥ç”¨æ¥ç»´æŠ¤æ ‘ä¸Šè·¯å¾„çš„ä¿¡æ¯ã€‚æŠŠæ ‘ä¸Šçš„èŠ‚ç‚¹æ‹†æˆä¸è¶…è¿‡$O(\\log n)$æ®µè¿ç»­çš„è·¯å¾„ï¼ˆé“¾ï¼‰ï¼Œä»¥æ˜ å°„åˆ°çº¿æ®µæ ‘æˆ–è€…ä»€ä¹ˆçš„æ„æ¥ç»´æŠ¤æ•°æ®ã€‚ ä¾ç…§å­æ ‘çš„å¤§å°ï¼Œå°†æœ€å¤§å­æ ‘ä½œä¸ºé‡è¾¹ï¼Œå…¶ä»–å­æ ‘ä½œä¸ºè½»è¾¹ï¼Œä»è€Œåœ¨æ ‘ä¸Šæ‹†åˆ†å‡ºå¤šæ¡é“¾ã€‚ä¸ºåŒä¸€æ¡é“¾ä¸Šçš„èŠ‚ç‚¹è¿ç»­ç¼–å·ï¼Œå®Œæˆå‰–åˆ†ã€‚è‡³äºå‰©ä¸‹çš„ï¼Œä¾ç…§ç¼–å·ä¸€æ¡é“¾å¯ä»¥è¿ç»­çš„æ˜ å°„åˆ°æ•°æ®ç»“æ„çš„æŸä¸ªå–é—´å†…ï¼Œç”¨ç±»ä¼¼äºå€å¢LCAçš„æ–¹æ³•åœ¨æ ‘ä¸Šå¾—åˆ°æ¯ä¸€ä¸ªè¯¢é—®æ‰€è¦†ç›–çš„é“¾çš„èµ·å§‹ä¸ç»“å°¾ç„¶åç»§ç»­å…¶ä»–æ“ä½œå°±å¯ä»¥äº†ã€‚ ","date":"2020-02-18","objectID":"/2020/02/heavy-light-decomposition/:0:0","tags":null,"title":"æ ‘é“¾å‰–åˆ†","uri":"/2020/02/heavy-light-decomposition/"},{"categories":["å­¦ä¹ "],"content":"é€šå¸¸ç­–ç•¥ å¯¹äºå­æ ‘çš„å¤§å°ç»Ÿè®¡ï¼Œdfså³å¯ã€‚ ä¹‹åèŠ‚ç‚¹ç¼–å·ä½¿ç”¨å…ˆåºçš„dfsåºï¼Œå¹¶ä¸”ä¼˜å…ˆè¿›å…¥é‡è¾¹ï¼Œä»¥ä¿è¯é“¾ä¸ŠèŠ‚ç‚¹çš„ç¼–å·è¿ç»­ã€‚ ä¸ºäº†åœ¨é“¾ä¸Šå¿«é€Ÿè·³è½¬ï¼Œè¿˜éœ€è¦è®°å½•æ¯ä¸ªèŠ‚ç‚¹æ‰€åœ¨é“¾çš„å¤´ã€‚ å…·ä½“çš„ä»£ç å¯ä»¥çœ‹ä¸‹é¢ä¸¤ä¸ªé¢˜ç›®ã€‚å…¶å®æˆ‘ä¹Ÿæ˜¯ä»åˆ«å¤„æŠ„äº†æ¿å­ ","date":"2020-02-18","objectID":"/2020/02/heavy-light-decomposition/:1:0","tags":null,"title":"æ ‘é“¾å‰–åˆ†","uri":"/2020/02/heavy-light-decomposition/"},{"categories":["å­¦ä¹ "],"content":"HDU 3966 Aragornâ€™s Story é¢˜ç›®è¦æ±‚åŒºé—´ä¿®æ”¹æŸæ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„æƒå€¼ï¼ŒæŸ¥è¯¢æŸä¸ªç‚¹çš„æƒå€¼ã€‚ å°±å‰–ï¼Œå‰–å®Œçº¿æ®µæ ‘è¿˜æ˜¯æ ‘çŠ¶æ•°ç»„åŒºé—´ä¿®æ”¹å•ç‚¹æŸ¥è¯¢ã€‚ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccmath\u003e#include \u003cmap\u003e#include \u003cqueue\u003e#include \u003ccstring\u003e#include \u003ccstdio\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXN=50010; vector\u003cint\u003e g[MAXN]; int vlen,elen,qlen; int tick=0; int fa[MAXN],sz[MAXN],dep[MAXN]; int son[MAXN],top[MAXN]; int dfn[MAXN],rnk[MAXN]; void dfs1(int u,int f){ fa[u]=f; dep[u]=dep[f]+1; sz[u]=1; son[u]=0; for(auto v:g[u]){ if(v==f)continue; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]\u003esz[son[u]]){ son[u]=v; } } } void dfs2(int u,int f){ top[u]=f; dfn[u]=++tick; rnk[tick]=u; if(son[u]==0)return; dfs2(son[u],f); for(auto v:g[u]){ if(v!=son[u] \u0026\u0026 v!=fa[u])dfs2(v,v); } } const int FTN=4*(MAXN+10); int ft[FTN]; int lowbit(int x){ return x\u0026-x; } void ftadd(int pos,int x){ if(pos\u003c=0)return; for(;pos\u003cFTN;pos+=lowbit(pos))ft[pos]+=x; } int ftget(int pos){ if(pos\u003c=0)return 0; int res=0; for(;pos;pos-=lowbit(pos))res+=ft[pos]; return res; } int query(int pos){ return ftget(dfn[pos]); } void modify(int l,int r,int x){ ftadd(l,x); ftadd(r+1,-x); } void solve(int x,int y,int delta){ int fx=top[x],fy=top[y]; while(fx!=fy){ if(dep[fx]\u003edep[fy])modify(dfn[fx],dfn[x],delta),x=fa[fx]; else modify(dfn[fy],dfn[y],delta),y=fa[fy]; fx=top[x]; fy=top[y]; } if(x!=y){ if(dfn[x]\u003cdfn[y])modify(dfn[x],dfn[y],delta); else modify(dfn[y],dfn[x],delta); }else modify(dfn[x],dfn[y],delta); } int num[MAXN]; int main(){ while(~scanf(\"%d%d%d\",\u0026vlen,\u0026elen,\u0026qlen)){ for(int i=0;i\u003c=vlen;i++)g[i].clear(); memset(ft,0,sizeof(ft)); memset(fa,0,sizeof(fa)); memset(sz,0,sizeof(sz)); memset(dep,0,sizeof(dep)); memset(son,0,sizeof(son)); memset(top,0,sizeof(top)); memset(dfn,0,sizeof(dfn)); memset(rnk,0,sizeof(rnk)); tick=0; for(int i=1;i\u003c=vlen;i++){ scanf(\"%d\",num+i); } for(int i=0;i\u003celen;i++){ int u,v; scanf(\"%d%d\",\u0026u,\u0026v); g[u].push_back(v); g[v].push_back(u); } dfs1(1,0); dfs2(1,1); /* for(int i=1;i\u003c=vlen;i++) cout\u003c\u003cdfn[i]\u003c\u003c\" \"; cout\u003c\u003cendl; */ for(int i=1;i\u003c=vlen;i++){ modify(dfn[i],dfn[i],num[i]); } /* for(int i=1;i\u003c=vlen;i++){ cout\u003c\u003cquery(i)\u003c\u003c\" \"; } cout\u003c\u003cendl; */ while(qlen--){ char opt[10]; scanf(\"%s\",opt); if(opt[0]=='I' || opt[0]=='D'){ int l,r,x; scanf(\"%d%d%d\",\u0026l,\u0026r,\u0026x); if(opt[0]=='D')x=-x; solve(l,r,x); }else{ int u; scanf(\"%d\",\u0026u); printf(\"%d\\n\",query(u)); } } } return 0; } ","date":"2020-02-18","objectID":"/2020/02/heavy-light-decomposition/:2:0","tags":null,"title":"æ ‘é“¾å‰–åˆ†","uri":"/2020/02/heavy-light-decomposition/"},{"categories":["å­¦ä¹ "],"content":"CF343D Water Tree ç¨å¾®æœ‰ç‚¹ä¸ä¸€æ ·ã€‚ä¿®æ”¹1è¦æ±‚ä¸ºç‚¹çš„æ•´ä¸ªå­æ ‘æ‰“æ ‡è®°ï¼Œä¿®æ”¹2è¦æ±‚å–æ¶ˆèŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹ä¸Šçš„æ ‡è®°ã€‚ æŒ‰ç…§dfsåºçš„ç¼–å·æ–¹å¼ï¼Œä¸ºæ¯ä¸€ä¸ªèŠ‚ç‚¹è®°å½•è¿›å…¥æ—¶é—´å’Œç¦»å¼€æ—¶é—´ï¼Œå°±èƒ½å¾—åˆ°è¯¥èŠ‚ç‚¹å­æ ‘æ˜ å°„åçš„è¿ç»­åŒºé—´ã€‚é‚£ä¹ˆæµ‡æ°´å°±å¯ä»¥å¥—ä¸€ä¸ªçº¿æ®µæ ‘ç›´æ¥æ”¹äº†ã€‚æ¸…ç©ºæ°´å¾€æ ¹èŠ‚ç‚¹è·³ç„¶åä¿®æ”¹ä¸€è·¯ä¸Šç»è¿‡çš„é“¾ã€‚ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccmath\u003e#include \u003cmap\u003e#include \u003cqueue\u003e#include \u003ccstring\u003e#include \u003ccstdio\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXN=500010; vector\u003cint\u003e g[MAXN]; int vlen,elen,qlen; int tick=0; int fa[MAXN],sz[MAXN],dep[MAXN]; int son[MAXN],top[MAXN]; int dfn[MAXN],outdfn[MAXN]; void dfs1(int u,int f){ fa[u]=f; dep[u]=dep[f]+1; sz[u]=1; son[u]=0; for(auto v:g[u]){ if(v==f)continue; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]\u003esz[son[u]]){ son[u]=v; } } } void dfs2(int u,int f){ top[u]=f; dfn[u]=++tick; if(son[u]==0){ outdfn[u]=++tick; return; } dfs2(son[u],f); for(auto v:g[u]){ if(v!=son[u] \u0026\u0026 v!=fa[u])dfs2(v,v); } outdfn[u]=++tick; } const int FTN=5*(MAXN*2+10); int dat[FTN]; int lc[FTN],rc[FTN]; int idx=0; int root=0; void build(int \u0026n,int l,int r){ if(!n)n=++idx; if(l\u003e=r){ dat[n]=2; return; } int mid=(l+r)/2; build(lc[n],l,mid); build(rc[n],mid+1,r); } void pushdown(int n){ if(dat[n]==0)return; dat[lc[n]]=dat[n]; dat[rc[n]]=dat[n]; dat[n]=0; } void fill_water(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ dat[n]=1; return; } pushdown(n); int mid=(L+R)/2; if(l\u003c=mid)fill_water(l,r,L,mid,lc[n]); if(mid\u003cr)fill_water(l,r,mid+1,R,rc[n]); } void f**k_water(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ dat[n]=2; return; } pushdown(n); int mid=(L+R)/2; if(l\u003c=mid)f**k_water(l,r,L,mid,lc[n]); if(mid\u003cr)f**k_water(l,r,mid+1,R,rc[n]); } void F**K_WATER(int u){ while(u!=0){ //cout\u003c\u003c\"clear \"\u003c\u003cdfn[u]\u003c\u003cendl; f**k_water(dfn[top[u]],dfn[u],1,tick,root); u=fa[top[u]]; } } int query(int pos,int L,int R,int n){ //1æœ‰æ°´ if(L==pos \u0026\u0026 R==pos)return dat[n]==1; pushdown(n); int mid=(L+R)/2; if(pos\u003c=mid)return query(pos,L,mid,lc[n]); else return query(pos,mid+1,R,rc[n]); } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003evlen; elen=vlen-1; for(int i=1;i\u003c=elen;i++){ int u,v;cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs1(1,0); dfs2(1,1); build(root,1,tick); /* for(int i=1;i\u003c=vlen;i++){ cout\u003c\u003cdfn[i]\u003c\u003c\" \"; } cout\u003c\u003cendl; for(int i=1;i\u003c=vlen;i++){ cout\u003c\u003coutdfn[i]\u003c\u003c\" \"; } cout\u003c\u003cendl; */ int qlen;cin\u003e\u003eqlen; while(qlen--){ int opt,u;cin\u003e\u003eopt\u003e\u003eu; if(opt==1){ fill_water(dfn[u],outdfn[u]-1,1,tick,root); //cout\u003c\u003c\"add \"\u003c\u003cdfn[u]\u003c\u003c\"-\"\u003c\u003coutdfn[u]\u003c\u003cendl; }else if(opt==2){ F**K_WATER(u); }else{ cout\u003c\u003cquery(dfn[u],1,tick,root)\u003c\u003c\"\\n\"; } } return 0; } ","date":"2020-02-18","objectID":"/2020/02/heavy-light-decomposition/:3:0","tags":null,"title":"æ ‘é“¾å‰–åˆ†","uri":"/2020/02/heavy-light-decomposition/"},{"categories":["code"],"content":"Ivan plays a computer game that contains some microtransactions to make characters look cooler. Since Ivan wants his character to be really cool, he wants to use some of these microtransactions â€” and he wonâ€™t start playing until he gets all of them. Each day (during the morning) Ivan earns exactly one burle. There are n types of microtransactions in the game. Each microtransaction costs 2 burles usually and 1 burle if it is on sale. Ivan has to order exactly ki microtransactions of the i-th type (he orders microtransactions during the evening). Ivan can order any (possibly zero) number of microtransactions of any types during any day (of course, if he has enough money to do it). If the microtransaction he wants to order is on sale then he can buy it for 1 burle and otherwise he can buy it for 2 burles. There are also m special offers in the game shop. The j-th offer (dj,tj) means that microtransactions of the tj-th type are on sale during the dj-th day. Ivan wants to order all microtransactions as soon as possible. Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing. ","date":"2020-01-21","objectID":"/2020/01/cf-1165f2microtransactions/:0:0","tags":null,"title":"[CF 1165F2]Microtransactions","uri":"/2020/01/cf-1165f2microtransactions/"},{"categories":["code"],"content":"åˆ†æ é¦–å…ˆï¼Œä¸å…³æ³¨åˆ°åº•ä¹°äº†å“ªä¸ªå•†å“ï¼Œå› ä¸ºæ¯ç§å•†å“çš„ä»·æ ¼éƒ½ä¸€æ ·ï¼Œè®°$i$ç§å•†å“éœ€è¦$k_i$ï¼Œå…¨ä½“å•†å“æ€»æ•°$K$ã€‚ é¦–å…ˆï¼Œå¦‚æœæ²¡æœ‰ä»»ä½•ä¼˜æƒ ï¼Œéœ€è¦$2K$å¤©ã€‚åœ¨æœ‰ä¼˜æƒ æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°½å¯èƒ½åœ¨ä¼˜æƒ å½“å¤©ä¹°é½éœ€è¦çš„å•†å“ã€‚æˆ‘ä»¬æ”¾å¼€çš„å¤©æ•°è¶Šå¤šï¼Œé’±è¶Šå¤šï¼ŒåŒæ—¶ä¹Ÿè¶Šæœ‰å¯èƒ½é‡åˆ°ä¼˜æƒ ï¼ˆèŠ±çš„é’±å‡å°‘ï¼‰ã€‚ä»¥æ­¤ï¼Œé¢˜ç›®å…·æœ‰å•è°ƒæ€§ã€‚ äºŒåˆ†æ—¶é—´$t$ã€‚å¾—å‡ºå“ªç§å•†å“æœ‰ä¼˜æƒ ï¼Œå¹¶ä»$2K$å…ƒå†…æŠµæ¶ˆä¼˜æƒ éƒ¨åˆ†ã€‚å°½é‡å°†ä¹°å•†å“çš„å†³ç­–æ‹–åˆ°è¯¥å•†å“æœ€åä¸€æ¬¡ä¼˜æƒ è¿›è¡Œï¼Œè‹¥å•†å“æœ‰ä¼˜æƒ ï¼Œä¹°æ¯”ä¸ä¹°å¥½ï¼Œæˆ‘ä»¬è¦å°½å¯èƒ½å°†æ‰‹ä¸­ç§¯æ”’çš„é’±æ‰”å‡ºå»ã€‚å”¯ä¸€çš„é—®é¢˜æ˜¯è¶Šé åçš„å•†å“æˆ‘ä»¬èƒ½å¤Ÿç”¨ä¹‹åçš„é’±å»ä¹°ï¼Œä½†æ˜¯æ›´é å‰çš„ä¼˜æƒ å¯èƒ½ä¼šå› ä¸ºä¹°äº†å‰è¿°é‚£ç§å•†å“è€Œæ²¡æœ‰æ›´å¤šé’±è´­ä¹°ã€‚å› æ­¤å°†æ¯ç§å•†å“è´­ä¹°æ—¶æœºæ‹–å¾—è¶Šæ™šè¶Šå¥½ï¼Œè¿™æ ·æˆ‘ä»¬é¡¶å¤šä¼šé‡åˆ°æ²¡é’±ä¹°ä¸‹ä¸€ä¸ªä¼˜æƒ çš„é—®é¢˜ï¼Œä¸è¿‡äºŒè€…è´¡çŒ®ä¸€æ ·ï¼Œè¿™å¯¹æœ€ç»ˆç­”æ¡ˆæ²¡æœ‰å½±å“ã€‚å› ä¸ºè¿™ç©æ„waäº†ä¸€å‘.. ","date":"2020-01-21","objectID":"/2020/01/cf-1165f2microtransactions/:1:0","tags":null,"title":"[CF 1165F2]Microtransactions","uri":"/2020/01/cf-1165f2microtransactions/"},{"categories":["code"],"content":"ä»£ç  #include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003e#include \u003cstack\u003e#include \u003cmap\u003e#include \u003cset\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXN=400010; // å•†å“æ•°ç›® æ‰“æŠ˜æ¬¡æ•° int n,m; ll wanted[MAXN]; ll bwanted[MAXN]; vector\u003cint\u003e offs[MAXN]; int goodoff[MAXN];//ç¬¬iç§å•†å“æœ€åçš„æ‰“æŠ˜æ—¶æœº int maxday=0; ll summ=0; bool check(ll day){ memset(goodoff,0,sizeof(goodoff)); memcpy(wanted,bwanted,sizeof(wanted)); for(int i=1;i\u003c=min((ll)maxday,day);i++){ for(auto t:offs[i]){ goodoff[t]=i; } } /* cout\u003c\u003c\"end at \"\u003c\u003cday\u003c\u003cendl; for(int i=1;i\u003c=n;i++){ cout\u003c\u003cgoodoff[i]\u003c\u003c\" \"; } cout\u003c\u003cendl; */ ll cost=summ*2; ll free=0; for(int i=1;i\u003c=min((ll)maxday,day);i++){ free++; for(auto t:offs[i]){ if(goodoff[t]!=i)continue; if(free\u003ewanted[t]){ free-=wanted[t]; cost-=wanted[t]; wanted[t]=0; }else{ wanted[t]-=free; cost-=free; free=0; } } } return cost\u003c=day; } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ewanted[i]; summ+=wanted[i]; } memcpy(bwanted,wanted,sizeof(bwanted)); for(int i=1;i\u003c=m;i++){ int d,t;cin\u003e\u003ed\u003e\u003et; maxday=max(maxday,d); offs[d].push_back(t); } ll l=0,r=5e5; while(r-l\u003e1){ ll mid=(l+r)/2; if(check(mid)){ r=mid; }else l=mid; } cout\u003c\u003cr\u003c\u003cendl; return 0; } ","date":"2020-01-21","objectID":"/2020/01/cf-1165f2microtransactions/:2:0","tags":null,"title":"[CF 1165F2]Microtransactions","uri":"/2020/01/cf-1165f2microtransactions/"},{"categories":["code"],"content":"You have a bag which contains n cards. There is a number written on each card; the number on i-th card is ai. You are playing the following game. During each turn, you choose and remove a random card from the bag (all cards that are still left inside the bag are chosen equiprobably). Nothing else happens during the first turn â€” but during the next turns, after removing a card (let the number on it be x), you compare it with the card that was removed during the previous turn (let the number on it be y). Possible outcomes are: if x \u003c y, the game ends and you lose; if x = y, the game ends and you win; if x \u003e y, the game continues. If there are no cards left in the bag, you lose. Cards are not returned into the bag after you remove them. You have to calculate the probability of winning in this game. It can be shown that it is in the form of PQ where P and Q are non-negative integers and Qâ‰ 0, Pâ‰¤Q. Output the value of Pâ‹…Qâˆ’1 (mod 998244353). ","date":"2020-01-21","objectID":"/2020/01/cf-1156fcard-bag/:0:0","tags":null,"title":"[CF 1156F]Card Bag","uri":"/2020/01/cf-1156fcard-bag/"},{"categories":["code"],"content":"åˆ†æ æ•°æ®èŒƒå›´è¶³å¤Ÿé€šè¿‡ç´¯ç§¯æ¯è½®æ¸¸æˆä¸­çš„èƒœç‡æ¥ç®—ã€‚å…ˆæƒ³åŠæ³•ç®—æ¸¸æˆè¿è¡Œåˆ°ç¬¬$i$è½®çš„æ¦‚ç‡ã€‚ å®šä¹‰$f(i,j)$ä¸ºç¬¬iæ¬¡æŠ½å¡æŠ½å‡º$j$ä¸”æ¸¸æˆå°†ç»§ç»­çš„æ¦‚ç‡ï¼Œå‘ç° $f(i,j)$åªèƒ½ä»$f(i,0 \\to j-1)$è½¬ç§»ã€‚å¦åˆ™æ¸¸æˆç»“æŸã€‚ ç”±ä¸Šæ¡ï¼Œç¬¬$i$æ¬¡æŠ½å‡º$j$çš„æ¦‚ç‡ä¹Ÿå¯çŸ¥ï¼Œå› ä¸ºå‰é¢æŠ½å¡æ²¡æœ‰æŠ½è¿‡$j$ã€‚ è®°ç‰Œæ€»æ•°$n$ï¼Œç‰Œé¢ä¸º$i$çš„ç‰Œæœ‰$c(i)$å¼ ï¼Œæœ‰è½¬ç§» $$ \\begin{aligned} f(i,j)=\\frac{c(j)}{n-i+1}\\sum_{0 \\leq k \\leq j-1}f(i-1,k) \\end{aligned} $$ æœ‰ç­”æ¡ˆ $$ \\text{ans}=\\sum_{1 \\leq i,j \\leq n} f(i,j)\\frac{c(j)-1}{n-i+1} $$ ","date":"2020-01-21","objectID":"/2020/01/cf-1156fcard-bag/:1:0","tags":null,"title":"[CF 1156F]Card Bag","uri":"/2020/01/cf-1156fcard-bag/"},{"categories":["code"],"content":"ä»£ç  #include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003e#include \u003cstack\u003e#include \u003cmap\u003e#include \u003cset\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXN=5010; const ll MOD=998244353; // æ¸¸æˆè¿›è¡Œåˆ°ç¬¬iè½®,æŠ½å‡ºjä¸”æ²¡æœ‰ç»“æŸçš„æ¦‚ç‡ ll f[MAXN][MAXN]; int card[MAXN]; ll inv[MAXN]; ll qpow(ll a,ll b,ll p){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%p){ if(b\u00261)res=res*a%p; } return res; } inline ll get_inv(ll a,ll p){ return qpow(a,p-2,p); } void init_inv(int n){ for(int i=1;i\u003c=n;i++){ inv[i]=get_inv(i,MOD); } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n;cin\u003e\u003en; init_inv(n); for(int i=1;i\u003c=n;i++){ int x;cin\u003e\u003ex; card[x]++; } f[0][0]=1; ll ans=0; for(int i=1;i\u003c=n;i++){ ll cnt=0; for(int j=0;j\u003ci;j++)cnt=(cnt+f[i-1][j])%MOD; for(int j=i;j\u003c=n;j++){ f[i][j]=((cnt*card[j])%MOD*inv[n-i+1])%MOD; //cout\u003c\u003c\"f(\"\u003c\u003ci\u003c\u003c\",\"\u003c\u003cj\u003c\u003c\")\"\u003c\u003cf[i][j]\u003c\u003cendl; cnt=(cnt+f[i-1][j])%MOD; } for(int j=1;j\u003c=n;j++){ ans=ans+((f[i-1][j]*(card[j]-1))%MOD*inv[n-i+1])%MOD; ans%=MOD; } } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-01-21","objectID":"/2020/01/cf-1156fcard-bag/:2:0","tags":null,"title":"[CF 1156F]Card Bag","uri":"/2020/01/cf-1156fcard-bag/"},{"categories":["code"],"content":"You are given a tree (an undirected connected acyclic graph) consisting of n vertices and nâˆ’1 edges. A number is written on each edge, each number is either 0 (letâ€™s call such edges 0-edges) or 1 (those are 1-edges). Letâ€™s call an ordered pair of vertices (x,y) (xâ‰ y) valid if, while traversing the simple path from x to y, we never go through a 0-edge after going through a 1-edge. Your task is to calculate the number of valid pairs in the tree. ","date":"2020-01-21","objectID":"/2020/01/cf-1156d-0-1-tree/:0:0","tags":null,"title":"[CF 1156D] 0-1 Tree","uri":"/2020/01/cf-1156d-0-1-tree/"},{"categories":["code"],"content":"åˆ†æ å½“ç»è¿‡ä¸€æ¡1ï¼Œå°±ä¸èƒ½å†ç»è¿‡0ã€‚æ‰€ä»¥è·¯å¾„åªä¼šæœ‰ï¼ˆç§°1ä¸ºé»‘ï¼Œ0ä¸ºç™½ï¼‰ å…¨0 å…¨1 ä»æŸå¤„åˆ’åˆ†åä¸€åŠä¸º1ä¸€åŠä¸º0 ç»´æŠ¤ä»ç‚¹uåˆ°å…¶å­æ ‘ä»»æ„èŠ‚ç‚¹çš„ç™½è‰²è·¯å¾„ï¼Œé»‘è‰²è·¯å¾„æ€»æ•°ã€‚é‚£ä¹ˆç­”æ¡ˆå°±å¯ä»¥ç»Ÿè®¡äº†ã€‚ ä»å­æ ‘åˆ°è‡ªå·±çš„é»‘ï¼Œç™½è·¯å¾„ å­æ ‘åˆ°å­æ ‘çš„é»‘ï¼Œç™½è·¯å¾„ ä»¥uä¸ºåˆ†ç•Œç‚¹çš„é»‘ç™½è·¯å¾„ã€‚åŒ…æ‹¬å­æ ‘åˆ°å­æ ‘ï¼Œå­æ ‘åˆ°éå­æ ‘ã€‚ å­æ ‘åˆ°éå­æ ‘çš„é»‘ç™½èŠ‚ç‚¹å·²ç»åŒ…æ‹¬åœ¨ç¬¬1ï¼Œ2éƒ¨åˆ†ã€‚ ","date":"2020-01-21","objectID":"/2020/01/cf-1156d-0-1-tree/:1:0","tags":null,"title":"[CF 1156D] 0-1 Tree","uri":"/2020/01/cf-1156d-0-1-tree/"},{"categories":["code"],"content":"ä»£ç  #include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003e#include \u003cstack\u003e#include \u003cmap\u003e#include \u003cset\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXV=200010,MAXE=400020; struct Edge{ int v,n,c; }edges[MAXE]; int head[MAXV],idx=0; void adde(int u,int v,int c){ edges[++idx].v=v; edges[idx].n=head[u]; edges[idx].c=c; head[u]=idx; } //ä»å­æ ‘åˆ°æœ¬èŠ‚ç‚¹ä¸ºç™½è‰²è·¯å¾„æˆ–é»‘è‰²è·¯å¾„çš„æ€»æ•°. //ä¸åŒ…æ‹¬è‡ªå·±. ll white[MAXV],black[MAXV]; void dfsCal(int u,int fa){ for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; dfsCal(e.v,u); white[u]+=e.c==0; black[u]+=e.c==1; if(e.c==0)white[u]+=white[e.v]; if(e.c==1)black[u]+=black[e.v]; } } ll ans=0; void solve(int u,int fa,ll w,ll b){ //å­æ ‘åˆ°æˆ‘ ans+=black[u]*2; ans+=white[u]*2; //å­æ ‘åˆ°å­æ ‘ for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; if(e.c==1){ ans+=(black[e.v]+1)*(black[u]-(black[e.v]+1)); } if(e.c==0){ ans+=(white[e.v]+1)*(white[u]-(white[e.v]+1)); } if(e.c==0){ ans+=(white[e.v]+1)*black[u]; } } //è·¨è¿‡æˆ‘ ans+=b*white[u]; ans+=w*black[u]; //cout\u003c\u003c\"arrive at \"\u003c\u003cu\u003c\u003c\" and collect \"\u003c\u003cans\u003c\u003cendl; for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; if(e.c==1){ solve(e.v,u,0,b+(black[u]-(black[e.v]+1)+1)); }else{ solve(e.v,u,w+(white[u]-(white[e.v]+1)+1),0); } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int nlen;cin\u003e\u003enlen; for(int i=1;i\u003c=nlen-1;i++){ int u,v,c; cin\u003e\u003eu\u003e\u003ev\u003e\u003ec; adde(u,v,c); adde(v,u,c); } dfsCal(1,0); for(int i=1;i\u003c=nlen;i++){ //cout\u003c\u003cwhite[i]\u003c\u003c\" \"\u003c\u003cblack[i]\u003c\u003cendl; } solve(1,0,0,0); cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-01-21","objectID":"/2020/01/cf-1156d-0-1-tree/:2:0","tags":null,"title":"[CF 1156D] 0-1 Tree","uri":"/2020/01/cf-1156d-0-1-tree/"},{"categories":["å­¦ä¹ "],"content":"æŠŠå…ˆå‰ä¿¡æ¯ä½çš„ä¸¤ç¯‡blogç»™æ‹†äº†,è¿™æ ·å¥½ç‚¹. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:0:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["å­¦ä¹ "],"content":"ä¸€ç‚¹å°æ’æ›²: å¦‚ä½•åœ¨windowsä¸Šçš„rustä½¿ç”¨gnuå·¥å…·é“¾ ä¼—æ‰€å‘¨çŸ¥windowså¯¹ç¼–ç¨‹çš„ä½“éªŒä¸å¦‚*nixå’Œosx,rustç”šè‡³åœ¨Windowsä¸Šçš„é…ç½®éƒ½éº»çƒ¦ä¸€ç‚¹.æ¯”å¦‚è¯´,ä¸ºäº†è£…ä¸ªrust,å¯èƒ½éœ€è¦å¦å¤–å‡†å¤‡vs2019.è¿™ä¸¤ä¸ªä¸œè¥¿çš„ç©ºé—´å ç”¨å·®äº†ä¸æ­¢ä¸€ç‚¹åŠç‚¹. æŠ˜è…¾äº†ä¸€å¤©.å¦‚æœèƒ½ä»”ç»†é˜…è¯»å®˜æ–¹çš„rustupæ–‡æ¡£çš„è¯,è¯´ä¸å®šå°±ä¸ç”¨è¿™ä¹ˆå¤´ç§ƒäº†. ä¸»è¦çš„é€‰é¡¹åœ¨äºé€‰å¥½hostå’Œversion.åœ¨rustupæ‰§è¡Œå®‰è£…æ—¶,ä¿®æ”¹ä¸º x86_64-pc-windows-gnu stable-gnu è¿™æ ·å®‰è£…çš„ç‰ˆæœ¬æ‰ä¼šä½¿ç”¨gnuå·¥å…·é“¾.ä½†æ˜¯å¦‚æ­¤åšçš„åæœ,æˆ‘è¿˜ä¸å¤ªæ¸…æ¥š. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:1:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["å­¦ä¹ "],"content":"ä»¥Cå¯¹æ’Rust è‡ªå·±ä¸»è¦è¿˜æ˜¯Cç³»è¯­è¨€ç”¨æˆ·,æ‰€ä»¥å®é™…å­¦ä¹ æ—¶,æ€»æ˜¯ä¼šç›¸æ¯”è¾ƒç€è¿›è¡Œ. letx:i32=10; é¦–å…ˆ,rustä¹Ÿä½¿ç”¨åˆ†å·.æ¯ä¸ªå˜é‡çš„å£°æ˜å¼€å¤´ä½¿ç”¨let,å¹¶ä¸”å°†å˜é‡ç±»å‹è·Ÿéšåç§°åé¢. éšç€æ—¶é—´å‘å±•,ç°ä»£è¯­è¨€å‡ ä¹éƒ½æŠ›å¼ƒäº†å˜é‡ç±»å‹åœ¨å·¦ä¾§çš„å£°æ˜æ–¹å¼.è¿™å¤§æ¦‚æ˜¯ä¸€ä¸ªå®è·µä¸Šçš„ç»éªŒ.å·¦ä¾§çš„ç±»å‹å£°æ˜ä¼šåœ¨å¤æ‚çŠ¶å†µä¸‹é€ æˆæå¤§çš„ç†è§£éšœç¢.æ¯”å¦‚ void (*signal(int, void (*fp)(int)))(int); é˜…è¯»æ­¤ç±»ä¸œè¥¿,æ€»ä¼šæ˜¯è®©äººå¤´ç–¼.ä½ ä¼šå‘ç°,ä¸ºäº†ç†è§£å®ƒåœ¨å¹²å˜›,è¿™ç§å£°æ˜æ–¹å¼ä½¿å¾—é˜…è¯»é¡ºåºå¿…é¡»æ˜¯é¡ºæ—¶é’ˆçš„èºæ—‹å¼,æ˜¾å¾—å¾ˆä¸è‡ªç„¶å’Œæ˜ç¡®.ä¸€æ—¦è°ƒæ•´ç±»å‹åˆ°å³ä¾§æ—¶,è¿™ä¸ªé—®é¢˜ä¼¼ä¹å°±ä¸å­˜åœ¨äº†. æ‰€ä»¥ä¸ä½†å˜é‡çš„å£°æ˜ç±»å‹ä½äºåç§°å·¦ä¾§,åŒ…æ‹¬å‡½æ•°å‚æ•°ç±»å‹å’Œè¿”å›å€¼ä¹Ÿéƒ½æ˜¯ä½äºå³ä¾§. å‰©ä¸‹çš„.. //rustä¸­çš„å˜é‡**é»˜è®¤ä¸ºä¸å¯æ›´æ”¹**.å¿…é¡»æ·»åŠ `mut`å…³é”®å­—æ‰ä½œä¸ºä¸€èˆ¬æ„ä¹‰ä¸Šçš„å˜é‡è€ƒè™‘. letmutx=9;x=6;lety=9;y=8;// this is not allowed. if\u003cexpr\u003e{//do something }elseif\u003cexpr\u003e{//do what }else{//yeah? }//ç‰¹æ®Šçš„æ­»å¾ªç¯ loop{}while\u003cexpr\u003e{}//ç”±äºRustçš„é›¶ä»£ä»·æŠ½è±¡,è¿­ä»£å™¨çš„ä½¿ç”¨æ²¡æœ‰æ€§èƒ½æŠ˜æ‰£. foriin1..9{}//è¿™ä¸ªæ˜¯å³é—­åŒºé—´ foriin1..=9{}//æ‰€æœ‰æ§åˆ¶æµéƒ½æ˜¯è¡¨è¾¾å¼,èƒ½å¤Ÿè¿”å›å€¼;æ‰€ä»¥æˆ‘ä»¬ä¹Ÿæ²¡æœ‰ä¸‰å…ƒè¿ç®—ç¬¦äº†. //å¯¹äºå¾ªç¯,å¯ä»¥ä½¿ç”¨break. letflag=ifa\u003e0{1//æœ€åä¸€è¡Œä¸å†™å¼•å·,ä»£è¡¨è¿”å›è¯¥å€¼.æ²¡è®°é”™çš„è¯åº”è¯¥æ˜¯ä»åˆ«çš„è¯­è¨€é‚£å€Ÿé‰´çš„. }else{-1};fn func(a:i32,b:i32)-\u003e i32{a+b} ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:2:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["å­¦ä¹ "],"content":"åŒ…ç®¡ç† rustå‘å±•å¤ªå¿«äº†,å„ç§æ–‡ç« å„è¯´å„è¯.è¿™é‡Œä¸»è¦æ˜¯ä¸€ä¸ªcrate(ä¸€ä¸ªåŒ…)å†…çš„ç»“æ„. rustä½¿ç”¨modæ¥æ˜ç¡®çš„æ ‡æ³¨ä¸€ä¸ªæ¨¡å—.å…³é”®å­—é»˜è®¤ä¸ºç§æœ‰,ä½¿ç”¨pubæ¥æ ‡æ³¨ä¸€ä¸ªå¯¹å¤–å…¬å¼€çš„å…³é”®å­—.åœ¨2018æ ‡å‡†,ç›®å½•ä¹Ÿä¼šä½œä¸ºä¸€ä¸ªæ¨¡å—è·¯å¾„,æ–‡ä»¶åä½œä¸ºæ¨¡å—å,æ–‡ä»¶å†…å…³é”®å­—åŒæ ·é»˜è®¤ç§æœ‰.åœ¨è¿™ç§æƒ…å†µ,ä½¿ç”¨modå…³é”®å­—æ¥æ˜¾å¼çš„å¼•å…¥æŸä¸ªæ¨¡å—.å¯¹äºç¬¬ä¸‰æ–¹æ¨¡å—,2018ä¸å†éœ€è¦æ˜¾å¼æ ‡æ³¨å¼•å…¥extern crate.(ä½†æ˜¯ä»ç„¶éœ€è¦use) åœ¨ä¸€ä¸ªåŒ…é‡Œ,å…è®¸æœ‰å¤šä¸ªcrate.å¦‚æœç¡¬è¦è¯´,ç±»ä¼¼äºvs studioé‡Œçš„è§£å†³æ–¹æ¡ˆå’Œé¡¹ç›®ä¹‹é—´çš„å…³ç³».ä½†æ˜¯,rustè¿˜æœ‰ä¸€äº›ä¸é‚£ä¹ˆæ˜¾ç„¶çš„é™åˆ¶ æœ€å¤šæœ‰ä¸€ä¸ªlib crate å¯ä»¥æœ‰å¤šä¸ªbinary crate ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:3:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["å­¦ä¹ "],"content":"ä¸€ä¸ªæœ€å°(?)çš„HTTPæœåŠ¡å™¨ å®ç°è¿™ä¸ªæœåŠ¡å™¨çš„è¿‡ç¨‹ä¸­,ä¼šé­é‡åˆ°å¾ˆå¤šRustå†…çš„é—®é¢˜.å‡è®¾æˆ‘ä»¬å·²ç»å¯¹æ¯”C++æŒæ¡å…¶åŸºæœ¬è¯­æ³•äº†. usestd::thread;usestd::sync::mpsc;usestd::sync::Arc;usestd::sync::Mutex;pubstruct ThreadPool{workers:Vec\u003cWorker\u003e,sender: mpsc::Sender\u003cMessage\u003e,}type Job=Box\u003cdynFnOnce()+Send+'static\u003e;//? enum Message{NewJob(Job),Terminate,}implThreadPool{/// Create thread pool /// /// The number of threads in pool /// /// # Paincs /// /// `new` will panic when size is not great than 0. pubfn new(size:usize)-\u003eThreadPool{assert!(size\u003e0);let(sender,receiver)=mpsc::channel();letreceiver=Arc::new(Mutex::new(receiver));letmutworkers=Vec::with_capacity(size);foridin0..size{workers.push(Worker::new(id,receiver.clone()));}ThreadPool{workers,sender}}pubfn execute\u003cF\u003e(\u0026self,f:F)whereF:FnOnce()+Send+'static{letjob=Box::new(f);self.sender.send(Message::NewJob(job)).unwrap();}}implDropforThreadPool{fn drop(\u0026mutself){for_in\u0026mutself.workers{self.sender.send(Message::Terminate).unwrap();}forworkerin\u0026mutself.workers{println!(\"shutting down worker {}\",worker.id);ifletSome(thread)=worker.thread.take(){thread.join().unwrap();}}}}struct Worker{id: usize,thread: Option\u003cthread::JoinHandle\u003c()\u003e\u003e,}implWorker{fn new(id:usize,receiver: Arc\u003cMutex\u003cmpsc::Receiver\u003cMessage\u003e\u003e\u003e)-\u003eWorker{letthread=thread::spawn(move||{loop{letmessage=receiver.lock().unwrap().recv().unwrap();matchmessage{Message::NewJob(job)=\u003e{println!(\"Worker {} got job.\",id);job();},Message::Terminate=\u003e{println!(\"Worker {} is terminating.\",id);break;}}}});Worker{id,thread: Some(thread),}}} usestd::io::prelude::*;usestd::net::{TcpListener,TcpStream};usestd::fs;usestd::time::Duration;usestd::thread;useautoman::ThreadPool;fn main(){letlistener=TcpListener::bind(\"127.0.0.1:7878\").unwrap();letpool=ThreadPool::new(1);forstreaminlistener.incoming(){letstream=stream.unwrap();pool.execute(||{handler(stream);});}}fn handler(mutstream: TcpStream){letmutbuffer=[0;512];stream.read(\u0026mutbuffer).unwrap();letget=b\"GET / HTTP/1.1\\r\\n\";letsleep=b\"GET /sleep HTTP/1.1\\r\\n\";let(status_line,filename)=ifbuffer.starts_with(get){(\"HTTP/1.1 200 OK\\r\\n\\r\\n\",\"hello.html\")}elseifbuffer.starts_with(sleep){thread::sleep(Duration::from_secs(5));(\"HTTP/1.1 200 OK\\r\\n\\r\\n\",\"hello.html\")}else{(\"HTTP/1.1 404 NOT FOUND\\r\\n\\r\\n\",\"404.html\")};letcontents=fs::read_to_string(filename).unwrap();letresponse=format!(\"{}{}\",status_line,contents);stream.write(response.as_bytes()).unwrap();stream.flush().unwrap();} ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:4:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["å­¦ä¹ "],"content":"FnOnce åœ¨C++é‡Œ,æˆ‘ä»¬èƒ½å¤Ÿç”¨Lambdaè¡¨è¾¾å¼åˆ›å»ºé—­åŒ…,å½“éœ€è¦ä¿å­˜ä¸€ä¸ªé—­åŒ…æ—¶,æ ‡å‡†åº“æä¾›äº†å«functionçš„ä¸œè¥¿.åœ¨Rusté‡Œ,æˆ‘ä»¬ä¹Ÿæœ‰é—­åŒ…,è€Œæè¿°ä¸€ä¸ªé—­åŒ…ç±»å‹çš„ç©æ„,å°±æ˜¯Fn***. type Job=Box\u003cdynFnOnce()+Send+\u0026#039;static\u003e; å¾—ç›Šäºrustçš„å†…å­˜æ¨¡å‹,è¯ç”Ÿå‡ºè¿™ä¸ªå¥‡è‘©ç©æ„.åæ­£è¿˜æ˜¯å’Œå˜é‡çš„æ‰€æœ‰æƒæœ‰å…³ç³».FnOnceçš„é—­åŒ…ä¼šè·å–å…¶æ•è·å˜é‡çš„æ‰€æœ‰æƒ.å¦å¤–FnMutçš„é—­åŒ…è·å¾—å…¶æ•è·å˜é‡çš„å¯å˜å€Ÿç”¨,Fnè·å¾—ä¸å¯å˜å€Ÿç”¨.å‹‰å¼ºå¯ä»¥å¯¹æ¯”C++é‡Œçš„[],[\u0026]. è‡³äºåˆ°åº•ä»€ä¹ˆé—­åŒ…ä¼šå®ç°å“ªä¸€ä¸ª,æ˜¯ç”±ç¼–è¯‘å™¨æ ¹æ®å®é™…æƒ…å†µåˆ¤æ–­çš„.æƒ³è¦å¼ºåˆ¶å°†å˜é‡æŒªè¿›é—­åŒ…æ—¶,å¯ä»¥å‰ç¼€move,å°±åƒWorkerçš„runé‡Œçš„ä»£ç ä¸€æ ·.å› ä¸ºå½“runæ‰§è¡Œå®Œ,receiverå°†ä¼šè¢«ä¸¢å¼ƒ,ä»è€Œå½±å“åˆ°é—­åŒ…é‡Œçš„å¼•ç”¨. å…¶ä»–çš„å‡ ä¸ª+å·å’ŒSend,'staticä»€ä¹ˆçš„.+å°±æ˜¯+,è¦æ±‚è¯¥ç±»å‹å¿…é¡»åŒæ—¶å®ç°è¿™ä¸‰ç§trait.Sendæ˜¯ä¸ªtrait(Types that can be transferred across thread boundaries).'staticç­‰æ—¶é—´å‘¨æœŸå®é™…ä¸Šä¹Ÿæ˜¯trait. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:5:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["å­¦ä¹ "],"content":"Boxå’Œdyn type Job=Box\u003cdynFnOnce()+Send+\u0026#039;static\u003e; â€¦â€¦æ²¡å®Œ..å‰é¢é‚£ä¸ªdynç©æ„ä¹Ÿæ˜¯æŒºå¥‡æ€ª,éœ€è¦å’Œimplå…³é”®å­—å¯¹æ¯”ç†è§£. Rustçš„ä¸€å¤§ç‰¹ç‚¹å°±æ˜¯é›¶ä»£ä»·æŠ½è±¡.ä¾‹å¦‚å¯¹äºæ³›å‹,ä¸€ç§å®ç°0æŠ½è±¡çš„æ–¹æ³•å°±æ˜¯åœ¨ç¼–è¯‘é˜¶æ®µå•ä¾‹åŒ–.C++ä¹Ÿæ˜¯å¦‚æ­¤å¤„ç†. ä¸è¿‡æœ‰ä¸€ç§æƒ…å†µç›®æµ‹C++æ— æ³•å®ç°é›¶æŠ½è±¡:åœ¨C++ä¸­,å¦‚æœå­˜åœ¨çˆ¶ç±»Aæœ‰è™šæ–¹æ³•f,è€Œå­ç±»Bé‡å†™äº†f,åˆæœ‰ä¸€ä¸ªå‡½æ•°g(A a)ä¼šè°ƒç”¨f.å½“æŠŠBä½œä¸ºå‚æ•°ä¼ ç»™gæ—¶,C++é€šè¿‡ä¸€ç§å«è™šå‡½æ•°è¡¨çš„æ–¹å¼å®ç°è°ƒç”¨Bå†™çš„f.è¿™ç§è¡Œä¸ºæ˜¯å‘ç”Ÿåœ¨è¿è¡Œæ—¶çš„. å¯¹äºRustæ¥è®²,è™½ç„¶æ²¡æœ‰ç±»ä¸ç»§æ‰¿,è¿™ç§æ“ä½œå®é™…ç­‰ä»·äºtrait.ä¸Šé¢çš„æƒ…å†µå¯¹ç­‰äºå­˜åœ¨trait A,å®ƒå®šä¹‰äº†ä¸€ä¸ªf,Bå®ç°äº†A,gåŒä¸Š.Rustèƒ½å¤Ÿåœ¨ç¼–è¯‘é˜¶æ®µå°±ç¡®å®šä¼ ç»™gçš„æ˜¯è°,å¹¶ä¸”ä¼˜åŒ–æ‰å®ƒ.ä¸è¿‡è¿™ç§ä¼˜åŒ–ä¹Ÿæ˜¯æœ‰é™åº¦çš„.å¦‚æœæŠŠä¸€å †å®ç°Açš„ç»“æ„çš„æŒ‡é’ˆå­˜åˆ°æ•°ç»„æˆ–è€…å…¶ä»–å†…å­˜ç»“æ„é‡Œ,é‚£Rustä¹Ÿæ˜¯æ— èƒ½ä¸ºåŠ›çš„,åªèƒ½åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ†å‘. å†å›æ¥çœ‹implå’Œdyn.å®ƒä»¬åˆ†åˆ«å¯¹åº”äº†èƒ½å¤Ÿä¼˜åŒ–(é™æ€åˆ†å‘)å’ŒåŠ¨æ€åˆ†å‘çš„æƒ…æ™¯. å¦å¤–,é‡‡ç”¨åŠ¨æ€åˆ†å‘çš„ç»“æ„ä¹Ÿä¸èƒ½åœ¨ç¼–è¯‘æ—¶ç¡®å®šå¤§å°,æ‰€ä»¥å¿…é¡»å¤–åŒ…Box.è¿™ä¸€ç‚¹è¿˜æ˜¯æœ‰ç‚¹ç‰¹æ®Šçš„,C++ä¼¼ä¹å¹¶ä¸ä¼šæŠ±æ€¨è¿™ä¸ªé—®é¢˜. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:6:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["å­¦ä¹ "],"content":"Arcå’ŒMutex fn new(id:usize,receiver: Arc\u003cMutex\u003cmpsc::Receiver\u003cMessage\u003e\u003e\u003e)-\u003eWorker; è¯´çœŸçš„,çœ‹åˆ°Workerçš„è¿™ä¸ªå‡½æ•°ç­¾å,å½“æ—¶å°±åƒå.Rustè¿™ç©æ„,åŠ¨ä¸åŠ¨å°±ä¼šåµŒå¥—ä¸Šå¥½å‡ å±‚çš„\u003c\u003e. é¦–å…ˆå…³äºArcâ€¦å…ˆRc.ä¸€èˆ¬æƒ…å†µä¸‹,ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒæ˜¯å¯ä»¥åœ¨ç¼–è¯‘é˜¶æ®µå°±ç¡®å®šä¸‹æ¥çš„.ä½†æ˜¯æ€»ä¼šæœ‰ä¸å¦‚æ„çš„æ—¶å€™,å½“æœ‰å¤šä¸ªç»“æ„åŒæ—¶äº«æœ‰æŸä¸ªå˜é‡çš„æ‰€æœ‰æƒ(ä¾‹å¦‚ä¸€æ£µæ ‘),å°±ä¸å¤ªå¥½ç¡®å®šå…¶å®é™…çš„é”€æ¯æ—¶æœº,è€Œä¸”Rustä¹Ÿä¸ä¼šç»™ä½ æœºä¼šå…±äº«æ‰€æœ‰æƒ.Rcæ˜¯ä¸€ä¸ªå¼•ç”¨è®¡æ•°æŒ‡é’ˆ,å˜é‡æ‰€æœ‰æƒç”±å®ƒä¿ç®¡,è€Œå®ƒèƒ½å¤Ÿæä¾›å¤šä»½åªè¯»å€Ÿç”¨. ç„¶è€ŒRcçº¿ç¨‹ä¸å®‰å…¨,Arcçº¿ç¨‹å®‰å…¨.ä¸è¿‡Arcæ€§èƒ½å¼±äºRc. å…¶æ¬¡æ˜¯Mutexâ€¦å°±æ˜¯ä¸ªé”â€¦ è‡³äºä¸ºå•¥ç”¨é”,å…ˆçœ‹mpsc,Multi-producer, single-consumer FIFO queue communication primitives. ä¸€å¤´é›¾æ°´çš„ç¼©å†™â€¦ç®€è€Œè¨€ä¹‹,è¿™ä¸ªä¸œè¥¿çš„è®¾å®šç±»ä¼¼äºgoé‡Œchannel,åŒæ—¶æ˜¯å¤šç”Ÿäº§è€…,å•æ¶ˆè´¹è€…æ¨¡å¼.æœ¬èº«ä½¿ç”¨æ²¡ä»€ä¹ˆç»•çš„åœ°æ–¹.ç»•çš„åœ°æ–¹åœ¨äºå¤šçº¿ç¨‹å…±äº«å’Œå•æ¶ˆè´¹è€…æ¨¡å¼çš„å†²çª,æ‰€ä»¥å¼•å…¥äº†é”,ä¿è¯åŒæ—¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿæ¶ˆè´¹æ¶ˆæ¯. é¡ºä¾¿åæ§½ä¸€å¥è¿™ä»£ç å†™çš„â€¦ letmessage=receiver.lock().unwrap().recv().unwrap(); å…¶å®æ¶‰åŠåˆ°Rcæ—¶,è¿˜æœ‰å¦å¤–ä¸€ä¸ªå¤–éƒ¨å¯å˜,å†…éƒ¨å¯å˜çš„éº»çƒ¦äº‹.è¿™é‡Œæ²¡æœ‰æåˆ°. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:7:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["å­¦ä¹ "],"content":"è¿˜æœ‰ unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrapâ€¦ å½“ç„¶å®ƒä»¬æœ¬æ¥ä¼šè¢«æ›¿ä»£æˆæ›´å¤æ‚çš„é”™è¯¯å¤„ç†. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:8:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["å­¦ä¹ "],"content":"å°ç»“ ç”¨Rustå†™çš„ç¨‹åº,å’Œè‡ªå·±è„‘è¢‹æ–—æ™ºæ–—å‹‡å‡ å›åˆ,å†å’Œç¼–è¯‘å™¨æ–—æ™ºæ–—å‹‡(å•æ–¹é¢æŒ¨æ)å‡ ç™¾å›åˆ,æœ€åæ˜¯çœŸçš„éš¾ä»¥å‡ºç°bug,æ¯•ç«Ÿä¸€åˆ‡éƒ½è¢«ç®¡çš„æ­»æ­»çš„.æˆ‘è¿˜çœ‹åˆ°Rusté‡Œä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„ç©æ„å«é”™è¯¯é©±åŠ¨,è¯´æ˜¯å…ˆæŠŠä»£ç å¤§æ¦‚æ¨¡æ ·çç³Šä¸Š,ç„¶åè®©ç¼–è¯‘å™¨checkä¸€é,å†ä¸€æ­¥æ­¥æ”¹æ‰ç¼–è¯‘å™¨çš„æŠ¥é”™é¡ºä¾¿å†™ä»£ç ,æœ€åå°±èƒ½åœ¨ç¼–è¯‘å™¨çš„åæ§½ä¸‹å®Œç¾å®ç°ç¨‹åº,å†åŠ ç‚¹æµ‹è¯•å°±é½å…¨äº†â€¦ è™½ç„¶æ•´ä¸ªè¯­æ³•çœ‹èµ·æ¥å¤æ‚å•°å—¦,ä¸è¿‡æ— æ³•å¦è®¤è¿™äº›è¯­å¥å¯¹äºå·¥ç¨‹æ¥è®²å®é™…ä¸Šéƒ½æ˜¯å¿…è¦çš„.æ‰€ä»¥è¿™ç©æ„çš„æ°”è´¨å†³å®šå®ƒä¸å¤ªé€‚åˆä½œä¸ºæ‰“æ¯”èµ›æ—¶ç”¨çš„è¯­è¨€.ç¿»äº†ç¿»CFå¥½å‡ åœºæ¯”èµ›,é›¶æ˜Ÿæœ‰å‡ ä¸ªRustçš„ä»£ç ä¹Ÿéƒ½æ²¡æœ‰æ¶‰åŠä»»ä½•æ•°æ®ç»“æ„,æœ¬æ¥è¿˜æƒ³ç»ä»°ä¸€ä¸‹ä»–ä»¬ä¼šæ€ä¹ˆå¤„ç†ç”Ÿå‘½å‘¨æœŸä¸€ç±»çš„é—®é¢˜. å¦‚æœæœ‰æœºä¼š,æ‹¿Rustå†™è¯¾è®¾åº”è¯¥å¯ä»¥ç©ä¸€ç©(å¤§æ¦‚ä¼šè¢«å¼ºè¡Œç”¨Cç³»è¯­è¨€).è‡³äºåŸæœ¬æƒ³æ‹¿Rustå†™ä¸ªæœ¬åœ°è¯„æµ‹å™¨,è¿˜æ˜¯ç®—äº†,æœ‰ç©ºå†è¯´å§. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:9:0","tags":null,"title":"ä¸Rustç©è€","uri":"/2020/01/have-fun-with-rust/"},{"categories":["code"],"content":"C æ— è„‘DP.è®¾çŠ¶æ€$f(i,j,0/1)$è¡¨ç¤ºå·²ç»è®¾ç½®äº†$i$ä½,ç”¨äº†$j$ä¸ªå¶æ•°,ç¬¬$i$ä½æ˜¯å¶æ•°/å¥‡æ•°.ç„¶å $$ \\begin{aligned} f(i,j,0)\u0026=\\min\\{f(i-1,j-1,0),f(i-1,j-1,1)+1\\} \\\\ f(i,j,1)\u0026=\\min\\{f(i-1,j,0)+1,f(i-1,j,1)\\} \\end{aligned} $$ ä»¥$i=1$ä½œä¸ºå¼€å§‹,å› ä¸ºç¬¬1ä½ä¸èƒ½ç®—ä»£ä»·. // missing? ","date":"2020-01-14","objectID":"/2020/01/codeforces-round-612-div-2/:1:0","tags":null,"title":"Codeforces Round #612 (Div. 2)","uri":"/2020/01/codeforces-round-612-div-2/"},{"categories":["code"],"content":"D ä¸€ä¸ªäº‹å®æ˜¯,ä¸¤æ£µå­ğŸŒ³çš„é—´å¤§å°å…³ç³»ä¸ä¼šå½±å“å…¶å†…éƒ¨èŠ‚ç‚¹çš„æ—¢å®šå…³ç³». ä»¥æ­¤,ç›´æ¥dfs,ä»åº•å±‚å‘ä¸Šæ„é€ ç›¸å¯¹å¤§å°é¡ºåº.åˆå¹¶æ—¶å­æ ‘é—´çš„ç›¸å¯¹å¤§å°æ²¡æœ‰å½±å“,æ‰€ä»¥ç›´æ¥å‰åæ¥åœ¨ä¸€èµ·å°±å¥½,å†æŠŠå½“å‰èŠ‚ç‚¹æ’åˆ°åˆé€‚çš„ä½ç½®ä½¿å…¶æ»¡è¶³cçš„æ¡ä»¶. å…¨éƒ¨å®Œæˆåå†å¯¹èŠ‚ç‚¹ç»Ÿä¸€æ ‡å·. æœ€å¼€å§‹å…ˆæ ‡äº†å·,ç„¶åè¶Šå†™è¶Šéº»çƒ¦,ç”Ÿæ°”. #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; const int MAXN=2010; const int MAXV=2010,MAXE=4020; int tick=0; struct Edge{ int v,n; }edges[MAXE]; int head[MAXV]; int idx=0; int sz[MAXV]; void adde(int u,int v){ edges[++idx].v=v; edges[idx].n=head[u]; head[u]=idx; } int name[MAXV]; int cur[MAXV][MAXV]; int dfs0(int u,int fa){ sz[u]=1; for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; sz[u]+=dfs0(e.v,u); } if(sz[u]==1){ name[u]=tick; cur[u][tick]++; tick+=2000; } return sz[u]; } int target[MAXV]; bool ok=1; vector\u003cint\u003e dfs(int u,int fa){ vector\u003cint\u003e res; for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; vector\u003cint\u003e cur=dfs(e.v,u); for(auto it=cur.begin();it!=cur.end();it++){ res.push_back(*it); } } if(target[u]\u003eres.size())ok=0; else res.insert(res.begin()+target[u],u); return res; } int main(){ int vlen;cin\u003e\u003evlen; int root; for(int i=1;i\u003c=vlen;i++){ int fa; cin\u003e\u003efa\u003e\u003etarget[i]; if(fa!=0){ adde(fa,i); }else root=i; } vector\u003cint\u003e res=dfs(root,0); if(ok){ cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int i=0;i\u003cres.size();i++){ name[res[i]]=i; } for(int i=1;i\u003c=vlen;i++){ cout\u003c\u003cname[i]+1\u003c\u003c\" \"; } cout\u003c\u003cendl; }else{ cout\u003c\u003c\"NO\"\u003c\u003cendl; } return 0; } ","date":"2020-01-14","objectID":"/2020/01/codeforces-round-612-div-2/:2:0","tags":null,"title":"Codeforces Round #612 (Div. 2)","uri":"/2020/01/codeforces-round-612-div-2/"},{"categories":["code"],"content":"Today, as a friendship gift, Bakry gave Badawy n integers a1,a2,â€¦,an and challenged him to choose an integer X such that the value max1â‰¤iâ‰¤n(aiâŠ•X) is minimum possible, where âŠ• denotes the bitwise XOR operation. As always, Badawy is too lazy, so you decided to help him and find the minimum possible value of max1â‰¤iâ‰¤n(aiâŠ•X). ","date":"2020-01-13","objectID":"/2020/01/cf1285d-dr-evil-underscores/:0:0","tags":null,"title":"CF1285D Dr.Evil Underscores","uri":"/2020/01/cf1285d-dr-evil-underscores/"},{"categories":["code"],"content":"åˆ†æ å°†è¾“å…¥æŒ‰ç…§äºŒè¿›åˆ¶ä½ä»é«˜ä½å¼€å§‹å»ºæ ‘,å°±èƒ½çœ‹å‡ºæ¥,ä¸€æ—¦ç¡®å®šäº†é«˜ä½$i$å¡«1è¿˜æ˜¯0å,åªä¼šæœ‰ä¸€æ£µå­æ ‘å½±å“ç­”æ¡ˆ.å¦ä¸€æ£µå­æ ‘çš„æ‰€æœ‰æ•°å­—éƒ½å› ä¸º$i$ä½ä¸Šçš„å¼‚æˆ–ç»“æœä¸º0è€Œå®šå°äºå¦ä¸€ä¸ªå­æ ‘. æ ‘ä¸ç”¨çœŸçš„å»ºå‡ºæ¥,è¿™æ ·å°±å¯ä»¥åšäº†. ","date":"2020-01-13","objectID":"/2020/01/cf1285d-dr-evil-underscores/:1:0","tags":null,"title":"CF1285D Dr.Evil Underscores","uri":"/2020/01/cf1285d-dr-evil-underscores/"},{"categories":["code"],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003climits\u003e#include \u003cvector\u003eusing namespace std; using ll=long long; const ll LMAX=numeric_limits\u003cll\u003e::max(); const int MAXN=100010; //int nlen; //int num[MAXN]; vector\u003cint\u003e num; int dfs(int ptr,const vector\u003cint\u003e \u0026vec){ if(ptr\u003c0)return 0; vector\u003cint\u003e one,zero; for(auto i:vec){ if((i\u003e\u003eptr)\u00261==1)one.push_back(i); else zero.push_back(i); } /* cout\u003c\u003c\"====vec====\"\u003c\u003cendl; for(auto i:one)cout\u003c\u003ci\u003c\u003c\",\"; cout\u003c\u003cendl; for(auto i:zero)cout\u003c\u003ci\u003c\u003c\",\"; cout\u003c\u003cendl; cout\u003c\u003c\"===========\"\u003c\u003cendl; */ if(one.size()==0) return dfs(ptr-1,zero); if(zero.size()==0) return dfs(ptr-1,one); //cout\u003c\u003c\"add\"\u003c\u003c(1\u003c\u003cptr)\u003c\u003cendl; return (1\u003c\u003cptr)+min(dfs(ptr-1,zero),dfs(ptr-1,one)); } int main(){ ios::sync_with_stdio(false); int nlen;cin\u003e\u003enlen; for(int i=0;i\u003cnlen;i++){ int x;cin\u003e\u003ex; num.push_back(x); } cout\u003c\u003cdfs(30,num)\u003c\u003cendl; return 0; } ","date":"2020-01-13","objectID":"/2020/01/cf1285d-dr-evil-underscores/:2:0","tags":null,"title":"CF1285D Dr.Evil Underscores","uri":"/2020/01/cf1285d-dr-evil-underscores/"},{"categories":["é—²æ‰¯"],"content":"æˆ‘è§‰å¾—è¿™ä»¶éœ€è¦å‘ä¸€ç¯‡æ¥åº†ç¥ä¸€ä¸‹ã€‚è™½ç„¶ä»å¤´åˆ°å°¾æˆ‘å°±æ²¡æ€€ç–‘è¿‡æœ€ç»ˆä¼šæ˜¯é›ªä¹ƒï¼Œï¼ˆé›ªä¹ƒ!ï¼‰ä½†æ˜¯ç»“å±€ä¸€å‡ºï¼Œè¿˜æ˜¯éå¸¸æ¬£æ…°ã€‚ çœŸå¥½å•Š.jpgã€‚ æ˜¯æ—¶å€™å†ä¹°ä¸€å¥—æ¥æ”¶è—äº†ã€‚ ","date":"2019-11-19","objectID":"/2019/11/eight-years-for-chunwu/:0:0","tags":null,"title":"8å¹´äº†ï¼Œæ˜¥ç‰©ç»ˆäºè¿æ¥äº†ç»“å±€","uri":"/2019/11/eight-years-for-chunwu/"},{"categories":["å­¦ä¹ "],"content":"ä¾‹é¢˜-4 HDU2089 ä¸è¦62 ç»Ÿè®¡æ•°ä½ä¸­æ²¡æœ‰å‡ºç°4å’Œ62çš„æ•°å­—ä¸ªæ•°ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:1:0","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ ä¸è¦4ï¼Œå¯ä»¥åœ¨4æ—¶ç›´æ¥ä¸è½¬ç§»ã€‚å¯¹äº62ï¼Œå¯ä»¥ç»´æŠ¤ä¸€ä¸ªä¸Šä¸€ä¸ªæ•°å­—å¡«äº†å•¥ï¼Œå°±å¯ä»¥åƒ4ä¸€æ ·åˆ¤æ–­äº†ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:1:1","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; constexpr int MAXN=20; ll cache[MAXN][MAXN]; int digits[20]; ll solve(int pos,int last,int lim){ if(pos==0)return 1; if(!lim \u0026\u0026 ~cache[pos][last])return cache[pos][last]; int maxd=9; if(lim)maxd=digits[pos]; ll res=0; for(int i=0;i\u003c=maxd;i++){ if(last*10+i==62 || i==4)continue; res+=solve(pos-1,i,lim \u0026\u0026 i==maxd); } if(!lim)cache[pos][last]=res; return res; } ll SOLVE(ll x){ int ptr=0; while(x){ digits[++ptr]=x%10; x/=10; } return solve(ptr,0,true); } int main(){ ll l,r; memset(cache,-1,sizeof(cache)); while(cin\u003e\u003el\u003e\u003er){ if(l==0 \u0026\u0026 r==0)break; cout\u003c\u003cSOLVE(r)-SOLVE(l-1)\u003c\u003cendl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:1:2","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä¾‹é¢˜-3 HDU3555 ç»Ÿè®¡æ‰€æœ‰å‡ºç°è¿‡49çš„æ•°å­—çš„ä¸ªæ•°ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:2:0","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ ç»Ÿè®¡æ‰€æœ‰æ²¡å‡ºç°è¿‡49çš„æ•°å­—ï¼Œå°±å’Œä¸Šä¸€é“ä¸€æ ·äº†ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:2:1","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=50; int digits[MAXN]; ll f[MAXN][MAXN]; ll solve(int pos,int last,int lim){ if(pos==0)return 1; if(!lim \u0026\u0026 ~f[pos][last])return f[pos][last]; int maxd=9; if(lim)maxd=digits[pos]; ll res=0; for(int i=0;i\u003c=maxd;i++){ if(last*10+i==49)continue; res+=solve(pos-1,i,lim \u0026\u0026 i==maxd); } if(!lim)f[pos][last]=res; return res; } inline ll SOLVE(ll x){ int ptr=0; while(x){ digits[++ptr]=x%10; x/=10; } return solve(ptr,0,true); } int main(){ ios::sync_with_stdio(false); int kase;cin\u003e\u003ekase; memset(f,-1,sizeof(f)); while(kase--){ ll r;cin\u003e\u003er; cout\u003c\u003cr-SOLVE(r)+1\u003c\u003cendl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:2:2","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä¾‹é¢˜-2 POJ3252 The cows, as you know, have no fingers or thumbs and thus are unable to play Scissors, Paper, Stoneï¿½ (also known as ï¿½Rock, Paper, Scissorsï¿½, ï¿½Ro, Sham, Boï¿½, and a host of other names) in order to make arbitrary decisions such as who gets to be milked first. They canï¿½t even flip a coin because itï¿½s so hard to toss using hooves. They have thus resorted to â€œround numberâ€ matching. The first cow picks an integer less than two billion. The second cow does the same. If the numbers are both â€œround numbersâ€, the first cow wins, otherwise the second cow wins. A positive integer N is said to be a â€œround numberâ€ if the binary representation of N has as many or more zeroes than it has ones. For example, the integer 9, when written in binary form, is 1001. 1001 has two zeroes and two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since it has two zeroes and three ones, it is not a round number. Obviously, it takes cows a while to convert numbers to binary, so the winner takes a while to determine. Bessie wants to cheat and thinks she can do that if she knows how many â€œround numbersâ€ are in a given range. Help her by writing a program that tells how many round numbers appear in the inclusive range given by the input (1 â‰¤ Start \u003c Finish â‰¤ 2,000,000,000). ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:3:0","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ è¿™é“é¢˜ç›®å°†ä¸Šç•Œæ‹†è§£ä¸ºäºŒè¿›åˆ¶æ•°ä½ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:3:1","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; typedef long long ll; const int MAXN=50; int digits[MAXN]; ll f[MAXN][MAXN][MAXN]; int len=0; ll solve(int pos,int one,int first, int lim){ if(pos==0){ //cout\u003c\u003cfirst\u003c\u003c\" \"\u003c\u003cone\u003c\u003cendl; if(first==0)return 0; if(first-one\u003e=one)return 1; return 0; } if(!lim \u0026\u0026 ~f[pos][one][first])return f[pos][one][first]; int maxd=1; if(lim)maxd=digits[pos]; ll res=0; for(int i=0;i\u003c=maxd;i++){ res+=solve(pos-1,one+(i==1),(i==1 \u0026\u0026 !first? pos : first),lim \u0026\u0026 i==maxd); } if(!lim)f[pos][one][first]=res; return res; } inline ll SOLVE(ll x){ int ptr=0; while(x){ digits[++ptr]=x%2; x/=2; } return solve(ptr,0,0,true); } int main(){ ios::sync_with_stdio(false); memset(f,-1,sizeof(f)); ll l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003cSOLVE(r)-SOLVE(l-1)\u003c\u003cendl; return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:3:2","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä¾‹é¢˜-1 HDU3652 A wqb-number, or B-number for short, is a non-negative integer whose decimal form contains the sub- string â€œ13â€ and can be divided by 13. For example, 130 and 2613 are wqb-numbers, but 143 and 2639 are not. Your task is to calculate how many wqb-numbers from 1 to n for a given integer n. ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:4:0","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ ç»´æŠ¤é¢å¤–2ä¸ªçŠ¶æ€ï¼Œä¸€ä¸ªçŠ¶æ€è®°å½•æ¨¡13çš„ä½™æ•°ï¼Œå¦ä¸€ä¸ªè¿›è¡Œç¼–ç ï¼š1ä¸ºä¸Šä¸€ä½ä¸º1ï¼Œ3ä¸ºå·²ç»å‡ºç°è¿‡13ï¼Œ0ä¸ºå…¶ä»–ã€‚ä¹‹åå°†è½¬ç§»æ¡ä»¶æè¿°æ¸…æ¥šå°±å¯ä»¥äº†ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:4:1","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=20; int num[MAXN]; ll f[MAXN][5][20]; ll dfs(int ptr,int last,int mod,bool lim){ //cout\u003c\u003c\"arrive\"\u003c\u003cptr\u003c\u003c\" \"\u003c\u003clast\u003c\u003c\" \"\u003c\u003cmod\u003c\u003c\" \"\u003c\u003clim\u003c\u003cendl; if(ptr\u003c=0){ if(last==3 \u0026\u0026 mod==0)return 1; else return 0; } if(!lim \u0026\u0026 ~f[ptr][last][mod])return f[ptr][last][mod]; int maxx=lim?num[ptr]:9; ll res=0; for(int i=0;i\u003c=maxx;i++){ if(last==3)res+=dfs(ptr-1,3,(mod*10+i)%13,lim \u0026\u0026 i==maxx); else if(last==1 \u0026\u0026 i==3)res+=dfs(ptr-1,3,(mod*10+i)%13,lim \u0026\u0026 i==maxx); else if(i==1)res+=dfs(ptr-1,1,(mod*10+i)%13,lim\u0026\u0026i==maxx); else res+=dfs(ptr-1,0,(mod*10+i)%13,lim\u0026\u0026i==maxx); } if(!lim)f[ptr][last][mod]=res; return res; } ll solve(ll r){ int ptr=0; while(r){ num[++ptr]=r%10; r/=10; } return dfs(ptr,0,0,1); } int main(){ ios::sync_with_stdio(false); cin.tie(0); memset(f,-1,sizeof(f)); ll r; while(cin\u003e\u003er){ cout\u003c\u003csolve(r)\u003c\u003cendl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:4:2","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä¾‹é¢˜0 HDU3709 A balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 42 + 11 = 9 and 9*1 = 9, for left part and right part, respectively. Itï¿½s your job to calculate the number of balanced numbers in a given range [x, y]. ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:5:0","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ è¿™é¢˜æœ‰ç‚¹éº»çƒ¦â€¦â€¦ å°†æ æ†åœ¨å“ªä¸é¢˜ç›®åˆ†ç¦»å‡ºæ¥ï¼Œæšä¸¾æ æ†å®šåœ¨ä½•å¤„ã€‚å†ç»´æŠ¤æ˜¯å¦å¹³è¡¡ã€‚å¹³è¡¡ä¸å¦è¿˜æ˜¯æŒºå¥½è€ƒè™‘çš„ï¼Œä»¥æ æ†ä¸º0ï¼Œå·¦å³å„èµ‹å€¼æ­£ä¸è´Ÿçš„æƒå€¼ï¼Œå½“åˆ°è¾¾è¾¹æ¥åå…¨æ†é‡é‡ä¸º0æ—¶å³ä¸ºå¹³è¡¡ã€‚ æœ‰ä¸€ä¸ªå°å‘ï¼Œå°±æ˜¯0ã€‚å¦‚æœè¿™ä¸ªæ•°å­—å…¨tmå¡«0çš„æ—¶å€™ï¼Œä¸ç®¡æ æ†å®šåœ¨å“ªï¼Œå®ƒéƒ½å¹³è¡¡â€¦â€¦ä½ å½“ç„¶å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå‰å¯¼é›¶æ ‡å¿—ï¼Œå°†æ‰€æœ‰0éƒ½å»æ‰æœ€åå†åŠ ä¸Šã€‚è¿˜æœ‰ä¸€ç§åŠæ³•å°±æ˜¯æœ€åå†å°†é‡å¤çš„0å‡å»ï¼Œç›¸æ¯”èµ·æ¥æ›´åŠ ç®€å•ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:5:1","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; int num[20]; ll f[20][20][2010]; ll dfs(int ptr,bool lim,int piv,int l){ if(ptr\u003c=0)return l==0; if(l\u003c0)return 0; if(!lim \u0026\u0026 ~f[ptr][piv][l])return f[ptr][piv][l]; int maxx=lim?num[ptr]:9; ll res=0; for(int i=0;i\u003c=maxx;i++){ res+=dfs(ptr-1,lim \u0026\u0026 i==maxx,piv,l+i*(ptr-piv)); } if(!lim)f[ptr][piv][l]=res; return res; } ll solve(ll r){ int ptr=0; while(r){ num[++ptr]=r%10; r/=10; } ll ans=0; for(int i=1;i\u003c=ptr;i++){ ans+=dfs(ptr,1,i,0); } return ans-ptr+1; } int main(){ ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); int kase;cin\u003e\u003ekase; while(kase--){ memset(f,-1,sizeof(f)); ll l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003csolve(r)+(l?-solve(l-1):0)\u003c\u003c'\\n'; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:5:2","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä¾‹é¢˜1 CF55D Volodya is an odd boy and his taste is strange as well. It seems to him that a positive integer number is beautiful if and only if it is divisible by each of its nonzero digits. We will not argue with this and just count the quantity of beautiful numbers in given ranges. ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:6:0","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ ç»´æŠ¤æ•°å­—å¯¹0-9æ¯ä¸ªæ•°å­—çš„æ¨¡ï¼Œä½†æ˜¯è¿™æ ·è¿˜éœ€è¦ç»´æŠ¤æŸäº›æ•°å­—æ˜¯å¦å‡ºç°ï¼Œç»§ç»­è€ƒè™‘ã€‚å½“æ•°å­—èƒ½åŒæ—¶è¢«$a$å’Œ$b$æ•´é™¤ï¼Œç­‰ä»·ä¸ºå…¶èƒ½å¤Ÿè¢«å®ƒä¿©çš„æœ€å°å…¬å€æ•°æ•´é™¤ã€‚ é‚£ä¹ˆæˆ‘ä»¬çš„é—®é¢˜å¯ä»¥ç¨å¾®ç®€åŒ–ä¸€ä¸‹äº†ã€‚ç»´æŠ¤å·²ç»å¡«å†™çš„æ•°ä½çš„æœ€å°å…¬å€æ•°ï¼Œå¹¶ç»´æŠ¤æ•°å­—å’Œã€‚åˆ°è¾¾è¾¹ç•Œæ—¶ï¼Œåªæœ‰æ»¡è¶³æ¡ä»¶æ‰è®¡æ•°ã€‚ è¿™é“é¢˜è¿˜æœ‰ä¸€ç‚¹éº»çƒ¦ï¼Œå°±æ˜¯å†…å­˜å®ƒä¸å¤Ÿç”¨ã€‚æŒ‰ç…§åˆ†æï¼Œè‡³å°‘éœ€è¦å¼€$2520\\times 2520$ï¼Œè¿˜è¦å†åŠ ä¸Šä¸ªæ•°ä½é•¿åº¦ã€‚å†…å­˜å°±ç‚¸äº†ã€‚å®é™…ä¸Šï¼Œæœ€å°å…¬å€æ•°ä»…æœ‰äº†äº†å‡ ä¸ªï¼Œå¯ä»¥äº‹å…ˆæ±‚å‡ºå¹¶å…ˆç¼–ç ï¼Œå°±èƒ½é™ä½ä¸€ç»´çŠ¶æ€ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:6:1","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003cmap\u003eusing namespace std; using ll = long long; const int MAXN = 2620; const int MAX_LCM = 2520; //posä½æ•°ä½™restæ¨¡Â·10Â·çš„æ–¹æ¡ˆ ll cache[20][MAXN][50]; int digits[20]; int idx = 0; int lcmref[MAXN]; ll gcd(ll a, ll b) { return !b ? a : gcd(b, a % b); } ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } void init_lcm() { for (int i = 0; i \u003c (1 \u003c\u003c 10); i++) { int temp = 1; for (int j = 1; j \u003c 10; j++) { if ((i \u003e\u003e j) \u0026 1) { temp = lcm(temp, j); } } if (!lcmref[temp]) { //cout \u003c\u003c temp \u003c\u003c endl; lcmref[temp]=++idx; } } } ll solve(int pos, int rest, int l, bool lim) { if (pos == 0) { if (rest % l == 0) return 1; return 0; } if (!lim \u0026\u0026 ~cache[pos][rest][lcmref[l]]) return cache[pos][rest][lcmref[l]]; ll res = 0; int maxd = 9; if (lim) maxd = digits[pos]; for (int i = 0; i \u003c= maxd; i++) { res += solve(pos - 1, (rest * 10 + i) % MAX_LCM, i == 0 ? l : lcm(l, i), lim \u0026\u0026 (i == maxd)); } if (!lim) cache[pos][rest][lcmref[l]] = res; return res; } ll SOLVE(ll x) { int ptr = 0; while (x) { digits[++ptr] = x % 10; x /= 10; } return solve(ptr, 0, 1, true); } int main() { ios::sync_with_stdio(false); init_lcm(); int kase; cin \u003e\u003e kase; memset(cache, -1, sizeof(cache)); while (kase--) { ll l, r; cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c SOLVE(r) - SOLVE(l - 1) \u003c\u003c endl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:6:2","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä¾‹é¢˜2 æ±‚$[l,r]$åŒºé—´å†…çš„æ‰€æœ‰æ»¡è¶³ä»¥ä¸‹è¦æ±‚çš„æ•°çš„å¹³æ–¹å’Œã€‚ æ•°ä½ä¸Šæ²¡æœ‰$7$ ä¸æ˜¯$7$çš„å€æ•° æ•°ä½å’Œä¸æ˜¯$7$çš„å€æ•° åŒºé—´ä¸º$10^{18}$çº§åˆ«ï¼Œè¯·å¯¹ç­”æ¡ˆå–æ¨¡$10^{9}+7$ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:7:0","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ è¿™é¢˜æŒºç‹ çš„â€¦â€¦é¦–å…ˆçœ‹å¦‚ä½•åˆ¤æ–­ä¸Šé¢çš„3ä¸ªæ¡ä»¶ã€‚ æ•°ä½ä¸Šæ²¡æœ‰$7$ï¼Œå¯ä»¥ç›´æ¥åœ¨æšä¸¾å¡«æ•°æ—¶è·³è¿‡$7$ã€‚ é * çš„å€æ•°ï¼Œå¯ä»¥ç»´æŠ¤å·²å¡«æ•°å­—çš„å–æ¨¡ã€‚å–æ¨¡ä¸º$0$åˆ™ä¸ºå€æ•°ã€‚ æ•°ä½å’Œï¼Œä»ç„¶å¯ä»¥ç›´æ¥ç»´æŠ¤ã€‚ è¿™æ ·å°±å¯ä»¥æ­£ç¡®çš„åˆ¤æ–­æŸä¸ªæ•°æ˜¯ä¸æ˜¯æ»¡è¶³æ¡ä»¶ã€‚æ¥ä¸‹æ¥æ˜¯å¹³æ–¹å’Œã€‚ å½“ä»¥æ•°ä½æ¥è€ƒè™‘å¹³æ–¹å’Œæ—¶ï¼Œé—®é¢˜å°±ç¨å¾®å˜å¾—å¤æ‚äº†ã€‚å‡è®¾æˆ‘ä»¬å·²ç»çŸ¥é“äº†ä¸‹ä¸€ä¸ªçŠ¶æ€çš„å¹³æ–¹å’Œä¸º$x_n$ï¼Œå¦‚ä½•å¾—åˆ°å½“å‰ä½$x$çš„å¹³æ–¹å’Œã€‚ å‡è®¾å½“å‰ä½$ptr$å¡«äº†$i$ã€‚å…¶æ•°ä½æ‰€è¡¨è¾¾çš„æ„ä¹‰æ˜¯$10^{p}i$ï¼Œé‚£ä¹ˆä»¥è¯¥ä½ä¸ä¸‹ä¸€çŠ¶æ€çš„å¹³æ–¹å’Œï¼Œéœ€è¦ä¸‹ä¸€çŠ¶æ€çš„å’Œï¼Œå®šä¸º$s_n$ã€‚å¯ä»¥å¾—åˆ° $$ (10^p i+s_n)^2=10^{2p}i^2+2 \\cdot 10^pis_n+s_n^2 $$ å¦å¤–ï¼Œå½“å‰ä½çš„å‡ºç°æ¬¡æ•°åœ¨å®é™…è®¡ç®—æ—¶éœ€è¦è€ƒè™‘è¿›å»ã€‚é‚£ä¹ˆï¼Œè¿˜éœ€è¦ç»´æŠ¤ä¸‹ä¸€çŠ¶æ€çš„ä¸ªæ•°ï¼Œè®°$cnt$ã€‚é‚£ä¹ˆï¼Œä¸Šå¼éœ€è¦ä¿®æ”¹ $$ 10^{2p}i^2 \\cdot cnt_n+2 \\cdot 10^pis_n+s_n^2 $$ åä¸¤é¡¹ä¸ä¹˜ä»¥$cnt$æ˜¯å› ä¸ºå®ƒä»¬æœ¬èº«å°±å·²ç»æ˜¯åŒ…æ‹¬äº†ä¸‹ä¸€çŠ¶æ€çš„æ‰€æœ‰è®¡æ•°ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ä»¥æ•°ä½ä¸ºè§’åº¦çš„å¹³æ–¹å’Œç»´æŠ¤åŠæ³•ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:7:1","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=22; const ll MOD=1e9+7; struct Status{ ll cnt; ll sum,sqsum; Status(ll cnt=-1,ll sum=0,ll sqsum=0):cnt(cnt),sum(sum),sqsum(sqsum){} } f[MAXN][9*20][10]; int num[MAXN]; ll qpow(ll a,ll b){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%MOD){ if(b\u00261)res=res*a%MOD; } return res; } Status dfs(int ptr,int sum,int mod,bool lim){ if(ptr\u003c=0){ return Status(sum%7!=0 \u0026\u0026 mod!=0); } if(!lim \u0026\u0026 ~f[ptr][sum][mod].cnt)return f[ptr][sum][mod]; int maxx=lim?num[ptr]:9; Status res(0); for(int i=0;i\u003c=maxx;i++){ if(i==7)continue; Status nex=dfs(ptr-1,sum+i,(mod*10+i)%7,lim\u0026\u0026i==maxx); res.cnt+=nex.cnt; res.cnt%=MOD; res.sum=(res.sum%MOD+qpow(10,ptr-1)*i%MOD*nex.cnt%MOD)%MOD; res.sum=(res.sum+nex.sum)%MOD; res.sqsum=(res.sqsum+nex.cnt%MOD*qpow(10,2*(ptr-1))%MOD*i%MOD*i%MOD)%MOD; res.sqsum=((res.sqsum+nex.sqsum)%MOD+2*qpow(10,ptr-1)%MOD*i%MOD*nex.sum%MOD)%MOD; } if(!lim)f[ptr][sum][mod]=res; return res; } ll solve(ll n){ int ptr=0; while(n){ num[++ptr]=n%10; n/=10; } return dfs(ptr,0,0,1).sqsum%MOD; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int kase;cin\u003e\u003ekase; while(kase--){ ll l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003c((solve(r)-(l?solve(l-1):0))%MOD+MOD)%MOD\u003c\u003cendl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:7:2","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"æ•°ä½DP ä¸Šé¢è¿™é“é¢˜ç›®å¤§æ¦‚ç®—æ˜¯æš´éœ²äº†æ•°ä½DPä¸­éœ€è¦è€ƒè™‘çš„äº‹æƒ…ã€‚æ•°ä½DPèƒ½å¤Ÿä¸»è¦èƒ½å¤Ÿç»Ÿè®¡æŸ2ä¸ªæ•°å­—åŒºé—´å†…æ»¡è¶³æŸäº›æ¡ä»¶çš„æ•°å­—çš„ä¿¡æ¯ï¼Œæ¯”å¦‚ä¸ªæ•°ã€å’Œã€å¹³æ–¹å’Œâ€¦â€¦ é¦–å…ˆæ•°ä½DPä¸æ˜¯å•ç‹¬è€ƒè™‘æ¯ä¸€ä¸ªæ•°å­—ï¼Œè€Œæ˜¯ä»¥æ•°ä½ä¸ºå•ä½çš„è€ƒè™‘ã€‚è¿™æ ·åœ¨è€ƒè™‘æ¡ä»¶æ»¡è¶³å’Œå„ç±»ä¿¡æ¯çš„ç»´æŠ¤æ—¶ï¼Œå°±éœ€è¦è½¬ä¸€è½¬ã€‚ å…ˆæ¥çœ‹è®°å¿†åŒ–æœç´¢ã€‚æ¯”è¾ƒç›´è§‚ï¼ˆ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:8:0","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"è®¡æ•°åŸºç¡€ åˆå§‹åŒ–çš„å€¼ä»ä½•è€Œæ¥ã€‚å½“æ•°ä½DPåˆ°è¾¾äº†è¾¹ç•Œï¼Œå°±æ˜¯è¦è€ƒè™‘åˆå§‹åŒ–çš„ä½ç½®ã€‚ä¸€èˆ¬ä¸ºæ»¡è¶³æ¡ä»¶ç½®$1$ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:8:1","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"æ»¡è¶³æ¡ä»¶ è¿™æ˜¯æˆ‘ä»¬éœ€è¦è€ƒè™‘çš„çŠ¶æ€ã€‚ä¾‹å¦‚ä¸Šé¢æåˆ°çš„ã€‚ æ•°ä½æ²¡æœ‰æŸæ•°ï¼šç›´æ¥ä¸è½¬ç§»ã€‚ æ•°ä½å’Œï¼šç›´æ¥ç»´æŠ¤ä¸€ç»´æ•°ä½å’Œã€‚ å€æ•°å…³ç³»ï¼šä»¥é€’æ¨æ–¹å¼ç»´æŠ¤å–æ¨¡ã€‚ æ•°å­—å‡ºç°æ¬¡æ•°ï¼šä½¿ç”¨çŠ¶å‹æ¥å¯¹æ¬¡æ•°ç¼–ç ã€‚ä¾‹å¦‚ï¼Œå¯¹æ¯ä¸€ç§æ•°å­—ç»´æŠ¤ç©ºé—´ä¸º3çš„çŠ¶æ€ï¼ˆ0ï¼Œå¥‡æ•°ï¼Œå¶æ•°ï¼‰ã€‚ å…¶å®è¿˜å¯èƒ½æœ‰å¾ˆå¤šï¼Œä¸»è¦è€ƒè™‘çš„é—®é¢˜æ˜¯è¯¥çŠ¶æ€ç»è¿‡ç¼–ç åèƒ½ä¸èƒ½ä¿å­˜ä¸‹æ¥ï¼Œä¸¤ä¸ªçŠ¶æ€ä¹‹é—´èƒ½ä¸èƒ½é€’æ¨è¿‡å»ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:8:2","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["å­¦ä¹ "],"content":"è®¡æ•° å¿…é¡»è€ƒè™‘$n-1$åˆ°$n$ä½ä¹‹é—´çš„è½¬ç§»å…³ç³»ã€‚é¦–å…ˆä¸€å®šä¼šç»´æŠ¤æ»¡è¶³æ€§è´¨çš„æ•°å­—ä¸ªæ•°ï¼Œä¹‹åæ¯ä¸€ä¸ªä½çš„è®¡ç®—éƒ½éœ€è¦è€ƒè™‘ä¸‹ä¸€çŠ¶æ€çš„ä¸ªæ•°ã€‚ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:8:3","tags":null,"title":"æ•°ä½DP","uri":"/2019/11/digital-dp/"},{"categories":["code"],"content":"Liaoning ship, which named after a province of China, is the first aircraft carrier commissioned into the Peopleâ€™s Liberation Army Navy. It was bought from Ukraine as a stripped hulk and was rebuilt by China as an important part of Chinaâ€™s blue water Navy plan. Liaoning ship has sailed far into the Pacific Ocean for serval times, which shows the power and resolve of China to defend her integrity of territory. Now Liaoning ship is on a new voyage to the Atlantic Ocean for a maneuver! The vast maneuver region on the ocean can be seen as an nÃ—n grid which has nÃ—n crosspoints. Each crosspoint stands for a check point of the maneuver region. Liaoning starts from the bottom-left check point whose coordinate is (0,0), and its destination is the upper-right checkpoint whose coordinate is (n-1,n-1). The positive side of the x axis points to the right, and the positive side of the y axis points up. All check pointsâ€™ coordinates are integral. During each move, Liaoning can go from one check point to its adjacent 8 check points along a straight line, and each move takes Liaoning one day. Some check points are not available to go due to the bad weather. And, as you know, on the Atlantic Ocean, there is a Bermuda Triangle in which many ships and planes were missing. Liaoning canâ€™t take risk to go into that triangle. Of course, Liaoning canâ€™t go outside the maneuver region. Please figure out a route for Liaoning to reach its destination as soon as possible. ","date":"2019-10-27","objectID":"/2019/10/liaoning-ships-voyage/:0:0","tags":null,"title":"Liaoning Shipâ€™s Voyage","uri":"/2019/10/liaoning-ships-voyage/"},{"categories":["code"],"content":"åˆ†æ å®é™…ä¸Šæœ¬ä½“æ˜¯ä¸ªDijkstraï¼Œä½†æ˜¯ä¸¤ç‚¹æ˜¯å¦ç›¸è¿éœ€è¦ä½¿ç”¨åˆ°è®¡ç®—å‡ ä½•çš„ä¸œè¥¿ã€‚é‡ç‚¹å°±åœ¨äºå¦‚ä½•åˆ¤æ–­è¡Œè¿›è¿‡ç¨‹æ˜¯å¦ç©¿è¿‡äº†ç™¾æ…•å¤§ä¸‰è§’ã€‚ ç„¶åå°±WAäº†8å‘ã€‚ å®é™…åˆ¤æ–­æ—¶ä¼šæœ‰å¾ˆå¤šé—®é¢˜ã€‚ä¾‹å¦‚ä»è¾¹ä¸Šç»è¿‡ï¼Œä»å¤–ç•Œåˆ°è¾¹ï¼Œä»è¾¹åˆ°è¾¹ï¼Œä»è¾¹åˆ°å¤–ç•Œï¼Œä»å¤–ç•Œåˆ°ç‚¹ï¼Œä»ç‚¹åˆ°å¤–ç•Œï¼Œä»è¾¹ç©¿è¿‡ç‚¹â€¦â€¦å¦‚æœä¸€å¼€å§‹é€‰æ‹©çš„åˆ¤æ–­æ–¹æ³•æœ‰é”…çš„è¯ï¼Œä¹‹åå°±æ”¹ä¸å‡ºæ¥äº†ï¼Œåªèƒ½WAâ€¦â€¦ æœ€ç»ˆæƒ³å‡ºæ¥çš„è§£å†³åŠæ³•æ˜¯æ‹¿åˆ°è¡Œè¿›çº¿æ®µä¸ä¸‰è§’å½¢ä¸‰è¾¹çš„äº¤ç‚¹ï¼Œè¿æ¥äº¤ç‚¹æ„é€ æ–°çº¿æ®µåï¼Œåˆ¤æ–­çº¿æ®µä¸­ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ï¼›å¹¶åŒæ—¶åˆ¤æ–­èµ·ç‚¹ç»ˆç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ã€‚è¿™æ ·å°±èƒ½é¿å…æ‰å¤æ‚çš„è®¨è®ºã€‚ å…¶æ¬¡ï¼Œé¡ºä¾¿æŠŠå·²ç»åœ¨ä¸‰è§’å½¢å†…çš„æ•´ç‚¹å…¨éƒ¨æ ‡è®°äº†ä¸èƒ½è®¿é—®ã€‚ è¿™æ ·å°±è¿‡äº†ã€‚ ","date":"2019-10-27","objectID":"/2019/10/liaoning-ships-voyage/:1:0","tags":null,"title":"Liaoning Shipâ€™s Voyage","uri":"/2019/10/liaoning-ships-voyage/"},{"categories":["code"],"content":"ä»£ç  æ¿å­åˆ¤ç‚¹åœ¨çº¿æ®µéƒ¨åˆ†æœ‰é—®é¢˜ï¼Œè¦æ”¹ã€‚ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccmath\u003e#include \u003ccstdlib\u003e#include \u003cqueue\u003eusing namespace std; const int MAXN=30; bool fuck=false; const double EPS=1e-7; const double PI=acos(-1); int sgn(double x){ return (x\u003e-EPS)-(x\u003cEPS); } struct Vec{ double x,y;//never change it yourself unless you dont need polar angle. double _polar;// make cache to accumulate speed as atan is too slow. Vec(){ x=y=0; } Vec(double x,double y):x(x),y(y){ _polar=atan2(y,x); } double dot(const Vec \u0026b)const{ return x*b.x+y*b.y; } double cross(const Vec \u0026b)const{ return x*b.y-b.x*y; } double len(){ return sqrt(sqlen()); } double sqlen(){ return x*x+y*y; } Vec normalize(){ double l=len(); return Vec(x/l,y/l); } Vec rotate(double angle){ return Vec(x*cos(angle)-y*sin(angle),x*sin(angle)+y*cos(angle)); } Vec operator * (double factor)const{ return Vec(x*factor,y*factor); } double operator * (const Vec \u0026b)const{ return cross(b); } Vec operator - (const Vec \u0026b)const{ return Vec(x-b.x,y-b.y); } Vec operator +(const Vec \u0026b)const{ return Vec(x+b.x,y+b.y); } double polar()const{ return _polar; } bool leftby(const Vec \u0026b)const{ return sgn(b.cross(*this))\u003e0; } bool samed(const Vec \u0026b)const{ return sgn(this-\u003ecross(b))==0 \u0026\u0026 sgn(this-\u003edot(b))\u003e0; } bool operator\u003c(const Vec \u0026b)const{ return this-\u003epolar()\u003cb.polar(); } bool operator==(const Vec \u0026b)const{ return sgn(b.x-this-\u003ex)==0 \u0026\u0026sgn(b.y-this-\u003ey)==0; } }; ostream\u0026 operator\u003c\u003c(ostream\u0026 out,const Vec \u0026b){ out\u003c\u003c\"(\"\u003c\u003cb.x\u003c\u003c\",\"\u003c\u003cb.y\u003c\u003c\")\"; return out; } typedef Vec Point; struct Line{ Point pos; Vec dirc; Line(Point pos=Point(0,0),Vec dirc=Vec(0,0)):pos(pos),dirc(dirc){} static Line fromPoints(Point a,Point b){ return Line(a,b-a); } double getarea(const Line \u0026b)const{ return abs(dirc.cross(b.dirc)); } // è·å¾—å‚çº¿ Line getppd(){ return Line(pos+dirc*0.5,dirc.rotate(PI/2)); } //TODO: what will happen if they have no intersection,-nan Point getintersection(const Line \u0026b)const{ Vec down=this-\u003epos-b.pos; double aa=b.dirc.cross(down); double bb=this-\u003edirc.cross(b.dirc); return this-\u003epos+this-\u003edirc*(aa/bb); } bool point_on_line(Point point){ if(!dirc.samed(point-pos)) return false; if(sgn((point-pos).sqlen()-dirc.sqlen())\u003e0) return false; return true; } bool on_ver(Point point){ if(sgn(point.x-pos.x)==0 \u0026\u0026 sgn(point.y-pos.y)==0)return true; if(sgn(point.x-(pos.x+dirc.x))==0 \u0026\u0026 sgn(point.y-(pos.y+dirc.y))==0)return true; return false; } double get_distance(Point point){ Line ppd=getppd(); ppd.pos=point; Point intersection=getintersection(ppd); ppd.dirc=intersection-point; Vec v=intersection-pos; return abs(v.cross(point-pos)/v.len()); } double get_distance(Line line){ return get_distance(line.pos); } }; Point points[3]; Line triangle[3]; char game[MAXN][MAXN]; double get_area(vector\u003cPoint\u003e \u0026points){ if(points.size()\u003c3){ return -1; } sort(points.begin(),points.end(),[](const Point \u0026a,const Point \u0026b){ return a.polar()\u003cb.polar(); }); Point base(0,0); Point last=points[0]; double res=0; for(int i=1;i\u003cpoints.size();i++){ Vec a=last-base,b=points[i]-base; res+=a.cross(b)/2; last=points[i]; } //add the last point(also the first point) Vec a=last-base,b=points[0]-base; res+=a.cross(b)/2; return fabs(res); } bool in_triangle(Point p){ if(fuck)return false; for(int i=0;i\u003c3;i++){ if(Line::fromPoints(points[i%3],points[(i+1)%3]).point_on_line(p))return false; } double areas=0; for(int i=0;i\u003c3;i++){ vector\u003cPoint\u003e ps; ps.push_back(points[i%3]); ps.push_back(points[(i+1)%3]); ps.push_back(p); areas+=get_area(ps); } vector\u003cPoint\u003e ps; for(int i=0;i\u003c3;i++)ps.push_back(points[i]); return sgn(areas-get_area(ps))==0; } bool has_intersetct(Line line){ if(fuck)return false; int cnt=0; Point p[3]; bool flg[3]={0,0,0}; for(int i=0;i\u003c3;i++){ if(sgn(line.dirc.cross(triangle[i].dirc))==0)continue; p[i]=line.getintersection(triangle[i]); if(line.point_on_line(p[i])||p[i]==line.pos) flg[i]=1; } if(in_triangle(line.pos)) return true; if(in_triangle(line.pos","date":"2019-10-27","objectID":"/2019/10/liaoning-ships-voyage/:2:0","tags":null,"title":"Liaoning Shipâ€™s Voyage","uri":"/2019/10/liaoning-ships-voyage/"},{"categories":["code"],"content":"è¿™é¢˜æ„å¤ªé•¿äº†ï¼Œæˆ‘æ‡’å¾—å¤åˆ¶ã€‚ ","date":"2019-10-23","objectID":"/2019/10/ccpc2017hangzhou-heathrock/:0:0","tags":["æœç´¢"],"title":"[CCPC2017æ­å·] Heathrock","uri":"/2019/10/ccpc2017hangzhou-heathrock/"},{"categories":["code"],"content":"åˆ†æ é¢â€¦â€¦å…¶å®å°±æ˜¯çˆ†æœæ¨¡æ‹Ÿã€‚ä½†æ˜¯çŠ¶æ€æ¯”è¾ƒå¤šï¼Œéœ€è¦è®°åŒæ–¹ç”Ÿå‘½å€¼ï¼Œ3ä¸ªéšä»çš„ç”Ÿå‘½ï¼Œå½“å‰åœºæ•°ï¼Œé­”åŠ›ï¼Œä½“åŠ›ï¼Œä»¥åŠä¸€äº›ç„å­¦ä¼˜åŒ–ã€‚ è‡ªé€‰ç›®æ ‡çš„ç‰Œä¸€å®šä¼šæ”¾åœ¨å›åˆçš„è¾ƒåå‡ºï¼Œå› ä¸ºå…¶ä¸ä¼šç´¯åŠ é­”åŠ›ã€‚ å¦‚æœå‰©ä¸‹çš„ç‰Œå…¨è¸¢è„¸ä¹Ÿè¸¢ä¸æ­»ï¼Œç›´æ¥è¿”å›ã€‚ ä¹‹åå°±èƒ½è·‘å¾—é£å¿«ã€‚ {% asset_img â€œ1.pngâ€ %} ","date":"2019-10-23","objectID":"/2019/10/ccpc2017hangzhou-heathrock/:1:0","tags":["æœç´¢"],"title":"[CCPC2017æ­å·] Heathrock","uri":"/2019/10/ccpc2017hangzhou-heathrock/"},{"categories":["code"],"content":"ä»£ç  ä¸€å¼€å§‹è¾“å‡ºäº†\"YESâ€ï¼Œæ·¦ã€‚ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003cstack\u003e#include \u003cqueue\u003eusing namespace std; const int MAXN=10; struct Card{ int type; int damage; int cost; int power; Card(){} Card(int type,int damage,int cost,int power):type(type),damage(damage),cost(cost),power(power){} } cards[MAXN]; bool used[MAXN]; int nlen; int md1,md2,md3; int mx1,mx2,mx3; stack\u003cint\u003e ans_cards,ans_target; bool dfs(int stone,int power,int bl_me,int bl_en,int m1,int m2,int m3,int depth,bool nearend=false){ if(stone\u003c0)return false; if(depth\u003e=3)return false; if(bl_en\u003c=0)return true; if(depth\u003e=1 \u0026\u0026 stone==10){ if(m1\u003e0)bl_me-=md1; if(m2\u003e0)bl_me-=md2; if(m3\u003e0)bl_me-=md3; if(m1\u003c=0)m1=mx1; if(m2\u003c=0)m2=mx2; if(m3\u003c=0)m3=mx3; } if(bl_me\u003c=0)return false; //full attacking to owner cannot kill it. int fullattack=0; int fakepower=power; int unusd_lian=0; for(int i=0;i\u003cnlen;i++){ if(used[i])continue; fakepower+=cards[i].power; if(cards[i].type==1)continue; unusd_lian++; fullattack+=cards[i].damage; } if(fullattack+fakepower*(unusd_lian)\u003cbl_en)return false; for(int i=0;i\u003cnlen;i++){ if(used[i])continue; const Card \u0026card=cards[i]; int reald=card.damage+power; if(card.cost\u003estone)continue; used[i]=1; if(!nearend \u0026\u0026 card.type==1){ if(stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1-reald,m2-reald,m3-reald,depth)){ ans_cards.push(i+1); ans_target.push(-1); return true; } } if(!nearend \u0026\u0026 card.type==2){ if(stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en-reald,m1,m2,m3,depth)){ ans_cards.push(i+1); ans_target.push(-1); return true; } } if(card.type==3){ if(stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en-reald,m1,m2,m3,depth,1)){ ans_cards.push(i+1); ans_target.push(0); return true; } if(m1\u003e0 \u0026\u0026 stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1-reald,m2,m3,depth,1)){ ans_cards.push(i+1); ans_target.push(1); return true; } if(m2\u003e0 \u0026\u0026 stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1,m2-reald,m3,depth,1)){ ans_cards.push(i+1); ans_target.push(2); return true; } if(m3\u003e0 \u0026\u0026 stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1,m2,m3-reald,depth,1)){ ans_cards.push(i+1); ans_target.push(3); return true; } } used[i]=0; } if(dfs(10,0,bl_me,bl_en,m1,m2,m3,depth+1)){ ans_cards.push(-1); ans_target.push(-1); return true; } return false; } int mc1,mc2,mc3; int bl_me,bl_en; int main(){ ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); int kase;cin\u003e\u003ekase; while(kase--){ memset(used,0,sizeof(used)); while(!ans_cards.empty())ans_cards.pop(); while(!ans_target.empty())ans_target.pop(); cin\u003e\u003enlen; cin\u003e\u003ebl_me\u003e\u003ebl_en; cin\u003e\u003emd1\u003e\u003emc1\u003e\u003emx1; cin\u003e\u003emd2\u003e\u003emc2\u003e\u003emx2; cin\u003e\u003emd3\u003e\u003emc3\u003e\u003emx3; for(int i=0;i\u003cnlen;i++){ cards[i].cost=cards[i].damage=cards[i].power=cards[i].type=0; int type;cin\u003e\u003etype; if(type==1 || type==2){ int cost,x,y; cin\u003e\u003ecost\u003e\u003ex\u003e\u003ey; cards[i].type=type; cards[i].cost=cost; cards[i].damage=x; cards[i].power=y; }else{ int cost,x; cin\u003e\u003ecost\u003e\u003ex; cards[i].type=type; cards[i].cost=cost; cards[i].damage=x; } } ans_cards.push(-1); ans_target.push(-1); if(dfs(10,0,bl_me,bl_en,mc1,mc2,mc3,0)){ cout\u003c\u003c\"Yes\\n\"; }else{ cout\u003c\u003c\"No\\n\"; continue; } int block=0; while(!ans_cards.empty()){ queue\u003cint\u003e pack_ans,pack_target; while(!ans_cards.empty() \u0026\u0026 ans_cards.top()!=-1){ pack_ans.push(ans_cards.top()); ans_cards.pop(); pack_target.push(ans_target.top()); ans_target.pop(); } if(!ans_cards.empty()){ ans_cards.pop(); ans_target.pop(); } if(pack_ans.empty())continue; cout\u003c\u003cpack_ans.size()\u003c\u003c\"\\n\"; while(!pack_ans.empty()){ cout\u003c\u003cpack_ans.front()\u003c\u003c\" \"; pack_ans.pop(); } cout\u003c\u003c\"\\n\"; while(!pack_target.empty()){ cout\u003c\u003cpack_target.front()\u003c\u003c\" \"; pack_target.pop(); } cout\u003c\u003c\"\\n\"; block++; } while(block\u003c3){ cout\u003c\u003c\"0\\n\"; block++; } } return 0; } ","date":"2019-10-23","objectID":"/2019/10/ccpc2017hangzhou-heathrock/:2:0","tags":["æœç´¢"],"title":"[CCPC2017æ­å·] Heathrock","uri":"/2019/10/ccpc2017hangzhou-heathrock/"},{"categories":["code"],"content":"ç»™å‡º2ä¸ªæ•°åˆ—ï¼Œ${a_i},{b_i}$.è¦æ±‚æ”¯æŒä»¥ä¸‹æ“ä½œ ä¿®æ”¹æ•°åˆ—açš„ç¬¬iä¸ªä¸ºx ä¿®æ”¹æ•°åˆ—bçš„ç¬¬iä¸ªä¸ºx ç»™å‡ºkï¼Œæ±‚æœ€å°çš„tï¼Œæ»¡è¶³$\\sum \\lfloor \\frac {t-b_i}{a_i} \\rfloor \\ge k$ æ“ä½œæ•°ä¸å¤šäº100000ï¼Œæ“ä½œ3ä¸å¤šäº1000ï¼›æ•°åˆ—é•¿åº¦ä¸å¤šäº10000ï¼Œaçš„å€¼åŸŸä¸å¤§äº1000ã€‚ ","date":"2019-10-21","objectID":"/2019/10/ccpc-2017-master-of-sequence/:0:0","tags":null,"title":"[CCPC 2017] Master of Sequence","uri":"/2019/10/ccpc-2017-master-of-sequence/"},{"categories":["code"],"content":"åˆ†æ å°†$\\lfloor \\frac {t-b_i}{a_i} \\rfloor$æ‹†å¼€ï¼Œè§‚å¯Ÿå‰åå¯èƒ½å‡ºç°çš„å·®ã€‚ $$ \\lfloor \\frac {t}{a_i} \\rfloor - \\lfloor \\frac {b_i}{a_i} \\rfloor $$ è®¾$t=k_1a_i+c_1,b_i=k_2a_i+c_2$ï¼Œä»£å…¥è§‚å¯Ÿã€‚ $$ \\begin{aligned} \\lfloor \\frac {t-b_i}{a_i} \\rfloor\u0026=\\lfloor \\frac {(k_1-k_2)a_i+c_1-c_2}{a_i} \\rfloor \\\\ \\end{aligned} $$ å¯ä»¥å‘ç°ï¼Œå½“æŠŠå¼å­æ‹†å¼€æ—¶ï¼Œæœ‰2ç§æƒ…å†µã€‚ $c_1 \u003e c_2$ï¼Œå•¥äº‹æ²¡æœ‰ã€‚ $c_1 \u003c c_2$ï¼Œæ‹†å¼€åä¼šå¤šç»Ÿè®¡ä¸€ä¸ª1ã€‚ äº‹å…ˆç»Ÿè®¡${b_i}$æ¨¡$a$çš„ä½™æ•°ï¼Œé‚£ä¹ˆæœ‰$t$åå°±èƒ½å¿«é€Ÿæ•°å‡ºç¬¬2ç§æƒ…å†µçš„æ•°é‡ã€‚ ","date":"2019-10-21","objectID":"/2019/10/ccpc-2017-master-of-sequence/:1:0","tags":null,"title":"[CCPC 2017] Master of Sequence","uri":"/2019/10/ccpc-2017-master-of-sequence/"},{"categories":["code"],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXA=1010,MAXB=100010; int nlen,mlen; int a[MAXB],acnt[MAXA]; int b[MAXB]; int fts[MAXA][MAXA]; int pre[MAXA][MAXA]; void force(int i){ pre[i][0]=fts[i][0]; for(int j=1;j\u003cMAXA;j++){ pre[i][j]=pre[i][j-1]+fts[i][j]; } } ll base=0; bool check(ll k,ll t){ ll res=-base; for(int i=1;i\u003c=1000;i++){ res+=(t/i)*acnt[i]; int c=t%i; ll offset=pre[i][1000]-pre[i][c]; res-=offset; } return res\u003e=k; } int main(){ ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); int kase;cin\u003e\u003ekase; while(kase--){ memset(acnt,0,sizeof(acnt)); memset(a,0,sizeof(a)); base=0; memset(fts,0,sizeof(fts)); cin\u003e\u003enlen\u003e\u003emlen; for(int i=1;i\u003c=nlen;i++){ cin\u003e\u003ea[i]; acnt[a[i]]+=1; } for(int i=1;i\u003c=nlen;i++){ cin\u003e\u003eb[i]; fts[a[i]][b[i]%a[i]]++; base+=b[i]/a[i]; } for(int i=1;i\u003c=1000;i++){ force(i); } for(int i=1;i\u003c=mlen;i++){ int opt; cin\u003e\u003eopt; if(opt==1){ int x,y; cin\u003e\u003ex\u003e\u003ey; acnt[a[x]]--; fts[a[x]][b[x]%a[x]]--; base-=b[x]/a[x]; force(a[x]); a[x]=y; fts[a[x]][b[x]%a[x]]++; acnt[a[x]]++; base+=b[x]/a[x]; force(a[x]); }else if(opt==2){ int x,y; cin\u003e\u003ex\u003e\u003ey; fts[a[x]][b[x]%a[x]]--; base-=b[x]/a[x]; force(a[x]); b[x]=y; fts[a[x]][b[x]%a[x]]++; force(a[x]); base+=b[x]/a[x]; }else if(opt==3){ int qk;cin\u003e\u003eqk; ll l=0,r=1e13; while(l+1\u003cr){ ll mid=(l+r)/2; if(check(qk,mid)){ r=mid; }else l=mid+1; } for(ll i=l;i\u003c=r;i++){ if(check(qk,i)){ cout\u003c\u003ci\u003c\u003c\"\\n\"; break; } } } } } return 0; } ","date":"2019-10-21","objectID":"/2019/10/ccpc-2017-master-of-sequence/:2:0","tags":null,"title":"[CCPC 2017] Master of Sequence","uri":"/2019/10/ccpc-2017-master-of-sequence/"},{"categories":["code"],"content":"å½“åœ¨ä½¿ç”¨ä¸€æŒ‡ç¦…é”®å…¥ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ—¶å€™ï¼Œä½ éœ€è¦ä¸åœçš„ç§»åŠ¨æ‰‹æŒ‡ã€‚æ¯”å¦‚è¯´è¾“å…¥â€œafâ€ï¼Œæ‰‹æŒ‡éœ€è¦è·¨è¿‡3ä¸ªé”®ï¼ˆåŒ…æ‹¬ç»ˆç‚¹ï¼‰è¾“å…¥â€œaâ€å’Œâ€œfâ€ã€‚ é’ˆå¯¹ä¸€ä¸ªç»å¸¸è¾“å…¥çš„å­—ç¬¦ä¸²ï¼Œä½ å¯ä»¥å®šåˆ¶ä¸€ä¸ªé•¿æ¡é”®ç›˜ï¼Œä½¿å¾—åœ¨è¿™ä¸ªé”®ç›˜ä¸Šè¾“å…¥å­—ç¬¦ä¸²éœ€è¦ç§»åŠ¨çš„è·ç¦»æœ€çŸ­ã€‚ ç»™å‡ºå­—ç¬¦ä¸²é•¿åº¦$n$ä¸å­—å…¸å¤§å°$k$ï¼ˆå°å†™å­—æ¯çš„å‰$k$ä¸ªï¼‰ï¼Œç»™å‡ºæœ€ä¼˜æƒ…å†µä¸‹æ‰‹æŒ‡éœ€è¦ç§»åŠ¨çš„è·ç¦»ã€‚ ","date":"2019-10-09","objectID":"/2019/10/cfedu74-e-keyboard-purchase/:0:0","tags":null,"title":"[CFEDU74 E] Keyboard Purchase","uri":"/2019/10/cfedu74-e-keyboard-purchase/"},{"categories":["code"],"content":"åˆ†æ è¿™é“é¢˜å’Œä¹‹å‰é‚£é“marbleså¾ˆåƒâ€¦â€¦æˆ–è€…è¯´çŠ¶å‹éƒ½æŒºåƒçš„ã€‚ é¢˜ç›®å³ä¾æ¬¡å†³å®šé”®ç›˜çš„ä¸‹ä¸€ä¸ªæŒ‰é”®è£…å•¥ï¼Œå¹¶åœ¨åŸå­—ç¬¦ä¸²é‡Œè®¡ç®—éœ€è¦ç§»åŠ¨çš„æ¬¡æ•°ã€‚è®¾$f(S)$è¡¨ç¤ºå·²ç»è€ƒè™‘äº†é›†åˆ$S$é‡Œæ‰€æœ‰çš„æŒ‰é”®ã€‚ä¸è¿‡ä»”ç»†æ€è€ƒä¸€ä¸‹å‘ç°è¿™ä¸ªä»£ä»·éœ€è¦çŸ¥é“å…ˆå‰å®‰è£…çš„æŒ‰é”®çš„é¡ºåºï¼Œè€Œè¿™ä¸ªé¡ºåºæ˜¾ç„¶ä¸èƒ½åŠ å…¥åˆ°çŠ¶æ€é‡Œï¼Œè¿™æ˜¯æ— æ³•æ¥å—çš„ã€‚å¿…é¡»è¦é€šè¿‡åˆ«çš„æ–¹å¼æ¥è®¡ç®—ã€‚ ç„¶åæˆ‘åˆå¡äº†ã€‚ è¿™æ˜¯æ²¡è§è¿‡çš„è½¬ç§»æ–¹å¼â€¦â€¦è€ƒè™‘æœ¬è½®æ²¡æœ‰æ’å…¥é”®Aï¼Œé‚£ä¹ˆä¸€å®šå°±æ’å…¥äº†åˆ«çš„é”®Bï¼Œé‚£ä¹ˆï¼Œè¿™æ¬¡å¯¹äºäº‹ä»¶â€œæ’Aâ€çš„ä¸€æ¬¡delayä¼šå¯¼è‡´åŸä¸²é‡ŒAå’Œç›¸é‚»åœ¨é”®ç›˜ä¸Šå·²ç¡®å®šä½ç½®çš„å­—æ¯é—´çš„è½¬ç§»å¤šä¸€ä¸ªä»£ä»·ã€‚ æœ‰ç§æ¨¡ç³Šçš„æ„Ÿè§‰ã€‚ä¹‹å‰é‚£ä¸ªé¢˜ç›®æ˜¯è®¡ç®—å½“å‰å…ƒç´ å’Œå·²æœ‰å…ƒç´ ä¹‹é—´çš„ä»£ä»·ï¼›è¿™ä¸ªæ˜¯è®¡ç®—å·²æœ‰å…ƒç´ å’Œæœªæœ‰å…ƒç´ ä¹‹é—´çš„ç´¯è¿›å¼ä»£ä»·ã€‚æä¸å¤ªæ¸…æ¥šè¿™ä¸ª$f(S)$ç°åœ¨ä»£è¡¨çš„æ˜¯ä»€ä¹ˆäº†â€¦ä¸çŸ¥å¯å¦æœ‰äººæŒ‡å¯¼ã€‚ ","date":"2019-10-09","objectID":"/2019/10/cfedu74-e-keyboard-purchase/:1:0","tags":null,"title":"[CFEDU74 E] Keyboard Purchase","uri":"/2019/10/cfedu74-e-keyboard-purchase/"},{"categories":["code"],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003cstring\u003eusing namespace std; using ll=long long; const int MAXK=21; int nlen,klen; string inp; int cost[MAXK][MAXK]; ll dp[1\u003c\u003c20]; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003enlen\u003e\u003eklen; cin\u003e\u003einp; for(int i=1;i\u003cnlen;i++){ cost[inp[i-1]-\u0026#039;a\u0026#039;][inp[i]-\u0026#039;a\u0026#039;]++; cost[inp[i]-\u0026#039;a\u0026#039;][inp[i-1]-\u0026#039;a\u0026#039;]++; } memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=0;i\u003c(1\u003c\u003cklen);i++){ ll scost=0; for(int j=0;j\u003cklen;j++){ if(!((i\u003e\u003ej)\u00261))continue; for(int k=0;k\u003cklen;k++){ if((i\u003e\u003ek)\u00261)continue; scost+=cost[j][k]; } } for(int j=0;j\u003cklen;j++){ if((i\u003e\u003ej)\u00261)continue; dp[i|(1\u003c\u003cj)]=min(dp[i|(1\u003c\u003cj)],dp[i]+scost); } } cout\u003c\u003cdp[(1\u003c\u003cklen)-1]\u003c\u003cendl; return 0; } ","date":"2019-10-09","objectID":"/2019/10/cfedu74-e-keyboard-purchase/:2:0","tags":null,"title":"[CFEDU74 E] Keyboard Purchase","uri":"/2019/10/cfedu74-e-keyboard-purchase/"},{"categories":["code"],"content":"You are given a directed graph with n vertices and m directed edges without self-loops or multiple edges. Letâ€™s denote the k-coloring of a digraph as following: you color each edge in one of k colors. The k-coloring is good if and only if there no cycle formed by edges of same color. Find a good k-coloring of given digraph with minimum possible k. ","date":"2019-10-06","objectID":"/2019/10/cf-edu72d-coloring-edges/:0:0","tags":null,"title":"[CF EDU72D] Coloring Edges","uri":"/2019/10/cf-edu72d-coloring-edges/"},{"categories":["code"],"content":"åˆ†æ å¯¹æˆ‘è¿™ä¸ªèœé¸¡æ¥è¯´ï¼Œå»æŸ“è‰²è¿”ç¥–è¾¹çš„æ“ä½œå¹¶ä¸æ€ä¹ˆæ˜¾ç„¶â€¦â€¦ç®—äº†â€¦â€¦ æ²¡èƒ½åšæŒåªæœ‰2ç§é¢œè‰²çš„çŒœæƒ³ã€‚æŒ‚åŸå¢™ã€‚ æ²¡å¿…è¦æŒ‚ä»£ç ã€‚ ","date":"2019-10-06","objectID":"/2019/10/cf-edu72d-coloring-edges/:1:0","tags":null,"title":"[CF EDU72D] Coloring Edges","uri":"/2019/10/cf-edu72d-coloring-edges/"},{"categories":["code"],"content":"Monocarp has arranged n colored marbles in a row. The color of the i-th marble is ai. Monocarp likes ordered things, so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment (and there is only one such segment for each color). In other words, Monocarp wants to rearrange marbles so that, for every color j, if the leftmost marble of color j is l-th in the row, and the rightmost marble of this color has position r in the row, then every marble from l to r has color j. To achieve his goal, Monocarp can do the following operation any number of times: choose two neighbouring marbles, and swap them. You have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles. Note that the order of segments of marbles having equal color does not matter, it is only required that, for every color, all the marbles of this color form exactly one contiguous segment. ","date":"2019-10-05","objectID":"/2019/10/cf585e-marbles/:0:0","tags":null,"title":"[CF585E] Marbles","uri":"/2019/10/cf585e-marbles/"},{"categories":["code"],"content":"åˆ†æ è¿™é“é¢˜çš„ç¿»è¯‘å°±æ˜¯â€œé‡æ–°ç¡®å®šæ¯ä¸ªé¢œè‰²çš„æƒå€¼ï¼Œä½¿å¾—é€†åºå¯¹æœ€å°‘â€ã€‚ ç„¶åæˆ‘å°±å¡äº†ï¼Œç°åœ¨æˆ‘ä¹Ÿä¸æ˜¯ç‰¹åˆ«æ¸…æ¥šä¸ºå•¥å¯ä»¥dpï¼Œåªæ˜¯çŸ¥é“èƒ½dpã€‚ é€‰æ‹©çŠ¶æ€$f(S)$è¡¨ç¤ºé›†åˆ$S$å·²ç»å…¨éƒ¨åˆ†é…æƒå€¼æ—¶äº§ç”Ÿçš„æœ€å°‘é€†åºå¯¹ã€‚æšä¸¾ä¸‹ä¸€ä¸ªé¢œè‰²ï¼Œç»™äºˆä¸‹ä¸€ä¸ªï¼ˆè¾ƒå°ï¼‰æƒå€¼ï¼Œå¹¶è®¡ç®—ä»£ä»·ã€‚ $$ f(S+\\{i\\})=min\\{f(S)+w\\} $$ æ¥ä¸‹æ¥æ˜¯wçš„å¤„ç†ã€‚æˆ‘ä»¬éœ€è¦çš„æ˜¯åœ¨å½“å‰é¢œè‰²çš„æ‰€æœ‰ç‚¹å‰çš„å·²ç»æ‹¥æœ‰æ–°æƒå€¼çš„ç‚¹æ•°ç›®ï¼Œè¿™å¯ä»¥äº‹å…ˆé¢„å¤„ç†ã€‚é¢„å¤„ç†é¢œè‰²iå‰é¢œè‰²jçš„pairæ•°å³å¯ã€‚ ","date":"2019-10-05","objectID":"/2019/10/cf585e-marbles/:1:0","tags":null,"title":"[CF585E] Marbles","uri":"/2019/10/cf585e-marbles/"},{"categories":["code"],"content":"ä»£ç  ä¸å°å¿ƒæŠŠptræ‰”åˆ°äº†é‡Œå±‚å¾ªç¯é‡ŒTäº†å‘â€¦ æ˜æ˜ç¬¬ä¸€æ­¥å®Œäº‹éƒ½å¾ˆç›´ç™½äº†ï¼Œå°±æ˜¯éå¾—è¢«å¡ä¸€ä¸‹ã€‚ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ciomanip\u003e#include \u003cvector\u003e#include \u003cstack\u003e#include \u003ccstring\u003e#include \u003cstring\u003eusing namespace std; using ll=long long; const int MAXN = 400010; const int MAXC=21; int nlen; int num[MAXN]; vector\u003cint\u003e pos[MAXC]; ll cnt[MAXC][MAXC]; int tick=0; int newColor[MAXN]; ll dp[1\u003c\u003cMAXC]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003enlen; for(int i=0;i\u003cnlen;i++){ cin\u003e\u003enum[i]; } memset(newColor,-1,sizeof(newColor)); for(int i=0;i\u003cnlen;i++){ if(newColor[num[i]]==-1)newColor[num[i]]=tick++; pos[newColor[num[i]]].push_back(i); } for(int i=0;i\u003ctick;i++){ for(int j=0;j\u003ctick;j++){ if(i==j)continue; int ptr=0; for(int k=0;k\u003cpos[i].size();k++){ if(ptr\u003c0)ptr=0; while(ptr\u003cpos[j].size() \u0026\u0026 pos[j][ptr]\u003cpos[i][k])ptr++; ptr--; if(ptr\u003e=0 \u0026\u0026 pos[j][ptr]\u003cpos[i][k]){ cnt[i][j]+=ptr+1; } } } } memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=0;i\u003c(1\u003c\u003ctick);i++){ for(int j=0;j\u003ctick;j++){ if((i\u003e\u003ej)\u00261)continue; ll diff=0; for(int k=0;k\u003ctick;k++){ if((i\u003e\u003ek)\u00261)diff+=cnt[j][k]; } dp[i|(1\u003c\u003cj)]=min(dp[i|(1\u003c\u003cj)],dp[i]+diff); } } cout\u003c\u003cdp[(1\u003c\u003ctick)-1]\u003c\u003cendl; return 0; } ","date":"2019-10-05","objectID":"/2019/10/cf585e-marbles/:2:0","tags":null,"title":"[CF585E] Marbles","uri":"/2019/10/cf585e-marbles/"},{"categories":["code"],"content":"Monocarp and Bicarp live in Berland, where every bus ticket consists of n digits (n is an even number). During the evening walk Monocarp and Bicarp found a ticket where some of the digits have been erased. The number of digits that have been erased is even. Monocarp and Bicarp have decided to play a game with this ticket. Monocarp hates happy tickets, while Bicarp collects them. A ticket is considered happy if the sum of the first $\\frac n2$ digits of this ticket is equal to the sum of the last $\\frac n2$ digits. Monocarp and Bicarp take turns (and Monocarp performs the first of them). During each turn, the current player must replace any erased digit with any digit from 0 to 9. The game ends when there are no erased digits in the ticket. If the ticket is happy after all erased digits are replaced with decimal digits, then Bicarp wins. Otherwise, Monocarp wins. You have to determine who will win if both players play optimally. ","date":"2019-10-05","objectID":"/2019/10/cf585d-ticket-game/:0:0","tags":null,"title":"[CF585D] Ticket Game","uri":"/2019/10/cf585d-ticket-game/"},{"categories":["code"],"content":"åˆ†æ åœ¨åšè¿™é“é¢˜çš„æ—¶å€™ï¼Œæˆ‘å‘ç°äº†å®é™…ä¸Šå½±å“ç­”æ¡ˆçš„åªå’Œä¸¤è¾¹çš„ å·²çŸ¥æ•°çš„å’Œ ä»¥åŠæœªçŸ¥ä½çš„æ•°ç›®æœ‰å…³ï¼Œå‘ç°äº†è·èƒœçš„æ ¹æœ¬æ˜¯å‰åä¸¤éƒ¨åˆ†å’Œçš„å·®å€¼å¤§å°ï¼Œå‘ç°äº†å…ˆæ‰‹çš„ç›®çš„æ˜¯æ‰©å¤§å·®å€¼ä½¿å¾—åæ‰‹æ— æ³•é€šè¿‡æŸç§æ–¹å¼è¿½èµ¶ã€‚ ä½†æ˜¯åˆ°è¿™æˆ‘å°±å¡ä½äº†ã€‚æ·¦ï¼Œä¸ºä»€ä¹ˆæˆ‘è¿™ä¹ˆèœã€‚ æ¥ä¸‹æ¥è¦è€ƒè™‘çš„æ˜¯ä¼˜åŠ¿ï¼Œåœ¨è¿™é“é¢˜é‡Œä¼˜åŠ¿å°±æ˜¯å·®å€¼ã€‚å…ˆæ‰‹çš„ç›®çš„æ˜¯æ‰©å¤§ä¼˜åŠ¿ï¼Œåœ¨å¤§çš„ä¸€è¾¹å¢å¤§ä¼šåŠ å¤§ä¼˜åŠ¿ï¼Œè€Œåœ¨å°çš„ä¸€è¾¹ç½®0ä¸ä¼šæ‰©å¤§ä¼˜åŠ¿ï¼›åæ‰‹è¦å‡å°ä¼˜åŠ¿ï¼ŒåŒæ ·çš„åŠæ³•å°±æ˜¯åœ¨å°çš„ä¸€ä¾§ç½®æ•°æ¥è¿½èµ¶å¦ä¸€ä¾§ï¼Œåœ¨å¤§çš„ä¸€ä¾§ç½®0ä¸ä¼šæ›´å¥½ã€‚ é‚£ä¹ˆï¼Œåˆå¯ä»¥å¾—å‡ºå…ˆæ‰‹æ‰©å¤§ä¼˜åŠ¿æœ€å¥½çš„åŠæ³•æ˜¯ç½®9ï¼ˆæœ€å¤§ï¼‰ã€‚é‚£ä¹ˆæ¸¸æˆæœ€å¼€å§‹çš„å‡ æ­¥ï¼Œå°±æ˜¯åŒæ–¹åœ¨ä¸¤ä¾§å¡«å†™9ã€‚ç›´åˆ°æŸä¾§ä¸å†æœ‰ç©ºä½ã€‚ æ­¤æ—¶ï¼Œå¦‚æœç©ºä½åœ¨å¤§çš„ä¸€ä¾§ï¼Œå…ˆæ‰‹å¿…èµ¢ã€‚å¦‚æœç©ºä½åœ¨å°çš„ä¸€ä¾§ï¼Œç»§ç»­è®¨è®ºå¦‚ä¸‹ $$ x_1+x_2+\\cdots+x_n=C $$ é¦–å…ˆ$2|n$æ˜¾ç„¶ã€‚ å½“Cä¸æ˜¯9çš„å€æ•°æ—¶ï¼Œå…ˆæ‰‹æ€»æœ‰åŠæ³•è®©æœ€ç»ˆç»“æœåç¦»ã€‚å› æ­¤è¯¥æƒ…å†µåªæœ‰å½“$\\frac n2 \\times 9 = n$æ—¶åæ‰‹æ‰èƒ½è·èƒœã€‚ ","date":"2019-10-05","objectID":"/2019/10/cf585d-ticket-game/:1:0","tags":null,"title":"[CF585D] Ticket Game","uri":"/2019/10/cf585d-ticket-game/"},{"categories":["code"],"content":"ä»£ç  å«–äº†é˜Ÿå‹çš„â€¦æˆ‘çxxæçš„ç»“è®ºWA23äº†â€¦ #include\u003cbits/stdc++.h\u003eusing namespace std; char s[200005]; int main() { int n; scanf(\"%d\",\u0026n); scanf(\"%s\",s+1); int cnt=0; int sum=0; for(int i=1;i\u003c=n/2;i++) { if(s[i]==\u0026#039;?\u0026#039;) cnt++; else sum+=s[i]-\u0026#039;0\u0026#039;; } for(int i=n/2+1;i\u003c=n;i++) { if(s[i]==\u0026#039;?\u0026#039;) cnt--; else sum-=s[i]-\u0026#039;0\u0026#039;; } //cout\u003c\u003ccnt\u003c\u003c\" \"\u003c\u003csum\u003c\u003cendl; if(sum*2==-cnt*9) puts(\"Bicarp\"); else puts(\"Monocarp\"); } ","date":"2019-10-05","objectID":"/2019/10/cf585d-ticket-game/:2:0","tags":null,"title":"[CF585D] Ticket Game","uri":"/2019/10/cf585d-ticket-game/"},{"categories":["å­¦ä¹ "],"content":"å¦‚ä½ æ‰€è§ï¼Œåç¼€è‡ªåŠ¨æœºã€‚ ç„¶è€Œå°±nmçœ‹ä¸æ‡‚ï¼Œå…ˆçœ‹ä¸æ‡‚å®ƒçš„å›¾æ˜¯å•¥ï¼Œåˆçœ‹ä¸æ‡‚å®ƒçš„è¾¹æ˜¯å•¥ï¼Œç°åœ¨è¿˜æ˜¯çœ‹ä¸æ‡‚å®ƒçš„è¾¹æ˜¯å’‹æ‰¾å‡ºæ¥çš„ã€‚å¯æ˜¯å’±ä¸æƒ³æä¸æ¸…æ¥šå®ƒæ˜¯å¹²å˜›çš„å°±ç›´æ¥ç”¨å•Šé ã€‚ åç¼€è‡ªåŠ¨æœºé¦–å…ˆæ˜¯è‡ªåŠ¨æœºã€‚ä¸€ä¸ªå­—ç¬¦ä¸²Sçš„åç¼€è‡ªåŠ¨æœºèƒ½æ¥å—Sçš„æ‰€æœ‰åç¼€ã€‚åŸºäºå®ƒçš„è¿™ä¸ªæ€§è´¨ï¼Œå®ƒèƒ½å¤Ÿåšåˆ°ï¼š æŸ¥è¯¢å­ä¸²æ˜¯å¦å‡ºç°ï¼šè¿™æ˜¾ç„¶è·‘ä¸€æ¬¡ï¼Œèƒ½åœ¨è‡ªåŠ¨æœºä¸Šè·‘å®Œå°±æ˜¯å‡ºç°è¿‡ã€‚ ç»Ÿè®¡ä¸åŒå­ä¸²çš„æ•°é‡ï¼šè‡ªåŠ¨æœºä¸Šæ¯æ¡ä¸åŒçš„è·¯å¾„å¯¹åº”ä¸€ä¸ªä¸åŒçš„å­ä¸²ã€‚å®šä¹‰$d(x)$ä¸ºä»¥xä¸ºèµ·ç‚¹çš„è·¯å¾„æ•°ç›®ï¼Œé€’æ¨å³å¯ã€‚ è®¡ç®—æ‰€æœ‰ä¸åŒå­ä¸²çš„é•¿åº¦æ€»å’Œï¼šå¾—åˆ°ä¸Šé¢çš„$d$ã€‚ä»¥xä¸ºèµ·ç‚¹ï¼Œæ¯æ¡è·¯å¾„éƒ½ä¼šè®©å­ä¸²æ€»é•¿åº¦å¢åŠ è·¯å¾„ä¸ªã€‚ä¾ç„¶æ˜¯é€’æ¨ã€‚ å­—å…¸åºç¬¬kå°å­ä¸²ï¼šå½“ä½ æœ‰è·¯å¾„æ•°äº†ï¼Œåªéœ€è¦æŒ‰ç…§å­—å…¸åºå¯¹èŠ‚ç‚¹æ’åºï¼Œç„¶ååƒç¼–ç ä¸€æ ·æ‰¾ã€‚ æœ€å°å¾ªç¯ç§»ä½ï¼šæŒ‡å°†åŸå­—ç¬¦ä¸²é¦–å°¾ç›¸æ¥ç§»ä½ï¼Œæ‰¾åˆ°å­—å…¸åºæœ€å°çš„ä¸€ä¸ªã€‚å°†å­—ç¬¦ä¸²$S$æ–­ç¯æˆé“¾$SS$ï¼Œç„¶åå»ºç«‹SAMï¼Œè´ªå¿ƒæ‰¾æœ€å°ç›´åˆ°é•¿åº¦è¾¾åˆ°$|S|$å³å¯ã€‚ å¤šç»„å­ä¸²å‡ºç°æ¬¡æ•°ï¼šdfsé¢„å¤„ç†æ¯ä¸ªèŠ‚ç‚¹çš„ç»ˆç‚¹é›†åˆå¤§å°ã€‚åœ¨è‡ªåŠ¨æœºä¸ŠæŸ¥æ‰¾ä¸²$P$å¯¹åº”çš„èŠ‚ç‚¹,å­˜åœ¨åˆ™ç­”æ¡ˆä¸ºè¯¥èŠ‚ç‚¹çš„ç»ˆç‚¹é›†åˆå¤§å°ï¼›ä¸å­˜åœ¨ç­”æ¡ˆä¸º$0$. æ‰€æœ‰å‡ºç°ä½ç½®ï¼šéå†æ ‘ï¼Œä¸€æ—¦å‘ç°ç»ˆç‚¹ç›´æ¥è¾“å‡ºã€‚ ","date":"2019-10-04","objectID":"/2019/10/sam/:0:0","tags":null,"title":"åç¼€è‡ªåŠ¨æœº","uri":"/2019/10/sam/"},{"categories":["å­¦ä¹ "],"content":"å»ºç«‹ æœ€æš´åŠ›çš„æ–¹å¼æ˜¯å»ºç«‹ä¸€ä¸ªO(n^2)çº§åˆ«çš„è‡ªåŠ¨æœºï¼Œä¸è¿‡é‚£ä¸ªå¤æ‚åº¦å°±æ²¡ä»€ä¹ˆæ„ä¹‰äº†ã€‚åç¼€è‡ªåŠ¨æœºéœ€è¦æ»¡è¶³çŠ¶æ€æ•°æœ€å°‘ï¼Œä¸ºçº¿æ€§çº§åˆ«ï¼Œä¸”è½¬ç§»ï¼ˆè¾¹ï¼‰ä¹Ÿä¸ºçº¿æ€§çº§åˆ«ã€‚ ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹æŠ˜è…¾äº†ã€‚ å®šä¹‰ä¸²Sçš„$endpos(x)$ä¸ºä¸€ä¸ªé›†åˆï¼Œå…ƒç´ ä¸ºxåœ¨å…¶å†…å‡ºç°çš„æ‰€æœ‰ä½ç½®çš„ç»“å°¾ä¸‹æ ‡ã€‚ ","date":"2019-10-04","objectID":"/2019/10/sam/:1:0","tags":null,"title":"åç¼€è‡ªåŠ¨æœº","uri":"/2019/10/sam/"},{"categories":["å­¦ä¹ "],"content":"èµ„æ–™ å‚è€ƒèµ„æ–™ 2015å¹´å›½å®¶é›†è®­é˜Ÿè®ºæ–‡ ","date":"2019-10-04","objectID":"/2019/10/sam/:2:0","tags":null,"title":"åç¼€è‡ªåŠ¨æœº","uri":"/2019/10/sam/"},{"categories":["å­¦ä¹ "],"content":"å­ä¸²ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½® å¯¹SAMä¸­æ‰€æœ‰çŠ¶æ€é¢„å¤„ç†firstposï¼ˆç¬¬ä¸€æ¬¡å‡ºç°è¯¥çŠ¶æ€çš„æœ«ç«¯ä½ç½®ï¼Œä¹Ÿå°±æ˜¯endposé›†åˆçš„æœ€å°å…ƒç´ ï¼‰ã€‚ æ‰©å±•æºå‡½æ•°ä¸ºsam_extend()ã€‚åˆ›å»ºæ–°çŠ¶æ€curæ—¶ï¼Œä»¤ $$ firstpos(cur)=len(cur)-1 $$ å½“qå¤åˆ¶åˆ°cloneæ—¶ï¼Œä»¤ $$ firstpos(clone)=firstpos(q) $$ éœ€è¦çš„ç­”æ¡ˆå°±æ˜¯$firstpos(t)-|P|+1$ï¼Œ$t$ä¸ºå­—ç¬¦ä¸²$P$çš„çŠ¶æ€ã€‚æ¯æ¬¡æŸ¥è¯¢éœ€è¦$O(|P|)$ ","date":"2019-10-04","objectID":"/2019/10/sam/:2:1","tags":null,"title":"åç¼€è‡ªåŠ¨æœº","uri":"/2019/10/sam/"},{"categories":["å­¦ä¹ "],"content":"æœ€çŸ­æœªå‡ºç°å­—ç¬¦ä¸² åŠ¨æ€è§„åˆ’ã€‚ è®©$d_v$ä¸ºèŠ‚ç‚¹$v$çš„ç­”æ¡ˆã€‚å¦‚æœä¸å­˜åœ¨ä½¿ç”¨å­—ç¬¦é›†ä¸­è‡³å°‘ä¸€ä¸ªå­—ç¬¦çš„è½¬ç§»ï¼Œé‚£ä¹ˆ$d_v=1$ï¼Œå¦åˆ™ $$ d_v=1+\\min_{w:(v,w,c) \\in SAM} d_w $$ å­—ç¬¦ä¸²å¯ä»¥ç”±è½¬ç§»æ¨å›å»ã€‚ ","date":"2019-10-04","objectID":"/2019/10/sam/:2:2","tags":null,"title":"åç¼€è‡ªåŠ¨æœº","uri":"/2019/10/sam/"},{"categories":["code"],"content":"è®¾$primes(x)$ä¸ºxçš„è´¨å› æ•°çš„é›†åˆã€‚ è®¾$g(x,p)$è¡¨ç¤ºå¯ä»¥æ•´é™¤xçš„æœ€å¤§çš„$p^k$ã€‚ è®¾$f(x,y)$è¡¨ç¤ºå°†xä½œåˆ†è§£åå¯¹æ¯ä¸ªè´¨å› å­ä½œç”¨åˆ°1åˆ°yä¸Šæ±‚$g$çš„ä¹˜ç§¯ã€‚ æ±‚$f(x,n)$ ","date":"2019-09-30","objectID":"/2019/09/cf589c-primes-and-multiplication/:0:0","tags":null,"title":"[CF589C] primes and multiplication","uri":"/2019/09/cf589c-primes-and-multiplication/"},{"categories":["code"],"content":"åˆ†æ â€¦â€¦æœ€åä½ ä¼šå‘ç°ï¼Œè¿™é¢˜å°±æ˜¯æ±‚é˜¶ä¹˜è´¨å› å­çš„ä¹˜ç§¯ã€‚ ","date":"2019-09-30","objectID":"/2019/09/cf589c-primes-and-multiplication/:1:0","tags":null,"title":"[CF589C] primes and multiplication","uri":"/2019/09/cf589c-primes-and-multiplication/"},{"categories":["code"],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003ccmath\u003eusing namespace std; const int MAXN=1010; using ll=long long; const ll P=1e9+7; vector\u003cll\u003e primes; void unpack(ll x){ ll b=x; for(int i=2;i\u003c=sqrt(b)+1;i++){ if(x%i==0)primes.push_back(i); while(x%i==0)x/=i; } if(x!=1)primes.push_back(x); } ll qpow(ll a,ll b,ll p){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%p){ if(b\u00261)res=res*a%p; } return res; } ll get(ll n,ll num){ ll res=0; while(n){ res=(res+n/num)%(P-1); n/=num; } return res; } int main(){ ios::sync_with_stdio(false); ll x,n;cin\u003e\u003ex\u003e\u003en; unpack(x); ll ans=1; for(ll item:primes){ ans=ans*qpow(item,get(n,item),P)%P; } cout\u003c\u003cans%P\u003c\u003cendl; return 0; } ","date":"2019-09-30","objectID":"/2019/09/cf589c-primes-and-multiplication/:2:0","tags":null,"title":"[CF589C] primes and multiplication","uri":"/2019/09/cf589c-primes-and-multiplication/"},{"categories":["code"],"content":"ç»™å‡ºä¸€äº›ç‚¹ï¼Œè¯¢é—®å¯¹äºç‚¹$(x,y)$ï¼Œæ±‚å…¶èƒ½å’Œå·²çŸ¥ç‚¹å½¢æˆå¤šå°‘ä¸ªç›´è§’ä¸‰è§’å½¢ã€‚ ","date":"2019-09-29","objectID":"/2019/09/ccpc2019-qinhuangdao-angel-beats/:0:0","tags":["è®¡ç®—å‡ ä½•"],"title":"[CCPC2019 ç§¦çš‡å²›] Angel Beats","uri":"/2019/09/ccpc2019-qinhuangdao-angel-beats/"},{"categories":["code"],"content":"åˆ†æ é¦–å…ˆï¼Œå¯¹äºè¯¢é—®çš„ç‚¹ï¼Œç›´æ¥åŠ å…¥é›†åˆç¦»çº¿æ“ä½œå°±å¯ä»¥ã€‚è¿™é“é¢˜å°±å˜æˆäº†å•çº¯çš„æ±‚ä¸‰è§’å½¢ã€‚ä¸€å¼€å§‹æˆ‘è·Ÿæ±‚é”è§’ä¸‰è§’å½¢é‚£é“é¢˜ä¸€æ ·åšï¼Œç„¶åå†™å¾—åˆæ¶å¿ƒåˆä¸çŸ¥é“å“ªé‡Œå‡ºäº†bugæ”¹ä¸å‡ºæ¥ã€‚ åæ¥ï¼Œå®é™…ä¸Šå¯ä»¥äº‹å…ˆç›´æ¥æšä¸¾2ç‚¹æŒ‰ç…§æ–œç‡ç»Ÿè®¡è¾¹æ•°ï¼Œå¯¹æ¯ä¸ªæŸ¥è¯¢$lg(n^2)$æŸ¥è¯¢ï¼Œä¼šçœå¾ˆå¤šäº‹ã€‚ ä¹‹åçš„å°±æ˜¯å¾ˆæ˜¾ç„¶çš„ï¼šæŸ¥è¯¢ç‚¹ä½œä¸ºç›´è§’æ‰«ä¸€éï¼ŒæŸ¥è¯¢ç‚¹ä½œä¸ºéç›´è§’æ‰«ä¸€éã€‚ ","date":"2019-09-29","objectID":"/2019/09/ccpc2019-qinhuangdao-angel-beats/:1:0","tags":["è®¡ç®—å‡ ä½•"],"title":"[CCPC2019 ç§¦çš‡å²›] Angel Beats","uri":"/2019/09/ccpc2019-qinhuangdao-angel-beats/"},{"categories":["code"],"content":"ä»£ç  æ·¦ã€‚ #include \u003ciostream\u003e#include \u003cmap\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; using ll = long long; const int MAXN = 2010; struct Point { ll x, y; Point(ll x, ll y) : x(x), y(y){}; Point(){} Point normalize() const { if (x \u003c 0 || (x == 0 \u0026\u0026 y \u003c 0)) return Point(-x, -y); return *this; } Point operator-(const Point \u0026other) const { return Point(x - other.x, y - other.y); } bool operator\u003c(const Point \u0026other) const { //å°†çº¿æŒ‰ç…§æ–œç‡æ’åºï¼Œä»¥åœ¨mapä¸­ç»Ÿè®¡åˆ°ä¸€èµ·ã€‚ Point a = normalize(), b = other.normalize(); return a.y * b.x \u003c b.y * a.x; } }; using Vec = Point; Point origin[MAXN],queries[MAXN]; int ans[MAXN]; map\u003cVec,int\u003e mp; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int nlen, qlen; while (cin \u003e\u003e nlen \u003e\u003e qlen) { memset(ans,0,sizeof(ans)); for (int i = 0; i \u003c nlen; i++) { cin\u003e\u003eorigin[i].x\u003e\u003eorigin[i].y; } for (int i = 0; i \u003c qlen; i++) { cin\u003e\u003equeries[i].x\u003e\u003equeries[i].y; } for (int i = 0; i \u003c nlen; i++) { mp.clear(); for (int j = 0; j \u003c nlen; j++) { if (i == j) continue; Vec temp = origin[j] - origin[i]; mp[temp]++; } for (int j = 0; j \u003c qlen; j++) { Vec temp = queries[j] - origin[i]; ans[j] += mp[Vec(-temp.y, temp.x)]; } } /* cout\u003c\u003c\"====not====\"\u003c\u003cendl; for(int i=0;i\u003cqlen;i++){ cout\u003c\u003cans[i]\u003c\u003c\"\\t\"; } cout\u003c\u003cendl\u003c\u003c\"====not====\"\u003c\u003cendl; */ for (int i = 0; i \u003c qlen; i++) { mp.clear(); for (int j = 0; j \u003c nlen; j++) { Vec temp = origin[j] - queries[i]; ans[i] += mp[Vec(-temp.y, temp.x)]; mp[temp]++; } } for (int i = 0; i \u003c qlen; i++) { cout \u003c\u003c ans[i] \u003c\u003c \"\\n\"; } } return 0; } ","date":"2019-09-29","objectID":"/2019/09/ccpc2019-qinhuangdao-angel-beats/:2:0","tags":["è®¡ç®—å‡ ä½•"],"title":"[CCPC2019 ç§¦çš‡å²›] Angel Beats","uri":"/2019/09/ccpc2019-qinhuangdao-angel-beats/"},{"categories":["code"],"content":"Petya recently found a game â€œChoose a Squareâ€. In this game, there areÂ nnÂ points numbered fromÂ 11Â toÂ nnÂ on an infinite field. TheÂ ii-th point has coordinatesÂ (xi,yi)Â and costÂ ci. You have to choose a square such that its sides are parallel to coordinate axes, the lower left and upper right corners belong to the lineÂ y=x, and all corners have integer coordinates. The score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square. Note that the length of the side can be zero. Petya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square. {% asset_img a.png %} ","date":"2019-09-23","objectID":"/2019/09/cf1221f-choose-a-sequence/:0:0","tags":null,"title":"[CF1221F] Choose a Sequence","uri":"/2019/09/cf1221f-choose-a-sequence/"},{"categories":["code"],"content":"åˆ†æ è¿™é“é¢˜å…¶å®å’Œå¤šæ ¡çš„Snowy Smileï¼ˆé¢˜æ–‡æ— å…³ï¼‰æŒºåƒçš„ã€‚ éœ€è¦è½¬åŒ–æ¡ä»¶ã€‚æ­£æ–¹å½¢å…¨éƒ¨ä½äºåæ ‡ç³»ç¬¬ä¸€è±¡é™çš„å¹³åˆ†çº¿ä¸Šï¼Œå¯ä»¥è¡¨ç¤ºä¸º$(l,r)$è¿™ç§å½¢å¼ã€‚ä¸€ä¸ªåœ¨æ­£æ–¹å½¢å†…çš„ç‚¹$(x,y)$(å‡è®¾$x \u003c y$,ç”±äºè¿™ä¸ªé¢˜ç›®çš„ç‰¹æ€§ï¼Œä¸æ»¡è¶³æ—¶å¯ä»¥ç›´æ¥è°ƒæ¢)æ»¡è¶³çš„æ¡ä»¶ä¸º $$l \\leq x \\leq y \\leq r$$ ç”±æ­¤ï¼Œè¿™é“é¢˜å°±å˜æˆäº†äºŒç»´ååºã€‚æœ¬æ¥çš„æœ¬æ¥ï¼Œä¸Šä¸ªé•¿å¾—åƒæ ‘çŠ¶æ•°ç»„ä¸€ç±»çš„ä¸œè¥¿å°±è§£å†³äº†ã€‚ å°†ç‚¹æŒ‰ç…§ç¬¬ä¸€ç»´æ’åºï¼Œä»å¤§åˆ°å°æšä¸¾ï¼Œåœ¨æ•°æ®ç»“æ„ä¸­ç»´æŠ¤ç»“å°¾åˆ°rçš„å‰ç¼€å’Œæœ€å¤§å€¼ï¼Œå¹¶æŸ¥è¯¢ï¼Œæ›´æ–°å…¨å±€ç­”æ¡ˆã€‚ä¸è¿‡è¿™ä¸ªé¢˜ç›®è¿˜è¦æ±‚æƒå€¼è¦å‡å»æ­£æ–¹å½¢è¾¹é•¿wã€‚ $$f(r)-(r-l)=l+[f(r)-r]$$ ç»´æŠ¤æœ€å¤§å€¼ï¼Œyåˆ†å¼€ï¼Œåªåœ¨pushupæ—¶åˆåœ¨ä¸€èµ·ã€‚ ç„¶åè¿˜è¦ç¦»æ•£åŒ–â€¦â€¦ ","date":"2019-09-23","objectID":"/2019/09/cf1221f-choose-a-sequence/:1:0","tags":null,"title":"[CF1221F] Choose a Sequence","uri":"/2019/09/cf1221f-choose-a-sequence/"},{"categories":["code"],"content":"ä»£ç  è¿™é¢˜ç»™æˆ‘æ•´è‡ªé—­äº†ï¼Œæˆ‘æƒ³ç”¨çº¿æ®µæ ‘å•ç‚¹ä¿®æ”¹æ¥é­”å¹»ç»´æŠ¤æˆ‘éœ€è¦çš„æ•°æ®ï¼ŒåŠ åŠ å‡å‡ã€‚ç»“æœå‘ç°2ç§ç»´æŠ¤æ–¹å¼éƒ½æœ‰æ— æ³•è§£å†³çš„é—®é¢˜ã€‚æœ€ååªèƒ½æ‰“tagã€‚ çº¿æ®µæ ‘ç»´æŠ¤$f(n)$ä¸ºåˆ°$n$ä¸ºæ­¢çš„å‰ç¼€å’Œã€‚æ¯æ¬¡åŠ ç‚¹ä»¥$x$ä¸ºç»„ï¼Œå¯¹å·²æœ‰ç‚¹å‡å»æ–°å¢çº¿æ®µçš„é•¿åº¦ï¼Œå†åŠ ä¸Šæ–°ç‚¹çš„å½±å“ã€‚é‚£ä¹ˆåœ¨çº¿æ®µæ ‘ä¸Šç»´æŠ¤çš„å°±æ˜¯ç­”æ¡ˆã€‚å–å‡ºæœ€å¤§å€¼å³å¯ã€‚ ä»£ç å†™å¾—åˆé•¿åˆä¸‘ï¼Œä¸è¿‡è¿‡äº†ã€‚ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; using ll=long long; const int MAXN=500010*4; ll tag[MAXN]; ll dMax[MAXN]; int dy[MAXN]; int lc[MAXN],rc[MAXN],idx=0; void build(int \u0026n,int l,int r){ if(!n)n=++idx; dy[n]=r; if(l\u003e=r){ tag[n]=0; return; } int mid=(l+r)/2; build(lc[n],l,mid); build(rc[n],mid+1,r); } void pushdown(int n,int l,int r){ if(!tag[n])return; tag[lc[n]]+=tag[n]; tag[rc[n]]+=tag[n]; dMax[lc[n]]+=tag[n]; dMax[rc[n]]+=tag[n]; tag[n]=0; } void collect(int n){ if(dMax[lc[n]]\u003edMax[rc[n]]){ dMax[n]=dMax[lc[n]]; dy[n]=dy[lc[n]]; }else{ dMax[n]=dMax[rc[n]]; dy[n]=dy[rc[n]]; } } void modify(int l,int r,int x,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ tag[n]+=x; dMax[n]+=x; return; } pushdown(n,L,R); int mid=(L+R)/2; if(l\u003c=mid)modify(l,r,x,L,mid,lc[n]); if(mid\u003cr)modify(l,r,x,mid+1,R,rc[n]); collect(n); } bool operator\u003c(const pair\u003cll,int\u003e \u0026a,const pair\u003cll,int\u003e \u0026b){ return a.first\u003cb.first; } pair\u003cll,int\u003e query(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ return make_pair(dMax[n],dy[n]); } pushdown(n,L,R); int mid=(L+R)/2; pair\u003cll,int\u003e res=make_pair(-0x3f3f3f3f,0); if(l\u003c=mid)res=max(res,query(l,r,L,mid,lc[n])); if(mid\u003cr)res=max(res,query(l,r,mid+1,R,rc[n])); return res; } struct Point{ int x,y,w; } points[MAXN]; vector\u003cint\u003e nums; int root=0; int main(){ /* build(root,1,10); int opt; while(cin\u003e\u003eopt){ if(opt==1){ int l,r,x;cin\u003e\u003el\u003e\u003er\u003e\u003ex; modify(l,r,x,1,10,root); } if(opt==2){ int l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003cquery(l,r,1,10,root).first\u003c\u003c\" \"\u003c\u003cquery(l,r,1,10,root).second\u003c\u003cendl; } } */ int nlen;cin\u003e\u003enlen; for(int i=1;i\u003c=nlen;i++){ Point \u0026p=points[i]; cin\u003e\u003ep.x\u003e\u003ep.y\u003e\u003ep.w; if(p.x\u003ep.y)swap(p.x,p.y); nums.push_back(p.y); nums.push_back(p.x); } sort(nums.begin(),nums.end()); auto rit=unique(nums.begin(),nums.end()); for(int i=1;i\u003c=nlen;i++){ points[i].x=lower_bound(nums.begin(),rit,points[i].x)-nums.begin(); points[i].y=lower_bound(nums.begin(),rit,points[i].y)-nums.begin(); } sort(points+1,points+1+nlen,[](const Point \u0026a,const Point \u0026b){ if(a.x!=b.x)return a.x\u003eb.x; return a.y\u003cb.y; }); int len=rit-nums.begin()-1; build(root,0,len); vector\u003cint\u003e::iterator lastit=rit-1; pair\u003cll,int\u003e ans=make_pair(-0x3f3f3f3f,0); int pairl=-0x3f3f3f3f; for(int i=1;i\u003c=nlen;i++){ int thisx=points[i].x; //auto it=lower_bound(nums.begin(),rit,points[i].x); auto it=nums.begin()+thisx; for(;lastit!=it;lastit--){ modify(lastit-nums.begin(),len,*(lastit-1)-*lastit,0,len,root); //cout\u003c\u003c\"cost \"\u003c\u003c*(lastit-1)-*lastit\u003c\u003c\" from \"\u003c\u003clastit-nums.begin()\u003c\u003c\" to \"\u003c\u003clen\u003c\u003cendl; } /* for(int j=0;j\u003c=len;j++){ cout\u003c\u003cquery(j,j,0,len,root).first\u003c\u003c\"\\t\"; } cout\u003c\u003cendl; */ while(i\u003c=nlen \u0026\u0026 points[i].x==thisx){ const Point \u0026p=points[i]; modify(p.y,len,p.w,0,len,root); //cout\u003c\u003c\"add \"\u003c\u003cp.w\u003c\u003c\" from \"\u003c\u003cp.y\u003c\u003c\" to \"\u003c\u003clen\u003c\u003cendl; i++; } i--; /* for(int j=0;j\u003c=len;j++){ auto temp2=query(j,j,0,len,root); cout\u003c\u003ctemp2.first\u003c\u003c\",\"\u003c\u003ctemp2.second\u003c\u003c\"\\t\"; } cout\u003c\u003cendl; */ pair\u003cll,int\u003e temp=query(0,len,0,len,root); if(ans\u003c=temp){ ans=temp; pairl=nums[thisx]; } } if(ans.first\u003e0){ cout\u003c\u003cans.first\u003c\u003cendl; cout\u003c\u003cpairl\u003c\u003c\" \"\u003c\u003cpairl\u003c\u003c\" \"\u003c\u003cnums[ans.second]\u003c\u003c\" \"\u003c\u003cnums[ans.second]\u003c\u003cendl; }else{ cout\u003c\u003c0\u003c\u003cendl; cout\u003c\u003c*nums.rbegin()+1\u003c\u003c\" \"\u003c\u003c*nums.rbegin()+1\u003c\u003c\" \"\u003c\u003c*nums.rbegin()+1\u003c\u003c\" \"\u003c\u003c*nums.rbegin()+1\u003c\u003cendl; } return 0; } ","date":"2019-09-23","objectID":"/2019/09/cf1221f-choose-a-sequence/:2:0","tags":null,"title":"[CF1221F] Choose a Sequence","uri":"/2019/09/cf1221f-choose-a-sequence/"},{"categories":["é—²æ‰¯"],"content":"Mathematicaæ˜¯ä¸ªå¥½ä¸œè¥¿ã€‚è™½ç„¶æ—©æœ‰è€³é—»åŠŸèƒ½å¼ºå¤§ï¼Œä½†æ˜¯æ²¡æƒ³åˆ°å¼ºå¤§åˆ°è¿™ç§åœ°æ­¥ã€‚ åŸæœ¬å› ä¸ºè¯¾ç¨‹åŸå› ï¼Œç ”ç©¶äº†ä¸€ä¸‹å¦‚ä½•åœ¨Mathematicaé‡Œç»˜åˆ¶è‚¡ç¥¨æ•°æ®ã€‚ä¸è¿‡ç°åœ¨åœæ­¢ï¼Œåªå®Œæˆäº†ä¸€å°éƒ¨åˆ†ã€‚å‰©ä¸‹çš„â€¦â€¦æƒ³æŠ˜è…¾çš„è¯ï¼ŒæŒ‰ç…§å·²ç»æœ‰çš„ä»£ç ï¼Œèƒ½å®¹æ˜“æ”¹å‡ºæ¥å…¶ä»–åŠŸèƒ½ã€‚ ","date":"2019-09-20","objectID":"/2019/09/mathematica-in-stocks/:0:0","tags":null,"title":"ä½¿ç”¨Mathematicaç»˜åˆ¶è‚¡ç¥¨ç›¸å…³æ›²çº¿","uri":"/2019/09/mathematica-in-stocks/"},{"categories":["é—²æ‰¯"],"content":"æ•°æ®æ¥æº é¦–å…ˆè¦è¯´çš„æ˜¯ï¼ŒMathematicaä¸­è‡ªè¡Œæä¾›äº†éæƒå¨çš„é‡‘èæ•°æ®ã€‚è¿™å¯¹æˆ‘ä»¬å¾ˆæ–¹ä¾¿ã€‚ ä½¿ç”¨å‘½ä»¤FinancialData,å°±å¯ä»¥è·å–å¤§é‡éœ€è¦çš„æ•°æ®ã€‚å…·ä½“å¯ä»¥æŸ¥çœ‹æ–‡æ¡£ã€‚ä¸è¿‡é—®é¢˜æ˜¯ï¼Œä¸çŸ¥ä½•ç§åŸå› ï¼Œè¯¥å‡½æ•°å¯¹æ·±æ²ªè‚¡ç¥¨æ”¯æŒå¾ˆå·®ï¼Œæ‰€ä»¥åœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œå¹¶ä¸èƒ½ç›´æ¥ä½¿ç”¨è¯¥å‡½æ•°ï¼Œæ¯”è¾ƒå¯æƒœâ€¦â€¦ æˆ‘ä»¬éœ€è¦å®ç°è‡ªå·±çš„æ•°æ®å¤„ç†ã€‚ ç»è¿‡ä¸€ç•ªå¯»æ‰¾åï¼Œæˆ‘å‘ç°äº†ä¸€ä¸ªåŸºäºPythonçš„è¯åˆ¸æ•°æ®å¹³å°baostockã€‚ç»è¿‡ç®€å•çš„å°è£…åï¼ŒMathematicaå°±å¯ä»¥ä½¿ç”¨Pythonä»å¹³å°ä¸Šæ‹‰å–æ•°æ®äº†ã€‚ è¿™ä¸ªä¾‹å­åªèƒ½æ‹‰å–æ—¥Kã€‚ BeginPackage[\"StockLink`\"]StockLink::usage=\"StockLink\";CloseLink::usage=\"CloseLink\";DailyKLine::usage=\"Get KLine data\";CandlestickData::usage=\"adjust KLine data to fit Candlestick Chart\";TradingChartData::usage=\"adjust KLine data to fit Trading Chart\";Begin[\"`Private`\"]StockLink[]:=Module[{conn},conn=StartExternalSession[\"Python\"];ExternalEvaluate[conn,\"importbaostockasbslg=bs.login()\"];conn];CloseLink[conn_]:=Module[{},ExternalEvaluate[conn,\"bs.logout()\"];DeleteObject[conn];];MMAListToPythonList[list_]:=StringReplace[ToString[list,InputForm],{\"\\\"\"-\u003e\"'\",\"{\"-\u003e\"[\",\"}\"-\u003e\"]\"}];DateObjectToStr[date_]:=DateString[date,\"ISODate\"];DailyKLine[conn_,code_,startDate_,endDate_]:=Module[{},raw=ExternalEvaluate[conn,StringTemplate[\"rs=bs.query_history_k_data_plus('``','date,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,isST',start_date='``',end_date='``',frequency='d',adjustflag='3')data_list={}while(rs.error_code=='0')\u0026rs.next():temp=rs.get_row_data()data_list[temp[0]]=temp[1:];data_list\"][code,DateObjectToStr[startDate],DateObjectToStr[endDate]]];ToExpression[#]\u0026/@raw];CandlestickData[raw_]:=Table[{DateObject[key],raw[key][[1;;4]]},{key,Keys[raw]}];TradingChartData[raw_]:=Table[{DateObject[key],raw[key][[1;;5]]},{key,Keys[raw]}];End[]EndPackage[] ","date":"2019-09-20","objectID":"/2019/09/mathematica-in-stocks/:1:0","tags":null,"title":"ä½¿ç”¨Mathematicaç»˜åˆ¶è‚¡ç¥¨ç›¸å…³æ›²çº¿","uri":"/2019/09/mathematica-in-stocks/"},{"categories":["é—²æ‰¯"],"content":"å›¾è¡¨ç»˜åˆ¶ åœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œé¦–å…ˆéœ€è¦å¯¼å…¥è¯¥åº“ï¼Œå¹¶ä¸”åˆå§‹åŒ–é“¾æ¥åï¼Œçµæ´»ç»„åˆå„éƒ¨åˆ†åŠŸèƒ½å³å¯ã€‚ \u003c\u003c(NotebookDirectory[]\u003c\u003e\"StockLink.wl\");conn=StockLink[];(:ä¾‹å¦‚è·å–æŸä¸ªæ—¥æœŸåŒºé—´å†…çš„æ•°æ®å¹¶è½¬åŒ–ï¼Œç»˜åˆ¶äº¤äº’å›¾æ ‡:)DailyKLine[conn,\"ss.000001\",Today,Today]//TradingChartData//InteractiveTradingChart è¾“å…¥æ—¥æœŸæ—¶ï¼Œå¯ä»¥ç›´æ¥æŒ‰ctrl+=ï¼Œåœ¨æ¡†ä¸­æè¿°æ—¶é—´ï¼Œæ¯”è¾ƒæ–¹ä¾¿ã€‚ ","date":"2019-09-20","objectID":"/2019/09/mathematica-in-stocks/:2:0","tags":null,"title":"ä½¿ç”¨Mathematicaç»˜åˆ¶è‚¡ç¥¨ç›¸å…³æ›²çº¿","uri":"/2019/09/mathematica-in-stocks/"},{"categories":["é—²æ‰¯"],"content":"å¯èƒ½é‡åˆ°çš„é—®é¢˜ å¦‚æœpythoné…ç½®ä¸å¯¹çš„è¯ï¼Œå¯èƒ½ä¼šå‡ºç°Mathematicaæ‰¾ä¸åˆ°pythonã€‚é—®é¢˜çš„è§£å†³æ–¹æ³•åœ¨å®˜æ–¹æ–‡æ¡£ä¸Šéå¸¸æ¸…æ™°ã€‚ ä¸è¿‡æˆ‘ä¸æŠ˜è…¾è‚¡ç¥¨ï¼Œå°±è¿™æ ·äº†ã€‚ ","date":"2019-09-20","objectID":"/2019/09/mathematica-in-stocks/:3:0","tags":null,"title":"ä½¿ç”¨Mathematicaç»˜åˆ¶è‚¡ç¥¨ç›¸å…³æ›²çº¿","uri":"/2019/09/mathematica-in-stocks/"},{"categories":["å­¦ä¹ "],"content":"æŠ€å·§ ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:1:0","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"è‡ªç„¶æº¢å‡º è‡ªç„¶æº¢å‡ºä¸ä¼šå½±å“ä½ä½æ•°æ®,æ‰€ä»¥æœ‰çš„æ—¶å€™ä½ ä¸éœ€è¦å–æ¨¡,è€Œæ˜¯ä¸€ä¸ªunsigned. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:1:1","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"é™¤æ³•å–æ¨¡ å¯¹äºå¼å­ $$ \\frac {a \\times b}{c} \\mod p \\equiv \\frac{a \\times b \\mod cp}{c} $$ ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:1:2","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"ç»†èŠ‚ æ³¨æ„æ•°æ®ç±»å‹,ä¾‹å¦‚6*(ll)(1\u003c\u003c30)æ˜¯è¦å‡ºé—®é¢˜çš„ æ³¨æ„å‡½æ•°åœ¨$f(1)$ä½ç½®çš„å–å€¼,ä¸è¦å¿˜è®°åˆå§‹åŒ– ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:2:0","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"å•ç‚¹$\\phi$çš„æ±‚è§£ ll euler_phi(ll n) { ll m = sqrt(n + 0.5); ll ans = n; for (ll i = 2; i \u003c= m; i++) if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } if (n \u003e 1) ans = ans / n * (n - 1); return ans; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:3:0","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"Divisor Given $n$ and $m$ ($1 \\leq n,m \\leq 5 \\times 10^4$), please calculate ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:4:0","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ ä¸‹é¢æ‰€æœ‰çš„é™¤æ³•éƒ½æ˜¯èˆå»å°æ•°çš„æ•´é™¤. $$ \\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) \u0026= \\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}[p \\perp q] \\\\ \u0026=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d|(p,q)}\\mu(d) \\\\ \u0026=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d}\\mu(d)[d|p][d|q] \\\\ \u0026=\\sum_d \\mu(d)\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{pd} \\sum_{qd}[pd|i][qd|j] \\\\ \u0026=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd}\\sum_{i=1}^{n/pd}\\sum_{j=1}^{m/qd} \\\\ \u0026=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd} \\frac n {pd}\\frac m {qd} \\\\ \u0026=\\sum_d \\mu(d) \\sum_p^{n/d} \\frac n {pd} \\sum_q^{m/d} \\frac m {qd} \\\\ \\end{aligned} $$ è®¾$S(n)=\\sum_{1\\leq i \\leq n} \\frac n i$ $$ \\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) \u0026=\\sum_d \\mu(d)S(n/d)S(m/d) \\end{aligned} $$ $n/d$çš„å–å€¼åœ¨ä¸€ä¸ªåŒºé—´ä¸­æ˜¯ç›¸åŒçš„,å› æ­¤å¯ä»¥æŠŠè¿™ä¸ªæ±‚å’Œå…¬å¼åˆ†å—è®¡ç®—.(åœ¨åˆ†å—å,éœ€è¦è·çŸ¥è¯¥æ®µåŒºåŸŸå†…$\\mu$çš„å’Œ,æ‰€ä»¥éœ€è¦æ±‚å‰ç¼€å’Œ)ç”±äº$n/d$çš„å–å€¼ä¸º$O(\\sqrt n)$çš„çº§åˆ«,å› æ­¤åœ¨çŸ¥é“$S$çš„å€¼çš„æƒ…å†µä¸‹,æ¯ä¸ªè¯¢é—®å¯ä»¥è¿™ä¸ªå¤æ‚åº¦ä¸­è®¡ç®—å‡ºæ¥. å¯¹äº$\\mu$,ä½¿ç”¨ç­›æ³•,å¹¶æ±‚å‡ºå…¶å‰ç¼€å’Œ. å¯¹äº$S$,ç›´æ¥æš´åŠ›è®¡ç®—. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:4:1","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; using ll=long long; const int MAXN=50010; bool isn_p[MAXN]; vector\u003cint\u003e primes; int mu[MAXN]; int premu[MAXN]; void init_prime(int len){ isn_p[1]=1; mu[1]=1; for(int i=2;i\u003c=len;i++){ if(!isn_p[i]){ primes.push_back(i); mu[i]=-1; } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=len;j++){ isn_p[i*primes[j]]=1; mu[i*primes[j]]=mu[i]*-1; if(i%primes[j]==0){ mu[i*primes[j]]=0; break; } } } premu[0]=0; for(int i=1;i\u003c=len;i++)premu[i]=premu[i-1]+mu[i]; } ll S[MAXN]; void init_S(int len){ for(int i=1;i\u003c=len;i++){ for(int l=1,r;l\u003c=i;l=r+1){ //remember this line r=i/(i/l); S[i]+=(ll)(r-l+1)*(i/l); } } } int main(){ ios::sync_with_stdio(false); init_prime(50000); init_S(50000); int kase;cin\u003e\u003ekase; while(kase--){ int n,m;cin\u003e\u003en\u003e\u003em; ll ans=0; // the minimum one will fastly approach to 0, leading the extra parts of bigger one do nothing to the answer. int minn=min(n,m); for(int l=1,r;l\u003c=minn;l=r+1){ r=min(n/(n/l),m/(m/l)); ans+=S[n/l]*S[m/l]*(premu[r]-premu[l-1]); } cout\u003c\u003cans\u003c\u003cendl; } return 0; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:4:2","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"table ç»™å‡ºå¤šç»„$n,m,a$,æ±‚ $$ \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j))[\\sigma_1((i,j)) \\geq a] $$ ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:5:0","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ è¿™é“é¢˜è®©è°éƒ½èƒ½çœ‹å‡ºæ¥é‡ç‚¹æ˜¯å¦‚ä½•å¤„ç†æ¡ä»¶ $$[\\sigma_1((i,j)) \\geq a]$$ å¯æ˜¯è¿™æˆ‘æ˜¾ç„¶ä¸çŸ¥é“è¯¥æ€ä¹ˆåš. å¯¹è¯¢é—®ä½œä»¥$a$ä»å°åˆ°å¤§ç¦»çº¿å¤„ç†,è¯¢é—®å‰å…ˆå¤„ç†æ–°å¢$a$çš„å½±å“. åœ¨å·²ç»æ»¡è¶³æ¡ä»¶çš„å‰æä¸‹å¯¹å…¬å¼ä½œåŒ–ç®€. $$ \\begin{aligned} \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j)) \u0026= \\sum_d \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1(d)[(i,j)=d] \\\\ \u0026=\\sum_d \\sum_{i\\leq \\frac nd}\\sum_{j\\leq \\frac md}\\sigma_1(d)[(i,j)=1] \\\\ \u0026=\\sum_d \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}}\\sigma_1(d) \\sum_t \\mu(t) \\\\ \u0026=\\sum_d \\sum_t \\mu(t) \\sigma_1(d) \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}} 1 \\\\ \u0026=\\sum_T \\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor \\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td) \\end{aligned} $$ å¯ä»¥çœ‹åˆ°è¿˜æ˜¯å¥—è·¯,å¼•å…¥d,å¼•å…¥$\\mu$,ä¹‹åèƒ¡ä¹±åŒ–ç®€. æŒ‰ç…§è¿™ä¸ªå¼å­,éœ€è¦è®¡ç®—çš„å°±æ˜¯$g(x)=\\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)$çš„å‰ç¼€å’Œ. æ¥ä¸‹æ¥æ˜¯å¦‚ä½•å¤„ç†æ¡ä»¶â€¦ å½“$a$æ¯æ‰©å¤§ä¸€ç‚¹,å°±æœ‰ä¸€éƒ¨åˆ†$\\mu(t)\\sigma_1(\\frac Td)$è¢«åŠ å…¥åˆ°å‡½æ•°$g$çš„å„ä¸ªéƒ¨åˆ†.ä½¿ç”¨ä¸€ç§æ•°æ®ç»“æ„æ¥ç»´æŠ¤$g$çš„å‰ç¼€å’Œ,ä¾‹å¦‚æ ‘çŠ¶æ•°ç»„.$a$æœ€å¤§åˆ°,æ¯æ¬¡å—åˆ°å½±å“çš„å°±æ˜¯$d$çš„å€æ•°,ä»¥æ­¤å¯ä»¥è®¡ç®—å‡ºæ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $$ WTF $$ è‡³æ­¤,é—®é¢˜å°±è§£å†³äº†. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:5:1","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  åˆä¸‘åˆé•¿. #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003eusing namespace std; using ll=long long; const int MAXN=100010; const int MAXQ=100010; const int MAXFT=400010; const ll P=(ll)1\u003c\u003c31; ll FT[MAXFT]; ll lowbit(int x){ return x\u0026-x; } void ftadd(int pos,ll x){ for(int i=pos;i\u003cMAXN;i+=lowbit(i)){ FT[i]=(FT[i]+x); } } ll ftget(int pos){ ll res=0; for(int i=pos;i;i-=lowbit(i)){ res=(res+FT[i]); } return res; } ll qpow(ll a,ll b,ll p){ ll res=1; for(b;b;b\u003e\u003e=1,a=(a*a)%p){ if(b\u00261)res=(res*a)%p; } return res; } ll qpow(ll a,ll b){ ll res=1; for(b;b;b\u003e\u003e=1,a=(a*a)){ if(b\u00261)res=(res*a); } return res; } bool is_np[MAXN]; ll sigma[MAXN],mu[MAXN]; int t[MAXN]; vector\u003cint\u003e primes; struct Sig{ ll sigma; int x; Sig(){} Sig(int x,ll sigma):x(x),sigma(sigma){} }; vector\u003cSig\u003e sigma_vec; void init(int n){ is_np[1]=1; sigma[1]=1; mu[1]=1; for(int i=2;i\u003c=n;i++){ if(!is_np[i]){ primes.push_back(i); sigma[i]=i+1; t[i]=1; mu[i]=-1; } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=n;j++){ is_np[i*primes[j]]=1; sigma[i*primes[j]]=sigma[i]*sigma[primes[j]]; t[i*primes[j]]=1; mu[i*primes[j]]=mu[i]*-1; if(i%primes[j]==0){ t[i*primes[j]]=t[i]+1; sigma[i*primes[j]]=sigma[i/qpow(primes[j],t[i])]*((ll)1-qpow(primes[j],(t[i]+1)+1))/(1-primes[j]); mu[i*primes[j]]=0; break; } } } for(int i=1;i\u003c=n;i++){ sigma_vec.push_back(Sig(i,sigma[i])); } } struct Q{ int n,m,a; int i; ll ans; bool operator\u003c(const Q \u0026b)const{ return a\u003cb.a; } } qs[MAXQ]; ll f(int n){ return ftget(n); } int curidx=0; void mergea(int newa){ for(;curidx\u003csigma_vec.size();curidx++){ Sig \u0026sig=sigma_vec[curidx]; if(sig.sigma\u003enewa)break; for(int i=sig.x;i\u003cMAXN;i+=sig.x){ ftadd(i,mu[i/sig.x]*sig.sigma%P); } } } int main(){ init(100000); sort(sigma_vec.begin(),sigma_vec.end(),[](Sig \u0026a,Sig \u0026b){ return a.sigma\u003cb.sigma; }); int qlen;cin\u003e\u003eqlen; for(int i=0;i\u003cqlen;i++){ Q \u0026q=qs[i]; scanf(\"%d%d%d\",\u0026q.n,\u0026q.m,\u0026q.a); q.i=i; } sort(qs,qs+qlen,[](Q \u0026a,Q \u0026b){ return a.a\u003cb.a; }); for(int i=0;i\u003cqlen;i++){ Q \u0026q=qs[i]; int n=q.n,m=q.m,a=q.a; ll \u0026ans=q.ans=0; mergea(a); for(int l=1,r;l\u003c=min(n,m);l=r+1){ r=min(n/(n/l),m/(m/l)); ans=ans+(n/l)*(m/l)*(f(r)-f(l-1)); } } sort(qs,qs+qlen,[](Q \u0026a,Q \u0026b){ return a.i\u003cb.i; }); for(int i=0;i\u003cqlen;i++){ printf(\"%lld\\n\",qs[i].ans%P); } return 0; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:5:2","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"product å®šä¹‰æ–æ³¢çº³å¦¾(?)(linuxè¿™è¾“å…¥æ³•å¤Ÿé­”æ€§)å‡½æ•°$f(x)$ æ±‚ $$ \\prod_{i=1}^n \\prod_{j=1}^m f((i,j)) $$ ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:6:0","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ é¦–å…ˆ,å…ˆå¼•ä¸ª$d$æ˜¯æ²¡é”™äº†. ä½†æ˜¯ è¿™é“é¢˜,æˆ‘åˆä¸ä¼š.æˆ‘ä¸çŸ¥é“è¯¥æ€ä¹ˆå¤„ç†$\\prod$â€¦è”¡å°±å®Œäº‹äº†. ç°åœ¨æ¥çœ‹,å½“å¼•å…¥ä¸€ä¸ª$d$å,åœ¨è¯¥æ±‚ç§¯å…¬å¼é‡Œå‡ºç°äº†ç›¸åŒé¡¹ç›¸ä¹˜.å°†è¯¥éƒ¨åˆ†çš„è®¡ç®—è°ƒæ•´ä¸ºå¹‚,å‰©ä¸‹çš„å°±åˆéƒ½ä¸€æ ·äº†. $$ \\begin{aligned} \\prod_{i=1}^n \\prod_{j=1}^m f((i,j)) \u0026= \\prod_d f(d)^{\\sum_{i\\leq n} \\sum_{j \\leq m} [(i,j)=d]} \\\\ \u0026=\\prod_d f(d)^{\\sum_{i\\leq \\frac nd} \\sum_{j \\leq \\frac md} [(i,j)=1]} \\\\ \u0026=\\prod_d f(d)^{\\sum_t \\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\ \u0026=\\prod_d \\prod_t f(d)^{\\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\ \u0026=\\prod_T (\\prod_{d|T} f(d)^{\\mu(\\frac Tt)})^{\\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor } \\end{aligned} $$ è®¾$g(x)=\\prod_{d|T} f(d)^{\\mu(\\frac Tt)}$,æ±‚å‰ç¼€å’Œå°±å®Œäº‹äº†. è¿™é“é¢˜éœ€è¦ä½¿ç”¨æ¬§æ‹‰å®šç†æ¥ä¼˜åŒ–æ±‚å¹‚çš„é€Ÿåº¦. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:6:1","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"æ¬§æ‹‰å®šç† å½“$(a,p)=1$,æœ‰ä»¥ä¸‹å¼å­ $$ a^b \\equiv a^{b \\mod \\phi(p)} \\pmod p $$ å½“$(a,p)\\neq 1$,æœ‰æ‰©å±•æ¬§æ‹‰å®šç† $$ a^b \\equiv a^{b \\mod \\phi(p)+ \\phi(p)} \\pmod p $$ æ ¹æ®è¿™2ä¸ªå¼å­,å¯ä»¥åœ¨å¿«é€Ÿé™å¹‚,æ¥åŠ å¿«è¿ç®—. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:6:2","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=1000010; const ll P=1e9+7; inline ll qpow(ll a,ll b,ll p){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%p){ if(b\u00261)res=res*a%p; } return res; } inline ll get_inv(ll a,ll p){ return qpow(a,p-2,p); } bool is_np[MAXN]; vector\u003cint\u003e primes; ll f[MAXN], g[MAXN]; ll inv_f[MAXN]; ll preg[MAXN],inv_pg[MAXN]; ll mu[MAXN]; void init(int n){ is_np[1]=1; mu[1]=1; for(int i=2;i\u003c=n;i++){ if(!is_np[i]){ primes.push_back(i); mu[i]=-1; } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=n;j++){ is_np[i*primes[j]]=1; mu[i*primes[j]]=mu[i]*-1; if(i%primes[j]==0){ mu[i*primes[j]]=0; break; } } } f[1]=f[2]=1; for(int i=3;i\u003c=n;i++){ f[i]=(f[i-1]+f[i-2])%P; } for(int i=1;i\u003c=n;i++){ inv_f[i]=get_inv(f[i],P); } for(int i=1;i\u003c=n;i++)g[i]=1; for(int i=1;i\u003c=n;i++){ for(int j=i;j\u003c=n;j+=i){ if(mu[j/i]==-1)g[j]=(g[j]*inv_f[i])%P; else if(mu[j/i]==1)g[j]=(g[j]*f[i])%P; //when mu==0,nothing happens } } preg[0]=1; for(int i=1;i\u003c=n;i++)preg[i]=preg[i-1]*g[i]%P; inv_pg[0]=1; for(int i=1;i\u003c=n;i++)inv_pg[i]=get_inv(preg[i],P)%P; } int main(){ init(1000000); //cout\u003c\u003c\"done\"\u003c\u003cendl; /* for(auto i:primes){ cout\u003c\u003ci\u003c\u003c\" \"; } cout\u003c\u003cendl; for(int i=1;i\u003c=20;i++){ cout\u003c\u003cg[i]\u003c\u003c\" \"; } cout\u003c\u003cendl; */ int kase; scanf(\"%d\",\u0026kase); while(kase--){ ll n,m; scanf(\"%d%d\",\u0026n,\u0026m); if(n\u003em)swap(n,m); ll ans=1; for(ll l=1,r;l\u003c=n;l=r+1){ r=min(n/(n/l),m/(m/l)); ll sum=preg[r]*inv_pg[l-1]%P; ans=ans*qpow(sum,(n/l)*(m/l)%(P-1),P)%P; } printf(\"%lld\\n\",ans); } return 0; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:6:3","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"phi3 ç»™å‡º$n$,æ±‚ $$ (\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n \\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)} \\phi((i,j,k))) \\mod 2^{30} $$ ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:7:0","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"åˆ†æ è¿™é“é¢˜é‡ç‚¹åœ¨äº $$\\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)}$$ è¿™å †ä¸œè¥¿çš„åŒ–ç®€.å¾ˆæ˜¾ç„¶,æˆ‘åˆä¸ä¼š. è§‚å¯Ÿ$\\phi(n)$çš„å…¬å¼ $$ \\phi(n)=n\\prod_i(1-\\frac 1{\\phi(i)}) $$ å¯ä»¥å¾—å‡ºä¸Šé¢é‚£ä¸€å †ç­‰äº$jk^2$.å‰©ä¸‹çš„å°±åˆéƒ½ä¸€æ ·äº†. $$ \\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi((i,j,k)) \u0026=\\sum_d\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi(d)[(i,j,k)=d] \\\\ \u0026=\\sum_d \\sum_{t} \\phi(d) \\mu(t) t^3d^3 \\sum_{i\\leq \\frac n{td}}\\sum_{j \\leq \\frac n{td}}\\sum_{k \\leq \\frac n{td}} jk^2 \\\\ \u0026=\\sum_T \\sum_{i\\leq \\frac nT}\\sum_{j \\leq \\frac nT} j\\sum_{k \\leq \\frac nT}k^2 (T^3 \\sum_{d|T} \\phi(d) \\mu(\\frac Td)) \\end{aligned} $$ è®¾$g(n)=\\sum_{d|T} \\phi(d) \\mu(\\frac Td)$,ç›´æ¥ç­›.æœ€åè®¡ç®—å‰ç¼€å’Œçš„æ—¶å€™å†ä¹˜ä¸Š$n^3$å°±å¯ä»¥äº†. è¿™é“é¢˜çš„å–æ¨¡è¿˜æœ‰è¿™ç§å¤„ç†æ–¹æ³•: ç›´æ¥å–æ•°ç»„ä¸ºunsignedå¹¶è‡ªç„¶æº¢å‡º.äºŒè¿›åˆ¶å30ä½ä¸ä¼šå—åˆ°å½±å“. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:7:1","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cstring\u003e#include \u003cvector\u003eusing namespace std; using ull=unsigned long long; using ll=long long; const int MAXN=10000010; const unsigned P=1\u003c\u003c30; bool isnp[MAXN]; vector\u003cint\u003e primes; int t[MAXN],M[MAXN]; unsigned Mt[MAXN]; unsigned g[MAXN]; ll preg[MAXN]; void init(int n){ isnp[1]=1; g[1]=1; for(int i=2;i\u003c=n;i++){ if(!isnp[i]){ primes.push_back(i); g[i]=i-1-1; t[i]=1; M[i]=Mt[i]=i; } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=n;j++){ int newone=i*primes[j]; isnp[newone]=1; g[newone]=g[i]*g[primes[j]]%P; t[newone]=1; M[newone]=Mt[newone]=primes[j]; if(i%primes[j]==0){ t[newone]=t[i]+1; Mt[newone]=Mt[i]*primes[j]%P; g[newone]=g[i/Mt[i]]*(Mt[newone]+Mt[i]/primes[j]-2*Mt[i])%P; break; } } } for(int i=1;i\u003c=n;i++){ preg[i]=preg[i-1]+(ll)i*i%P*i%P*g[i]%P; preg[i]%=P; } } int main(){ init(10000000); int kase; scanf(\"%d\",\u0026kase); while(kase--){ int n; scanf(\"%d\",\u0026n); ll ans=0; for(int l=1,r;l\u003c=n;l=r+1){ r=n/(n/l); ull lim=n/l; ull sum1=lim*(lim+1)%(2*P)/2; ull sum2=lim*(lim+1)%(6*P)*(2*lim+1)%(6*P)/6; ans=ans+lim*sum1%P*sum2%P*(preg[r]-preg[l-1])%P; } printf(\"%lld\\n\",ans%P); } return 0; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:7:2","tags":null,"title":"ä¸€äº›ç­›æ³•çš„é¢˜","uri":"/2019/09/some-sieve/"},{"categories":["code"],"content":"You are given a string S consisting of only lowercase english letters and some queries. For each query (l,r,k), please output the starting position of the k-th occurence of the substring SlSl+1â€¦Sr in S. ","date":"2019-08-25","objectID":"/2019/08/hdu-6704-kth-occurrence/:0:0","tags":null,"title":"[HDU 6704] Kth Occurrence","uri":"/2019/08/hdu-6704-kth-occurrence/"},{"categories":["code"],"content":"åˆ†æ ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯å¿«é€Ÿæ‰¾å‡ºæ‰€æœ‰å‡ºç°çš„å­ä¸²çš„ä½ç½®,å¯ä»¥ä½¿ç”¨åç¼€æ•°ç»„.è¿™äº›å­—ä¸²å‡ºç°åœ¨saçš„ä¸€ä¸ªè¿ç»­çš„åŒºé—´ä¸­. ç¬¬äºŒä¸ªé—®é¢˜æ˜¯æ‰¾å‡ºè¿™äº›å‡ºç°ä½ç½®ä¸­çš„ç¬¬kå¤§,å¯ä»¥ä½¿ç”¨ä¸»å¸­æ ‘,ä»¥saå»ºæ ‘. ","date":"2019-08-25","objectID":"/2019/08/hdu-6704-kth-occurrence/:1:0","tags":null,"title":"[HDU 6704] Kth Occurrence","uri":"/2019/08/hdu-6704-kth-occurrence/"},{"categories":["code"],"content":"ä»£ç  æ€è·¯æ¸…æ™°,ä½†è¿™ä»£ç å®ƒä¸å¥½å†™ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003cstring\u003e#include \u003ccstdlib\u003e#include \u003ccmath\u003eusing namespace std; const int MAXN=100060; using ull=unsigned long long; int n; int sa[MAXN], x[MAXN], c[MAXN], y[MAXN]; char a[MAXN]; inline void SA() { int m = 128; for (int i = 0; i \u003c= m; i++) c[i] = 0; for (int i = 1; i \u003c= n; i++) c[x[i]]++; for (int i = 1; i \u003c= m; i++) c[i] += c[i - 1]; for (int i = n; i; i--) sa[c[x[i]]--] = i; for (int k = 1, p; k \u003c= n; k \u003c\u003c= 1) { p = 0; for (int i = n; i \u003e n - k; i--) y[++p] = i; for (int i = 1; i \u003c= n; i++) if (sa[i] \u003e k) y[++p] = sa[i] - k; for (int i = 0; i \u003c= m; i++) c[i] = 0; for (int i = 1; i \u003c= n; i++) c[x[i]]++; for (int i = 1; i \u003c= m; i++) c[i] += c[i - 1]; for (int i = n; i; i--) sa[c[x[y[i]]]--] = y[i]; p = y[sa[1]] = 1; for (int i = 2, a, b; i \u003c= n; i++) { a = sa[i] + k \u003e n ? -1 : x[sa[i] + k]; b = sa[i - 1] + k \u003e n ? -1 : x[sa[i - 1] + k]; y[sa[i]] = (x[sa[i]] == x[sa[i - 1]]) \u0026\u0026 (a == b) ? p : ++p; } swap(x, y); m = p; } } int tot; int sum[(MAXN \u003c\u003c 5) + 10], rt[MAXN + 10], ls[(MAXN \u003c\u003c 5) + 10], rs[(MAXN \u003c\u003c 5) + 10]; int build(int l, int r) //å»ºæ ‘ { int root = ++tot; if (l == r) return root; int mid = l + r \u003e\u003e 1; ls[root] = build(l, mid); rs[root] = build(mid + 1, r); return root; //è¿”å›è¯¥å­æ ‘çš„æ ¹èŠ‚ç‚¹ } int update(int k, int l, int r, int root) //æ’å…¥æ“ä½œ { int dir = ++tot; ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + 1; if (l == r) return dir; int mid = l + r \u003e\u003e 1; if (k \u003c= mid) ls[dir] = update(k, l, mid, ls[dir]); else rs[dir] = update(k, mid + 1, r, rs[dir]); return dir; } //left root, right root, querying l,r, the k-th int query(int u, int v, int l, int r, int k) //æŸ¥è¯¢æ“ä½œ { int mid = l + r \u003e\u003e 1, x = sum[ls[v]] - sum[ls[u]]; //é€šè¿‡åŒºé—´å‡æ³•å¾—åˆ°å·¦å„¿å­çš„ä¿¡æ¯ if (l == r){ return l; } if (k \u003c= x) //è¯´æ˜åœ¨å·¦å„¿å­ä¸­ return query(ls[u], ls[v], l, mid, k); else //è¯´æ˜åœ¨å³å„¿å­ä¸­ return query(rs[u], rs[v], mid + 1, r, k - x); } int height[MAXN]; int st[20][MAXN]; inline void get_height() { int k = 0; for (int i = 1; i \u003c= n; ++i) { if (x[i] == 1) continue; if (k) --k; int j = sa[x[i] - 1]; while (j + k \u003c= n \u0026\u0026 i + k \u003c= n \u0026\u0026 a[i + k] == a[j + k]) ++k; height[x[i]] = k; } } void build_st() { for (int i = 1; i \u003c= n; i++) st[0][i] = height[i]; for (int k = 1; k \u003c= 19; k++) { for (int i = 1; i + (1 \u003c\u003c k) - 1 \u003c= n; i++) { st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 \u003c\u003c k - 1)]); } } } int lcp(int ll, int rr) { int l = x[ll], r = x[rr]; if (l \u003e r) swap(l, r); if (l == r) return n - sa[l]+1; int t = log2(r - l); return min(st[t][l + 1], st[t][r - (1 \u003c\u003c t) + 1]); } int main(){ int kase;cin\u003e\u003ekase; while(kase--){ int nlen,qlen;cin\u003e\u003enlen\u003e\u003eqlen; scanf(\"%s\",a+1); for(int i=0;i\u003cMAXN;i++)x[i]=a[i]; n=nlen; SA(); n=nlen; get_height(); build_st(); /* for(int i=1;i\u003c=nlen;i++)cout\u003c\u003csa[i]\u003c\u003c\" \"; cout\u003c\u003cendl; for(int i=1;i\u003c=nlen;i++)cout\u003c\u003cx[i]\u003c\u003c\" \"; cout\u003c\u003cendl; */ tot=0; memset(sum,0,sizeof(sum)); rt[0] = build(1, nlen); for (int i = 1; i \u003c= n; ++i) rt[i] = update(sa[i], 1, nlen, rt[i - 1]); while(qlen--){ int ql,qr,qk; scanf(\"%d%d%d\",\u0026ql,\u0026qr,\u0026qk); int sublen=qr-ql+1; int ex_l,ex_r; //binary search { int l=1,r=x[ql]; while(r-l\u003e1){ int mid=(l+r)/2; if(lcp(sa[mid], ql) \u003e= sublen){ r=mid; }else l=mid+1; } for(l;l\u003c=r;l++){ if(lcp(sa[l], ql) \u003e= sublen){ ex_l=l; break; } } } { int l=x[ql],r=nlen; while(r-l\u003e1){ int mid=(l+r)/2; if(lcp(sa[mid], ql) \u003e= sublen){ l=mid; }else r=mid-1; } for(r;r\u003e=l;r--){ if(lcp(sa[r], ql) \u003e= sublen){ ex_r=r; break; } } } //cout\u003c\u003cex_l\u003c\u003c\" \"\u003c\u003cex_r\u003c\u003cendl; if(ex_r-ex_l+1\u003cqk){ cout\u003c\u003c-1\u003c\u003cendl; } else cout\u003c\u003cquery(rt[ex_l - 1], rt[ex_r], 1, nlen, qk)\u003c\u003cendl; } } return 0; } ","date":"2019-08-25","objectID":"/2019/08/hdu-6704-kth-occurrence/:2:0","tags":null,"title":"[HDU 6704] Kth Occurrence","uri":"/2019/08/hdu-6704-kth-occurrence/"},{"categories":["code"],"content":"You are given an array a1,a2,â€¦,an(âˆ€iâˆˆ[1,n],1â‰¤aiâ‰¤n). Initially, each element of the array is unique. Moreover, there are m instructions. Each instruction is in one of the following two formats: (1,pos),indicating to change the value of apos to apos+10,000,000; (2,r,k),indicating to ask the minimum value which is not equal to any ai ( 1â‰¤iâ‰¤r ) and **not less ** than k. Please print all results of the instructions in format 2. ","date":"2019-08-24","objectID":"/2019/08/a-wonderful-bug/:0:0","tags":null,"title":"è®°ä¸€ä¸ªbug (HDU 6703)","uri":"/2019/08/a-wonderful-bug/"},{"categories":["code"],"content":"åˆ†æ è¿™é¢˜å¼ºåˆ¶åœ¨çº¿.é¦–å…ˆ1æ“ä½œç›¸å½“äºåˆ é™¤äº†è¿™ä¸ªæ•°. dalaoè‡ªé—­äº†ä¸€ä¼šgetåˆ°äº†å®ƒçš„æ­£ç¡®åšæ³•,æˆ‘å°±ç›´æ¥æ‹¿æ¥ç”¨äº†. ç»´æŠ¤ä¸€æƒå€¼çº¿æ®µæ ‘,ä½ç½®iå­˜å…¶åœ¨aä¸­å‡ºç°çš„ä½ç½®.é‚£ä¹ˆå½“1åˆ°råŒºé—´å†…å‡ºç°ä½ç½®çš„æœ€å¤§å€¼è¶…è¿‡äº†r,æ ¹æ®é¸½å·¢åŸç†,è‡³å°‘æœ‰ä¸€ä¸ªæ•°æœªè¢«é™åˆ¶. åŠ ä¸Šä¸å°äºkçš„æ¡ä»¶,å°±æ˜¯kåˆ°rä¸­,æ‰¾åˆ°æœ€å°çš„ä¸€ä¸ªr,ä½¿å¾—å®ƒæ»¡è¶³ä¸Šé¢çš„æ¡ä»¶,è¾“å‡ºè¿™ä¸ªr. ","date":"2019-08-24","objectID":"/2019/08/a-wonderful-bug/:1:0","tags":null,"title":"è®°ä¸€ä¸ªbug (HDU 6703)","uri":"/2019/08/a-wonderful-bug/"},{"categories":["code"],"content":"ä»£ç  ä¸€ä¸ªå¥‡è‘©çš„bugâ€¦ å½“ä½¿ç”¨äº†freadè¿™ç§å…ˆè¯»å®Œç¼“å†²åŒºå†å¤„ç†çš„å¿«é€Ÿè¯»å…¥è€Œåˆ æ¼äº†cinæ—¶â€¦ä¼šæ˜¾è€Œæ˜“è§çš„é‡åˆ°bug. ä½†æ˜¯,å› ä¸ºç¼“å†²åŒºçš„å­˜åœ¨,å°èŒƒå›´æ•°æ®è¢«å¿«ä¹çš„è¯»å…¥äº†ç¼“å†²åŒº,cinå¹¶ä¸ä¼šå®é™…å½±å“ä»€ä¹ˆ.ä¸€æ—¦é‡åˆ°å¤§èŒƒå›´æ•°æ®,cinæå‰è¯»å…¥äº†æ¥ä¸‹æ¥çš„æ•°æ®,å¯¼è‡´ç¬¬ä¸€ä¸ªç¼“å†²åŒºä¹‹å¤–çš„æ•°æ®å…¨éƒ¨å‡ºé”™â€¦ è‰¹. #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; const int MAXN = 400000; namespace IO { const int MAXSIZE = 1 \u003c\u003c 20; char buf[MAXSIZE], *p1, *p2; #define gc() \\ (p1 == p2 \u0026\u0026 (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++) inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == '-') f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f; } char pbuf[1 \u003c\u003c 20], *pp = pbuf; inline void push(const char \u0026c) { if (pp - pbuf == 1 \u003c\u003c 20) fwrite(pbuf, 1, 1 \u003c\u003c 20, stdout), pp = pbuf; *pp++ = c; } inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } } // namespace IO /////////////////////////////////////////////////////////////////////////////////////// int dat[MAXN]; int a[MAXN]; int lc[MAXN], rc[MAXN], idx = 0; inline int imax(int a,int b){ if(a\u003eb)return a; return b; } void collect(int n) { dat[n] = max(dat[lc[n]], dat[rc[n]]); } int build(int \u0026n, int l, int r) { if (!n) n = ++idx; dat[n] = a[l]; if (l == r) return dat[n]; int mid = (l + r) / 2; return dat[n] = imax(build(lc[n], l, mid), build(rc[n], mid + 1, r)); } void modify(int x, int l, int r, int L, int R, int n) { if (l \u003c= L \u0026\u0026 R \u003c= r) { dat[n] = x; return; } int mid = (L + R) / 2; if (l \u003c= mid) modify(x, l, r, L, mid, lc[n]); if (mid \u003c r) modify(x, l, r, mid + 1, R, rc[n]); collect(n); } int query(int l, int r,int target, int L, int R, int n) { if(L\u003er || R\u003cl || dat[n]\u003c=target)return -1; if(L==R)return L; int mid = (L + R) / 2; int res=query(l,r,target,L,mid,lc[n]); return ~res?res:query(l,r,target,mid+1,R,rc[n]); } int root; int num[MAXN]; int main() { int kase=IO::rd(); while (kase--) { int nlen, qlen; nlen=IO::rd(); qlen=IO::rd(); for (int i = 1; i \u003c= nlen; i++) { num[i] = IO::rd(); a[num[i]] = i; } build(root, 1, nlen); int lastans = 0; while (qlen--) { int opt=IO::rd(); if (opt == 1) { int pos=IO::rd(); pos ^= lastans; if(num[pos]==0 || num[pos]\u003enlen)continue; modify(0x3f3f3f3f, num[pos], num[pos], 1, nlen, root); } else { int t2, t3; t2=IO::rd(); t3=IO::rd(); //cin \u003e\u003e t2 \u003e\u003e t3; int r = t2 ^ lastans, k = t3 ^ lastans; int t=query(k,nlen,r,1,nlen,root); cout\u003c\u003c(lastans=(~t?t:nlen+1))\u003c\u003cendl; } } } return 0; } ","date":"2019-08-24","objectID":"/2019/08/a-wonderful-bug/:2:0","tags":null,"title":"è®°ä¸€ä¸ªbug (HDU 6703)","uri":"/2019/08/a-wonderful-bug/"},{"categories":["code"],"content":"å†…å®¹æœ‰å¤åˆ¶å’Œå‚è€ƒã€‚ è¿™ç¯‡æ–‡ç« ä¸»è¦ç”¨äºè®°å½•åœ¨æ¢ç´¢è¯„æµ‹ç³»ç»ŸReefæœŸé—´æˆ‘æ‰€å­¦çš„ä¸œè¥¿,ä»¥ä¾¿ä¹‹åæŸ¥é˜…. Reefé¢„è®¡ä¸»è¦æ”¯æŒè¿œç¨‹è¯„æµ‹ åŠ ä¸€ç‚¹æœ¬åœ°è¯„æµ‹â€¦.. ç»“æœä¸»è¦çš„ä¸œè¥¿éƒ½ç‰¹ä¹ˆæ˜¯æœ¬åœ°è¯„æµ‹çš„. ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:0:0","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"æ€»ä½“æ¶æ„ Reefé¢„è®¡å°†é‡‡ç”¨seccompä½œä¸ºç¬¬ä¸€é“å®‰å…¨å…³å¡,ä½¿ç”¨å¤šçº¿ç¨‹æ£€æµ‹ç¨‹åºè€—æ—¶/å†…å­˜ç­‰ä¿¡æ¯. åœ¨å¤–å±‚ä½¿ç”¨dockerå°è£…å¹¶å†æ¬¡é™åˆ¶èµ„æº,æ¥å…¥é˜Ÿåˆ—ä»¥èƒ½å¤Ÿæ–¹ä¾¿çš„æ¨ªå‘æ‰©å±•. ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:1:0","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"seccomp seccompä¸ºlinuxç³»ç»Ÿä¸Šæ‰æœ‰çš„å®‰å…¨æŠ€æœ¯,å› æ­¤å¿…é¡»ä½¿ç”¨linux.åœ¨å®‰è£…å¿…è¦çš„å®‰è£…åŒ…å $ sudo apt install libseccomp2 libseccomp-dev seccomp å³å¯ä½¿ç”¨. å½“ç„¶,åœ¨windowsä¸‹çš„Jobsä¼¼ä¹ä¹Ÿå¯ä»¥åˆ©ç”¨,ä½†æ˜¯æˆ‘ä¸å¤ªæ‡‚,å¾®è½¯æ–‡æ¡£å†™å¾—ä¹Ÿå¥‡æ€ª,è€Œä¸”è¿˜å¾—æ˜¯æœåŠ¡å™¨ç‰ˆæœ¬çš„windowsæ‰èƒ½ç”¨. ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:0","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"åŸºæœ¬ä½¿ç”¨ seccompéœ€è¦ç”±ç¨‹åºä¸»åŠ¨åŠ è½½.å…¶ä½¿ç”¨æ–¹æ³•åŸºæœ¬ä¸ºä¸‹ //g++ -g test.c -o o -lseccomp #include \u003cunistd.h\u003e#include \u003cseccomp.h\u003e#include \u003clinux/seccomp.h\u003e int main(void){ //åˆå§‹åŒ–ç­›é€‰å™¨ scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW);//flagæŒ‡æ˜é»˜è®¤é€šè¿‡ //æ·»åŠ æ‹¦æˆª,å¹¶æŒ‡æ˜ä¸€æ—¦æ‹¦æˆªå°±å°†ç¨‹åºkillæ‰. seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); //å°†è§„åˆ™åŠ è½½æ³¨å…¥. seccomp_load(ctx); char * filename = \"/bin/sh\"; char * argv[] = {\"/bin/sh\",NULL}; char * envp[] = {NULL}; write(1,\"i will give you a shell\\n\",24); //ç¨‹åºå°†ä¼šåœ¨æ­¤è¡Œå´©æºƒ. syscall(59,filename,argv,envp);//execve return 0; } seccomp_initæ˜¯åˆå§‹åŒ–çš„è¿‡æ»¤çŠ¶æ€,è¿™é‡Œç”¨çš„æ˜¯SCMP_ACT_ALLOW,è¡¨ç¤ºé»˜è®¤å…è®¸æ‰€æœ‰çš„syscacll.å¦‚æœåˆå§‹åŒ–çŠ¶æ€ä¸ºSCMP_ACT_KILL,åˆ™è¡¨ç¤ºé»˜è®¤ä¸å…è®¸æ‰€æœ‰çš„syscall. /** * Kill the process */ #define SCMP_ACT_KILL 0x00000000U /** * Throw a SIGSYS signal */ #define SCMP_ACT_TRAP 0x00030000U /** * Return the specified error code */ #define SCMP_ACT_ERRNO(x) (0x00050000U | ((x) \u0026 0x0000ffffU)) /** * Notify a tracing process with the specified value */ #define SCMP_ACT_TRACE(x) (0x7ff00000U | ((x) \u0026 0x0000ffffU)) /** * Allow the syscall to be executed after the action has been logged */ #define SCMP_ACT_LOG 0x7ffc0000U /** * Allow the syscall to be executed */ #define SCMP_ACT_ALLOW 0x7fff0000U è§„åˆ™æ·»åŠ  /** * Add a new rule to the filter * @param ctx the filter context * @param action the filter action * @param syscall the syscall number * @param arg_cnt the number of argument filters in the argument filter chain * @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended) * * This function adds a series of new argument/value checks to the seccomp * filter for the given syscall; multiple argument/value checks can be * specified and they will be chained together (AND\u0026#039;d together) in the filter. * If the specified rule needs to be adjusted due to architecture specifics it * will be adjusted without notification. Returns zero on success, negative * values on failure. * */ int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, ...); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);,arg_cntä¸º0,è¡¨ç¤ºç›´æ¥é™åˆ¶execve,ä¸ç®¡ä»–ä»€ä¹ˆå‚æ•°. å¦‚æœarg_cntä¸ä¸º0,é‚£arg_cntè¡¨ç¤ºåé¢é™åˆ¶çš„å‚æ•°çš„ä¸ªæ•°,ä¹Ÿå°±æ˜¯åªæœ‰è°ƒç”¨execve,ä¸”å‚æ•°æ»¡è¶³è¦æ±‚æ—¶,æ‰ä¼šæ‹¦æˆªsyscall. seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write),1,SCMP_A2(SCMP_CMP_EQ,0x10));//ç¬¬2(ä»0)ä¸ªå‚æ•°ç­‰äº0x10 /** * Specify an argument comparison struct for use in declaring rules * @param arg the argument number, starting at 0 * @param op the comparison operator, e.g. SCMP_CMP_* * @param datum_a dependent on comparison * @param datum_b dependent on comparison, optional */ #define SCMP_CMP(...) ((struct scmp_arg_cmp){__VA_ARGS__}) /** * Specify an argument comparison struct for argument 0 */ #define SCMP_A0(...) SCMP_CMP(0, __VA_ARGS__) /** * Specify an argument comparison struct for argument 1 */ #define SCMP_A1(...) SCMP_CMP(1, __VA_ARGS__) /** * Specify an argument comparison struct for argument 2 */ #define SCMP_A2(...) SCMP_CMP(2, __VA_ARGS__) /** * Specify an argument comparison struct for argument 3 */ #define SCMP_A3(...) SCMP_CMP(3, __VA_ARGS__) /** * Specify an argument comparison struct for argument 4 */ #define SCMP_A4(...) SCMP_CMP(4, __VA_ARGS__) /** * Specify an argument comparison struct for argument 5 */ #define SCMP_A5(...) SCMP_CMP(5, __VA_ARGS__) /** * Comparison operators */ enum scmp_compare { _SCMP_CMP_MIN = 0, SCMP_CMP_NE = 1, /**\u003c not equal */ SCMP_CMP_LT = 2, /**\u003c less than */ SCMP_CMP_LE = 3, /**\u003c less than or equal */ SCMP_CMP_EQ = 4, /**\u003c equal */ SCMP_CMP_GE = 5, /**\u003c greater than or equal */ SCMP_CMP_GT = 6, /**\u003c greater than */ SCMP_CMP_MASKED_EQ = 7, /**\u003c masked equality */ _SCMP_CMP_MAX, }; /** * Argument datum */ typedef uint64_t scmp_datum_t; /** * Argument / Value comparison definition */ struct scmp_arg_cmp { unsigned int arg; /**\u003c argument number, starting at 0 */ enum scmp_compare op; /**\u003c the comparison op, e.g. SCMP_CMP_* */ scmp_datum_t datum_a; scmp_datum_t datum_b; }; ctxçš„å†…å®¹å¯ä»¥ä½¿ç”¨å‡½æ•°dumpå‡ºæ¥,ä¹‹åå¯ä»¥ç›´æ¥ä½¿ç”¨prctlå‘½ä»¤ç›¸å…³ç›´æ¥è½½å…¥,æ–¹ä¾¿ä½¿ç”¨? ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:1","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"seccompè°ƒè¯• ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å¯¼å‡ºæ‰€æœ‰å¯èƒ½çš„å‘½ä»¤ file=syscall-names.h echo \"static const char *syscall_names[] = {\" \u003e $file echo \"#include \u003csys/syscall.h\u003e\" | cpp -dM | grep \u0026#039;^#define __NR_\u0026#039; | LC_ALL=C sed -r -n -e \u0026#039;s/^\\#define[ \\t]+__NR_([a-z0-9_]+)[ \\t]+([0-9]+)(.*)/ [\\2] = \"\\1\",/p\u0026#039; \u003e\u003e $file echo \"};\" \u003e\u003e $file ä½¿ç”¨å¦‚ä¸‹ä»£ç å¯¼å‡ºä¸€æ®µä»£ç æ‰€éœ€è¦çš„æƒé™.éµå¾ªæœ€å°æƒé™åŸåˆ™,è¯•éªŒä»£ç è¿è¡Œæ‰€éœ€è¦çš„æœ€å°‘æƒé™. #define __USE_GNU 1 #define _GNU_SOURCE 1 #include \u003csignal.h\u003e#include \u003csys/prctl.h\u003e#include \u003clinux/types.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/seccomp.h\u003e#include \u003cseccomp.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstddef.h\u003e#include \"syscall-names.h\"#if defined(__i386__) #define REG_RESULT REG_EAX #define REG_SYSCALL REG_EAX #define REG_ARG0 REG_EBX #define REG_ARG1 REG_ECX #define REG_ARG2 REG_EDX #define REG_ARG3 REG_ESI #define REG_ARG4 REG_EDI #define REG_ARG5 REG_EBP #elif defined(__x86_64__) #define REG_RESULT REG_RAX #define REG_SYSCALL REG_RAX #define REG_ARG0 REG_RDI #define REG_ARG1 REG_RSI #define REG_ARG2 REG_RDX #define REG_ARG3 REG_R10 #define REG_ARG4 REG_R8 #define REG_ARG5 REG_R9 #endif #ifndef SYS_SECCOMP #define SYS_SECCOMP 1 #endif const char *const msg=\"system call invalid: \"; static void write_uint(char *buf, unsigned int val) { int width = 0; unsigned int tens; if (val == 0) { strcpy(buf, \"0\"); return; } for (tens = val; tens; tens /= 10) ++ width; buf[width] = \u0026#039;\\0\u0026#039;; for (tens = val; tens; tens /= 10) buf[--width] = (char) (\u0026#039;0\u0026#039; + (tens % 10)); } static void helper(int nr, siginfo_t *info, void *void_context) { char buf[255]; ucontext_t *ctx = (ucontext_t *)(void_context); unsigned int syscall; if (info-\u003esi_code != SYS_SECCOMP) return; if (!ctx) return; syscall = (unsigned int) ctx-\u003euc_mcontext.gregs[REG_SYSCALL]; strcpy(buf, msg); if (syscall \u003c sizeof(syscall_names)) { strcat(buf, syscall_names[syscall]); strcat(buf, \"(\"); } write_uint(buf + strlen(buf), syscall); if (syscall \u003c sizeof(syscall_names)) strcat(buf, \")\"); strcat(buf, \"\\n\"); write(STDOUT_FILENO, buf, strlen(buf)); _exit(1); } static int install_helper() { struct sigaction act; sigset_t mask; memset(\u0026act, 0, sizeof(act)); sigemptyset(\u0026mask); sigaddset(\u0026mask, SIGSYS); act.sa_sigaction = \u0026helper; act.sa_flags = SA_SIGINFO; if (sigaction(SIGSYS, \u0026act, NULL) \u003c 0) { perror(\"sigaction\"); return -1; } if (sigprocmask(SIG_UNBLOCK, \u0026mask, NULL)) { perror(\"sigprocmask\"); return -1; } return 0; } #include \u003cstdio.h\u003eint main(){ if(install_helper()){ printf(\"install helper failed\"); return 1; } scmp_filter_ctx ctx = NULL; ctx = seccomp_init(SCMP_ACT_ALLOW); seccomp_rule_add(ctx, SCMP_ACT_TRAP, SCMP_SYS(execve), 0); seccomp_load(ctx); seccomp_release(ctx); fprintf(stdout, \"something to stdout\\n\"); char * filename = \"/bin/sh\"; char * argv[] = {\"/bin/sh\",NULL}; char * envp[] = {NULL}; write(1,\"i will give you a shell\\n\",24); syscall(59,filename,argv,envp);//execve return 0; } ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:2","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"æ³¨å…¥ç¨‹åº åˆšåˆšæåˆ°äº†seccompå¿…é¡»ç”±ç¨‹åºä¸»åŠ¨åŠ è½½,å› æ­¤éœ€è¦æœ‰ä¸€ä¸ªåŠæ³•å°†ä»£ç æ³¨å…¥åˆ°ç”¨æˆ·çš„ä»£ç ä¸­. ç­‰å¾…å®Œæˆ ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:3","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"å…¶ä»–è¯­è¨€ è¿™ç©æ„è²Œä¼¼è‡³å°‘èƒ½æ–¹ä¾¿çš„ç”¨åœ¨cç³»è¯­è¨€,javaå’Œpythonä¸Š. ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:4","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"Docker å‡†å¤‡ä½¿ç”¨Dockeré‡æ„æ•´ä¸ªOJ ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:3:0","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"å¤šé˜¶æ®µæ„å»º ä½¿ç”¨Docker,å°†OJåˆ†è§£ä¸ºå¤šä¸ªé˜¶æ®µæ¥æ„å»º. å‰ç«¯æ„å»º åç«¯æ„å»º è¿è¡Œç¯å¢ƒæ„å»ºä¸ä»£ç æ•´åˆ nginxæ„å»º å‘½ä»¤ #...# ä½¿ç”¨phpä½œä¸ºåŸºç¡€,æŒ‡æ˜è¯¥æ„å»ºé˜¶æ®µä¸ºcodeislandFROMphp:alpine as codeisland# åœ¨å®¹å™¨æ‰“åŒ…é˜¶æ®µå®‰è£…æ•°æ®åº“é©±åŠ¨RUN docker-php-ext-install pdo pdo_pgsqlARG PATH=/app/laravel# ä»å…¶ä»–é˜¶æ®µå¤åˆ¶ä»£ç åˆ°æœ¬é˜¶æ®µCOPY --from=DELETED /app/ ${PATH}# æ‰§è¡Œå…¶ä»–åˆå§‹åŒ–å‘½ä»¤# [DELETED]# æŒ‡æ˜å®¹å™¨çš„å·¥ä½œè·¯å¾„WORKDIR${PATH}#... ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:3:1","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"å®¹å™¨åè°ƒ ä½¿ç”¨Docker-composeæ¥åè°ƒå„ä¸ªå®¹å™¨çš„å…³ç³». æ•°æ®åº“å®¹å™¨ rediså®¹å™¨ ç½‘ç«™åç«¯å®¹å™¨ è¯„æµ‹å™¨å®¹å™¨ è¯„æµ‹ä»£ç†å®¹å™¨ nginxå®¹å™¨ é™åˆ¶è¯„æµ‹å™¨å®¹å™¨çš„èµ„æºæ¶ˆè€—çš„ä¾‹å­ deploy:resources:limits:cpus:\u0026#039;0.50\u0026#039;memory:1024M ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:3:2","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"ç½‘ç»œ â€¦å­¦æ ¡ç½‘å…³çš„ç™»å½•çŠ¶æ€æ ¹æœ¬æ²¡æ³•ç»´æŒ,å¡æ­». ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:3:3","tags":null,"title":"OJçš„åç«¯","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"nä¸ªæœ‰æ ‡å·çš„çƒå›´æˆä¸€ä¸ªåœˆã€‚æ¯ä¸ªçƒæœ‰ä¸¤ç§é¢œè‰²å¯ä»¥é€‰æ‹©é»‘æˆ–ç™½æŸ“è‰²ã€‚é—®æœ‰å¤šå°‘ç§æ–¹æ¡ˆä½¿å¾—æ²¡æœ‰å‡ºç°è¿ç»­ç™½çƒ7ä¸ªæˆ–è¿ç»­é»‘çƒ7ä¸ªã€‚ å¯¹æ–¹æ¡ˆæ•°mod 2015ï¼Œçƒæœ€å¤šæœ‰100000ä¸ªã€‚ åˆ†æ è€ƒè™‘å¯¹äºéç¯çŠ¶çƒçš„ç­”æ¡ˆè®¡ç®—ï¼Œå¯ä»¥è®¾$sum(i,k)$è¡¨ç¤ºç¬¬iä¸ªçƒä¸ºkè‰²æ—¶çš„æ–¹æ¡ˆæ•°ã€‚å…¶è®¡ç®—éå¸¸æ˜¾ç„¶ $$ sum(i,k)=\\sum_{1\\leq j \\leq 6}{sum(i-j,1-k)} $$ æ¥ä¸‹æ¥è€ƒè™‘æ”¶å°¾ç›¸æ¥åéœ€è¦æ’é™¤çš„æƒ…å†µï¼Œå³æ”¶å°¾åŒè‰²çƒé•¿åº¦ç›¸åŠ è¶…è¿‡6çš„æƒ…å†µï¼Œè¿™å¯ä»¥ç›´æ¥æšä¸¾ã€‚ é¦–å–iä¸ªæœ«å–jä¸ªåŒè‰²ï¼Œä»ç­”æ¡ˆä¸­åˆ é™¤æ­¤æ—¶å‰©ä¸‹çƒçš„æ–¹æ¡ˆæ•°ï¼Œæ³¨æ„å‰©ä¸‹çš„çƒçš„é¦–æœ«çƒé¢œè‰²ä¸èƒ½å’Œå·²ç»æšä¸¾çš„é¢œè‰²åŒè‰²ã€‚é‰´äºè¿™ç§è¦æ±‚ï¼Œæˆ‘ä»¬é€€å›åˆ°sumçš„é€’æ¨å…¬å¼å¤„ï¼Œå†³å®šsumçš„è¾¹ç•Œæ¡ä»¶ä¸ºé¦–ä¸ªçƒå›ºå®šä¸ºé»‘è‰²ï¼Œè¿™æ ·å°±èƒ½å¾ˆæ–¹ä¾¿çš„ç¡®å®šçƒçš„é¢œè‰²ï¼Œä¸”æ ¹æ®å¯¹ç§°æ€§ç­”æ¡ˆå¯ä»¥ç›´æ¥x2å¾—åˆ°ã€‚ é¢˜å°±åšå®Œäº†ã€‚ ä»£ç  æ·¦ï¼Œä¸ºä»€ä¹ˆå½“æ—¶æ²¡å†™ã€‚ #include \u003ciostream\u003eusing namespace std; const int MAXN=100010; const int P=2015; int sum[MAXN][2]; int main(){ int kase;cin\u003e\u003ekase; sum[0][1]=1; for(int i=1;i\u003c=100000;i++){ for(int j=1;j\u003c=min(i,6);j++){ (sum[i][1]+=sum[i-j][0])%=P; (sum[i][0]+=sum[i-j][1])%=P; } } sum[0][1]=0; int cnt=0; while(kase--){ int nlen;cin\u003e\u003enlen; int ans=(sum[nlen][0]+sum[nlen][1])%P; if(nlen\u003e=7) for(int i=1;i\u003c=6;i++) for(int j=1;j\u003c=6;j++) if(i+j\u003e=7 \u0026\u0026 nlen-i-j\u003e=0) ans=(ans-sum[nlen-i-j][0])%P; cout\u003c\u003c\"Case #\"\u003c\u003c++cnt\u003c\u003c\": \"\u003c\u003c((ans*2)%P+2015)%P\u003c\u003cendl; } return 0; } ","date":"2019-08-10","objectID":"/2019/08/fzu-2204seven/:0:0","tags":null,"title":"[FZU 2204]Seven","uri":"/2019/08/fzu-2204seven/"},{"categories":["code"],"content":"There are n pirate chests buried in Byteland, labeled by 1,2,â€¦,n. The i-th chestâ€™s location is (xi,yi), and its value is wi, wi can be negative since the pirate can add some poisonous gases into the chest. When you open the i-th pirate chest, you will get wi value. You want to make money from these pirate chests. You can select a rectangle, the sides of which are all paralleled to the axes, and then all the chests inside it or on its border will be opened. Note that you must open all the chests within that range regardless of their values are positive or negative. But you can choose a rectangle with nothing in it to get a zero sum. Please write a program to find the best rectangle with maximum total value. The first line of the input contains an integer T(1â‰¤Tâ‰¤100), denoting the number of test cases. In each test case, there is one integer n(1â‰¤nâ‰¤2000) in the first line, denoting the number of pirate chests. For the next n lines, each line contains three integers xi,yi,wi(âˆ’109â‰¤xi,yi,wiâ‰¤109), denoting each pirate chest. It is guaranteed that âˆ‘nâ‰¤10000. ","date":"2019-08-07","objectID":"/2019/08/hdu6638-snowy-smile/:0:0","tags":null,"title":"[HDU6638] Snowy Smile","uri":"/2019/08/hdu6638-snowy-smile/"},{"categories":["code"],"content":"åˆ†æ é¦–å…ˆï¼Œæˆ‘æ²¡åšå‡ºæ¥ã€‚ è¿™é“é¢˜å®é™…ä¸Šå°±æ˜¯åœ¨è¦æ±‚ä½ ç”¨å°äº$O(N^3)$çš„å¤æ‚åº¦æ±‚å‡ºæœ€å¤§å’Œå­çŸ©é˜µã€‚æ³¨æ„åˆ°è¯¥é¢˜çš„ç‚¹ç¨€ç–ï¼Œæ‰€ä»¥ä»¥ç‚¹ä¸ºè€ƒè™‘å¯¹è±¡ã€‚ ä¸‰æ–¹çš„åšæ³•ï¼Œæšä¸¾çŸ©é˜µçš„ä¸Šè¾¹ç•Œå’Œä¸‹è¾¹ç•Œï¼Œç»´æŠ¤çºµå‘ä¸Šçš„å’Œï¼Œæ±‚æœ€å¤§å­—æ®µå’Œã€‚å½“ä»¥ç‚¹è€ƒè™‘æ—¶ï¼Œä¸Šä¸‹è¾¹ç•Œå°±å¯ä»¥ç›´æ¥ç”±æ’åºåçš„ç‚¹å†³å®šã€‚ä¹‹åï¼Œä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤æœ€å¤§å­æ®µå’Œã€‚ ","date":"2019-08-07","objectID":"/2019/08/hdu6638-snowy-smile/:1:0","tags":null,"title":"[HDU6638] Snowy Smile","uri":"/2019/08/hdu6638-snowy-smile/"},{"categories":["code"],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; constexpr int MAXN=400010; ll d_sub[MAXN],d_pre[MAXN],d_suf[MAXN]; ll d_sum[MAXN]; int lc[MAXN],rc[MAXN]; int idx=0; void build(int \u0026n,int l,int r){ if(!n)n=++idx; d_sum[n]=d_sub[n]=d_pre[n]=d_suf[n]=0; if(l==r){ return; } int mid=(l+r)/2; build(lc[n],l,mid); build(rc[n],mid+1,r); //combine data } void collect(int node){ d_sum[node]=d_sum[lc[node]]+d_sum[rc[node]]; d_pre[node]=max(d_pre[lc[node]],d_sum[lc[node]]+d_pre[rc[node]]); d_suf[node]=max(d_suf[rc[node]],d_sum[rc[node]]+d_suf[lc[node]]); d_sub[node]=max(max(d_sub[lc[node]],d_sub[rc[node]]),d_suf[lc[node]]+d_pre[rc[node]]); } void modify(int x,int l,int r,int L,int R,int node){ if(l\u003c=L \u0026\u0026 R\u003c=r){ //only single point to modify d_sub[node]=d_sub[node]+x; d_pre[node]=d_pre[node]+x; d_suf[node]=d_suf[node]+x; d_sum[node]+=x; return; } int mid=(L+R)/2; if(l\u003c=mid)modify(x,l,r,L,mid,lc[node]); if(mid\u003cr)modify(x,l,r,mid+1,R,rc[node]); collect(node); } int root; ll query_all(){ return d_sub[root]; } struct Chest{ int x,y,v; bool operator\u003c(const Chest \u0026other)const{ if(x==other.x)return y\u003cother.y; return x\u003cother.x; } } chests[MAXN]; vector\u003cint\u003e refy; int main(){ ios::sync_with_stdio(false); int kase;cin\u003e\u003ekase; while(kase--){ int nlen;cin\u003e\u003enlen; refy.clear(); for(int i=0;i\u003cnlen;i++){ Chest \u0026chest=chests[i]; cin\u003e\u003echest.x\u003e\u003echest.y\u003e\u003echest.v; refy.push_back(chest.y); } sort(chests,chests+nlen); sort(refy.begin(),refy.end()); auto refyend=unique(refy.begin(),refy.end()); int maxy=0; for(int i=0;i\u003cnlen;i++){ chests[i].y=lower_bound(refy.begin(),refyend,chests[i].y)-refy.begin()+1; maxy=max(maxy,chests[i].y); } int lastx=0; ll ans=0; for(int i=0;i\u003cnlen;i++){ if(lastx==chests[i].x)continue; lastx=chests[i].x; //cout\u003c\u003c\"start from \"\u003c\u003clastx\u003c\u003cendl; build(root,1,maxy); int nextx=chests[i].x; for(int j=i;j\u003cnlen;j++){ if(chests[j].x!=nextx){ nextx=chests[j].x; ans=max(ans,query_all()); } modify(chests[j].v,chests[j].y,chests[j].y,1,maxy,root); } ans=max(ans,query_all()); } cout\u003c\u003cmax(0ll,ans)\u003c\u003cendl; } return 0; } ","date":"2019-08-07","objectID":"/2019/08/hdu6638-snowy-smile/:2:0","tags":null,"title":"[HDU6638] Snowy Smile","uri":"/2019/08/hdu6638-snowy-smile/"},{"categories":["å­¦ä¹ "],"content":"å¯¹äºå¯ä»¥ç¦»çº¿çš„åŒºé—´è¯¢é—®é—®é¢˜ï¼Œè«é˜Ÿç®—æ³•æå‡ºäº†ä¸€ç§å¯ä»¥åœ¨$O(n\\sqrt n)$(æ— ä¿®æ”¹)ï¼Œ$O(n^{5/3})$(å¸¦ä¿®æ”¹)å†…å¾—å‡ºç­”æ¡ˆçš„æ–¹æ³•ã€‚ ä¸»è¦çš„æ€è·¯æ˜¯å¯¹è¯¢é—®ç¦»çº¿å¹¶åˆ†å—ï¼Œåˆ©ç”¨åœ¨2ä¸ªåŒºé—´é—´ç­”æ¡ˆçš„å¿«é€Ÿè½¬ç§»ï¼ˆå¦‚æœæ— æ³•æ‰¾åˆ°å¿«é€Ÿè½¬ç§»çš„æ–¹æ³•ï¼Œå°±æ²¡æ³•ç”¨äº†ï¼‰é™ä½å¤æ‚åº¦ã€‚ ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:0:0","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"1 ç®—æ³•æ€æƒ³ è«é˜Ÿç®—æ³•æ˜¯ç”±è«æ¶›æå‡ºçš„ç®—æ³•ï¼Œå¯ä»¥è§£å†³ä¸€ç±»ç¦»çº¿åŒºé—´è¯¢é—®é—®é¢˜ï¼Œé€‚ç”¨æ€§æä¸ºå¹¿æ³›ã€‚å³,èƒ½å¤Ÿä½¿ç”¨è«é˜Ÿç®—æ³•å¤„ç†çš„é—®é¢˜ä¸€èˆ¬å…·æœ‰å¦‚ä¸‹ç‰¹å¾ åŒºé—´è¯¢é—® å¯ä»¥ç¦»çº¿ ä¸åŒåŒºé—´é—´çš„ç­”æ¡ˆèƒ½å¤Ÿè¾ƒå¿«çš„äº’æ¨. åœ¨æ»¡è¶³ä»¥ä¸Šæ¡ä»¶æ˜¯,é€šè¿‡åˆç†çš„å®‰æ’è¯¢é—®çš„å¤„ç†é¡ºåº,èƒ½å¤Ÿè·å¾—ä¸€ä¸ªä¼˜ç§€çš„æ€»ä½“å¤æ‚åº¦ã€‚ä»¥ä¸‹ï¼Œå‡è®¾åŒºé—´çš„è½¬ç§»éœ€è¦$O(1)$ å‡è®¾å·²çŸ¥åŒºé—´$[l,r]$ç­”æ¡ˆï¼Œæœ‰ä¸‹ä¸€ä¸ªéœ€è¦å¤„ç†çš„åŒºé—´$[lâ€™,râ€™]$ã€‚è¿›è¡Œç­”æ¡ˆåœ¨åŒºé—´é—´çš„å•æ­¥è½¬ç§»éœ€è¦å¤æ‚åº¦$O(|l-l'|+|r-r'|)$ï¼Œå³è½¬ç§»çš„å¤æ‚åº¦ä¸ºäºŒè€…çš„æ›¼å“ˆé¡¿è·ç¦»ã€‚é‚£ä¹ˆï¼Œå°†æ‰€æœ‰è¯¢é—®ç‚¹é“ºå¹³åœ¨äºŒç»´å¹³é¢ä¸Šï¼ŒæŒ‰æ›¼å“ˆé¡¿è·ç¦»ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘ï¼Œå¦‚æ­¤æ‰€å¾—åˆ°çš„è½¬ç§»ä»£ä»·æœ€å°ã€‚ ä½†æ˜¯ä¸€èˆ¬æƒ…å†µä¸‹è¿™ç§åšæ³•ä»£ç é‡è¾ƒå¤§ï¼Œåœ¨ä»£ç é‡å’Œæ—¶é—´å¤æ‚åº¦é—´çš„å¦¥åè¯ç”Ÿäº†ä¸€ä¸ªä¼˜ç§€çš„æ›¿ä»£æ–¹æ¡ˆã€‚åˆ†å—ã€‚ å¯¹åŒºé—´é•¿åº¦æŒ‰æ ¹å·åˆ†å—ï¼Œä»¥å·¦ç«¯ç‚¹æ‰€åœ¨çš„åˆ†å—çš„åºå·ä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œå³ç«¯ç‚¹ä¸ºç¬¬äºŒå…³é”®å­—æ’åºã€‚é‚£ä¹ˆ åœ¨åŒä¸€åˆ†å—ï¼Œå³ç«¯ç‚¹é€’å¢ï¼Œå¤„ç†è¯¥åˆ†å—æ‰€æœ‰è¯¢é—®å³ç«¯ç‚¹éœ€è¦$O(N)$ï¼Œæ€»ä½“ä¸º$O(N \\sqrt N)$ã€‚ åœ¨åˆ†å—è½¬ç§»ï¼Œå³ç«¯ç‚¹æœ€å¤šå˜åŒ–$N$ï¼Œäºæ˜¯ä¹Ÿæœ‰$O(N \\sqrt N)$ã€‚ åœ¨åŒä¸€åˆ†å—ï¼Œå·¦ç«¯ç‚¹å˜åŒ–æœ€å¤š$\\sqrt N$ï¼Œä¸åŒåˆ†å—é—´æœ€å¤šå˜åŒ–$\\sqrt N$ï¼Œäºæ˜¯Nä¸ªè¯¢é—®æœ‰$O(N \\sqrt N)$ã€‚ æ€»ä½“å¤æ‚åº¦$O(N\\sqrt N)$ ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:1:0","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"2 æ— ä¿®æ”¹è«é˜Ÿ ä»¥$B=\\sqrt{n}$ï¼ŒæŒ‰ç…§$(l/B,r)$å¯¹è¯¢é—®æ’åºã€‚ ä¹‹åæšä¸¾æ¯ä¸€ä¸ªè¯¢é—®ï¼Œå°†ç­”æ¡ˆåœ¨ç›¸é‚»è¯¢é—®åŒºé—´é—´æš´åŠ›çš„+1-1è½¬ç§»ã€‚ ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:2:0","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"Problem: å°Yçš„è¢œå­ ä½œä¸ºä¸€ä¸ªç”Ÿæ´»æ•£æ¼«çš„äººï¼Œå°Zæ¯å¤©æ—©ä¸Šéƒ½è¦è€—è´¹å¾ˆä¹…ä»ä¸€å †äº”é¢œå…­è‰²çš„è¢œå­ä¸­æ‰¾å‡ºä¸€åŒæ¥ç©¿ã€‚ç»ˆäºæœ‰ä¸€å¤©ï¼Œå°Zå†ä¹Ÿæ— æ³•å¿å—è¿™æ¼äººçš„æ‰¾è¢œå­è¿‡ç¨‹ï¼Œäºæ˜¯ä»–å†³å®šå¬å¤©ç”±å‘½â€¦â€¦ å…·ä½“æ¥è¯´ï¼Œå°ZæŠŠè¿™Nåªè¢œå­ä»1åˆ°Nç¼–å·ï¼Œç„¶åä»ç¼–å·Låˆ°R(L å°½ç®¡å°Zå¹¶ä¸åœ¨æ„ä¸¤åªè¢œå­æ˜¯ä¸æ˜¯å®Œæ•´çš„ä¸€åŒï¼Œç”šè‡³ä¸åœ¨æ„ä¸¤åªè¢œå­æ˜¯å¦ä¸€å·¦ä¸€å³ï¼Œä»–å´å¾ˆåœ¨æ„è¢œå­çš„é¢œè‰²ï¼Œæ¯•ç«Ÿç©¿ä¸¤åªä¸åŒè‰²çš„è¢œå­ä¼šå¾ˆå°´å°¬ã€‚ ä½ çš„ä»»åŠ¡ä¾¿æ˜¯å‘Šè¯‰å°Zï¼Œä»–æœ‰å¤šå¤§çš„æ¦‚ç‡æŠ½åˆ°ä¸¤åªé¢œè‰²ç›¸åŒçš„è¢œå­ã€‚å½“ç„¶ï¼Œå°Zå¸Œæœ›è¿™ä¸ªæ¦‚ç‡å°½é‡é«˜ï¼Œæ‰€ä»¥ä»–å¯èƒ½ä¼šè¯¢é—®å¤šä¸ª(L,R)ä»¥æ–¹ä¾¿è‡ªå·±é€‰æ‹©ã€‚ è¢œå­çš„æ•°é‡æœ€å¤šä¸º50000ï¼ˆæ˜¯çœŸçš„ğŸ‚ğŸºï¼‰ åˆ†æ è¿™ä¼¼ä¹æ˜¯è«é˜Ÿçš„ä¾‹é¢˜ï¼ˆ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstdlib\u003e#include \u003ccstring\u003e#include \u003ccmath\u003eusing namespace std; using ll=long long; const int MAXN=50010,MAXQ=50010; ll gcd(ll a,ll b){ return !b?a:gcd(b,a%b); } ll c2(ll n){ if(n\u003c2)return 0; return n*(n-1)/2; } int a[MAXN]; int block=0; struct Q{ int l,r; int i; ll ansu,ansd; bool operator\u003c(const Q \u0026b)const{ if(l/block!=b.l/block)return l/block\u003cb.l/block; return r\u003cb.r; } }qs[MAXQ]; int cnt[MAXN]; ll cup=0,cdown=0; void remove(int ptr){ cup-=c2(cnt[a[ptr]]); cnt[a[ptr]]--; cdown--; cup+=c2(cnt[a[ptr]]); } void add(int ptr){ cup-=c2(cnt[a[ptr]]); cnt[a[ptr]]++; cdown++; cup+=c2(cnt[a[ptr]]); } int main(){ int nlen,qlen;cin\u003e\u003enlen\u003e\u003eqlen; for(int i=1;i\u003c=nlen;i++)cin\u003e\u003ea[i]; for(int i=0;i\u003cqlen;i++)cin\u003e\u003eqs[i].l\u003e\u003eqs[i].r; for(int i=0;i\u003cqlen;i++)qs[i].i=i; block=sqrt(nlen); sort(qs,qs+qlen); /* cout\u003c\u003c\"current queries:\"\u003c\u003cendl; for(auto q:qs){ cout\u003c\u003cq.l\u003c\u003c\" \"\u003c\u003cq.r\u003c\u003cendl; } cout\u003c\u003c\"=====\"\u003c\u003cendl; */ int l=1,r=1; add(1); for(int i=0;i\u003cqlen;i++){ Q \u0026q=qs[i]; if(q.l==q.r){ q.ansu=0;q.ansd=1; continue; } while(q.l\u003cl)add(--l); while(r\u003cq.r)add(++r); while(l\u003cq.l)remove(l++); while(q.r\u003cr)remove(r--); q.ansu=cup; q.ansd=cdown; //cout\u003c\u003ccup/c2(cdown)\u003c\u003cendl; } sort(qs,qs+qlen,[](const Q \u0026a,const Q \u0026b){ return a.i\u003cb.i; }); for(int i=0;i\u003cqlen;i++){ if(qs[i].ansd\u003c2){ cout\u003c\u003c\"0/1\"\u003c\u003cendl; continue; } ll u=qs[i].ansu; ll d=c2(qs[i].ansd); ll g=gcd(u,d); if(g!=0)u/=g,d/=g; cout\u003c\u003cu\u003c\u003c\"/\"\u003c\u003cd\u003c\u003cendl; } return 0; } ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:2:1","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"3 å¸¦ä¿®æ”¹è«é˜Ÿ å¦‚æœå¯¹åŒºé—´çš„æŸ¥è¯¢ä¹‹ä½™ï¼Œè¿˜ä¼šä¿®æ”¹åŒºé—´ï¼Œä¸”è¿™ç§ä¿®æ”¹ä¹Ÿå¯ä»¥å¿«é€Ÿä¿®æ”¹ã€æ’¤é”€ã€‚é‚£ä¹ˆï¼Œå¯ä»¥ä½¿ç”¨è«é˜Ÿçš„ä¸€ä¸ªæ‰©å±•â€”â€”å¸¦ä¿®æ”¹è«é˜Ÿå®ç°ã€‚ å‡è®¾æœ‰$m$ä¸ªè¯¢é—®ï¼Œå°†ä¿®æ”¹æ“ä½œå¹³é“ºåœ¨æ—¶é—´çº¿ä¸Šï¼Œè®¡ç®—æ¯æ¬¡è¯¢é—®æ‰€å¤„çš„æ—¶é—´ç‚¹ã€‚å°†æ—¶é—´ä¹Ÿä½œä¸ºæŸ¥è¯¢çš„ä¸€ä¸ªå‚æ•°ï¼Œå‚ä¸åˆ†å—å’Œè½¬ç§»ã€‚æŒ‰ç…§$(l/B_1,r/B_2,time)$å¯¹è¯¢é—®æ’åºã€‚åˆ†å—æœ‰$n^2/B_1B_2$ä¸ªã€‚ å¯¹äºæ¯ä¸ªå—ï¼Œ$time$æœ€å¤šå˜åŒ–$m$æ¬¡ï¼Œæœ‰$O(m)$ã€‚æ€»ä½“æœ‰$O(\\frac{n^2m}{B_1B_2})$ã€‚ å¯¹äºæ¯ä¸ªè¯¢é—®å†…ï¼Œ$l$å’Œ$r$æœ€å¤šå˜åŒ–$B_1$ã€$B_2$ã€‚æœ‰$O(mB_1+mB_2)$ã€‚ å¯¹äºä¸åŒå—è½¬ç§»ï¼Œæœ‰æœ€å¤§å¤æ‚åº¦$O(n)$ã€‚æœ‰$O(\\frac{n^3}{B_1B_2})$ å½“må’ŒnåŒé˜¶ï¼Œå–$B_1=B_2=n^{2/3}$ï¼Œè¾¾åˆ°å¤æ‚åº¦$O(n^{5/3})$ã€‚ æšä¸¾æ¯ä¸€ä¸ªè¯¢é—®ï¼Œå°†ç­”æ¡ˆåœ¨ä¸åŒæ—¶é—´çº¿é—´æš´åŠ›+1-1è·³è½¬ï¼Œå†æš´åŠ›åœ¨ç›¸é‚»è¯¢é—®çš„åŒºé—´é—´+1-1è½¬ç§»ã€‚ å¬èµ·æ¥æœ‰ç‚¹é•¿å¯¿çš„æ„æ€ã€‚ ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:3:0","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"Problem: Game Again Alice and Bob is playing a game with stones. There are N piles of stones labelled from 1 to N, the i th pile has ai stones. First Alice will choose piles of stones with consecutive labels, whose leftmost is labelled with L and the rightmost one is R. After, Bob will choose another consecutive piles labelled from l to r (Lâ‰¤lâ‰¤râ‰¤R). Then theyâ€™re going to play game within these piles. Hereâ€™s the rules of the game: Alice takes first and the two will take turn to make a move: choose one pile with nonegetive stones and take at least one stone and at most all away. One who cant make a move will lose. Bob thinks this game is not so intersting because Alice always take first. So they add a new rule, which is that Bob can swap the number of two adjacent pilesâ€™ stones whenever he want before a new round. That is to say, if the i th and i+1 pile have ai and ai+1 stones respectively, after this swapping there will be ai+1 and ai. Before todayâ€™s game with Bob, Alice wants to know, if both they play game optimally when she choose the piles from L to R, there are how many pairs (l, r) chosed by Bob that will make Alice win. åˆ†æ nimæ¸¸æˆè¾“èµ¢å°±æ˜¯çœ‹å¼‚æˆ–å’Œï¼Œå¼‚æˆ–å’Œå¯ä»¥çœ‹å‰ç¼€å¼‚æˆ–å’Œå†…æœ‰å¤šå°‘ä¸ªå€¼ç›¸åŒçš„ç‚¹ã€‚æ‰€ä»¥å®ƒå°±æ˜¯åœ¨é—®ä¸€ä¸ªåŒºé—´é‡Œæœ‰å¤šå°‘ä¸ªç›¸åŒç‚¹å¯¹ã€‚ å¸¦å•ç‚¹ä¿®æ”¹çš„åŒºé—´ç‚¹å¯¹è®¡æ•°ã€‚ ä»£ç  #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cvector\u003eusing namespace std; using ll=long long; const int MAXN=100010,MAXQ=100010; const int MAXPOS=2e6+11; int nlen,qlen; int game[MAXN]; int pre[MAXN]; int modified[MAXQ],midx=0,belong[MAXN]; int block=0; struct Q{ int i; int l,r; int tick; bool operator\u003c(const Q \u0026b)const{ // if(l/block!=b.l/block)return l/block\u003cb.l/block; // if(r/block!=b.r/block)return r/block\u003cb.r/block; if(belong[l]!=belong[b.l]) return belong[l]\u003cbelong[b.l]; if(belong[r]!=belong[b.r]) return belong[r]\u003cbelong[b.r]; return tick\u003cb.tick; } }q[MAXQ]; int qidx=0; ll cache=0; int cnt[MAXPOS]; inline void add(int pos){ int \u0026c=cnt[pre[pos]]; cache-=(ll)c*(c-1)/2; c++; cache+=(ll)c*(c-1)/2; } inline void rm(int pos){ int \u0026c=cnt[pre[pos]]; cache-=(ll)c*(c-1)/2; c--; cache+=(ll)c*(c-1)/2; } int l=1,r=1,curt=0; inline void jumpup(int tim){ if(tim==0)return; int pos=modified[tim]; int a=game[pos]; int b=game[pos+1]; swap(game[pos],game[pos+1]); if(l\u003c=pos \u0026\u0026 pos\u003c=r){ rm(pos); } pre[pos]^=a; pre[pos]^=b; if(l\u003c=pos \u0026\u0026 pos\u003c=r){ add(pos); } } inline void jumpdown(int tim){ jumpup(tim); } ll qans[MAXQ]; int main(){ //freopen(\"00.in\",\"r\",stdin); while(~scanf(\"%d%d\",\u0026nlen,\u0026qlen)){ block=pow(nlen,2.0/3); for(int i=1;i\u003c=nlen;i++){ scanf(\"%d\",\u0026game[i]); belong[i]=(i-1)/block; } pre[0]=0; for(int i=1;i\u003c=nlen;i++)pre[i]=pre[i-1]^game[i]; qidx=0,midx=0; for(int i=1;i\u003c=qlen;i++){ int opt; scanf(\"%d\",\u0026opt); if(opt==1){ int l,r; scanf(\"%d%d\",\u0026l,\u0026r); q[qidx].i=qidx; q[qidx].l=l; q[qidx].l--; q[qidx].r=r; q[qidx].tick=midx; qidx++; }else if(opt==2){ scanf(\"%d\",\u0026modified[++midx]); } } sort(q,q+qidx); memset(cnt,0,sizeof(cnt)); cache=0; l=r=1;curt=0; add(1); for(int i=0;i\u003cqidx;i++){ if(q[i].r-q[i].l+1\u003c2){ qans[q[i].i]=0; continue; } while(curt\u003cq[i].tick)jumpup(++curt); while(q[i].tick\u003ccurt)jumpdown(curt--); while(q[i].l\u003cl)add(--l); while(r\u003cq[i].r)add(++r); while(l\u003cq[i].l)rm(l++); while(q[i].r\u003cr)rm(r--); //qans[q[i].i]=cache; ll len=r-l+1; qans[q[i].i]=len*(len-1)/2-cache; } for(int i=0;i\u003cqidx;i++){ printf(\"%lld\\n\",qans[i]); } } return 0; } Problem 3289. â€“ Matoçš„æ–‡ä»¶ç®¡ç† ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:3:1","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"4 æ ‘ä¸Šè«é˜Ÿ/è½¬åŒ– å½“å¯¹äºæ ‘ä¸Šçš„è·¯å¾„æŸ¥è¯¢ï¼Œæ¯ä¸ªç‚¹çš„è´¡çŒ®ä¹Ÿèƒ½å¤Ÿå¿«é€ŸåŠ å…¥/åˆ é™¤ï¼Œé‚£ä¹ˆè«é˜Ÿä»ç„¶å¯ä»¥åšã€‚ ä¸€ç§æ€è·¯æ˜¯æŠŠæ ‘è½¬åŒ–ä¸ºdfsåºåˆ—ã€‚ å°†è¯¢é—®$u \\to v$å…ˆæŒ‰ç…§dfsåºåˆ—å¯¹uå’Œvæ¢ä½ï¼Œä½¿å¾—å°çš„åœ¨å‰ã€‚ uæ˜¯vçš„ç¥–å…ˆï¼Œå–uå’Œvç¬¬ä¸€æ¬¡å‡ºç°çš„åŒºé—´ã€‚ å¦‚æœuä¸æ˜¯vçš„ç¥–å…ˆï¼Œå–uæœ€åä¸€æ¬¡å’Œvçš„ç¬¬ä¸€æ¬¡å‡ºç°ï¼Œè¿˜éœ€è¦åŠ å…¥lca(u,v)ã€‚ æ³¨æ„å¤„ç†åœ¨uå’Œvå†³å®šçš„åŒºé—´å†…èŠ‚ç‚¹å‡ºç°ä¸¤æ¬¡çš„æƒ…å†µã€‚æ­¤æ—¶åº”è®¤ä¸ºè¯¥ç‚¹ä¸å­˜åœ¨ã€‚ ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:4:0","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"WC2013 ç³–æœå…¬å›­ è¿™é“é¢˜å°±æ˜¯å…¸å‹çš„æ ‘ä¸Šè«é˜Ÿ.ç®€å•æ¥è¯´,åœ¨ä¸€ä¸ªæ ‘ä¸Šä¸åŒèŠ‚ç‚¹æœ‰ä¸åŒçš„ç³–æœ,ç¬¬$i$ç§ç³–æœæœ¬èº«æœ‰ç¾å‘³åº¦$V_i$,äººä»¬ä¼šåœ¨ä¹¦ä¸Šèµ°ç®€å•è·¯å¾„,å¹¶å“å°æ¯ä¸ªèŠ‚ç‚¹çš„ç³–æœ.åŒä¸€ç§ç³–æœåƒå¤šæ¬¡å¯èƒ½ä¼šè…»,å®šä¹‰ç¬¬$i$æ¬¡åƒåŒç§ç³–æœçš„æ–°å¥‡åº¦$W_i$,æ‰€ä»¥åƒæ‰ä¸€ä¸ªç³–æœçš„æ„‰æ‚¦(å·ç¨)åº¦è¡¨ç¤ºä¸ºç³–æœç¾å‘³åº¦å’Œæ–°å¥‡åº¦çš„ä¹˜ç§¯.åœ¨æŸäº›æ—¶åˆ»,æŸäº›èŠ‚ç‚¹å‘çš„ç³–çš„ç±»å‹ä¼šæ”¹å˜. ä»£ç å†™å¾—å¤ªé•¿äº†â€¦ä¸è¿‡è¿˜æ˜¯æ¯”è¾ƒæ¸…æ™°çš„ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ccassert\u003e#include \u003ccstring\u003e#include \u003ccmath\u003eusing namespace std; using ll = long long; const int XN = 200010, XM = 200010; vector\u003cint\u003e g[XN]; int delicious[XM]; int w[XM]; int kind[XN]; int origin[XN]; struct Q { int idx; int u, v; int l, r; }qs[XN]; int in[XN], out[XN]; int ref_tick[XN]; int fa[XN][25]; int dep[XN]; int tick = 0; void dfs(int u, int f) { fa[u][0] = f; dep[u] = dep[f] + 1; in[u] = ++tick; ref_tick[tick] = u; for (auto v : g[u]) { if (v == f)continue; dfs(v, u); } out[u] = ++tick; ref_tick[tick] = u; } int lca(int u, int v) { if (dep[u] \u003c dep[v])swap(u, v); for (int p = 20; p\u003e=0; p--) { if (dep[fa[u][p]] \u003e= dep[v]) u = fa[u][p]; } if (u == v)return u; for (int p = 20; p\u003e=0; p--) { if (fa[u][p] != fa[v][p]) { u = fa[u][p]; v = fa[v][p]; } } return fa[u][0]; } pair\u003cint,int\u003e modified[XN]; int cnt[XM],inq[XN]; ll ans[XN]; int belongs[XN]; vector\u003cint\u003e his[XN]; int main() { ios::sync_with_stdio(false); memset(ans, -1, sizeof(ans)); int n, m, q; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for (int i = 1; i \u003c= m; i++)cin \u003e\u003e delicious[i]; for (int i = 1; i \u003c= n; i++)cin \u003e\u003e w[i]; for (int i = 0; i \u003c n-1; i++) { int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v); g[v].push_back(u); } for (int i = 1; i \u003c= n; i++)cin \u003e\u003e kind[i]; for (int i = 1; i \u003c= n; i++)origin[i] = kind[i]; for (int i = 0; i \u003c q; i++) { int opt, u, v; cin \u003e\u003e opt \u003e\u003e u \u003e\u003e v; if (opt == 0) { modified[i].first = u; modified[i].second = v; } else { qs[i].idx = i; qs[i].u = u; qs[i].v = v; } } dfs(1, 0); //for (int i = 1; i \u003c= tick; i++)cout \u003c\u003c ref_tick[i] \u003c\u003c \" \"; //cout \u003c\u003c endl; for (int p = 1; p \u003c 20; p++) { for (int i = 1; i \u003c= n; i++) { fa[i][p] = fa[fa[i][p - 1]][p - 1]; } } //åŒºé—´[) for (int i = 0; i \u003c q; i++) { Q\u0026 cur = qs[i]; if (cur.u == 0)continue; if (in[cur.u] \u003e in[cur.v])swap(cur.u, cur.v); if (lca(cur.u, cur.v) == cur.u) { cur.l = in[cur.u]; cur.r = in[cur.v]+1; } else { cur.l = out[cur.u]; cur.r = in[cur.v] + 1; } //cout \u003c\u003c cur.l \u003c\u003c \" \" \u003c\u003c cur.r \u003c\u003c endl; } int B = pow(tick, 2.0 / 3); for (int i = 0; i \u003c XN; i++) { belongs[i] = i / B; } sort(qs, qs + q, [=](const Q\u0026 a, const Q\u0026 b) { if (belongs[a.l] != belongs[b.l])return belongs[a.l] \u003c belongs[b.l]; if (belongs[a.r] != belongs[b.r])return belongs[a.r] \u003c belongs[b.r]; return a.idx \u003c b.idx; }); int L = 1, R = 1, T = 0;//T) ll wage=0; for (int i = 0; i \u003c q; i++) { Q\u0026 cur = qs[i]; //cout \u003c\u003ccur.idx\u003c\u003c\",\"\u003c\u003c \"from [\" \u003c\u003c L \u003c\u003c \",\" \u003c\u003c R \u003c\u003c \") to [\" \u003c\u003c cur.l \u003c\u003c \",\" \u003c\u003c cur.r \u003c\u003c \")\" \u003c\u003c endl; if (cur.l == cur.r \u0026\u0026 cur.r == 0)continue; //time while (cur.idx \u003c T) { T--; if (modified[T].first == 0) { continue; } int u = modified[T].first, v = modified[T].second; if (inq[u]) { wage -= (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"remove \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c kind[u] \u003c\u003c \")\" \u003c\u003c (ll)delicious[kind[u]] * w[cnt[kind[u]]] \u003c\u003c endl; cnt[kind[u]]--; } kind[u] = his[u].back(); his[u].pop_back(); if (inq[u]) { cnt[kind[u]]++; wage += (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"add \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c kind[u] \u003c\u003c \")\" \u003c\u003c (ll)delicious[kind[u]] * w[cnt[kind[u]]] \u003c\u003c endl; } } while (cur.idx \u003e T) { if (modified[T].first == 0) { T++; continue; } int u = modified[T].first, v = modified[T].second; if (inq[u]) { wage -= (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"remove \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c kind[u] \u003c\u003c \")\" \u003c\u003c (ll)delicious[kind[u]] * w[cnt[kind[u]]] \u003c\u003c endl; cnt[kind[u]]--; } his[u].push_back(kind[u]); kind[modified[T].first] = modified[T].second; if (inq[u]) { cnt[kind[u]]++; wage += (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"add \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c kind[u] \u003c\u003c \")\" \u003c\u003c (ll)delicious[kind[u]] * w[cnt[kind[u]]] \u003c\u003c endl; } T++; } //L and R //[) while (cur.l \u003c L) { L--; int u = ref_tick[L]; if (!inq[u]) { cnt[kind[u]]++; wage += (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"add \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:4:1","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"5 æ ‘ä¸Šè«é˜Ÿ â€œä¸€èˆ¬æ¥è®²,æ ‘ä¸Šè«é˜Ÿå±äºæ¯”è¾ƒè¾¹ç¼˜åŒ–çš„ä¸œè¥¿,å› ä¸ºå…¶æ‰€ä¾èµ–çš„æ ‘åˆ†å—å¤„äºæ¯”è¾ƒå°´å°¬çš„å¢ƒåœ°.â€ ä¸ºäº†è¿›è¡Œä¸‹ä¸€ç§æ ‘ä¸Šè«é˜Ÿ,ä¹Ÿå°±æ˜¯çœŸçš„ç›´æ¥åœ¨æ ‘ä¸Šåˆ†å—åšè«é˜Ÿ,æˆ‘ä»¬ç¬¬ä¸€ä¸ªéœ€è¦è§£å†³çš„é—®é¢˜æ˜¯å¦‚ä½•ç»™æ ‘åˆ†å—.æˆ‘ä»¬å¯¹äºå—çš„è¦æ±‚ä»ç„¶æ²¡æœ‰å¤§çš„æ”¹å˜. å—å†…ç‚¹é—´è·ç¦»ä¸èƒ½è¶…è¿‡å—å¤§å° å—å†…ç‚¹æ•°ç›®é€‚ä¸­ å—ç¼–å·ç›¸é‚»,å—ä¹Ÿéœ€è¦è¿ç»­ ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:5:0","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"æ ‘åˆ†å— BZOJ 1086 [SCOI2005]ç‹å®¤è”é‚¦ ä»–æƒ³æŠŠä»–çš„å›½å®¶åˆ’åˆ†æˆè‹¥å¹²ä¸ªçœï¼Œæ¯ä¸ªçœéƒ½ç”±ä»–ä»¬ç‹å®¤è”é‚¦çš„ä¸€ä¸ªæˆå‘˜æ¥ç®¡ç†ã€‚ä»–çš„å›½å®¶æœ‰ ä¸ªåŸå¸‚ï¼Œç¼–å·ä¸º ã€‚ä¸€äº›åŸå¸‚ä¹‹é—´æœ‰é“è·¯ç›¸è¿ï¼Œä»»æ„ä¸¤ä¸ªä¸åŒçš„åŸå¸‚ä¹‹é—´æœ‰ä¸”ä»…æœ‰ä¸€æ¡ç›´æ¥æˆ–é—´æ¥çš„é“è·¯ã€‚ æ¯ä¸ªçœè‡³å°‘è¦æœ‰$B$ä¸ªåŸå¸‚ï¼Œæœ€å¤šåªæœ‰$3B$ä¸ªåŸå¸‚ã€‚ æ¯ä¸ªçœå¿…é¡»æœ‰ä¸€ä¸ªçœä¼šï¼Œè¿™ä¸ªçœä¼šå¯ä»¥ä½äºçœå†…ï¼Œä¹Ÿå¯ä»¥åœ¨è¯¥çœå¤–ã€‚ä½†æ˜¯è¯¥çœçš„ä»»æ„ä¸€ä¸ªåŸå¸‚åˆ°è¾¾çœä¼šæ‰€ç»è¿‡çš„é“è·¯ä¸Šçš„åŸå¸‚ï¼ˆé™¤äº†æœ€åä¸€ä¸ªåŸå¸‚ï¼Œå³è¯¥çœçœä¼šï¼‰éƒ½å¿…é¡»å±äºè¯¥çœã€‚ ä¸€ä¸ªåŸå¸‚å¯ä»¥ä½œä¸ºå¤šä¸ªçœçš„çœä¼šã€‚ è¿™é¢˜è²Œä¼¼æ˜¯æ ‘åˆ†å—çš„èµ·æº.è€Œå®ƒçš„åšæ³•,å°±æ˜¯æˆ‘ä»¬å°†è¦ä½¿ç”¨çš„æ ‘åˆ†å—çš„åŸºç¡€.å…¶åšæ³•å¦‚ä¸‹. æ€»ä½“åšæ³•æ˜¯ä½¿ç”¨dfsç»´æŠ¤ç”±å­æ ‘èŠ‚ç‚¹ç»„æˆçš„æ ˆ.å½“è¿›å…¥uæ—¶,è®°å½•å½“å‰æ ˆé¡¶,å°†å­èŠ‚ç‚¹åŠ å…¥æ ˆ.å½“æ ˆé¡¶å’Œä¹‹å‰è®°å½•çš„æ ˆé¡¶å·®è¾¾åˆ°åˆ†å—ç•Œé™æ—¶,å°±æŠŠå®ƒä»¬å¼¹å‡ºå¹¶ç»„æˆä¸€ä¸ªå—.è¿™ä¿è¯äº†å—é—´è”é€š,å—ä¸ç»è¿‡å…¶ä»–èŠ‚ç‚¹.è¿™ç§åšæ³•æ€»èƒ½ä¿è¯åˆ†å—å¤§å°åœ¨$[B,2B]$,æœ€åä¸€ä¸ªå—å¤§å°åœ¨$[B,3B]$. å½“vä¸å½¢æˆæ–°å—æ—¶,è¯´æ˜vçš„æ ˆå¤§å°å°äºB.è€Œæ ˆåˆå¹¶å‰,vçš„çˆ¶èŠ‚ç‚¹uçš„æ ˆä¹Ÿå°äºB,å› æ­¤æ€»ä½“å¤§å°å°äº2B. DFSå®Œæˆå,å¯èƒ½å‰©ä½™å°äºBä¸ªèŠ‚ç‚¹.è¿™äº›èŠ‚ç‚¹åŠ å…¥æœ€åä¸€ä¸ªå—,ä»è€Œå¤§å°å°äº3B. ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:5:1","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"å›åˆ°è«é˜Ÿ ç»ˆäºæˆ‘ä»¬å¯¹æ ‘å®Œæˆäº†åˆ†å—.æˆ‘ä»¬çš„æ€»ä½“æ€è·¯ä»ç„¶æ˜¯ç¦»çº¿æ’åº,æš´åŠ›è½¬ç§». è®¾$T_u$ä¸º$u$åˆ°æ ¹èŠ‚ç‚¹çš„è¾¹é›†åˆ.é‚£ä¹ˆuåˆ°vçš„è·¯å¾„ä¸º$T_u \\Delta T_v$. æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ä»$T_u \\Delta T_v$åˆ°$T_uâ€™\\Delta T_v'$ã€‚ç”±äºå¯¹ç§°å·®æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œæœ‰ $$ T_u \\Delta T_v \\Delta (T_u \\Delta T_uâ€™) \\Delta (T_v\\Delta T_vâ€™)=T_uâ€™\\Delta T_vâ€™ $$ æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥è®°å½•æ¯ä¸ªç‚¹æ˜¯å¦æœ‰è¢«ç®—å…¥ç­”æ¡ˆï¼Œç„¶åæš´åŠ›è½¬ç§»ä»$u \\leadsto u'$ï¼Œä»$v \\leadsto v'$ï¼Œå¯¹äºåœ¨ç­”æ¡ˆä¸­çš„åˆ é™¤ï¼Œå¯¹äºä¸åœ¨ç­”æ¡ˆä¸­çš„åŠ å…¥ã€‚ ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:5:2","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["å­¦ä¹ "],"content":"6 æ³¨æ„ å…³äºè®°å½•å½“å‰é—®é¢˜çš„åŒºé—´çš„å¼€é—­é—®é¢˜ï¼Œéœ€è¦è°¨æ…å®‰æ’ã€‚ åœ¨ç¡®è®¤äº†åŒºé—´å¼€é—­åï¼Œå…³äºæœ€åˆå§‹çš„çŠ¶æ€ï¼Œéœ€è¦è°¨æ…å®‰æ’ã€‚ ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:6:0","tags":["è«é˜Ÿ","åˆ†å—","LCA"],"title":"è«é˜Ÿç®—æ³•","uri":"/2019/08/mo-s-algorithm/"},{"categories":["code"],"content":"zz6d likes reading very much, so he bought a lot of books. One day, zz6d brought n books to a classroom in school. The books of zz6d is so popular that K students in the classroom want to borrow his books to read. Every book of zz6d has a number i (1\u003c=i\u003c=n). Every student in the classroom wants to get a continuous number books. Every book has a pleasure value, which can be 0 or even negative (causing discomfort). Now zz6d needs to distribute these books to K students. The pleasure value of each student is defined as the sum of the pleasure values of all the books he obtains.Zz6d didnâ€™t want his classmates to be too happy, so he wanted to minimize the maximum pleasure of the K classmates. zz6d can hide some last numbered books and not distribute them,which means he can just split the first x books into k parts and ignore the rest books, every part is consecutive and no two parts intersect with each other.However,every classmate must get at least one book.Now he wonders how small can the maximum pleasure of the K classmates be. 1\u003c=T\u003c=10 1\u003c=n\u003c=2*105 1\u003c=k\u003c=n -109\u003c=ai\u003c=109 åˆ†æ æœ€å¤§å€¼æœ€å°ï¼Œè€ƒè™‘äºŒåˆ†ç­”æ¡ˆã€‚æ€è€ƒé¢˜ç›®æ˜¯å¦å…·æœ‰å•è°ƒæ€§ï¼šå½“æœ€å¤§å€¼æå¤§æ—¶ï¼Œä¹¦å¯ä»¥éšä¾¿åˆ†ï¼Œå½“æœ€å¤§å€¼æå°æ—¶ï¼Œå¯èƒ½ä¼šå‡ºç°æ— æ³•å‡‘é½çš„çŠ¶å†µï¼Œç›®æµ‹æ»¡è¶³ã€‚ é¢˜ç›®è¦æ±‚åˆ†ä¹¦æ—¶å¿…é¡»è¿ç»­åˆ†ï¼Œå¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥åšã€‚å‡è®¾äºŒåˆ†çš„ç­”æ¡ˆä¸ºlim $$f(i)=\\max \\{ f(j) | \\sum_{k=j+1}^i a_k \\leq lim \\}+1$$ å°†æ±‚å’Œæ”¹ä¸ºå‰ç¼€å’Œï¼Œ$pre(i)$ã€‚ $$f(i)=\\max \\{ f(j) | pre(i)-pre(j-1) \\leq lim \\}+1$$ åŠ¨æ€è§„åˆ’çš„å¤æ‚åº¦ä¸º$O(n^2)$ï¼Œå¤ªæ…¢ï¼Œè€ƒè™‘ä¼˜åŒ–ã€‚ æ¯æ¬¡è½¬ç§»éƒ½ä»å…ˆå‰å·²ç»å‡ºç°çš„æ»¡è¶³è¦æ±‚çš„fä¸­è½¬ç§»ã€‚é™åˆ¶æ¡ä»¶è½¬ä¸€ä¸‹ï¼Œå°±æ˜¯ $$pre(i)-lim \\leq pre(?)$$ å½“æœ‰2ä¸ªfå¯¹åº”çš„å‰ç¼€å’Œç›¸åŒï¼Œæˆ‘ä»¬é€‰æ‹©æ›´å¤§çš„é‚£ä¸ª æ‰€ä»¥å¯ä»¥ç›´æ¥ç»´æŠ¤å·²ç»å‡ºç°çš„æ¯ç§å‰ç¼€å’Œæ‰€å¯¹åº”çš„æœ€å¤§fã€‚å¯ä»¥ç¦»æ•£åŒ–åä½¿ç”¨æƒå€¼çº¿æ®µæ ‘ã€‚å¤æ‚åº¦å˜ä¸º$O(n\\lg n)$ æ€»å¤æ‚åº¦ä¸º$O(n\\lg n \\lg n)$ã€‚ ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=900010; ll dat[MAXN]; int lc[MAXN],rc[MAXN]; int idx=0; int build(int \u0026n,int l,int r){ if(!n)n=++idx; dat[n]=-0x3f3f3f3f; if(l\u003e=r)return dat[n]; int mid=(l+r)/2; dat[n]=max(build(lc[n],l,mid),build(rc[n],mid+1,r)); return dat[n]; } void collectchild(int node){ dat[node]=max(dat[lc[node]],dat[rc[node]]); } int query_n(int l,int r,int L,int R,int node){ if(l\u003c=L \u0026\u0026 R\u003c=r)return dat[node]; int mid=(L+R)/2; int res=-0x3f3f3f3f; if(l\u003c=mid)res=max(res,query_n(l,r,L,mid,lc[node])); if(mid\u003cr)res=max(res,query_n(l,r,mid+1,R,rc[node])); return res; } void modify(int l,int r,ll x,int L,int R,int node){ if(L\u003e=R){ dat[node]=max(dat[node],x); return; } int mid=(L+R)/2; if(l\u003c=mid)modify(l,r,x,L,mid,lc[node]); if(mid\u003cr)modify(l,r,x,mid+1,R,rc[node]); collectchild(node); } ll prefix[MAXN]; ll bprefix[MAXN]; ll num[MAXN]; int nlen,sel; int rlen; int root; bool check(ll x){ build(root,0,rlen-1); int zero=lower_bound(bprefix,bprefix+rlen,0)-bprefix; modify(zero,zero,0,0,rlen-1,root); for(int i=1;i\u003c=nlen;i++){ int start=lower_bound(bprefix,bprefix+rlen,bprefix[prefix[i]]-x)-bprefix; int dp=query_n(start,rlen-1,0,rlen-1,root)+1; if(dp\u003e=sel)return true; modify(prefix[i],prefix[i],dp,0,rlen-1,root); } return false; } int main(){ //debug /* int opt; build(root,0,10-1); while(cin\u003e\u003eopt){ if(opt==1){ int pos,x;cin\u003e\u003epos\u003e\u003ex; modify(pos,pos,x,0,10-1,root); }else{ int l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003cquery_n(l,r,0,10-1,root)\u003c\u003cendl; } } */ int kase;cin\u003e\u003ekase; while(kase--){ cin\u003e\u003enlen\u003e\u003esel; for(int i=1;i\u003c=nlen;i++){ cin\u003e\u003enum[i]; } bprefix[0]=prefix[0]=0; for(int i=1;i\u003c=nlen;i++)bprefix[i]=prefix[i]=prefix[i-1]+num[i]; //discrete sort(bprefix,bprefix+nlen+1); rlen=unique(bprefix,bprefix+nlen+1)-bprefix; for(int i=0;i\u003c=nlen;i++)prefix[i]=lower_bound(bprefix,bprefix+rlen,prefix[i])-bprefix; //binary ll l=-1e15,r=1e15; while(l+1\u003cr){ ll mid=(l+r)/2; if(check(mid)){ r=mid; }else l=mid; } for(ll i=l;i\u003c=r;i++){ if(check(i)){ cout\u003c\u003ci\u003c\u003cendl; break; } } } return 0; } å¤šç»„è¯¢é—®æ²¡æœ‰æ¸…ç†å¹²å‡€æ•°ç»„ï¼ŒWAäº†å¥½å‡ å‘ã€‚ ","date":"2019-08-01","objectID":"/2019/08/distribution-of-books/:0:0","tags":null,"title":"Distribution of Books","uri":"/2019/08/distribution-of-books/"},{"categories":["code"],"content":"Farmer John keeps a website called â€˜FansBlogâ€™ .Everyday , there are many people visited this blog.One day, he find the visits has reached P , which is a prime number.He thinks it is a interesting fact.And he remembers that the visits had reached another prime number.He try to find out the largest prime number Q ( Q \u003c P ) ,and get the answer of Q! Module P.But he is too busy to find out the answer. So he ask you for help. ( Q! is the product of all positive integers less than or equal to n: n! = n * (n-1) * (n-2) * (n-3) *â€¦ * 3 * 2 * 1 . For example, 4! = 4 * 3 * 2 * 1 = 24 ) First line contains an number T(1\u003c=T\u003c=10) indicating the number of testcases. Then T line follows, each contains a positive prime number P (1e9â‰¤pâ‰¤1e14) åˆ†æ è¿™é¢˜å¾—çŸ¥é“2ä¸ªç»“è®ºï¼Œç„¶è€Œæˆ‘éƒ½ä¸çŸ¥é“ã€‚ ","date":"2019-08-01","objectID":"/2019/08/fansblog/:0:0","tags":null,"title":"Fansblog","uri":"/2019/08/fansblog/"},{"categories":["code"],"content":"å¨å°”é€Šå®šç† å½“Pä¸ºè´¨æ•°æ—¶ï¼Œ$(P-1)! \\equiv -1 \\pmod P$. æ³¨æ„è¿™é‡Œ$!$æ˜¯é˜¶ä¹˜ï¼Œä¸æ˜¯å–åçš„æ„æ€ã€‚ ","date":"2019-08-01","objectID":"/2019/08/fansblog/:1:0","tags":null,"title":"Fansblog","uri":"/2019/08/fansblog/"},{"categories":["code"],"content":"ç´ æ•°åˆ†å¸ƒ å½“èŒƒå›´å˜å¤§æ—¶ï¼Œç´ æ•°çš„å‡ºç°é¢‘ç‡å¢é«˜ï¼Œå¯»æ‰¾ä¸€ç´ æ•°çš„ç›¸é‚»ç´ æ•°å¤æ‚åº¦é€æ¸è¶‹è¿‘äºçº¿æ€§ã€‚ æ‰€ä»¥ï¼Œå¯»æ‰¾ç´ æ•°Pçš„å‰ä¸€ä¸ªç´ æ•°å¯ä»¥ç›´æ¥æš´åŠ›æ‰¾ã€‚æ‰¾åˆ°ä¹‹ååˆ©ç”¨$(P-1)! \\equiv -1 \\pmod P$å³å¯å¿«é€Ÿç”±$P-1$çš„é˜¶ä¹˜é€šè¿‡é€†å…ƒè½¬åˆ°$Q$çš„é˜¶ä¹˜ï¼Œè¿™é¢˜å°±åšå®Œäº†ã€‚ å› ä¸ºåœ¨è®¡ç®—é€†å…ƒæ—¶ä¼šçˆ†llï¼Œä½¿ç”¨å¿«é€Ÿä¹˜æ³•æ¥é¿å…ï¼Œå¤æ‚åº¦ç¬¦åˆè¦æ±‚ã€‚ ä»£ç  #include \u003ciostream\u003e#include \u003ccmath\u003e#include \u003ccstdlib\u003e#include \u003calgorithm\u003eusing namespace std; using ll=long long; inline ll qmul(ll x,ll y,ll q){ ll res=0; for(;y;y\u003e\u003e=1,x=(x+x)%q){ if(y\u00261)res=(res+x)%q; } return res; } inline ll qpow(ll x,ll a,ll q){ ll res=1; for(a;a;a\u003e\u003e=1,x=qmul(x,x,q)){ if(a\u00261)res=qmul(res,x,q); } return res; } inline ll get_rev(ll x,ll q){ return qpow(x,q-2,q); } inline bool is_prime(ll x){ for(ll i=2;i\u003c=sqrt(x);i++){ if(x%i==0)return false; } return true; } inline ll factor(ll l,ll r,ll q){ ll res=1; for(ll i=l;i\u003c=r;i++)res=qmul(res,i,q); return res; } int main(){ ios::sync_with_stdio(false); int kase;cin\u003e\u003ekase; while(kase--){ ll x;cin\u003e\u003ex; ll prex=x-1; while(!is_prime(prex))prex--; ll ans=qmul(x-1,get_rev(factor(prex+1,x-1,x),x),x); cout\u003c\u003cans\u003c\u003cendl; } return 0; } ","date":"2019-08-01","objectID":"/2019/08/fansblog/:2:0","tags":null,"title":"Fansblog","uri":"/2019/08/fansblog/"},{"categories":["code"],"content":"ä¸€äº›ç»“è®º $N!$çš„è´¨å› æ•°åˆ†è§£ä¸­æŸè´¨æ•°çš„æŒ‡æ•°ä¸º$\\sum_{r=1}^{\\inf}n/p^r $ çº¦æ•°ä¸ªæ•°ä¸ºè´¨å› æ•°æŒ‡æ•°+1çš„ä¹˜ç§¯ï¼Œå’Œä¸ºè´¨å› æ•°æšä¸¾æŒ‡æ•°æ¬¡å’Œçš„ä¹˜ç§¯ã€‚ è´¹é©¬å°å®šç†è¦æ±‚pæ˜¯è´¨æ•° ","date":"2019-07-22","objectID":"/2019/07/salt-fish-playing-number/:1:0","tags":null,"title":"å’¸é±¼æ•°è®º","uri":"/2019/07/salt-fish-playing-number/"},{"categories":["code"],"content":"æ¬§æ‹‰å‡½æ•° å°äºxä¸”ä¸å…¶äº’è´¨çš„æ•°çš„ä¸ªæ•° $$ \\phi(x)=x\\prod_{k=1}^n(1-\\frac{1}{p_k}) $$ $phi(1)=1$ $phi(p)=p-1$,å½“pä¸ºè´¨æ•° $phi(2n)=phi(n)$ $phi(phi(phiâ€¦))))=1$ å¯¹äºä»»æ„ç§¯æ€§å‡½æ•°$f(xy)=f(x)f(y)$ï¼Œå¯ä»¥ç­›ã€‚æ¬§æ‹‰å‡½æ•°éå®Œå…¨ç§¯æ€§å‡½æ•°ã€‚ $phi(xy)=phi(x)(y-1)$,å½“xä¸yäº’è´¨ $phi(xy)=phi(x)y$,å½“xä¸yä¸äº’è´¨ for(int i=2;i\u003c=n;i++){ if(!no[i]){ p[++cnt]=i; phi[i]=i-1; } for(int j=1;j\u003c=cnt\u0026\u0026p[j]*i\u003c=n;j++){ no[p[j]*i]=1; if(i%p[j]==0){ phi[p[j]*i]=phi[i]*p[j]; break; } phi[p[j]*i]=phi[i]*(p[j]-1); } } ","date":"2019-07-22","objectID":"/2019/07/salt-fish-playing-number/:2:0","tags":null,"title":"å’¸é±¼æ•°è®º","uri":"/2019/07/salt-fish-playing-number/"},{"categories":["code"],"content":"æ‰©å±•æ¬§å‡ é‡Œå¾— å­˜åœ¨xï¼Œyä½¿å¾—ax+by=gcdï¼ˆaï¼Œbï¼‰ æ±‚é€†å…ƒï¼Œè¦æ±‚xä¸æ¨¡æ•°äº’è´¨ void exgcd(ll a,ll b,ll \u0026x,ll \u0026y){ if(!b){ x=1,y=0; }else{ exgcd(b,a%b,y,x); y-=(a/b)*x; } } ","date":"2019-07-22","objectID":"/2019/07/salt-fish-playing-number/:3:0","tags":null,"title":"å’¸é±¼æ•°è®º","uri":"/2019/07/salt-fish-playing-number/"},{"categories":["code"],"content":"é€’æ¨é€†å…ƒ inv(i) = inv(mod % i) * (mod-mod/i) % mod; é˜¶ä¹˜çš„é€†å…ƒï¼šinv(i)=inv(i+1)*(i+1) ","date":"2019-07-22","objectID":"/2019/07/salt-fish-playing-number/:4:0","tags":null,"title":"å’¸é±¼æ•°è®º","uri":"/2019/07/salt-fish-playing-number/"},{"categories":["code"],"content":"é›†åˆæŒ‘é€‰ ä»ç»™å®šçš„Nä¸ªé›†åˆä¸­å„æŒ‘å‡ºä¸€ä¸ªæ•°å¹¶æ±‚å’Œï¼Œæ±‚å‡ºå‰$K$å¤§çš„$K$ä¸ªå’Œã€‚ è€ƒè™‘å¦‚ä½•ä»2ä¸ªé›†åˆ$A$,$B$ä¸­é€‰å‡ºå‰$K$å¤§ã€‚é™åºæ’åºå$a_1$å’Œ$b_1$æ˜¾ç„¶æ˜¯æœ€å¤§ï¼Œç¬¬äºŒå¤§åˆ™æ˜¯$(a_1,b_2)$æˆ–è€…$(a_2,b_1)$ã€‚ä¸å¦¨ä»¥$(a_1,b_2)$æ¥è®²ï¼Œé‚£ä¹ˆç¬¬ä¸‰å¤§ç«äº‰è€…é™¤$(a_2,b_1)$è¿˜æœ‰$(a_1,b_3)$ï¼Œ$(a_2,b_3)$â€¦â€¦æ¯å¯¹ç»„åˆéƒ½èƒ½æ‰¾åˆ°ç›´æ¥å°äºå®ƒçš„2ä¸ªç»„åˆï¼Œè€Œè¿™ç§åç»§å…³ç³»æ˜¾ç„¶å–éäº†æ‰€æœ‰ç»„åˆã€‚ä»…éœ€è¦å‰Kå¤§çš„æˆ‘ä»¬æŒ‰éœ€æ‰©å±•è¿™ä¸€æ£µæ ‘å³å¯ã€‚2ä¸ªé›†åˆçš„å‰Kå¤§å¯ä¸ç¬¬3ä¸ªé›†åˆæ‰§è¡Œç›¸åŒçš„æ“ä½œï¼Œä»è€Œå¾—åˆ°æœ€ç»ˆç­”æ¡ˆã€‚å®é™…ç¼–å†™æ—¶ï¼ŒæŒ‰ç…§ä¸€å®šé¡ºåºé™åˆ¶æ‰©å±•æ–¹å‘æ¥ä¿è¯æ¯ä¸ªæ–¹æ¡ˆä»…è®¿é—®ä¸€æ¬¡ï¼Œä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤ï¼Œå¤æ‚åº¦ä¸º$O(\\sum^N{K\\log n_k}) \\leq O(KN)$ ","date":"2019-07-22","objectID":"/2019/07/water-series/:1:0","tags":null,"title":"æ°´çš„åˆé›† 1","uri":"/2019/07/water-series/"},{"categories":["code"],"content":"LISä¼˜åŒ– $$f(i)=max\\{f(j)| j å¯ä»¥å‘ç°ï¼Œä¸€æ—¦æœ‰$a(k) \u003c a(j), f(k) \\geq f(j)$ï¼Œjè¿™ä¸ªä½ç½®å°±æ²¡æœ‰ç”¨äº†ã€‚æŒ‰ç…§è¯¥è§„å¾‹ç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆè®°å½•ï¼Œä»¥é•¿åº¦å•è°ƒï¼ˆåˆ™æ•°å­—aç»“å°¾çš„LISè‡ªç„¶å•è°ƒï¼‰ã€‚æ­¤åè½¬ç§» ","date":"2019-07-22","objectID":"/2019/07/water-series/:2:0","tags":null,"title":"æ°´çš„åˆé›† 1","uri":"/2019/07/water-series/"},{"categories":["code"],"content":"ç»™å‡ºä¸€ä¸ª$N \\times N$çš„éè´Ÿæ•´æ•°çŸ©é˜µï¼Œè¦æ±‚æ‰¾åˆ°ä¸€æ¡ä»å·¦ä¸Šè§’æ•°å­—åˆ°å³ä¸‹è§’æ•°å­—çš„è·¯çº¿ï¼Œä¸” åªèƒ½å‘å³æˆ–è€…ä¸‹èµ°ã€‚ å°†ç»è¿‡æ•°å­—ç›¸ä¹˜åå¾—åˆ°çš„ç»“æœï¼Œä½¿å…¶æœ«å°¾çš„â€œ0â€æœ€å°‘ã€‚ $$ N \\leq 1000 $$ ","date":"2019-07-20","objectID":"/2019/07/bupt-warmupcf-milktea/:0:0","tags":["åŠ¨æ€è§„åˆ’"],"title":"[BUPT WARMUP|CF] çç å¥¶èŒ¶","uri":"/2019/07/bupt-warmupcf-milktea/"},{"categories":["code"],"content":"åˆ†æ å¤§æ¦‚æ˜¯å› ä¸ºæœ«å°¾çš„0é•¿å¾—åƒçç ã€‚ æ€è€ƒ0æ˜¯æ€ä¹ˆå‡ºç°çš„ï¼Œå¯ä»¥å‘ç°ç»“æœä¸­å› æ•°10çš„æŒ‡æ•°è¶Šå°è¶Šå¥½ï¼Œå³ï¼Œä½¿å¾—ç»è¿‡çš„è·¯ä¸Šå‡‘å‡ºçš„å› æ•°10æœ€å°‘å³å¯ã€‚10çš„è´¨å› æ•°åˆ†è§£ä¸º$2 \\times 5$ï¼Œä»¥çŸ©é˜µä¸­æ¯ä¸ªæ•°æ‰€å«å› æ•°2å’Œ5çš„æ•°ç›®åˆ†åˆ«DPä¸€éæ±‚è·¯å¾„ï¼Œå†åœ¨ä¸¤æ¬¡DPçš„ç»“æœä¸­å–å°ã€‚ ä¸€ä¸ªç‰¹æ®Šæƒ…å†µæ˜¯æ•°å­—é‡Œæœ‰0ï¼Œé‚£ä¹ˆç»è¿‡0çš„è·¯çš„æœ«å°¾0ä¸€å®šæ˜¯1ä¸ªâ€¦â€¦ä¸€å¼€å§‹è„‘è¢‹æŠ½äº†ä»¥ä¸ºæ˜¯0ä¸ªã€‚å¦‚æœå…¶ä»–æƒ…å†µçš„è·¯å¾„æœ«å°¾0éƒ½å¤šäº1ä¸ªçš„è¯ï¼Œå°±ç‰¹åˆ¤èµ°0ã€‚ ","date":"2019-07-20","objectID":"/2019/07/bupt-warmupcf-milktea/:1:0","tags":["åŠ¨æ€è§„åˆ’"],"title":"[BUPT WARMUP|CF] çç å¥¶èŒ¶","uri":"/2019/07/bupt-warmupcf-milktea/"},{"categories":["code"],"content":"ä»£ç  #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; constexpr int MAXN=1010; int game[MAXN][MAXN]; int num[2][MAXN][MAXN]; int cal(int x,int fac){ if(x==0)return 0; int res=0; while(x%fac==0){ x/=fac; res++; } return res; } int n; int dp[MAXN][MAXN]; int from[MAXN][MAXN]; void dodp(int fac){ for(int i=0;i\u003cMAXN;i++){ for(int j=0;j\u003cMAXN;j++){ dp[i][j]=0x3f3f3f3f; } } dp[0][1]=dp[1][0]=0; for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n;j++){ if(dp[i-1][j]\u003cdp[i][j-1]){ from[i][j]=2; dp[i][j]=dp[i-1][j]; }else{ from[i][j]=1; dp[i][j]=dp[i][j-1]; } dp[i][j]+=num[fac][i][j]; } } } string genpath(){ string res=\"\"; int i=n,j=n; for(int p=from[i][j];i!=1 || j!=1 ;p=from[i][j]){ if(p==2){ res+=\"D\"; i--; }else{ res+=\"R\"; j--; } } reverse(res.begin(),res.end()); return res; } int main(){ ios::sync_with_stdio(false); cin\u003e\u003en; bool haszero=false; int zeroi,zeroj; for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n;j++){ cin\u003e\u003egame[i][j]; if(game[i][j]==0){ haszero=1; zeroi=i,zeroj=j; } } } for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n;j++){ num[0][i][j]=cal(game[i][j],2); num[1][i][j]=cal(game[i][j],5); } } int ans=0x7f7f7f7f; dodp(0); string P; if(ans\u003edp[n][n]){ ans=dp[n][n]; P=genpath(); } dodp(1); if(ans\u003edp[n][n]){ ans=dp[n][n]; P=genpath(); } if(haszero \u0026\u0026 ans\u003e1){ cout\u003c\u003c1\u003c\u003cendl; for(int i=1;i\u003czeroi;i++)cout\u003c\u003c\"D\"; for(int j=1;j\u003czeroj;j++)cout\u003c\u003c\"R\"; for(int i=zeroi+1;i\u003c=n;i++)cout\u003c\u003c\"D\"; for(int j=zeroj+1;j\u003c=n;j++)cout\u003c\u003c\"R\"; cout\u003c\u003cendl; return 0; } cout\u003c\u003cans\u003c\u003cendl; cout\u003c\u003cP\u003c\u003cendl; return 0; } ","date":"2019-07-20","objectID":"/2019/07/bupt-warmupcf-milktea/:2:0","tags":["åŠ¨æ€è§„åˆ’"],"title":"[BUPT WARMUP|CF] çç å¥¶èŒ¶","uri":"/2019/07/bupt-warmupcf-milktea/"},{"categories":["code"],"content":"There is a tree having n nodes, the i-th node of which has a type of color, denoted by an integer $c_i$ The path between every two nodes is unique, of which we define the value is the number of distinct types of colors appearing on it. Calculate the sum of values of all possible paths, $\\frac{n(n-1)}{2}$ in total, between two different nodes on the tree. ","date":"2019-07-12","objectID":"/2019/07/colorful-tree/:0:0","tags":null,"title":"Colorful Tree","uri":"/2019/07/colorful-tree/"},{"categories":["code"],"content":"è¾“å…¥èŒƒå›´ å¤šç»„æ•°æ®,çº¦50;èŠ‚ç‚¹æ•°$2 \\times 10^5$. åˆ†æ æ²¡æƒ³å‡ºæ¥è¯¥æ€ä¹ˆåš.ç»Ÿè®¡è·¯å¾„é¢œè‰²çš„ç­”æ¡ˆæ²¡æœ‰ä»€ä¹ˆåˆå¹¶çš„å¥½æ–¹æ³•,åŒæ—¶ä¹Ÿä¸èƒ½æŒ‰ç…§æ¯ç§é¢œè‰²å•ç‹¬è€ƒè™‘. åæ¥ç»è¿‡dalaoç‚¹æ‹¨,è¯¥é¢˜ä¸­çš„\"ç»Ÿè®¡ä¸€æ¡è·¯å¾„ä¸Šé¢œè‰²ç§ç±»\"çš„è¦æ±‚å¯ä»¥è½¬åŒ–ä¸ºæ±‚å…¶åé¢â€œæ²¡æœ‰æŸç§é¢œè‰²çš„è·¯å¾„æœ‰å¤šå°‘ç§â€. å¦‚æ­¤,å¯¹äºæ¯ä¸€ç§é¢œè‰²å°±å¯ä»¥ä½¿ç”¨$n(n-1)/2-size$æ¥æ±‚å…¶å¯¹ç­”æ¡ˆçš„è´¡çŒ®äº†.So,æ¥è§£å†³è¿™ä¸ªé—®é¢˜. åŸå›¾æ˜¯ä¸€æ£µæ ‘,å¦‚æœæŸç‚¹$N$ä¸ºé¢œè‰²$c$,é‚£ä¹ˆç»è¿‡$N$çš„å­æ ‘ä»»æ„ç‚¹è·¨è¶Š$N$çš„è·¯å¾„éƒ½æœ‰è¯¥é¢œè‰².æ‰€æœ‰ä¸åŒ…æ‹¬è¯¥é¢œè‰²$c$çš„è·¯å¾„åªèƒ½å‡ºç°åœ¨ä»¥$N$ä¸ºåˆ‡ç‚¹çš„å…¶ä»–2éƒ¨åˆ†.è€ƒè™‘å…¶ä¸­ä¸€ä¸ªéƒ¨åˆ†,ä»»æ„é€‰ä¸­å…¶ä¸­2ä¸ªèŠ‚ç‚¹å³å¯æ„å»ºä¸€æ¡è·¯å¾„,ä½†è¿˜æ˜¯å¿…é¡»æ»¡è¶³åˆšåˆšçš„æ¡ä»¶(ä¸èƒ½è·¨è¶Šé¢œè‰²$c$çš„èŠ‚ç‚¹).ä»¥dfsé€’å½’è¿›å»å³å¯. è€ƒè™‘èƒ½å¦é€’å½’åˆå¹¶å·²æœ‰ç­”æ¡ˆ.èƒ½å¤Ÿå¾—åˆ°çš„æ•°æ®æœ‰å­èŠ‚ç‚¹ä¸­2éƒ¨åˆ†çš„èŠ‚ç‚¹æ•°ç›®,æ˜¾ç„¶èƒ½å¤Ÿåˆå¹¶å‡ºä»¥å½“å‰èŠ‚ç‚¹ä¸ºç•Œåˆ’åˆ†çš„2éƒ¨åˆ†ä¸­çš„ä¸€éƒ¨åˆ†,è‡ªç„¶å¯ä»¥åœ¨é€’å½’è¿”å›åæ¨å‡ºå¦ä¸€éƒ¨åˆ†. ä»£ç  #include \u003ciostream\u003e#include \u003cset\u003e#include \u003calgorithm\u003e#include \u003ccstdlib\u003e#include \u003ccstring\u003e#include \u003ccmath\u003e#include \u003cvector\u003eusing namespace std; typedef long long ll; const int MAXV=200010; vector\u003cint\u003e g[MAXV]; inline void adde(int u,int v){ g[u].push_back(v); } int color[MAXV]; ll sz[MAXV]; ll gsz; ll res=0; void dfs(int u,int fa){ gsz++; for(auto v:g[u]){ if(v==fa)continue; ll b_gsz=gsz; ll b_sz=sz[color[u]]; dfs(v,u); ll d=(gsz-b_gsz)-(sz[color[u]]-b_sz); res+=d*(d-1)/2; sz[color[u]]+=d; } sz[color[u]]++; } int flag[MAXV]; int main(){ ios::sync_with_stdio(false); int n; int kase=0; while(cin\u003e\u003en){ for(int i=1;i\u003c=n;i++)g[i].clear(); memset(sz,0,sizeof(sz)); gsz=0; res=0; vector\u003cint\u003e discol; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ecolor[i]; flag[color[i]]=1; } for(int i=1;i\u003c=n;i++){ if(flag[i])discol.push_back(i); } for(int i=0;i\u003cn-1;i++){ int u,v;cin\u003e\u003eu\u003e\u003ev; adde(u,v); adde(v,u); } int disnum=discol.size(); dfs(1,0); ll ans=(ll)disnum*n*(n-1)/2; for(auto i:discol){ ll t=n-sz[i]; ans-=t*(t-1)/2; } cout\u003c\u003c\"Case #\"\u003c\u003c++kase\u003c\u003c\": \"\u003c\u003cans-res\u003c\u003cendl; } return 0; } ","date":"2019-07-12","objectID":"/2019/07/colorful-tree/:1:0","tags":null,"title":"Colorful Tree","uri":"/2019/07/colorful-tree/"},{"categories":["å­¦ä¹ "],"content":" å†™ä»£ç æ˜¯ä¸å¯èƒ½å†™ä»£ç çš„,ä»Šä¸‹åˆæ˜¯ä¸æƒ³å†™ä»£ç çš„.ä¸æƒ³å†™ä»£ç ,åˆä¸æƒ³å’¸é±¼,å°±åªèƒ½é å­¦ç‚¹æ–°ä¸œè¥¿æ¥å‡è£…è‡ªå·±åœ¨å·¥ä½œçš„æ ·å­,å¿ƒé‡Œæ‰èƒ½å¥½å—äº›. çªƒæ ¼ç æ‹‰ å‡ ä¹å¯ä»¥è‚¯å®š,ä¸‹é¢çš„å†…å®¹è‚¯å®šä¼šå‡ºé”…. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:0:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å‚…é‡Œå¶å˜æ¢çš„å®é™…æ„ä¹‰ ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:1:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"ä»ç”µå‹è¯´èµ· è¢«æ¨¡ç”µæŠ˜ç£¨çš„åŒå­¦éƒ½çŸ¥é“,æœ‰ç§ä¸œè¥¿å«åšå‚…é‡Œå¶çº§æ•°,å¯ä»¥å°†æˆå‘¨æœŸæ€§å˜åŒ–çš„ç”µå‹åˆ†è§£ä¸ºæ•°ä¸ªä¸‰è§’å‡½æ•°æ³¢çš„å åŠ . åœ¨è¿™é‡Œ,æˆ‘ä»¬æå‡ºå¦ä¸€ä¸ªé—®é¢˜,å¦‚æœä¸çŸ¥é“å‘¨æœŸ,è¯¥å¦‚ä½•å°†è¿™äº›å åŠ åœ¨ä¸€èµ·çš„ä¿¡å·æ‹†åˆ†ä¸ºå•çº¯çš„ä¸‰è§’æ³¢? ä¸‰è§’æ³¢å åŠ å›¾è±¡å‘¨æœŸå¹¶ä¸é‚£ä¹ˆæ˜¾ç„¶,ä¹Ÿè®¸ä½ å¯ä»¥è¯•ä¸€è¯•. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:1:1","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"ä¸€ç§ç¼ ç»•æœº æœ‰ä¸€ç§å¥‡ç‰¹çš„æ–¹æ³•,æˆ‘ä»¬å°†ä¸€æ®µæ—¶åŸŸå›¾è±¡åœ¨ç¬›å¡å°”åæ ‡ç³»ä¸Šä»¥åŸç‚¹ä¸ºåœ†å¿ƒç»•èµ·æ¥,ä¸€åœˆä¸€åœˆç¼ èµ·æ¥,ç„¶åè°ƒæ•´æºå›¾è±¡ç¼ ç»•çš„é€Ÿç‡(å‡ ç§’ä¸€åœˆ),è§‚å¯Ÿæ•´ä¸ªå›¾å½¢çš„è´¨å¿ƒå˜åŒ–. è¿™ä¸ªè´¨å¿ƒä¼šéšç€å›¾è±¡ç¼ ç»•çš„é¢‘ç‡è€Œå‘ç”Ÿä½ç§».å–è´¨å¿ƒçš„xåæ ‡ä¸ºyè½´,ä»¥ç¼ ç»•çš„é¢‘ç‡ä¸ºæ¨ªè½´,ä½œå‡ºå›¾è±¡B.åœ¨è¿™ä¸ªå›¾è±¡ä¸Š,ä¼šè§‚æµ‹åˆ°ä¸€ä¸ªç°è±¡:(å‡è®¾æˆ‘ä»¬å·²çŸ¥åŸå›¾åƒçš„åˆ†è§£ä¸‰è§’æ³¢é¢‘ç‡)å½“ç¼ ç»•é¢‘ç‡æ¥è¿‘æŸä¸ªæºä¸‰è§’æ³¢çš„é¢‘ç‡æ—¶,ç¼ ç»•å›¾è±¡å‡ºç°é‡åˆ,è´¨å¿ƒç›¸å¯¹åŸç‚¹å‡ºç°è¾ƒå¤§ä½ç§»,å›¾è±¡å‡ºç°ä¸€ä¸ªå³°å€¼. ç»§ç»­è°ƒæ•´ç¼ ç»•é¢‘ç‡,å³°å€¼æ¶ˆå¤±,å›¾è±¡å›å½’åˆ°å°èŒƒå›´æ³¢åŠ¨. é€šè¿‡è§‚å¯Ÿå›¾è±¡B,å¯ä»¥è®¤ä¸º,å‡ºç°å³°å€¼çš„é¢‘ç‡å¯¹åº”ç€ä¸€ä¸ªé¢‘ç‡çš„æºä¸‰è§’æ³¢.å¦‚æ­¤,å°±å°†å åŠ å›¾è±¡è¿˜åŸäº†å›å». ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:1:2","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å‚…é‡Œå¶å˜æ¢çš„æ•°å­¦å®ç° ç°åœ¨,è€ƒè™‘å¦‚ä½•é€šè¿‡çš„æ•°å­¦çš„æ–¹æ³•æ¥å®ç°è¿™ä¸ªç¼ ç»•. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:2:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å¦‚ä½•ç¼ ç»• å°†$g(t)$çš„å›¾è±¡ç¼ ç»•åˆ°åœ†ä¸Šå¬èµ·æ¥æŒºå¥‡æ€ªçš„,æœ‰è¿™æ ·çš„æ•°å­¦æ–¹æ³•å—. æœ‰ä¸€ä¸ªä¸œè¥¿,å«åš$y=e^{ix}$.å½“å…¶å›¾è±¡ç”»åœ¨å¤å¹³é¢æ—¶,å°±å‡ºç°äº†æœ‰è¶£çš„äº‹æƒ…:ä¸€ä¸ªåœ†.å¯¹è¿™ä¸ªå…¬å¼åšä¸€äº›åŠ å·¥. $$ y=g(t)e^{-2\\pi i ft} $$ å¦‚æ­¤,å°±èƒ½å¤Ÿå°†$g(t)$ä»¥$f$é¢‘ç‡ç¼ ç»•. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:2:1","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å…³äºè´¨å¿ƒ ä¸Šæ–‡æˆ‘ä»¬å–è´¨å¿ƒçš„xåæ ‡ä½œå›¾,ç°åœ¨éœ€è¦ç¨å¾®ä¿®æ”¹ä¸€ä¸‹. å®é™…ä¸Š,æˆ‘ä»¬å…³å¿ƒçš„æ˜¯è´¨å¿ƒç›¸å¯¹äºåŸç‚¹çš„åç§»è·ç¦».åŒæ ·,ä»¥å¤å¹³é¢çš„æ–¹å¼æ¥è¡¨ç¤ºè´¨å¿ƒä½ç½®å°±èƒ½å¤ŸåŒæ—¶ä¿ç•™xå’Œyåæ ‡ä¿¡æ¯. å…³äºå¦‚ä½•æ±‚å–è´¨å¿ƒ,å…¶å®ä¹Ÿå¾ˆç›´è§‚.é€‰å–ç¼ ç»•å›¾è±¡ä¸Šçš„æ•°ä¸ªç‚¹,å–å¹³å‡,å°±æ˜¯è´¨å¿ƒçš„å¤§çº¦ä½ç½®.å½“ç‚¹çš„æ•°ç›®è¾¾åˆ°æé™,æ±‚å’Œå…¬å¼åŒ–ä¸ºç§¯åˆ†,æ‰€æ±‚å³ä¸ºè´¨å¿ƒ. $$ \\hat g(f)=\\frac{1}{t_2-t_1} \\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}} $$ ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:2:2","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"? ç›®å‰ä¸ºæ­¢,è¿™å‡ ä¹å·²ç»æ˜¯å‚…é‡Œå¶å˜æ¢äº†.åœ¨æ•°å­¦åº”ç”¨æ—¶,å‚…é‡Œå¶å˜æ¢ä¼šå»æ‰å–å‡å€¼,å³ $$ \\hat g(f)=\\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}} $$ ä¹Ÿå°±æ˜¯è¯´,å–æ ·çš„æ—¶åŸŸä¿¡å·è¶Šé•¿,è¯¥è´¨å¿ƒçš„åç§»å€¾å‘è¶Šå¤§,è¿™å’Œæˆ‘ä»¬æƒ³è¦çš„æ•ˆæœä¸€è‡´. è¿™å°±æ˜¯å‚…é‡Œå¶å˜æ¢,å®ç°äº†æ—¶åŸŸä¿¡å·åˆ°é¢‘åŸŸä¿¡å·çš„è½¬æ¢. æ­¤å¤–,è¿˜æœ‰æ–¹æ³•å°†é¢‘åŸŸä¿¡å·å†æ¬¡é€†å˜æ¢ä¸ºæ—¶åŸŸä¿¡å·çš„æ–¹æ³•. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:2:3","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"åº”ç”¨ å‚…é‡Œå¶å˜æ¢åœ¨å¾ˆå¤šé¢†åŸŸéƒ½æœ‰é‡è¦ä½œç”¨.åªè¦é—®é¢˜èƒ½è½¬æ¢ä¸ºæ—¶åŸŸé¢‘åŸŸä¹‹é—´çš„å˜åŒ–,å°±æœ‰å‚…é‡Œå¶å˜æ¢çš„ç”¨æ­¦ä¹‹å¤„. æ¯”å¦‚,åœ¨éŸ³é¢‘å¤„ç†è½¯ä»¶ä¸­,å¸¸å¸¸æœ‰ä¸€ä¸ªåŠŸèƒ½å«åšæ¶ˆé™¤äººå£°.åŸºäºå‚…é‡Œå¶å˜æ¢æˆ‘ä»¬å¯ä»¥è®¾è®¡ä¸€ä¸ª(è‡³å°‘ç†è®ºä¸Šæœ‰ç”¨)çš„ç®—æ³•. é¦–å…ˆ,ä»»ä½•å£°éŸ³éƒ½æ˜¯ç›¸åº”é¢‘ç‡çš„æ³¢å¯¹æ°”å‹å˜åŒ–å¼•èµ·çš„,ä¹Ÿå°±æ˜¯ä¸åŒé¢‘ç‡çš„æ³¢åœ¨æ—¶é—´ä¸Šå åŠ åœ¨ä¸€èµ·,äº§ç”Ÿäº†å£°éŸ³.å°†æºæ³¢ä½¿ç”¨å‚…é‡Œå¶å˜æ¢æ‹†åˆ†åˆ°å¤šä¸ªä¸‰è§’æ³¢ä¸Šå».åˆ é™¤äººå£°æ‰€åœ¨çš„é¢‘åŸŸ,å†å°†é¢‘åŸŸä¿¡å·é€†å˜æ¢ä¸ºæ—¶åŸŸä¿¡å·.äººå£°ä¾¿æ¶ˆå¤±äº†. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:3:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"ç¦»æ•£å‚…é‡Œå¶å˜æ¢ è¿ç»­æ„ä¹‰ä¸‹çš„å‚…é‡Œå¶å˜æ¢å…ˆåˆ°æ­¤ä¸ºæ­¢.åœ¨è®¡ç®—æœºä¸­æ‰€å¤„ç†çš„æ•°æ®ä¸€èˆ¬éƒ½æ˜¯ç¦»æ•£çš„.æˆ‘ä»¬éœ€è¦çš„æ˜¯ç¦»æ•£å‚…é‡Œå¶å˜æ¢. ç¦»æ•£æ„ä¹‰ä¸‹çš„æ—¶åŸŸä¿¡å·å’Œé¢‘åŸŸä¿¡å·å°±éƒ½å˜æˆäº†ç‚¹é›†.å½“ä»è¿ç»­å‘ç¦»æ•£è¿‡æ¸¡æ—¶,å¯ä»¥è¿™æ ·æ€è€ƒ: åœ¨è¿ç»­çš„å›¾è±¡ä¸Šä»¥ä¸€å®šé—´éš”å–æ ·å¾—åˆ°ç¦»æ•£ç‚¹é›†.ä½¿ç”¨è¯¥ç‚¹é›†è¿›è¡Œå‚…é‡Œå¶å˜æ¢. è¿™ä¹Ÿæ˜¯æˆ‘ä»¬ä¸€å¼€å§‹é‡‡å–çš„è´¨å¿ƒæ±‚è§£æ–¹æ³•,åªä¸è¿‡,è¿™æ¬¡æˆ‘ä»¬ä»ç¼ ç»•æ—¶å°±å–æ ·.(è´¨ç‚¹ä¾ç„¶æ˜¯çœŸæ­£çš„è´¨ç‚¹) å¯¹äºç‚¹é›†$g(0\\leq n \u003c N)$,å®ƒçš„å‚…é‡Œå¶å˜åŒ–å°±æ˜¯ $$ \\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk} $$ ç®€å•ç²—æš´. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:4:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ åœ¨äº†è§£äº†å…³äºå‚…é‡Œå¶å˜æ¢çš„ä¸€ç³»åˆ—èƒŒæ™¯ä¸ä¸€ä¸ªåº”ç”¨å,æˆ‘ä»¬å†å›æ¥è§£å†³ä¸€äº›é‡è¦çš„é—®é¢˜. æ ¹æ®å‚…é‡Œå¶å˜æ¢çš„å…¬å¼å®šä¹‰ $$ \\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk} $$ å…¶æœ´ç´ ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(N^2)$ è¿™ä¸ªå¤æ‚åº¦è¿˜ä¸å¤Ÿä¼˜ç§€.ä¸€ç§å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ç®—æ³•åˆ©ç”¨$e^{ix}$çš„æ€§è´¨,å°†å¤æ‚åº¦é™ä½åˆ°äº†$O(N\\lg N)$. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:5:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å•ä½æ ¹ ç»™$e^{ix}$ä¸ªåå­—. åœ¨æ•°å­¦ä¸Š, $n$æ¬¡å•ä½æ ¹æ˜¯ $n$æ¬¡å¹‚ä¸º1çš„å¤æ•°.å®ƒä»¬ä½äºå¤å¹³é¢çš„å•ä½åœ†ä¸Š,æ„æˆæ­£nè¾¹å½¢çš„é¡¶ç‚¹,å…¶ä¸­ä¸€ä¸ªé¡¶ç‚¹æ˜¯1. è®° $$ \\omega_{n,k}=-e^{i\\frac{2\\pi}{n}k} $$ å…¶å‡ ä½•æ„ä¹‰ä¸ºå•ä½åœ†ä¸Šçš„nç­‰åˆ†ç‚¹çš„é¡ºæ—¶é’ˆç¬¬kä¸ª. ä¸€èˆ¬æ¥è¯´,å•ä½æ ¹å–é€†æ—¶é’ˆ,ä¸è¿‡è¿™é‡Œä¸ºäº†æ–¹ä¾¿,å–é¡ºæ—¶é’ˆ. å¦‚åŒä¸‰è§’å‡½æ•°ä¸€æ ·,å•ä½æ ¹å­˜åœ¨ä¸€äº›æ˜¾ç„¶çš„å®šç†. **æŠ˜åŠ:**$\\omega_{2n,2k}=\\omega_{n,k}$ **åŒ–ç®€:**$\\omega_{n,k+\\frac 2n}=-\\omega_{n,k}$ ä¿®æ”¹å…¬å¼ æ¥çœ‹åŸæœ¬çš„ç¦»æ•£å‚…é‡Œå¶å˜æ¢å…¬å¼ $$ \\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk} $$ ä½¿ç”¨å•ä½æ ¹æ¥æ›¿æ¢ä¸€ä¸‹ $$ \\hat g(k)=\\sum_{n=0}^{N-1}\\omega_{N,nk} g(n) $$ æŒ‰ç…§åŒ–ç®€å…¬å¼çš„æŒ‡å¼•,å°†æ±‚å’Œå…¬å¼æŒ‰ç…§å•ä½æ ¹å¥‡å¶æ‹†åˆ†ä¸º2éƒ¨åˆ†. $$ \\begin{aligned} \\hat g(k) \u0026= \\sum_{n=0}^{N-1}\\omega_{N,nk} g(n) \\\\ \u0026= \\sum_{0 \\leq n æ³¨æ„åˆ°ä¸ç®¡æ˜¯$\\hat g_{even}(k)$è¿˜æ˜¯$\\hat g_{even}(k)$,å®ƒä»¬éƒ½ä»¥$N/2$ä¸ºå‘¨æœŸ.æ¥ä¸‹æ¥,åº”ç”¨åŒ–ç®€å®šç† $$ \\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k) $$ å°†è¿™2ä¸ªå¼å­æ”¾åœ¨ä¸€èµ· $$ \\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\ \\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k) $$ å½“kå–éåŸé—®é¢˜è§„æ¨¡çš„ä¸€åŠæ—¶,å¯ä»¥ç›´æ¥ç”±ç¬¬äºŒä¸ªå¼å­å¾—åˆ°å¦ä¸€åŠ.é—®é¢˜çš„è§„æ¨¡å‡åŠ.é€’å½’æ±‚è§£,æœ€ç»ˆçš„å¤æ‚åº¦å°±é™åˆ°äº†$O(N \\lg N)$. è¿™å°±æ˜¯Cooley-Turkeyå¿«é€Ÿå‚…é‡Œå¶å˜æ¢ç®—æ³•. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:5:1","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å¿«é€Ÿä¹˜æ³• å®šä¹‰å¤šé¡¹å¼$A(x)=\\sum_k a_kx^{k+1}$,$B(x)$åŒç†,æ±‚è§£$C(x)=A(x)B(x)$. å¾ˆå®¹æ˜“çœ‹å‡º,æœ´ç´ ç®—æ³•çš„å¤æ‚åº¦ä¸º$O(N^2)$. ç°åœ¨,æ¥çœ‹å¦‚ä½•ä½¿ç”¨FFTå¿«é€Ÿè®¡ç®—. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:6:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"ç‚¹å€¼è¡¨ç¤º å¯¹äºä¸€ä¸ªæ¬¡æ•°ä¸º$n-1$çš„å¤šé¡¹å¼,å…¶å›¾è±¡ä¸Šäº’ä¸ç›¸åŒçš„$n$ä¸ªç‚¹å¯ä»¥å”¯ä¸€ç¡®å®šè¯¥å¤šé¡¹å¼. â€¦ å¦‚åŒç¡®å®šæ··åˆåœ¨ä¸€èµ·çš„å‡ ä¸ªæ³¢ä¸€æ ·. è‡³äºä¸ºä»€ä¹ˆæ˜¯å¯¹çš„,å¤§å¯åœ¨Googleä¸Šæœç´¢ä¸€ç•ª. å–$x$ä¸ºæ•°ä¸ªå•ä½æ ¹,åœ¨$A(x)$å’Œ$B(x)$ä¸Šåˆ©ç”¨å•ä½æ ¹çš„æ€§è´¨å¾—åˆ°$A$å’Œ$B$çš„ç‚¹å€¼è¡¨ç¤º,å°†ç‚¹å€¼ç›¸ä¹˜å¾—åˆ°$C$çš„ç‚¹å€¼è¡¨ç¤º.ä¹‹å,å°†$C$çš„ç‚¹å€¼è¡¨ç¤ºå†è½¬æ¢ä¸ºç³»æ•°è¡¨ç¤º. å—¯?FFTåœ¨å“ª? å…¶å®åœ¨è¿™é‡Œ, $$ \\hat g(\\omega)=A(\\omega)=\\sum_{n}\\omega A[x^{n+1}] $$ ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:6:1","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"ç¦»æ•£å·ç§¯ æœ‰ä¸€ç§æ•°å­¦è¿ç®—,å«åšå·ç§¯.ç°åœ¨åªè®¨è®ºå®ƒçš„ç¦»æ•£æƒ…å†µ. $$ (f * g)(n)=\\sum_{\\tau=-\\inf}^{inf}f(\\tau)g(n-\\tau) $$ è¿™ç©æ„çš„æ„ä¹‰â€¦å®åœ¨æ˜¯ä¸æ€ä¹ˆæ˜æ˜¾.ä¸è¿‡å¥½åœ¨æˆ‘ä»¬åªæ˜¯æƒ³ç®—ä¸ªå¤šé¡¹å¼ä¹˜æ³•,ä¹Ÿå°±æ˜¯æŠŠå¤šé¡¹å¼çš„ç³»æ•°ç®—æ¥ç®—å»: $C[x^n]$ è¡¨ç¤ºå¤šé¡¹å¼$C$ä¸­$x^n$é¡¹çš„ç³»æ•°. $$ C[x^{n}]=\\sum_{\\tau=0}^{n}A[x^\\tau]B[x^{n-\\tau}] $$ å—¯? å¦‚æœæˆ‘ä»¬è®¾å¤šé¡¹å¼ä¸­ä¸å­˜åœ¨çš„é¡¹çš„ç³»æ•°ä¸º0çš„è¯. $$ C[x^{n}]=\\sum_{\\tau=-\\inf}^{\\inf}A[x^\\tau]B[x^{n-\\tau}] $$ å“ˆ, $$ C[x^n]=(A*B)[x^n] $$ ### å·ç§¯å®šç† å·ç§¯å®šç†æŒ‡å‡º: ä¸€ä¸ªåŸŸä¸­çš„å·ç§¯å¯¹åº”äºå¦ä¸€ä¸ªåŸŸä¸­çš„ä¹˜ç§¯. è¿™æ„å‘³ç€,ä¸Šé¢è¿™ä¸ªè®¡ç®—(å·ç§¯)å¯¹åº”ç€å¦ä¸€ä¸ªåŸŸé‡Œçš„ä¹˜ç§¯.ä¹Ÿå°±æ˜¯ $$ F(C[x^n])=F(A[x^n]) \\cdot F(B[x^n]) $$ è¿™ä¾¿æ˜¯æ·±å±‚åŸç†.å¯¹Aå’ŒBçš„å–æ ·(é¢‘åŸŸ)ç§°ä¸ºAå’ŒBçš„ç‚¹å€¼è¡¨ç¤º,æœ€ç»ˆä»¥ä¹˜ç§¯çš„æ–¹å¼å¾—åˆ°äº†Cçš„ç‚¹å€¼è¡¨ç¤º(é¢‘åŸŸ).ç”¨FFTæ¥è®¡ç®—ä¹˜æ³•çš„è¯´æ³•æ˜¯å¯¹çš„. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:6:2","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å‚…é‡Œå¶é€†å˜æ¢ å¦‚ä½•ä»ä¸€ä¸ªé¢‘åŸŸä¿¡å·å†å¾—åˆ°æ—¶åŸŸä¿¡å·? $$ g(n)=\\frac 1N\\sum_{k=0}^{N-1}e^{i\\frac{2\\pi}{N}nk} \\hat g(k) $$ æ³¨æ„:æ­¤å¤„çš„1/Nä¸ä¸Šé¢çš„å˜æ¢æ˜¯ç›¸åŒ¹é…çš„. è¿™ä¸ªå¼å­å¯ä»¥ç†è§£æˆå¯¹å˜æ¢åçš„å¼å­å†å˜æ¢,æ„å‘³ç€å®ƒåŒæ ·å¯ä»¥ç”¨å˜æ¢æ—¶çš„æ€æƒ³æ¥åŠ é€Ÿ. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:7:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"FFTçš„C++å®ç° ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„é—®é¢˜å°±æ˜¯,å¯¹äºå•ä½æ ¹çš„è¿ç®—æ¶‰åŠåˆ°äº†ç²¾åº¦çš„é—®é¢˜.ä½†ç›®å‰è¿˜ä¸éœ€è¦è®¨è®º. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:8:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"ç¿»è½¬æ“ä½œ å¯ä»¥è§‚å¯Ÿåˆ°,æŒ‰ç…§ä¸Šé¢çš„ç®—æ³•å®ç°,æˆ‘ä»¬éœ€è¦åœ¨æ¯æ¬¡é€’å½’æŒ‰ç…§å¥‡å’Œå¶å°†å–æ ·åˆ†ç»„.ä¸”æ¯æ¬¡é€’å½’éƒ½ä¼šåˆ†ç»„.æ¯æ¬¡åˆ†ç»„éƒ½ä¼šæ¶‰åŠåˆ°æ•°ç»„çš„å¤åˆ¶,å¸¸æ•°è¾ƒå¤§. è§‚å¯Ÿåˆ†ç»„æ“ä½œä¸­ä¸‹æ ‡çš„å˜åŒ–. (è¡¨ç¤ºä¸‹æ ‡) 0 1 2 3 4 5 6 7 0 2 4 6 | 1 3 5 7 0 4 | 2 6 | 1 5 | 3 7 å°†å…¶è½¬æ¢ä¸ºäºŒè¿›åˆ¶ 000 001 010 011 100 101 110 111 000 100 010 110 001 101 011 111 å¯ä»¥å‘ç°,æœ€ç»ˆçš„åˆ†ç»„ç»“æœå°±æ˜¯å°†åŸä¸‹æ ‡äºŒè¿›åˆ¶ç¿»è½¬.æ‰€ä»¥å¯ä»¥ç›´æ¥ä¸€æ¬¡å®Œæˆåˆ†ç»„. æ³¨æ„,è¿™è¦æ±‚å–æ ·ä¸º2çš„å¹‚æ¬¡. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:8:1","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"ğŸ¦‹è´è¶æ“ä½œ è§£å†³äº†é€’å½’ä¸­ç”±é¡¶è‡³åº•çš„åˆ†ç»„å,æ¥ä¸‹æ¥ä¼˜åŒ–å­é—®é¢˜åˆå¹¶æ—¶çš„æ•°ç»„å¤åˆ¶. è§‚å¯ŸåŸæ¥çš„åˆå¹¶å¼å­ $$ \\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\ \\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k) $$ æŒ‰ç…§ç®—æ³•ä¸­çš„å®ç°æ–¹æ³•,å…¶ä¸º $$ \\hat g(k)=\\hat g(k)+\\omega_{N,k} \\hat g(k+\\frac N2) \\\\ \\hat g(k+\\frac N2)=\\hat g(k)-\\omega_{N,k} \\hat g(k+\\frac N2) $$ æƒ³è¦çœç•¥æ•°ç»„å¤åˆ¶,è¿›è¡ŒåŸåœ°åˆå¹¶,é—®é¢˜å‡ºåœ¨æ–°æ•°å€¼å¤ªæ—©åœ°æ›¿æ¢æ‰äº†æˆ‘ä»¬éœ€è¦çš„æ•°å€¼. å–è¾…åŠ©å˜é‡,ä¿®æ”¹åŸå¼ $$ t=\\omega_{N,k} \\hat g(k+\\frac N2)\\\\ \\hat g(k+\\frac N2)=\\hat g(k)-t\\\\ \\hat g(k)=\\hat g(k)+t $$ è¿™ä¸ªæ“ä½œè¢«ç§°ä¸º\"è´è¶æ“ä½œâ€,åå­—å¾ˆæœ‰æ„æ€. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:8:2","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"ä»£ç  åœ¨è¿™æ®µä»£ç ä¸­åŒæ—¶å»æ‰äº†é€’å½’. const double PI=acos(-1); inline complex\u003cdouble\u003e gomega(int n,int k,bool rev=false){ complex\u003cdouble\u003e res(cos(2*PI/n*k),sin(2*PI/n*k)); if(rev)return conj(res); else return res; } const int MAXN=10; struct FFT{ complex\u003cdouble\u003e omega[MAXN],omegaI[MAXN]; FFT(int n){ for(int i=0;i\u003cn;i++){ omega[i]=gomega(n,i); omegaI[i]=gomega(n,i,1); } } void transform(complex\u003cdouble\u003e *a,int n,const complex\u003cdouble\u003e *omega){ for(int i=0,j=0;i\u003cn;i++){ if(i\u003ej)swap(a[i],a[j]); //äºŒè¿›åˆ¶æ¢ä½ for(int l=n/2;(j^=l)\u003cl;l\u003e\u003e=1); } for(int l=2;l\u003c=n;l\u003c\u003c=1){ int m=l/2; for(complex\u003cdouble\u003e *p=a;p!=a+n;p+=l){ for(int i=0;i\u003cm;i++){ //è´è¶æ“ä½œ complex\u003cdouble\u003e t=omega[n/l*i]*p[m+i]; p[m+i]=p[i]-t; p[i]+=t; } } } } void dft(complex\u003cdouble\u003e *a,int n){ transform(a,n,omega); } void idft(complex\u003cdouble\u003e *a,int n){ transform(a,n,omegaI); for(int i=0;i\u003cn;i++)a[i]/=n; } }; å¦‚æœæƒ³è¦å®ç°å¿«é€Ÿä¹˜æ³•,åªè¦å°†2ä¸ªå¤šé¡¹å¼çš„ç³»æ•°å‡½æ•°ä¼ å…¥è¿›è¡Œå˜æ¢,å˜æ¢ç»“æœç›¸ä¹˜å¹¶é€†å˜æ¢å³å¯. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:8:3","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"åº”ç”¨ ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:9:0","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å¿«é€Ÿä¹˜æ³• æŒ‡å¿«é€Ÿå¤§æ•°ä¹˜æ³•ã€‚ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccomplex\u003e#include \u003ccmath\u003eusing namespace std; const int MAXN=300000; const double PI=acos(-1); inline complex\u003cdouble\u003e gomega(int n,int k,bool rev=false){ complex\u003cdouble\u003e res(cos(2*PI/n*k),sin(2*PI/n*k)); if(rev)return conj(res); else return res; } struct FFT{ complex\u003cdouble\u003e omega[MAXN],omegaI[MAXN]; FFT(){ } void init(int n){ for(int i=0;i\u003cn;i++){ omega[i]=gomega(n,i); omegaI[i]=gomega(n,i,1); } } void transform(complex\u003cdouble\u003e *a,int n,const complex\u003cdouble\u003e *omega){ for(int i=0,j=0;i\u003cn;i++){ if(i\u003ej)swap(a[i],a[j]); //äºŒè¿›åˆ¶æ¢ä½ for(int l=n/2;(j^=l)\u003cl;l\u003e\u003e=1); } for(int l=2;l\u003c=n;l\u003c\u003c=1){ int m=l/2; for(complex\u003cdouble\u003e *p=a;p!=a+n;p+=l){ for(int i=0;i\u003cm;i++){ //è´è¶æ“ä½œ complex\u003cdouble\u003e t=omega[n/l*i]*p[m+i]; p[m+i]=p[i]-t; p[i]+=t; } } } } void dft(complex\u003cdouble\u003e *a,int n){ transform(a,n,omega); } void idft(complex\u003cdouble\u003e *a,int n){ transform(a,n,omegaI); for(int i=0;i\u003cn;i++)a[i]/=n; } }; complex\u003cdouble\u003e a[2][MAXN]; int ans[MAXN]; FFT fft; int main(){ int nlen;cin\u003e\u003enlen; int n=1; //æ ¹æ®åŸç†ï¼Œnå¿…é¡»å–å¤§äº2nlençš„æ•°ï¼Œæ‰èƒ½æ»¡è¶³å–æ ·è¦æ±‚å’Œåè½¬æ“ä½œè¦æ±‚ while(n\u003c2*nlen)n*=2; fft.init(n); for(int i=0;i\u003c2;i++){ string inp;cin\u003e\u003einp; for(int j=0,k=inp.size()-1;j\u003cinp.size();j++,k--){ a[i][j]=complex\u003cdouble\u003e(inp[j]-\u0026#039;0\u0026#039;,0); } fft.dft(a[i],n); } for(int i=0;i\u003cn;i++)a[0][i]=a[0][i]*a[1][i]; fft.idft(a[0],n); int reslen=nlen+nlen-1; for(int i=reslen-1,k=0;i\u003e=0;i--,k++) ans[k]=(int)floor(a[0][i].real()+0.5); /* for(int i=0;i\u003creslen;i++)cout\u003c\u003cans[i]\u003c\u003c\" \"; cout\u003c\u003cendl; */ for(int i=0;i\u003cMAXN;i++){ ans[i+1]+=ans[i]/10; ans[i]%=10; } int ptr=MAXN-1; while(ans[ptr]==0)ptr--; for(;ptr\u003e=0;ptr--)cout\u003c\u003cans[ptr]; cout\u003c\u003cendl; return 0; } ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:9:1","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["å­¦ä¹ "],"content":"å®é™…æ„ä¹‰ ä½†æ˜¯æ›´åŠ å€¼å¾—å…³å¿ƒçš„æ˜¯å…¶å¹¿ä¹‰ä¸Šçš„ç‰©ç†æ„ä¹‰ã€‚Nä¸ªé‡‡æ ·ç‚¹æ‹¿åˆ°çš„Nä¸ªå€¼åˆ°åº•å¯¹åº”ç€ä»€ä¹ˆã€‚ è®¾é‡‡æ ·ç‡ä¸º$F$ï¼Œé‡‡æ ·é—´éš”ä¸º$T=\\frac{1}{F}$ã€‚è®¾é‡‡æ ·æ¬¡æ•°$N$ã€‚é‚£ä¹ˆæ˜¾ç„¶ä¸ç®¡æ˜¯æ•°æ®ä¸‹æ ‡è¿˜æ˜¯ç»“æœä¸‹æ ‡ï¼Œéƒ½ä¸æ˜¯å…¶åŸæœ‰æ„ä¹‰ã€‚ æœ‰å¦‚ä¸‹å¯¹åº”å…³ç³» é‡‡æ ·æ—¶é•¿ä¸º$TN$æˆ–è€…$N/F$ï¼ˆé‡‡æ ·åŒºé—´é•¿åº¦ï¼‰ æ•°æ®ä¸‹æ ‡å¾ˆæ˜¾ç„¶ ç»“æœç•¥æœ‰ä¸€ç‚¹ç‚¹ç»•ã€‚å¯¹äºã€Œåœ¨$N$ä¸ªç‚¹ä¸­å‡ºç°äº†$k$ä¸ªå‘¨æœŸã€çš„åŸºä¿¡å·ï¼Œä¸€ä¸ªå‘¨æœŸ$N/k$ä¸ªç‚¹ï¼Œä¸€ä¸ªå‘¨æœŸæ—¶é•¿$\\frac{N}{kF}$ã€‚å¦‚æœä¸æƒ³æŠŠä½ çš„é¢‘åŸŸå›¾åƒç”»çˆ†é‚£å°±å€’è¿‡æ¥å–å‘¨æœŸé¢‘ç‡$\\frac{F}{N}k$ã€‚ å³ç»“æœçš„ç‚¹ä¸‹æ ‡$x$å¯¹åº”ç€é¢‘ç‡ä¸º$\\frac{F}{N}x$çš„åŸºä¿¡å·ã€‚ ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:9:2","tags":["FFT"],"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","uri":"/2019/07/fast-fourier-transform/"},{"categories":["é—²æ‰¯"],"content":"ä¼—æ‰€å‘¨çŸ¥ï¼Œå¿«é€Ÿæ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n\\lg n)$çš„ã€‚ç„¶è€Œå› ä¸ºæˆ‘å¤ªèœï¼Œå†™å‡ºæ¥çš„å¿«é€Ÿæ’åºä¸€ä¸å°å¿ƒå°±æˆäº†$O(n^2)$â€¦ ","date":"2019-07-12","objectID":"/2019/07/do-i-write-qsort-right/:0:0","tags":null,"title":"æˆ‘æŠŠå¿«æ’å†™é”™äº†?","uri":"/2019/07/do-i-write-qsort-right/"},{"categories":["é—²æ‰¯"],"content":"è¿™ä¸ªè¾£é¸¡é—®é¢˜ è¿™ä¸ªåº”è¯¥éƒ½çŸ¥é“ï¼Œå½“å¾…æ’åºæ•°ç»„å·²ç»æœ‰åºæ—¶ï¼Œå›ºå®šé€‰æ‹©æŸä¸€ä¸ªä½ç½®çš„æ•°å­—å½“å“¨å…µçš„å¿«æ’ä¼šå˜æˆ$O(n^2)$ã€‚ä¸€ä¸ªè§£å†³æ–¹æ³•å°±æ˜¯éšæœºé€‰æ‹©å“¨å…µï¼Œæˆ–è€…å¹²è„†å°†è¾“å…¥çš„æ•°ç»„æ‰“ä¹±åå†æ’åºã€‚ ç„¶è€Œï¼Œå¦‚æœè¾“å…¥çš„æ•°ç»„æ•°å­—å…¨éƒ¨ç›¸åŒå‘¢ï¼Ÿ å½“ç„¶è¿™åœ¨å®é™…ä¸­å¾ˆå°‘è§ï¼Œä½†æ˜¯åœ¨å®ç°çš„æ—¶å€™å°±è¦å°å¿ƒã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‰€å®ç°çš„å¿«æ’å¿…é¡»å¯¹äºç›¸åŒæ•°å­—ä¹Ÿäº¤æ¢ä½ç½®ï¼Œå¦åˆ™å°±ä¼šé€€åŒ–ä¸º$O(n^2)$ã€‚ æ¯”å¦‚è¯´ï¼Œè¿™ä¸ª void quicksort(int left,int right) { int i,j,t,temp; if(left\u003eright) return; temp=a[left]; //tempä¸­å­˜çš„å°±æ˜¯åŸºå‡†æ•° i=left; j=right; while(i!=j) { //é¡ºåºå¾ˆé‡è¦ï¼Œè¦å…ˆä»å³è¾¹å¼€å§‹æ‰¾ while(a[j]\u003e=temp \u0026\u0026 i\u003cj) j--; //å†æ‰¾å³è¾¹çš„ while(a[i]\u003c=temp \u0026\u0026 i\u003cj) i++; //äº¤æ¢ä¸¤ä¸ªæ•°åœ¨æ•°ç»„ä¸­çš„ä½ç½® if(i\u003cj) { t=a[i]; a[i]=a[j]; a[j]=t; } } //æœ€ç»ˆå°†åŸºå‡†æ•°å½’ä½ a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//ç»§ç»­å¤„ç†å·¦è¾¹çš„ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹ quicksort(i+1,right);//ç»§ç»­å¤„ç†å³è¾¹çš„ ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹ } è¿˜æœ‰è¿™ä¸ªï¼Œ void quick_sort(int s[], int l, int r) { if (l \u003c r) { //Swap(s[l], s[(l + r) / 2]); //å°†ä¸­é—´çš„è¿™ä¸ªæ•°å’Œç¬¬ä¸€ä¸ªæ•°äº¤æ¢ å‚è§æ³¨1 int i = l, j = r, x = s[l]; while (i \u003c j) { while(i \u003c j \u0026\u0026 s[j] \u003e= x) // ä»å³å‘å·¦æ‰¾ç¬¬ä¸€ä¸ªå°äºxçš„æ•° j--; if(i \u003c j) s[i++] = s[j]; while(i \u003c j \u0026\u0026 s[i] \u003c x) // ä»å·¦å‘å³æ‰¾ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„æ•° i++; if(i \u003c j) s[j--] = s[i]; } s[i] = x; quick_sort(s, l, i - 1); // é€’å½’è°ƒç”¨ quick_sort(s, i + 1, r); } } å®ƒä»¬éƒ½ä¼šè·³è¿‡ç›¸åŒçš„æ•°å­—ï¼Œæ¯æ¬¡æ’åºåå“¨å…µæ€»ä¼šåœ¨è¾¹ç•Œä¸Šï¼Œå¯¼è‡´ç®—æ³•åŠ£åŒ–åˆ°$O(n^2)$ã€‚ å¤§æ¦‚å°±æ˜¯è¿™å›äº‹ï¼Œæ²¡åˆ«çš„äº†ã€‚è¿™ç§æƒ…å†µå½“ç„¶æœ‰æ”¹è¿›çš„å¿«é€Ÿæ’åºå¯ä»¥ç›´æ¥é¿å…è¿™ç§ç½•è§çš„æƒ…å†µï¼Œåœ¨ä¸å¤§å¹…åº¦æ”¹åŠ¨ç®—æ³•çš„å‰æä¸‹ï¼Œå°±è¦å¯¹ç›¸åŒçš„å…ƒç´ ä¹Ÿè¿›è¡Œæ¢ä½æ‰å¯ä»¥ï¼Œå³ä½¿ä¼šå¢åŠ äº¤æ¢æ¬¡æ•°ã€‚ ","date":"2019-07-12","objectID":"/2019/07/do-i-write-qsort-right/:1:0","tags":null,"title":"æˆ‘æŠŠå¿«æ’å†™é”™äº†?","uri":"/2019/07/do-i-write-qsort-right/"}]