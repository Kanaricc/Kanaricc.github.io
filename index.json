[{"categories":["闲扯"],"content":"这个东西很复杂，似乎也不好找到「恰好足够」的资料，要么讲得太浅，要么就只能去翻硬件文档。但是仅仅为了一个要求模糊而且并不好玩的作业做到那种地步确实是有点没意思，不过还好它解答了我的疑问。下面这些内容目的只是给我足够的底气去处理作业中并不明确的部分。更加详细或者粗略的内容在网上有很多介绍，至少短期内不会出现在这里。 ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:0:0","tags":null,"title":"由内存分页看CPU系统界面","uri":"/2020/05/paging-introduction/"},{"categories":["闲扯"],"content":"分页 现代CPU基本上只支持分页式的内存管理方式了。具体为将内存划分为大小相同的块，对于一个“进程”的虚拟地址，维护其（连续的）每块虚拟地址到（可能并不连续）物理地址的转换表。这张表显然足够大，就也存在内存里。 那么问题就是，在这整个过程中，到底从哪一部分开始是操作系统的事情。事实上，虚拟地址到物理地址的转换以及后续的访问、读取/写入是硬件的工作，内存分配、页表存储是操作系统的事。连接这两者的桥梁是页表格式的约定和一个特殊的寄存器。操作系统在调度进程运行前，将页表的地址送给特殊寄存器，由硬件直接按约定好的格式读取页表完成后续工作。 这种办法不是绝对的，至少X86架构是这么做的。段式存储策略类似，其存有特殊寄存器作为偏移量，也由系统先将偏移量装入寄存器再把控制权交出去。 ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:1:0","tags":null,"title":"由内存分页看CPU系统界面","uri":"/2020/05/paging-introduction/"},{"categories":["闲扯"],"content":"问题 不过这里似乎有个套娃问题。我的系统代码也是运行在虚拟地址下的，系统从何知晓物理地址的事情。实际上，CPU也真的不允许系统瞎搞。在这里，办法是「提前」将页表的地址事先映射到虚拟内存地址上。……操作系统让CPU从页表里翻译到页表的物理地址，感觉怪怪的。「提前」是指这个过程一般在更底层的代码完成，例如boot阶段，因为系统无法自行访问到自己的页表，套娃是不存在的。 ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:1:1","tags":null,"title":"由内存分页看CPU系统界面","uri":"/2020/05/paging-introduction/"},{"categories":["闲扯"],"content":"异常处理 不过系统是通过什么知道该做什么的，既然内存由系统分配，控制权交给了软件，那么系统是如何在必要时为软件分配内存。这其实是别的东西。 例如异常处理。常见的段错误、除0错误。这里又是一波CPU和操作系统的约定。CPU会在出现异常情况时，将异常原因装入寄存器，将当前运行到的代码地址保存，跳转到事先约定好的异常处理代码地址，从而启动由系统自定义的异常处理流程。而内存的分配一般也是通过这种形式完成。定义一种特殊的异常syscall，软件把参数传给寄存器后去触发中断把控制权交出去，系统分配完内存再ret回去回归到软件的正常运行流程。不过现代CPU似乎用了更快速的方式。 这里还挺有意思的，这种异常处理方式注定了它异常处理过程可能再发生异常。然而也不能无限套娃。一般情况下，第一次异常将进入异常处理流程，异常处理触发异常将进入二次异常处理，一般二次异常处理操作系统会初始化软件，因为先前的运行状态无法再维持了（似乎？）。二次异常过程如果再次发生异常，硬件将直接重启。 ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:2:0","tags":null,"title":"由内存分页看CPU系统界面","uri":"/2020/05/paging-introduction/"},{"categories":["闲扯"],"content":"内核态/用户态 在这之中总会感觉缺了点什么。如果说操作系统也只是一段代码，那么操作系统与普通软件的区别在哪，把操作系统分配内存的代码拿过来不久不需要它了。 这涉及到了内核态/用户态的问题。操作系统运行在内核态，只有内核态可以访问关键资源，所以操作系统代码与一般软件代码有地位上的差别。但这还不够，为什么操作系统可以运行在内核态。其实这是CPU提供的功能。CPU所提供的分级保护域概念，使得操作系统在占据高特权后能够自由决定接下来运行代码的权限。这种机制诞生了所谓特权指令，即只有在高权限下才能运行的指令，一般用于访问关键资源。所以，用户软件必须通过中断，让系统来为其准备需要的资源。 所以目前一个结论是，如果没有「系统」，我们根本就无从谈起软中断和「特权指令」的概念，也很难实现一般意义上的异常处理和内存管理。 而如果想把编译器编译的程序直接跑在一个虚拟机上——我们先不谈实现这个真正的现代CPU模拟器的工作量——就算直接给你一个现成的模拟器，单单是准备这个能够直接跑在虚拟机上的程序也是一件麻烦的事情。这意味着你要在一个没有系统的现代CPU上跑程序 第一，软件不能依赖标准库，因为标准库平台相关。这是最直接的难题。平时常用的printf/scanf/cin/cout统统GG，当然这还是最表面的，你还会发现一些你本来以为是语言特性的东西居然是平台相关的，比如你熟悉的main不管用了，甚至堆栈的处理都出现麻烦。 第二，你要熟悉代码的真实加载流程。第一个问题，Java是有运行时的我们都知道，C有吗？如果回答是没有的话，那你就有点麻烦了。C有运行时，运行时负责为后续代码准备环境，并且调起main。没有运行时意味着你必须直面整个加载流程，为你的代码准备由更「底层」的代码直接调起的入口函数。 第三，你要熟悉tool chain的配置。如果你熟悉代码的真实加载流程了，就知道实际上一个个可执行文件的格式是系统相关的。你必须让linker创建直接机器相关的代码。 第四，你要直接接手和其他硬件的交互。想在屏幕上输出一行「hello, world」也会很麻烦。 我不是很清楚整个流程，也许理想情况下事情就到此为止了，只要你肯自己实现CPU而且合理的偷懒…不过口嗨尚且写这么多字，真要落实到代码上我也不知道会发生什么。 ","date":"2020-05-04","objectID":"/2020/05/paging-introduction/:3:0","tags":null,"title":"由内存分页看CPU系统界面","uri":"/2020/05/paging-introduction/"},{"categories":null,"content":"飘忽不定。 ","date":"2020-05-03","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" 被打上「石乐志」标签的文章是彻底属于“闲扯”的存在 感觉时间过去足够长了，把之前糊概率作业的小玩意拿出来。实际上东西不多，但是众所周知，作业能糊多长和干货量没有多大关系，和作业成绩关系就更不大了。 在W的池子开前算一波概率。 设$A_n$表示第$n$次抽到6星，$B_n$表示前$n-1$次都没有六星。得$P(A_n|B_n)$。 $$P(A_n|B_n)=\\begin{cases} 0.02,\\quad 0\\leq n \\leq 50 \\\\ 0.02+0.02(n-50),\\quad 50 同时 $$ \\begin{aligned} P(\\overline {A_n}|B_n)\u0026=1-P(A_n|B_n) \\\\ \\end{aligned} $$ 省略一些没必要凑字数的套娃操作之后能得到递推式 $$ P(B_n)=P(B_{n-1})-P(A_{n-1}B_{n-1}) $$ 同时有初始$P(B_1)=1$。 那么，X抽恰好抽到6星的概率为 $$ P\\{X=k\\}=P(A_kB_k)=P(A_k|B_k)P(B_k) $$ 已有公式构成递推 $$ \\begin{aligned} P\\{X=k\\}\u0026=P(A_kB_k)=P(A_k|B_k)P(B_k) \\\\ P(B_n)\u0026=P(B_{n-1})-P\\{X=k-1\\} \\end{aligned} $$ 当出现6星时，抽到W的概率为$35\\%$。设抽到W的概率为$P_s$能够得到递推式 $$ \\begin{aligned} P_s(n)\u0026=\\sum_{1\\leq k\\leq n}P\\{X=k\\}(0.35+(1-0.35)P_s(n-k))\\\\ P_s(0)\u0026=0 \\end{aligned} $$ 直接套上CAS系统算。 把W接上岛的概率把W接上岛的概率 \" 把W接上岛的概率 这个图…说实话我觉得沉底了完全有可能…⚠️危⚠️ 噫，好，我出了，这游戏又可以继续玩了。 说真的，单在手游的范围内讨论，mrfz的质量可以说是佼佼者了。不过何时能脱离单一的手游模式，做点别的呢。 剧情杀我。 ","date":"2020-04-30","objectID":"/2020/04/pulling-w/:0:0","tags":["石乐志"],"title":"如何把W接上岛","uri":"/2020/04/pulling-w/"},{"categories":["code"],"content":"C. Emergency Evacuation 当没有人碰在一起时，耗时就是离门最远的人需要的耗时。当有人碰在一起时，才会发生其他情况。 人碰在一起的条件是他们距离门的距离一样，可以让人反着跑看出来。当碰在一起时，必定会有一个人等待一秒。而这个等的人到底是谁并没有区别，原本会在下一秒到达该格子的人总是会被等待的人卡住。然后就你卡我，我卡他，他再卡后面的人。 将逃跑需要时间相同的人往后匀。时间的值域不大所以直接用桶。 ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:1:0","tags":["二分","动态规划","思维","单调栈"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"D. Shortest Common Non-Subsequence 补 先考虑怎么构造一个字符串的最小非子序列。用类似于序列自动机的方法构造。 为字符串添加起始节点，令$f(i,x)$表示在该自动机上第i状态填x得到的最短非子序列长度。转移是 $$ f(i,x)=\\min \\{f(\\text{next}(i,x),y)|y\\}+1 $$ 其中$\\text{next}(i,x)$为第i位后最近的x的位置。只要最短长度时，扔掉x也无所谓 $$ f(i)=min\\{f(\\text{next}(i,x))|x\\}+1 $$ 初始状态为$f(n+1)=0$。 改造为该题，设状态$f(i,j)$为在俩自动机上跑到$i,j$状态的最短XX长度，有 $$ f(i,j)=\\min\\{f(n_1(i,x),n_2(j,x))|x\\}+1 $$ 初始状态有$f(n_1+1,n_2+1)=0$。 感觉有一个值得思考的问题是最长公共子串的写法…毕竟转移方程看起来几乎一样来着… $$ f(i,j)=\\max\\{f(n_1(i,x),n_2(j,x))|x\\}+1 $$ 那重点就只能在于初始状态了。 看起来应该是$f(n_1+1,n_2+1)=-\\infty,f(n_1, * )=f( * ,n_2)=0$，主要考虑的 不能转移到不存在n+1状态，这意味着填写的字母不存在。 n状态无字符，0。 ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:2:0","tags":["二分","动态规划","思维","单调栈"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"E. Eulerian Flight Tour …… 看起来是把边选/不选对度造成的影响抽象成方程组来解。复杂度看起来没问题，估计解完还要再处理一堆东西…回头再说。 ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:3:0","tags":["二分","动态规划","思维","单调栈"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"K. Sixth Sense 算最大得分可以贪心。对方和自己的牌升序排序后，拿正好能对抗的牌去和对方牌一一打。 剩下的是怎么求字典序最大的答案。能够发现，当当前这张牌打得太大时，就可能导致后续某一轮牌输掉，让总比分减少。这看起来可以二分。不过写着写着把样例3给wa了。 之后意识到这个东西并不是整个区间单调，需要在得分和输分的两个出牌区间分别做两次。 #include \u003ccstdio\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cunordered_map\u003e#include \u003cvector\u003e#include \u003cmap\u003e#include \u003ccmath\u003e#include \u003ciostream\u003eusing namespace std; const int XN=5050; int my[XN],you[XN]; int myrnk[XN],yournk[XN]; int used[XN]; int n; int maxans=0; //从第n轮开始 int check(int round){ int ptr=1; while(ptr\u003c=n \u0026\u0026 yournk[ptr]\u003cround)ptr++; if(ptr\u003en)return 0; int res=0; for(int i=1;i\u003c=n;i++){ if(used[i])continue; if(ptr\u003en)break; if(my[myrnk[i]]\u003eyou[yournk[ptr]]){ res++; ptr++; while(ptr\u003c=n \u0026\u0026yournk[ptr]\u003cround)ptr++; } } return res; } vector\u003cint\u003e rest; int main(){ ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); cin\u003e\u003en; for(int i=1;i\u003c=n;i++){ cin\u003e\u003eyou[i]; } for(int i=1;i\u003c=n;i++){ cin\u003e\u003emy[i]; } for(int i=1;i\u003c=n;i++)myrnk[i]=yournk[i]=i; sort(myrnk+1,myrnk+1+n,[](auto a,auto b){ return my[a]\u003cmy[b]; }); sort(yournk+1,yournk+1+n,[](auto a,auto b){ return you[a]\u003cyou[b]; }); for(int i=1;i\u003c=n;i++)rest.push_back(i); maxans=check(1); int app=0; for(int i=1;i\u003c=n;i++){ //赢的 { int l=0,r=rest.size(); while(l\u003cr \u0026\u0026 my[myrnk[rest[l]]]\u003c=you[i])l++; while(l+1\u003cr){ int mid=(l+r)/2; int chosen=rest[mid]; used[chosen]=1; if(app+1+check(i+1)\u003e=maxans)l=mid; else r=mid; used[chosen]=0; } if(l\u003cr){ used[rest[l]]=1; if(app+1+check(i+1)\u003e=maxans){ cout\u003c\u003cmy[myrnk[rest[l]]]\u003c\u003c\" \"; rest.erase(rest.begin()+l); app++; continue; }else{ used[rest[l]]=0; } } } { int l=0,r=(int)rest.size()-1; while(l\u003cr \u0026\u0026 my[myrnk[rest[r]]]\u003eyou[i])r--; r++; while(l+1\u003cr){ int mid=(l+r)/2; int chosen=rest[mid]; used[chosen]=1; if(app+check(i+1)\u003e=maxans)l=mid; else r=mid; used[chosen]=0; } used[rest[l]]=1; cout\u003c\u003cmy[myrnk[rest[l]]]\u003c\u003c\" \"; rest.erase(rest.begin()+l); } } cout\u003c\u003cendl; return 0; } ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:4:0","tags":["二分","动态规划","思维","单调栈"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"Extra 在群里看到一道题，在$1 \\leq x \\leq m$的n个数中找到一个字典序最小的序列且为1-m的一个排列。 最开始想维护每个数字出现的次数，然后从第一位开始向后扫，当前数字正好是还缺少的最小数字或者此后再也没有该数字出现的话就输出。后面的条件是对的，的确当后方没有数字时，就不得不在该位输出，但是前面的条件有些问题。如果一个更大的数字结束的比小数字更快，且下一个缺少的最小数字并非“小数字”，就会翻车。此时的情况最优应该是以不得不输出的位置开始，划分为两个问题，前面尽可能找字典序小的一段。 维护单调栈，当新加入的数字比前一个更优（字典序小）时，如果前一个数字在后面还有，就可以把它踢掉，否则前面的答案就定了，输出答案后再从该位重新开始。 #include\u003ccstdio\u003e#include\u003ccmath\u003e#include\u003calgorithm\u003e#include\u003cunordered_map\u003e#include \u003cvector\u003e#include \u003cmap\u003e#include \u003ccmath\u003e#include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cdeque\u003eusing namespace std; const int XN=30; int cnt[XN]; bool used[XN]; deque\u003cchar\u003e q; int main(){ string inp;cin\u003e\u003einp; for(auto chr:inp)cnt[chr-'a']++; for(auto chr:inp){ cnt[chr-'a']--; if(used[chr-'a'])continue; while(!q.empty() \u0026\u0026 q.back()\u003echr \u0026\u0026 cnt[q.back()-'a']\u003e0){ used[q.back()-'a']=0; q.pop_back(); } q.push_back(chr); used[chr-'a']=1; if(cnt[chr-'a']==0){ while(!q.empty()){ cout\u003c\u003cq.front(); q.pop_front(); } } } while(!q.empty()){ cout\u003c\u003cq.front(); q.pop_front(); } cout\u003c\u003cendl; return 0; } ","date":"2020-04-12","objectID":"/2020/04/icpc2018-yokohama/:5:0","tags":["二分","动态规划","思维","单调栈"],"title":"ICPC2018 Yokohama","uri":"/2020/04/icpc2018-yokohama/"},{"categories":["code"],"content":"Little Mishka enjoys programming. Since her birthday has just passed, her friends decided to present her with array of non-negative integers a1, a2, …, an of n elements! Mishka loved the array and she instantly decided to determine its beauty value, but she is too little and can’t process large arrays. Right because of that she invited you to visit her and asked you to process m queries. Each query is processed in the following way: Two integers l and r (1 ≤ l ≤ r ≤ n) are specified — bounds of query segment. Integers, presented in array segment [l, r] (in sequence of integers al, al + 1, …, ar) even number of times, are written down. XOR-sum of written down integers is calculated, and this value is the answer for a query. Formally, if integers written down in point 2 are x1, x2, …, xk, then Mishka wants to know the value , where — operator of exclusive bitwise OR. Since only the little bears know the definition of array beauty, all you are to do is to answer each of queries presented. ","date":"2020-04-10","objectID":"/2020/04/cf703d-mishka-and-interesting-sum/:0:0","tags":["树状数组"],"title":"[CF703D] Mishka and Interesting Sum","uri":"/2020/04/cf703d-mishka-and-interesting-sum/"},{"categories":["code"],"content":"分析 被大哥们秒切了…都没来得及想💔 利用了异或的性质。 想找到一个区间内出现奇数次的数的异或和非常简单，只要维护一个前缀和就可以了。那么知道了奇数次的数字，就能从所有数字的异或中求到补——出现偶数次的数的异或。 值得一写的是求某区间内不同元素相关信息的一个思路。之前有好几道题都是这么干的（一个钥匙的题，一个书的题）。即维护元素的下一次出现位置，将左区间排序后，使用数据结构查询右端点。当左端点越过了某数后，就将其下一次出现的位置加入到结构中。整体为$O(n\\lg n)$。 如果题目的范围小一点，可以莫队。 ","date":"2020-04-10","objectID":"/2020/04/cf703d-mishka-and-interesting-sum/:1:0","tags":["树状数组"],"title":"[CF703D] Mishka and Interesting Sum","uri":"/2020/04/cf703d-mishka-and-interesting-sum/"},{"categories":["code"],"content":"代码 没上快读T了发。 #include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e#include \u003cstack\u003e#include \u003cunordered_map\u003eusing namespace std; const int XN=1000010; const int FTXN=4000010; namespace IO { const int IN=1e6; char in[IN],*ip=in,*ie=in; #define getchar() (ip==ie \u0026\u0026 (ie=(ip=in)+fread(in,1,IN,stdin),ip==ie)?EOF:*ip++) struct Istream { template \u003cclass T\u003e Istream \u0026operator \u003e\u003e(T \u0026x) { static char ch;static bool neg; for(ch=neg=0;ch\u003c'0' || '9'\u003cch;neg|=ch=='-',ch=getchar()); for(x=0;'0'\u003c=ch \u0026\u0026 ch\u003c='9';(x*=10)+=ch-'0',ch=getchar()); x=neg?-x:x; return *this; } }fin; const int OUT=1e6; char out[OUT],*op=out,*oe=out+OUT; #define flush() fwrite(out,1,op-out,stdout) #define putchar(x) ((op==oe?(flush(),op=out,*op++):*op++)=(x)) struct Ostream { ~Ostream() { flush(); } template \u003cclass T\u003e Ostream \u0026operator \u003c\u003c(T x) { x\u003c0 \u0026\u0026 (putchar('-'),x=-x); static char stack[233];static int top; for(top=0;x;stack[++top]=x%10+'0',x/=10); for(top==0 \u0026\u0026 (stack[top=1]='0');top;putchar(stack[top--])); return *this; } Ostream \u0026operator \u003c\u003c(char ch) { putchar(ch); return *this; } }fout; } using IO::fin; using IO::fout; int ft[FTXN]; int lowbit(int x){ return x\u0026-x; } void ftadd(int pos,int x){ for(;pos\u003cFTXN;pos+=lowbit(pos)){ ft[pos]^=x; } } int ftget(int pos){ int res=0; for(;pos;pos-=lowbit(pos))res^=ft[pos]; return res; } int num[XN]; int xo[XN]; struct Q{ int l,r; int i; } qs[XN]; int ans[XN]; unordered_map\u003cint,int\u003e curpos; int nxt[XN]; int main(){ int n;fin\u003e\u003en; //cout\u003c\u003c\"st\"\u003c\u003cendl; for(int i=1;i\u003c=n;i++)fin\u003e\u003enum[i]; for(int i=0;i\u003c=n;i++)xo[i]=xo[i-1]^num[i]; //cout\u003c\u003c\"done\"\u003c\u003cendl; for(int i=n;i\u003e=1;i--){ nxt[i]=curpos[num[i]]; curpos[num[i]]=i; } // for(int i=1;i\u003c=n;i++){ // cout\u003c\u003cnxt[i]\u003c\u003c\" \"; // } // cout\u003c\u003cendl; int qlen;fin\u003e\u003eqlen; for(int i=0;i\u003cqlen;i++){ fin\u003e\u003eqs[i].l\u003e\u003eqs[i].r; qs[i].i=i; } for(auto [x,pos]:curpos){ ftadd(pos,x); } sort(qs,qs+qlen,[](const Q \u0026a,const Q \u0026b){ return a.l\u003cb.l; }); int la=1; //cout\u003c\u003c\"done\"\u003c\u003cendl; for(int i=0;i\u003cqlen;i++){ Q \u0026q=qs[i]; while(q.l\u003ela){ ftadd(la,num[la]); //cout\u003c\u003c\"remove \"\u003c\u003cla\u003c\u003cendl; if(nxt[la]){ ftadd(nxt[la],num[la]); //cout\u003c\u003c\"add \"\u003c\u003cnxt[la]\u003c\u003cendl; } la++; } ans[q.i]=ftget(q.r)^(xo[q.r]^xo[q.l-1]); } for(int i=0;i\u003cqlen;i++)fout\u003c\u003cans[i]\u003c\u003c'\\n'; return 0; } ","date":"2020-04-10","objectID":"/2020/04/cf703d-mishka-and-interesting-sum/:2:0","tags":["树状数组"],"title":"[CF703D] Mishka and Interesting Sum","uri":"/2020/04/cf703d-mishka-and-interesting-sum/"},{"categories":["code"],"content":"给一个字符串，现有这么一种操作，将字符串内每一个字母替换成一给定字符串。例如$T_a=abc,T_b=ee$，那么$ab$就会被替换成$abcee$。 给出初始的字符串$S$，和26个字母所对应的字符串$T_i$，应用操作$K$次，询问第$i$个位置的字符。 $$|S| \\leq 1000000$$ $$2 \\leq |T_i| \\leq 50,K \\leq 10^{15}$$ ","date":"2020-04-08","objectID":"/2020/04/kattis-prolonged-password/:0:0","tags":["倍增"],"title":"Prolonged Password","uri":"/2020/04/kattis-prolonged-password/"},{"categories":["code"],"content":"分析 头秃。开始以为关键是在于数出一个字符串经过K次操作后达到的长度，然后然后用类似于二分的方法去递归地分层找到需要的位置。于是就统计每个字母的数目，用矩阵快速幂拿到长度…… 现在看着过于智障。这1e15的指数和1e15的下标，你怎么敢快速幂。 由替换字符串的长度可以得到，这种操作顶多执行50次（$2^{50}$）。因此字符串的长度部分计算实际上不占大头，用个倍增就能处理出来。 现在剩下的问题是操作次数$K$过大。方法仍然是基于50次。一个字符扩展50次，就足够把所有的询问包含在内。因此要计算出第一个字符替换的循环节，将操作次数降到接近50。此后通过倍增法去一层层定位询问下标所处的位置。 最开始方向错了是一码事…感觉K的范围也挺无聊的…代码等到之后再补上。 ","date":"2020-04-08","objectID":"/2020/04/kattis-prolonged-password/:1:0","tags":["倍增"],"title":"Prolonged Password","uri":"/2020/04/kattis-prolonged-password/"},{"categories":["code"],"content":"代码 实际实现时，降K可能浮动26左右，所以多处理这么一点。 #include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ciostream\u003e#include \u003cstack\u003e#include \u003ccstring\u003e#include \u003ccassert\u003eusing namespace std; using ll=long long; const int MAXN=30; string inp; ll K; string rep[30]; ll f[26][81]; void upd(ll \u0026a,ll b){ if(a==-1)return; if(b==-1){ a=-1; return; } a+=b; if(a\u003e1e15)a=-1; } char reduceK(){ //找到循环节 char chr=inp[0]; bool vis[30]; stack\u003cchar\u003e st; memset(vis,0,sizeof(vis)); while(!vis[chr-'a']){ st.push(chr); vis[chr-'a']=1; chr=rep[chr-'a'][0]; } int cycle=1; while(st.top()!=chr){ cycle++; st.pop(); } st.pop(); int pre=st.size(); //将K削到54-80 if(K\u003c=54)return '\\0'; if(K-pre\u003c=54)return '\\0'; K-=pre; K=K-(K-54)/cycle*cycle; return chr; } char solve(ll idx,string str,int p){ if(p==0){ return str[idx-1]; } for(int i=0;i\u003cstr.size();i++) { if (f[str[i] - 'a'][p] == -1 || f[str[i] - 'a'][p] \u003e= idx)return solve(idx, rep[str[i] - 'a'],p-1); idx-=f[str[i] - 'a'][p]; } //不该出现这种情况 assert(false); } int main(){ ios::sync_with_stdio(false); cin\u003e\u003einp;// for(int i=0;i\u003c26;i++){ cin\u003e\u003erep[i]; f[i][1]=rep[i].size(); } for(int i=0;i\u003c26;i++)f[i][0]=1; cin\u003e\u003eK; for(int p=2;p\u003c=80;p++){ for(int i=0;i\u003c26;i++){ for(int k=0;k\u003crep[i].size();k++){ upd(f[i][p],f[rep[i][k]-'a'][p-1]); } } } char start=reduceK(); int qlen;cin\u003e\u003eqlen; while(qlen--){ ll idx;cin\u003e\u003eidx; if(start=='\\0')cout\u003c\u003csolve(idx,inp,K)\u003c\u003cendl; else cout\u003c\u003csolve(idx,rep[start-'a'],K-1)\u003c\u003cendl;//-1 } } ","date":"2020-04-08","objectID":"/2020/04/kattis-prolonged-password/:2:0","tags":["倍增"],"title":"Prolonged Password","uri":"/2020/04/kattis-prolonged-password/"},{"categories":["闲扯"],"content":" 我再换blog的后端我就是狗。 Tiddlywiki是我在寻找Mediawiki的替代品时意外发现的东西。起初我还是只惊艳于它的特殊的组织方式和齐全的功能，整个软件只有一个html文件，逻辑、数据全部保存在里面。后来，在我深入这套软件的模板功能时，了解到了它的哲学。 Tiddlywiki从最初就打算为用户准备一个极端稳定且独立的非线性文字笔记系统。其第一个版本在2004年发布，直到现在仍然在稳定的运行。为了做到上面的要求，wiki才采用了单文件方式，不追求任何时髦技术，尽可能不依赖任何现存的其他软件，尽可能做到兼容，甚至代码也完全基于vanilla和html5。而这么做的原因大概就是要达到一点要求：在提供足够功能的前提下，保证系统的独立和在很长一段时间内的可靠，从而维持数据的独立。 为何这么强调数据的独立？因为数据显然比凭依的记录手段更有价值。试想如果（如果！）有一天OneNote被砍掉了，我觉得不会有用户会先于自己的笔记去担忧巨硬的明天，用户第一考虑的该是如何将自己沉积多年的笔记统统转移出来。这很难，即使转移出来，恐怕也无法获得同样的编辑体验。 在这里，缅怀一下被谷姐砍掉的reader… 数据具有更高的价值，数据应该尽可能避免对特定系统的依赖。 在过去的一段时间里，我又多次看到了这种意见。有人在讨论NAS时持有这种观点，认为要远离不靠谱的网盘，数据和处理数据的工具应该分离；在vnote的issue中看到作者否定使用sqlite保存数据时也如是说，不使用私有格式，要为用户留足转移笔记的空间。 不过，保持数据更高的独立性也并非好事，这一般意味着无法得到更多的功能。想要解决也有点思路，要么把系统稳定性做到极致，别有事没事威胁数据安全，要么把格式做成标准，大家通用，给数据留足后路。 所以扯了这么多废话，结论就是我又回到静态博客了，顺便体验了一遍从数据库转移到文件的痛苦。先把数据库导出json，再拿python转换格式，还要莫名其妙再转义一遍文件里的dos换行符。啧，即使是最通用的文本文件，照样不同平台间移植会有代价。¯\\(ツ)/¯ 我再也不折腾了，再折腾我就是狗。 ","date":"2020-04-07","objectID":"/2020/04/info-dependence/:0:0","tags":[],"title":"由Tiddywiki说起","uri":"/2020/04/info-dependence/"},{"categories":["学习"],"content":"目前，针对图片，视频，我们有通过在频域上乱搞的方式为其添加不可见水印。这种技术主要依靠的就是二维傅立叶变换。 $$ \\hat g(f)=\\int{g(t)e^{-2\\pi i ft}dt} $$ 这个是一维的傅立叶变换。那么，如果现在有一个二维信号$g(t_1,t_2)$，是不是可以简单的把上式改为 $$ \\hat g(f_1,f_2)=\\int\\int{g(t_1,t_2)e^{-2\\pi i (f_1t_1+f_2t_2)}dt_1dt_2} $$ 事实上是的。而逆变换为 $$ g(t_1,t_2)=\\frac{1}{4 \\pi^2}\\int\\int\\hat g(f_1,f_2)e^{2\\pi i (t_1f_1+t_2f_2)}df_1df_2 $$ 如果写成离散形式，也是一种套路。 $$ \\hat g(f_1,f_2)=\\sum\\sum{g(t_1,t_2)e^{-2\\pi i (f_1t_1+f_2t_2)}} $$ $$ g(t_1,t_2)=\\frac{1}{4 \\pi^2}\\sum\\sum\\hat g(f_1,f_2)e^{2\\pi i (t_1f_1+t_2f_2)} $$ 二维的傅立叶变换仍然是将信号分解为多个成分，只不过这里成了平面意义上的波，而且多了一个方向。这里的方向我们直接把$f_1,f_2$绘制到中心点为$(0,0)$的坐标系上，从而能够形成一张附带全部信息的频域图。 对于二维傅立叶变换的结果，也和一维的结果又类似含义。一个一元函数的高频低频意味着其变化快与慢的成分，一个声音的高频低频意味着其高音和低音部分，而一个二维变换的结果高频低频也意味着该数据变化快与慢的部分。 既然能够从音频频域上摘掉对声音有意义的频率（例如删掉与人声相关的频率），那就也可以在图片频域中叠加对人有意义的频率。所谓图片与视频的隐写术就是将对人眼有意义的频率叠加到频域中再进行逆变换的结果。包括音频也可以这么干，利用短时距傅立叶变换在频域上画一点有意义的图像再逆变换回去，就能当作更高级一点的音频水印。不过实际测试起来，在音频频域上搞得太过头的话听感影响挺大的。 这种技术相比直接打水印有很多好处，利用频率的特性意味着它可以对抗很多一般的攻击方式。不过一旦攻击能够影响频率，例如再次拍摄/录音这种，至少朴素的隐写就基本上gg了。 所以看到有人拿这个玩意去水大创就有点好奇，问了问能否识别我现拍的照片，得到的答复是不行……还以为会有干货，稍微有些失望。 ","date":"2020-03-27","objectID":"/2020/03/a-little-2d-fft/:0:0","tags":["FFT"],"title":"一点点二维傅立叶变换","uri":"/2020/03/a-little-2d-fft/"},{"categories":["学习"],"content":"今天仍然是被吊起来打的一天。 点分治是一种用于解决树上路径问题的思路。它的关键就是选中一点，统计经过该点的答案后删除点，再递归到两个子树中进行同样的操作。 删除的点连带删除了一些已经计算过的路径。 当每次选择重心作为根时，能保证点分治的复杂度本身为$O(n \\log n)$。当然你得保证$O(n)$做完你的事情，同样清数组时也必须只清用到的。 印象里之前有道树上DP的题，自己yy瞎糊的算法写的难看又难调，就有点这种感觉。不过那个是$O(n)$的，大概泛用上不如这个。 ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:0:0","tags":null,"title":"一点点点分治","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["学习"],"content":"聪聪可可 聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。 他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画 nn 个“点”，并用 n-1n−1 条“边”把这 nn 个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是 33 的倍数，则判聪聪赢，否则可可赢。 聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:1:0","tags":null,"title":"一点点点分治","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["学习"],"content":"分析 统计路径。但是这题dp的话能转移。 但是还是用点分治。 枚举一个点后，设$f(u,j)$表示到$u$点模3为$j$的路径数有多少。转移很明显，统计也很显然。 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003cqueue\u003e#include \u003ccstring\u003eusing namespace std; const int XV=20010; using pii=pair\u003cint,int\u003e; using ll=long long; vector\u003cpii\u003e g[XV]; bool vis[XV]; int sz[XV]; int dfs1(int u,int fa){ sz[u]=1; for(auto [v,w]:g[u]){ if(vis[v] || v==fa)continue; sz[u]+=dfs1(v,u); } return sz[u]; } int SZ; int rt; int maxsz[XV]; queue\u003cint\u003e ready_to_clear; void getroot(int u,int fa){ sz[u]=1; ready_to_clear.push(u); for(auto [v,w]:g[u]){ if(vis[v] || v==fa)continue; getroot(v,u); sz[u]+=sz[v]; maxsz[u]=max(maxsz[u],sz[v]); } maxsz[u]=max(maxsz[u],SZ-sz[u]); if(rt==0 || maxsz[u]\u003cmaxsz[rt])rt=u; } ll ans=0; ll f[XV][3]; void cal(int u,int fa){ for(auto [v,w]:g[u]){ if(vis[v] || v==fa)continue; cal(v,u); int t[3]; for(int i=0;i\u003c3;i++){ t[(i+w)%3]=f[v][i]; } t[w%3]++;//由v直接出发 if(u==rt){ //从该子树到之前所有的子树 ans+=t[0]*f[u][0]; ans+=t[1]*f[u][2]; ans+=t[2]*f[u][1]; } for(int i=0;i\u003c3;i++){ f[u][i]+=t[i]; } } if(u==rt)ans+=f[u][0]; } void solve(int u){ vis[u]=1; while(!ready_to_clear.empty()){ int u=ready_to_clear.front();ready_to_clear.pop(); f[u][0]=f[u][1]=f[u][2]=0; maxsz[u]=0; } cal(u,0); //cout\u003c\u003c\"after\"\u003c\u003cu\u003c\u003c\",ans=\"\u003c\u003cans\u003c\u003cendl; for(auto [v,w]:g[u]){ if(vis[v])continue; SZ=sz[v];rt=0; getroot(v,0); solve(rt); } } ll gcd(ll a,ll b){ return !b?a:gcd(b,a%b); } int main(){ ios::sync_with_stdio(false); int nlen;cin\u003e\u003enlen; for(int i=1;i\u003c=nlen-1;i++){ int u,v,w;cin\u003e\u003eu\u003e\u003ev\u003e\u003ew; g[u].emplace_back(v,w); g[v].emplace_back(u,w); } memset(vis,0,sizeof(vis)); SZ=nlen; rt=0;getroot(1,0); solve(rt); ll win=ans*2+nlen; ll all=1LL*nlen*nlen; ll g=gcd(win,all); cout\u003c\u003cwin/g\u003c\u003c\"/\"\u003c\u003call/g\u003c\u003cendl; } ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:1:1","tags":null,"title":"一点点点分治","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["学习"],"content":"[HDU6643] yts1999 Doesn’t Like This Problem Mr. Bread has a tree T with n vertices, labeled by 1,2,…,n. Each vertex of the tree has a positive integer value wi. The value of a non-empty tree T is equal to w1×w2×⋯×wn. A subtree of T is a connected subgraph of T that is also a tree. Please write a program to calculate the number of non-empty subtrees of T whose values are not larger than a given number m. ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:2:0","tags":null,"title":"一点点点分治","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["学习"],"content":"分析 虽然我不知道为什么就显然点分治了，但是他们说是。要DP还是容易看出来的。 点分治能够解决路径问题，这种连通性问题也可以解决。也是枚举一个点后，统计包括这个点的连通块的答案。 选中该点后，进行DP。然后是他们说的非常套路的利用dfs序将树映射到序列上的做法。以$f(i,j)$表示在$i$点处值为$j$的方案数。 选中$i$： $$f(i,ja)+=f(i+1,a)$$ 不选$i$，那么同时要跳过i的整个子树： $$f(i,j)+=f(i+\\text{sz}(i),j)$$ 另外是这道题的$j$范围太大。看到一个很骚的写法是存成$j$和$M/j$，然后每个都只有$\\sqrt M$这么大…我寻思你再给我一遍这个题我也yy不出来这种存法。 总之有两个东西可以注意一下： 对树上涉及依赖关系的DP可以考虑使用dfs序映射。 我不知道这个处理j的办法有没有泛用性。 ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:2:1","tags":null,"title":"一点点点分治","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["学习"],"content":"代码 代码中的重心、点分治的solve应该形成较为固定的写法。 origin /// copied #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccmath\u003e using namespace std; using ll=long long; const int XN=2010; vector\u003cint\u003e g[XN]; int dfn[XN],sz[XN],tick=0; int re[XN]; int vis[XN]; int wage[XN]; int m; int square; int dfs(int u,int fa) { sz[u] = 1; dfn[u] = ++tick; re[tick] = u; for (auto v:g[u]) { if (vis[v] || v==fa)continue; sz[u] += dfs(v, u); } return sz[u]; } int SZ; int maxsz[XN],root=0; void getroot(int u,int fa) { sz[u] = 1; maxsz[u] = 0; for (auto v:g[u]) { if (vis[v] || v == fa)continue; getroot(v, u); sz[u] += sz[v]; maxsz[u] = max(maxsz[u], sz[v]); } maxsz[u] = max(maxsz[u], SZ - maxsz[u]); if (root == 0 || maxsz[u] \u003c maxsz[root])root = u; } const int MOD=1000000007; int M(int \u0026x) { return x %= MOD; } int f[XN][XN],f2[XN][XN]; int cal() { //默认选中root int res = 0; for (int i = 0; i \u003c= tick + 1; i++) { memset(f[i], 0, sizeof(f[i])); memset(f2[i], 0, sizeof(f2[i])); } f[tick + 1][1] = 1; for (int i = tick; i \u003e= 1; i--) { int w = wage[re[i]]; for (int j = 1; j \u003c= min(m / w, square); j++) { int to = w * j; if (to \u003c= square)M(f[i][to] += f[i + 1][j]); else M(f2[i][m / to] += f[i + 1][j]); } for (int j = w; j \u003c= square; j++) { M(f2[i][j / w] += f2[i + 1][j]); } //不选j，那么要跳过整个子树 for (int j = 1; j \u003c= square; j++)M(f[i][j] += f[i + sz[re[i]]][j]); for (int j = 1; j \u003c= square; j++)M(f2[i][j] += f2[i + sz[re[i]]][j]); } for (int i = 1; i \u003c= square; i++)M(res += f[1][i]); for (int i = 1; i \u003c= square; i++)M(res += f2[1][i]); //去掉不选root的情况 res--; return M(res += MOD); } int ans=0; void solve(int u) { vis[u] = 1; tick = 0; dfs(u, 0); M(ans += cal()); for (auto v:g[u]) { if (vis[v])continue; SZ = sz[v]; root = 0; getroot(v, 0); solve(root); } } int main() { int kase; cin \u003e\u003e kase; while (kase--) { int n; cin \u003e\u003e n \u003e\u003e m; square = sqrt(m); for (int i = 1; i \u003c= n; i++)g[i].clear(); memset(vis,0,sizeof(vis)); tick = 0; ans = 0; for (int i = 1; i \u003c= n; i++)cin \u003e\u003e wage[i]; for (int i = 1; i \u003c= n - 1; i++) { int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v); g[v].push_back(u); } root = 0; SZ = n; getroot(1, 0); solve(root); cout \u003c\u003c ans \u003c\u003c endl; } } ","date":"2020-03-26","objectID":"/2020/03/a-littile-tree-divide/:2:2","tags":null,"title":"一点点点分治","uri":"/2020/03/a-littile-tree-divide/"},{"categories":["学习"],"content":"艹了天天都被不知道的知识点教育，知道的又做不出来。 :lei: 在动态规划中，决策单调性指对于$j \u003c j'$，$f(j’)$的最佳转移$f(i’)$位置$i'$一定不小于$f(j)$的$i$。 假设 $$f(r)=\\min{f(k-1)+w(k,r)}$$ 为了证明这一点，首先假设 $$f(r)=f(k-1)+w(k,r)$$ 此时我们有$\\forall i \u003c k$， $$f(k-1)+w(k,r) 此后，将r后挪1。我们必须要证明$\\forall i \u003c k$， $$f(k-1)+w(k,r+1) 也就是证明对于两边的两个增量$\\Delta$有 $$w(k,r+1) - w(k,r) ","date":"2020-03-23","objectID":"/2020/03/juece-dandiao/:0:0","tags":null,"title":"一点点决策单调性","uri":"/2020/03/juece-dandiao/"},{"categories":["学习"],"content":"使用分治 一旦有决策单调性了，我们就可以通过优于$n^2$的总复杂度完成规划。 例如使用分治。当我们找到区间$[ l, r ]$的中点$m$的决策点$p$时，那么$[l, m-1]$区间只能从不晚于$p$转移，$[m+1, r]$只能从不早于$p$转移。 l和r是当前要决策的区间，L和R是转移位置。 void solve(int l,int r,int L,int R) { if(l\u003er)return; int mid=(l+r)/2; int p=0; for(int i=L;i\u003c=min(mid,R);i++){ //这里的下标写法要和方程配套 if(f[i-1]+w[i,mid]\u003cf[mid]){ f[mid]=f[i-1]+w[i,mid]; p=i; } } solve(l,mid-1,L,p); solve(mid+1,r,p,R); } ","date":"2020-03-23","objectID":"/2020/03/juece-dandiao/:1:0","tags":null,"title":"一点点决策单调性","uri":"/2020/03/juece-dandiao/"},{"categories":["学习"],"content":"【CF868F】yts1999 Doing Minimization You are given an array of n integers a1… an. The cost of a subsegment is the number of unordered pairs of distinct indices within the subsegment that contain equal elements. Split the given array into k non-intersecting non-empty subsegments so that the sum of their costs is minimum possible. Each element should be present in exactly one subsegment. ","date":"2020-03-23","objectID":"/2020/03/juece-dandiao/:2:0","tags":null,"title":"一点点决策单调性","uri":"/2020/03/juece-dandiao/"},{"categories":["学习"],"content":"分析 设$f(i,j)$表示前j个分i段。 这个题目就满足决策单调。一个更长的区间+1之后只有可能比短的区间增加更多的代价。 接下来的问题是怎么算这道题里的$w(i,j)$。$n^2$显然不行。看到有人整了个类似莫队的东西，不过我还没太弄明白这个复杂度是怎么算的，看起来是和分治的内层循环一致所以就对复杂度没有更多的贡献了。 一共进行k轮分治，$O(kn\\log n)$ #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003eusing namespace std; using ll=long long; const int XN=100010; ll f[30][XN]; ll wage; int cl,cr; int num[XN]; ll cnt[XN]; void jump(int l,int r){ while(cl\u003cl){ cnt[num[cl]]--; wage-=cnt[num[cl]]; cl++; } while(l\u003ccl){ cl--; wage+=cnt[num[cl]]; cnt[num[cl]]++; } while(r\u003ccr){ cnt[num[cr]]--; wage-=cnt[num[cr]]; cr--; } while(cr\u003cr){ cr++; wage+=cnt[num[cr]]; cnt[num[cr]]++; } } void solve(int l,int r,int L,int R,int k) { if(l\u003er)return; int mid=(l+r)/2; int p=0; for(int i=L;i\u003c=min(mid,R);i++){ jump(i,mid); if(f[k-1][i-1]+wage\u003cf[k][mid]){ f[k][mid]=f[k-1][i-1]+wage; p=i; } } solve(l,mid-1,L,p,k); solve(mid+1,r,p,R,k); } int main(){ ios::sync_with_stdio(false); int n,kk;cin\u003e\u003en\u003e\u003ekk; for(int i=1;i\u003c=n;i++)cin\u003e\u003enum[i]; memset(f,0x3f,sizeof(f)); for(auto \u0026 i : f)i[0]=0; for(int i=1;i\u003c=n;i++){ wage+=cnt[num[i]]; cnt[num[i]]++; f[1][i]=wage; } // for(int i=1;i\u003c=n;i++){ // cout\u003c\u003cf[1][i]\u003c\u003c\u0026#039; \u0026#039;; // } // cout\u003c\u003cendl; wage=0;cl=1;cr=0; memset(cnt,0,sizeof(cnt)); for(int i=2;i\u003c=kk;i++){ solve(1,n,1,n,i); } cout\u003c\u003cf[kk][n]\u003c\u003cendl; } ","date":"2020-03-23","objectID":"/2020/03/juece-dandiao/:2:1","tags":null,"title":"一点点决策单调性","uri":"/2020/03/juece-dandiao/"},{"categories":["code"],"content":"Patrick Star bought a bookshelf, he named it ZYG !! Patrick Star has N book . The ZYG has K layers (count from 1 to K) and there is no limit on the capacity of each layer ! Now Patrick want to put all N books on ZYG : Assume that the i-th layer has cnti(0≤cnti≤N) books finally. Assume that f[i] is the i-th fibonacci number (f[0]=0,f[1]=1,f[2]=1,f[i]=f[i−2]+f[i−1]). Define the stable value of i-th layers stablei=f[cnti]. Define the beauty value of i-th layers beautyi=2stablei−1. Define the whole beauty value of ZYG score=gcd(beauty1,beauty2,…,beautyk)(Note: gcd(0,x)=x). Patrick Star wants to know the expected value of score if Patrick choose a distribute method randomly ! ","date":"2020-03-21","objectID":"/2020/03/hdu-6363-bookshelf/:0:0","tags":null,"title":"[HDU 6363] bookshelf","uri":"/2020/03/hdu-6363-bookshelf/"},{"categories":["code"],"content":"分析 我tm这辈子学不会数论了。 先是两个【——】结论 $\\gcd(2^a-1,2^b-1)=2^{\\gcd(a,b)}-1$ $\\gcd(\\text{fib}(a),\\text{fib}(b))=\\text{fib}(\\gcd(a),\\gcd(b))$ 然后原题的score就变成 $$2^{\\text{fib}(\\gcd(a_1,a_2,\\cdots))}-1$$ 接下来才有机会瞎搞。枚举gcd，$d|n$，$a$的分配方式有$C^{n/d+k-1}{k-1}$种。这种分配包括了d’是d的倍数的所有情况的可能。令$F(d)=C^{n/d+k-1}{k-1}$，$f(d)$为真正的数目，于是有 $$F(d)=\\sum_{d|d'}f(d')$$ 依照莫比乌斯反演，有 $$f(d)=\\sum_{d|d'}\\mu(\\frac{d'}{d})F(d')$$ 于是原题得以解决。 ","date":"2020-03-21","objectID":"/2020/03/hdu-6363-bookshelf/:1:0","tags":null,"title":"[HDU 6363] bookshelf","uri":"/2020/03/hdu-6363-bookshelf/"},{"categories":["学习"],"content":"抄起我的混凝土数学，复习了会上升下降积分，看了看斯特林数和伯努利数。结果误把伯努利数的递推式看成了$O(n)$的，改了半天一到3次方以上就翻车，这才反应过来。 8会啊…找了很长时间才知道是拉格朗日插值。 有这么一条定理。 平面上的n+1个点可以确定一个n次多项式。 而$\\sum i^p$是一个$p+1$次多项式，况且在$p \\leq 1000000$的前提下很容易找到前$p+1$个点。如果我们找到一种方式去构造这样一个多项式问题就解决了。 拉格朗提出了这么一种方法。 ","date":"2020-03-19","objectID":"/2020/03/lagrange-polynomial/:0:0","tags":null,"title":"一点点拉格朗日插值","uri":"/2020/03/lagrange-polynomial/"},{"categories":["学习"],"content":"构造 设函数 $$\\ell_j(x)=\\prod_{k \\neq j} \\frac{x-x_k}{x_j-x_k}$$ 注意其特性 $x_j$被带入时，其为$1$ 其他任何$x$被带入时，会出现$0$项。 因此这个东西就可以为任何一个点对创建在多项式中的单元$y_j \\ell_j(x_j)$。剩下的问题是如何快速求解。 当我们只求单点（率先带入点），且整数x连续取值时，观察到分母和分子都变为阶乘形式，且分式的构成元素在前后两项之间具有递推的关系。 $$ \\ell_j(x)=\\frac{(x-1)(x-2)\\cdots (x-(j-1))(x-(j+1))\\cdots (x-n)}{(j-1)(j-2) \\cdots (j-(j-1))(j-(j+1)) \\cdots (j-n))} $$ 可以看到，分子和分母项都能够拆分为左右两个部分。分别维护前缀后缀与阶乘逆元即可。 阶乘并不需要全部的，仅仅是左侧和右侧的一小部分。 ","date":"2020-03-19","objectID":"/2020/03/lagrange-polynomial/:1:0","tags":null,"title":"一点点拉格朗日插值","uri":"/2020/03/lagrange-polynomial/"},{"categories":["学习"],"content":"板子 嫖的，自己的写爆了而且巨丑。 int lagrange(int n,int *x,int *y,int k) { int ans=0; for(int i=1;i\u003c=n;++i) { int f=1,g=1; for(int j=1;j\u003c=n;++j) if(i!=j) { f=1LL*f*(k-x[j]+mod)%mod; g=1LL*g*(x[i]-x[j]+mod)%mod; } upd(ans,1LL*y[i]*f%mod*inv(g)%mod); } return ans; } int lagrange(int n,int *y,int k) { int ans=0; pre[0]=suf[n+1]=1; for(int i=1;i\u003c=n;++i) pre[i]=1LL*pre[i-1]*(k-i)%mod; for(int i=n;i\u003e=1;--i) suf[i]=1LL*suf[i+1]*(k-i)%mod; for(int i=1;i\u003c=n;++i) { int a=1LL*pre[i-1]*suf[i+1]%mod*inv[i-1]%mod*inv[n-i]%mod; if((n-i)\u00261) a=mod-a; upd(ans,1LL*a*y[i]%mod); } return ans; } ","date":"2020-03-19","objectID":"/2020/03/lagrange-polynomial/:2:0","tags":null,"title":"一点点拉格朗日插值","uri":"/2020/03/lagrange-polynomial/"},{"categories":["学习"],"content":"错误的代码 这份看错了伯努利数的递推复杂度 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cset\u003e#include \u003ccmath\u003e#include \u003cmap\u003eusing namespace std; using ll=long long; const int MAXN=1000010; const int mod=1e9+7; ll inv[MAXN]; double B[MAXN]; double C[MAXN]; void init(int n){ //niyuan inv[1]=1; for(int i=2;i\u003c=n+1;i++) { inv[i] = inv[mod % i] * (mod - mod / i) % mod; } //C C[0]=1; for(int i=1;i\u003c=n+1;i++){ // C[i]=C[i-1]*(n+1-i+1)%mod*inv[i]%mod; C[i]=C[i-1]*(n+1-i+1)/i; } //WRONG //伯努利数的递推是n^2级别的，理解式子上出现了失误。 B[0]=1; double s=C[0]; for(int i=1;i\u003c=n;i++){ // B[i]=-inv[i+1]*s%mod; // s=(s+B[i]*C[i]%mod)%mod; B[i]=-s/(i+1); s=(s+B[i]*C[i]); } } ll n2[MAXN]; int main(){ ll n,m;cin\u003e\u003en\u003e\u003em; init(m); for(int i=0;i\u003c=m;i++)cout\u003c\u003cC[i]\u003c\u003c\" \"; cout\u003c\u003cendl; for(int i=0;i\u003c=m;i++)cout\u003c\u003cB[i]\u003c\u003c\" \"; cout\u003c\u003cendl; n2[0]=1; for(int i=1;i\u003c=m+1;i++){ n2[i]=n2[i-1]*n%mod; } for(int i=0;i\u003c=m+1;i++)cout\u003c\u003cn2[i]\u003c\u003c\" \"; cout\u003c\u003cendl; double ans=0; for(int i=0;i\u003c=m;i++){ // ans=(ans+C[i]*B[i]%mod*n2[m+1-i]%mod)%mod; ans=(ans+C[i]*B[i]*n2[m+1-i]); } // (ans*=inv[m+1])%=mod; ans=ans/(m+1); cout\u003c\u003cans\u003c\u003cendl; } 这份自己yy的拉格朗日插值在阶乘的求法上有问题。 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cset\u003e#include \u003ccmath\u003e#include \u003cmap\u003eusing namespace std; using ll=long long; const int MAXN=1000010; const int mod=1e9+7; ll fac[MAXN]; ll facinv[MAXN]; ll inv[MAXN]; ll qpow(ll a,ll b,ll p=mod){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%p){ if(b\u00261){ res=res*a%p; } } return res; } inline ll get_inv(ll a,ll p=mod){ return qpow(a,p-2,p); } inline ll Fac(int n,bool pos=true){ int flg=1; if(!pos \u0026\u0026 n%2==1)flg=-1; return fac[n]*flg; } inline ll Invfac(int n,bool pos=true){ int flg=1; if(!pos \u0026\u0026 n%2==1)flg=-1; return facinv[n]*flg; } void init(int n){ fac[0]=1; for(int i=1;i\u003c=n;i++)fac[i]=fac[i-1]*i%mod; facinv[n]=get_inv(fac[n]); for(int i=n-1;i\u003e=1;i--){ facinv[i]=facinv[i+1]*(i+1)%mod; } facinv[0]=1; inv[1]=1; for(int i=2;i\u003c=n;i++) inv[i] = inv[mod % i] * (mod-mod/i) % mod; } ll ans=0; ll yy[MAXN]; int main(){ int n,m;cin\u003e\u003en\u003e\u003em; int M=m+2; init(max(n,M)); for(int i=1;i\u003c=M;i++){ yy[i]=qpow(i,m); } for(int i=1;i\u003c=M;i++){ yy[i]=(yy[i]+yy[i-1])%mod; } for(int i=1;i\u003c=M;i++)cout\u003c\u003cyy[i]\u003c\u003c\" \"; cout\u003c\u003cendl; if(n\u003c=M){ cout\u003c\u003cyy[n]\u003c\u003cendl; return 0; } for(int i=1;i\u003c=M;i++){ ll cell=yy[i]*Fac(n-1)%mod*Invfac(n-M-1)%mod*inv[n-i]%mod; (cell*=Invfac(i-1))%=mod; (cell*=Invfac(abs(i-M),false))%=mod; (ans+=cell)%=mod; // ll cell=yy[i]*Fac(n-1)/Fac(n-M-1)/(n-i); // cell/=Fac(i-1); // cell/=Fac(abs(i-M),false); // ans+=cell; } cout\u003c\u003c(ans+mod)%mod\u003c\u003cendl; } ","date":"2020-03-19","objectID":"/2020/03/lagrange-polynomial/:3:0","tags":null,"title":"一点点拉格朗日插值","uri":"/2020/03/lagrange-polynomial/"},{"categories":["code"],"content":"HDU6319 Ascending Rating Before the start of contest, there are n ICPC contestants waiting in a long queue. They are labeled by 1 to n from left to right. It can be easily found that the i-th contestant’s QodeForces rating is ai. Little Q, the coach of Quailty Normal University, is bored to just watch them waiting in the queue. He starts to compare the rating of the contestants. He will pick a continous interval with length m, say [l,l+m−1], and then inspect each contestant from left to right. Initially, he will write down two numbers maxrating=−1 and count=0. Everytime he meets a contestant k with strictly higher rating than maxrating, he will change maxrating to ak and count to count+1. Little T is also a coach waiting for the contest. He knows Little Q is not good at counting, so he is wondering what are the correct final value of maxrating and count. Please write a program to figure out the answer. ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:1:0","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"分析 一开始想着从左到右滑动窗口维护一个单调队列，结果发现没法统计count。 反向滑动就好了，我还没太反应过来为啥。唯一捉住的一点想法是“数据无用”的时刻。在正向维护时，后想加入但是未被加入的元素可能因为前者pop掉而漏掉，但是反向维护时只会弹出已经使用的无用元素，任何时候新元素都会被加入。 ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:1:1","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"HDU6331 Walking Plan There are n intersections in Bytetown, connected with m one way streets. Little Q likes sport walking very much, he plans to walk for q days. On the i-th day, Little Q plans to start walking at the si-th intersection, walk through at least ki streets and finally return to the ti-th intersection. Little Q’s smart phone will record his walking route. Compared to stay healthy, Little Q cares the statistics more. So he wants to minimize the total walking length of each day. Please write a program to help him find the best route. ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:2:0","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"分析 ……果然还是菜，别人过得像飞一样。先是读错了题，把ki streets理解成了路径权的限制，就翻了车。后发现是k条之后，猜了发是不是倍增，又争执了很久到底最短路能不能蹦。最后结论是大概可以蹦。（既然过了那就也是了） 结果发现倍增的话答案没法统计。大哥们说分块，才终于看到了一点希望。wa了数发才过。 ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:2:1","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"HDU6325 Interstellar Travel After trying hard for many years, Little Q has finally received an astronaut license. To celebrate the fact, he intends to buy himself a spaceship and make an interstellar travel. Little Q knows the position of n planets in space, labeled by 1 to n. To his surprise, these planets are all coplanar. So to simplify, Little Q put these n planets on a plane coordinate system, and calculated the coordinate of each planet (xi,yi). Little Q plans to start his journey at the 1-th planet, and end at the n-th planet. When he is at the i-th planet, he can next fly to the j-th planet only if xi\u003cxj, which will cost his spaceship xi×yj−xj×yi units of energy. Note that this cost can be negative, it means the flight will supply his spaceship. Please write a program to help Little Q find the best route with minimum total cost. ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:3:0","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"分析 这题如果你在a和b两点之间找第三点，然后计算代价差，就会发现最终的代价里出现了a到b的直线方程。代价变成了该直线上第三点的值和真实值的差， 可是见鬼了这是怎么发现的。 结论是一个点在直线之上，就要进行中转。所以最终答案大方向是求一个凸包。 ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:3:1","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"HDU6321 Dynamic Graph Matching In the mathematical discipline of graph theory, a matching in a graph is a set of edges without common vertices. You are given an undirected graph with n vertices, labeled by 1,2,…,n. Initially the graph has no edges. There are 2 kinds of operations : u v, add an edge (u,v) into the graph, multiple edges between same pair of vertices are allowed. u v, remove an edge (u,v), it is guaranteed that there are at least one such edge in the graph. Your task is to compute the number of matchings with exactly k edges after each operation for k=1,2,3,…,n2. Note that multiple edges between same pair of vertices are considered different. ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:4:0","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"分析 数据范围能够状压。 用$f(i,state)$表示此次操作完后，已经选择的点有state所能构成的方案数。对于加边uv，就有如下转移。表示在未选择uv的已匹配状态里再选上uv构成新state。 $$f(i,s)=\\sum f(i-1,s-\\{u,v\\})$$ 表示在删除uv时，从方案中再次扣去这些状态。 $$f(i,s)-=f(i,s-\\{u,v\\})$$ 把第一维滚动掉，这两个公式对转移顺序没有要求，每次更新都不会更新被用来转移的状态，瞎掰写。 ","date":"2020-03-19","objectID":"/2020/03/spring-training-3/:4:1","tags":null,"title":"Spring Training 3","uri":"/2020/03/spring-training-3/"},{"categories":["code"],"content":"Alice 想要得到一个长度为 n 的序列，序列中的数都是不超过 m 的正整数，而且这 n 个数的和是 p 的倍数。 Alice 还希望，这 n 个数中，至少有一个数是质数。 Alice 想知道，有多少个序列满足她的要求。 $$1 \\leq n \\leq 10 ^ 9, 1 \\leq m \\leq 2 \\times 10 ^ 7, 1 \\leq p \\leq 100$$ ","date":"2020-03-18","objectID":"/2020/03/builds-sequences/:0:0","tags":["快速幂"],"title":"[???] Builds Sequences","uri":"/2020/03/builds-sequences/"},{"categories":["code"],"content":"分析 这题做得很爽… 首先是一个套路，维护倍数可以转为维护当前和的模。因此如果递推的话，只需要100个状态，看起来是可做的。但是这个n的范围实在是有点，先列一下再说。 把2e7个数字全部模完，它们对答案的贡献只和剩余类有关。这样我们就能知道在和的模为a时有多少种方案能够凑到b了。得出递推方程 $$ f(i,j)=\\sum_{0 \\leq k 其中$c(k)$是模为k的数有多少个。 至少有一个质数的条件转为无质数，从所有的c中扣去质数后再算一遍方案数，二者相减。 最后，关于n，这个公式能够用快速幂加速。 ","date":"2020-03-18","objectID":"/2020/03/builds-sequences/:1:0","tags":["快速幂"],"title":"[???] Builds Sequences","uri":"/2020/03/builds-sequences/"},{"categories":["code"],"content":"代码 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cset\u003e#include \u003ccmath\u003e#include \u003cmap\u003eusing namespace std; using pii=pair\u003cint,int\u003e; using ll=long long; const int MAXN=110; const int MAXM=20000010; const int MOD=20170408; bool isnp[MAXM]; vector\u003cint\u003e primes; void init(int n){ isnp[1]=1; for(int i=2;i\u003c=n;i++){ if(!isnp[i]){ primes.push_back(i); } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=n;j++){ isnp[i*primes[j]]=1; if(i%primes[j]==0){ break; } } } } struct Mat{ ll a[MAXN][MAXN]; Mat(){ memset(a,0,sizeof(a)); } Mat operator*(const Mat \u0026other){ Mat res; for(int i=1;i\u003cMAXN;i++){ for(int j=1;j\u003cMAXN;j++){ for(int k=1;k\u003cMAXN;k++){ res.a[i][j]=(res.a[i][j]+a[i][k]*other.a[k][j]%MOD)%MOD; } } } return res; } void debug(){ for(int i=1;i\u003cMAXN;i++){ for(int j=1;j\u003cMAXN;j++){ cout\u003c\u003ca[i][j]\u003c\u003c\" \"; } cout\u003c\u003cendl; } } void normalize(){ for(int i=1;i\u003cMAXN;i++) { a[i][i] = 1; } } }; Mat qpow(Mat a,int b){ Mat res; res.normalize(); for(;b;b\u003e\u003e=1,a=a*a){ if(b\u00261)res=res*a; } return res; } Mat base; int pool[MAXN],nopool[MAXN]; Mat incprime,noprime; int main() { ios::sync_with_stdio(false); int n,m,p;cin\u003e\u003en\u003e\u003em\u003e\u003ep; for(int i=1;i\u003c=m;i++){ pool[i%p]++; nopool[i%p]++; } init(m); for(auto it:primes){ nopool[it%p]--; } // for(auto it:nopool){ // cout\u003c\u003cit\u003c\u003c\" \"; // } // cout\u003c\u003cendl; for(int j=1;j\u003c=p;j++){ for(int i=1;i\u003c=p;i++){ //cout\u003c\u003c((i-1-(j-1))%p+p)%p\u003c\u003cendl; incprime.a[i][j]=pool[((j-1-(i-1))%p+p)%p]; noprime.a[i][j]=nopool[((j-1-(i-1))%p+p)%p]; } } base.a[1][1]=1; incprime=base*qpow(incprime,n); // incprime.debug(); noprime=base*qpow(noprime,n); // noprime.debug(); cout\u003c\u003c((incprime.a[1][1]-noprime.a[1][1])%MOD+MOD)%MOD\u003c\u003cendl; return 0; } ","date":"2020-03-18","objectID":"/2020/03/builds-sequences/:2:0","tags":["快速幂"],"title":"[???] Builds Sequences","uri":"/2020/03/builds-sequences/"},{"categories":["code"],"content":"Wu got hungry after an intense training session, and came to a nearby store to buy his favourite instant noodles. After Wu paid for his purchase, the cashier gave him an interesting task. You are given a bipartite graph with positive integers in all vertices of the right half. For a subset 𝑆 of vertices of the left half we define 𝑁(𝑆) as the set of all vertices of the right half adjacent to at least one vertex in 𝑆, and 𝑓(𝑆) as the sum of all numbers in vertices of 𝑁(𝑆). Find the greatest common divisor of 𝑓(𝑆) for all possible non-empty subsets 𝑆 (assume that GCD of empty set is 0). Wu is too tired after his training to solve this problem. Help him! ","date":"2020-03-08","objectID":"/2020/03/cf-1322c-instant-noodles/:0:0","tags":null,"title":"[CF 1322C] Instant Noodles","uri":"/2020/03/cf-1322c-instant-noodles/"},{"categories":["code"],"content":"分析 这道题的范围有500000之大，所以实在是无法从子集本身入手，只能考虑一下gcd是否存在性质。 假设现在有一个子集$a$，当我们为其加上一个$\\Delta$后，这两个结果都会参与gcd的计算，更相减损后表现为$\\Delta$参与gcd计算。 这个$\\Delta$的增量直接贡献答案的特性可能是重要的一环。比赛时因为时间也好，别的也罢，被卡在这自闭不会了。 接下来确定增量是什么。 是否是单独的一个元素：对于一个右节点$v$，是否存在添加一个左节点后只增加其一个的情况。干脆把全部的左节点全部选中，然后删掉包含$v$的。接下来，观察是否存在一个左节点只增加$v$。这显然会有不存在的情况。 在不存在的情况时，我们有这些结论。假设这个捣乱的节点是$v'$ $v'$由于删除所有包含$v$的节点而被共同删除。 $v'$无法被不包含$v$的其他节点增加，那么能增加$v'$的节点定包含$v$。 此时有两种情况。 所有添加v的节点均包含$v'$。那么二者共进退，表现为捆绑在一起的一个节点。 并不是所有添加v的节点均包含$v'$。那么，我们就能通过添加别的节点率先加上v，从而能够单独添加v’，从而能够单独添加v。 所以，这个增量不是单个元素，而是这么一个东西：邻域相同的元素。 可以做了？……太菜，搞不明白这怎么在比赛期间短期折腾出来。 ","date":"2020-03-08","objectID":"/2020/03/cf-1322c-instant-noodles/:1:0","tags":null,"title":"[CF 1322C] Instant Noodles","uri":"/2020/03/cf-1322c-instant-noodles/"},{"categories":["code"],"content":"Roma is playing a new expansion for his favorite game World of Darkraft. He made a new character and is going for his first grind. Roma has a choice to buy exactly one of 𝑛 different weapons and exactly one of 𝑚 different armor sets. Weapon 𝑖 has attack modifier 𝑎𝑖 and is worth 𝑐𝑎𝑖 coins, and armor set 𝑗 has defense modifier 𝑏𝑗 and is worth 𝑐𝑏𝑗 coins. After choosing his equipment Roma can proceed to defeat some monsters. There are 𝑝 monsters he can try to defeat. Monster 𝑘 has defense 𝑥𝑘, attack 𝑦𝑘 and possesses 𝑧𝑘 coins. Roma can defeat a monster if his weapon’s attack modifier is larger than the monster’s defense, and his armor set’s defense modifier is larger than the monster’s attack. That is, a monster 𝑘 can be defeated with a weapon 𝑖 and an armor set 𝑗 if 𝑎𝑖\u003e𝑥𝑘 and 𝑏𝑗\u003e𝑦𝑘. After defeating the monster, Roma takes all the coins from them. During the grind, Roma can defeat as many monsters as he likes. Monsters do not respawn, thus each monster can be defeated at most one. Thanks to Roma’s excessive donations, we can assume that he has an infinite amount of in-game currency and can afford any of the weapons and armor sets. Still, he wants to maximize the profit of the grind. The profit is defined as the total coins obtained from all defeated monsters minus the cost of his equipment. Note that Roma must purchase a weapon and an armor set even if he can not cover their cost with obtained coins. Help Roma find the maximum profit of the grind. ","date":"2020-03-08","objectID":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/:0:0","tags":null,"title":"[CF 1320C] World of Darkraft: Battle for Azathoth","uri":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/"},{"categories":["code"],"content":"分析 这题代表了一类基本的思路。枚举其中一维，用数据结构维护另一维。 假设我们枚举武器攻击力，首先能够挑出所有被击杀的怪物。当我们的防具为k时，所有攻击力小于k的都可以计算收益。反过来说，对于攻击力为k的怪物，只要我们的防具大于k，就可以计算收益。 所以每枚举一个主角攻击力，我们把怪物按照其攻击力为下标作收益前缀和，就可以获取到当主角防具为k时所能得到的收益。为了计算入防具的花费，预处理每个防具等级k所需要的最少的钱，预先在相应下标扣除。此时还需要一个结构来求去所有前缀和中最大。这些操作都可以用线段树完成。 ","date":"2020-03-08","objectID":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/:1:0","tags":null,"title":"[CF 1320C] World of Darkraft: Battle for Azathoth","uri":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/"},{"categories":["code"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003climits\u003eusing namespace std; using ll=long long; const int MAXN=1000100*4; int idx=0; int lc[MAXN],rc[MAXN]; ll award[MAXN]; int cost[MAXN]; ll flag[MAXN]; int root; int wlen,alen,mlen; struct Weapon { int rnk, cost; bool operator\u003c(const Weapon \u0026b) const { //if (rnk == b.rnk)return cost \u003c b.cost;实际没用 return rnk \u003c b.rnk; } } weapons[MAXN]; struct Armor { int rnk, cost; bool operator\u003c(const Armor \u0026b) const { if (rnk == b.rnk)return cost \u003c b.cost; return rnk \u003c b.rnk; } } armors[MAXN]; void collect(int n){ award[n]=max(award[lc[n]],award[rc[n]]); } void pushdown(int n){ if(flag[n]){ flag[lc[n]]+=flag[n]; flag[rc[n]]+=flag[n]; award[lc[n]]+=flag[n]; award[rc[n]]+=flag[n]; flag[n]=0; } } //枚举武器，维护防具 void build(int \u0026n,int l,int r,int init=-0x3f3f3f3f) { if (!n)n = ++idx; if (l == r) { award[n]=-cost[l]; return; } int mid = (l + r) / 2; build(lc[n], l, mid,init); build(rc[n], mid + 1, r,init); collect(n); } void modify(ll x,int l,int r,int L,int R,int n) { if (l \u003c= L \u0026\u0026 R \u003c= r) { flag[n] += x; award[n] += x; return; } pushdown(n); int mid = (L + R) / 2; if (l \u003c= mid)modify(x, l, r, L, mid, lc[n]); if (mid \u003c r)modify(x, l, r, mid + 1, R, rc[n]); collect(n); } ll query(){ return award[root]; } ll query(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ return award[n]; } pushdown(n); ll res=-numeric_limits\u003cll\u003e::max(); int mid=(L+R)/2; if(l\u003c=mid)res=max(res,query(l,r,L,mid,lc[n])); if(mid\u003cr)res=max(res,query(l,r,mid+1,R,rc[n])); return res; } struct Monster{ int att,de; int cost; } monsters[MAXN]; void debug(int n){ for(int i=1;i\u003c=n;i++){ cout\u003c\u003cquery(i,i,1,n,root)\u003c\u003c\" \"; } cout\u003c\u003cendl; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e wlen \u003e\u003e alen \u003e\u003e mlen; int vallim = 0; for (int i = 0; i \u003c wlen; i++)cin \u003e\u003e weapons[i].rnk \u003e\u003e weapons[i].cost; for(int i=0;i\u003calen;i++)cin\u003e\u003earmors[i].rnk\u003e\u003earmors[i].cost; for(int i=0;i\u003cmlen;i++)cin\u003e\u003emonsters[i].de\u003e\u003emonsters[i].att\u003e\u003emonsters[i].cost; sort(weapons,weapons+wlen); sort(monsters,monsters+mlen,[](auto a,auto b){ return a.de\u003cb.de; }); fill(cost,cost+MAXN,numeric_limits\u003cint\u003e::max()); int maxarm=0; for(int i=0;i\u003calen;i++){ cost[armors[i].rnk]=min(cost[armors[i].rnk],armors[i].cost); maxarm=max(maxarm,armors[i].rnk); } for(int i=maxarm-1;i\u003e=1;i--){ cost[i]=min(cost[i],cost[i+1]); } build(root,1,maxarm); //debug(maxarm); ll ans=-numeric_limits\u003cll\u003e::max(); int ptr=0; for(int i=0;i\u003cwlen;i++){ while(ptr\u003cmlen \u0026\u0026 monsters[ptr].de\u003cweapons[i].rnk){ if(monsters[ptr].att\u003cmaxarm){ modify(monsters[ptr].cost,monsters[ptr].att+1,maxarm,1,maxarm,root); } ptr++; } ans=max(ans,query()-weapons[i].cost); } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-03-08","objectID":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/:2:0","tags":null,"title":"[CF 1320C] World of Darkraft: Battle for Azathoth","uri":"/2020/03/cf-1320c-world-of-darkraft-battle-for-azathoth/"},{"categories":["code"],"content":"没注意到数据范围是100。 You are given a string 𝑠 consisting of lowercase Latin letters. Let the length of 𝑠 be |𝑠|. You may perform several operations on this string. In one operation, you can choose some index 𝑖 and remove the 𝑖-th character of 𝑠 (𝑠𝑖) if at least one of its adjacent characters is the previous letter in the Latin alphabet for 𝑠𝑖. For example, the previous letter for b is a, the previous letter for s is r, the letter a has no previous letters. Note that after each removal the length of the string decreases by one. So, the index 𝑖 should satisfy the condition 1≤𝑖≤|𝑠| during each operation. For the character 𝑠𝑖 adjacent characters are 𝑠𝑖−1 and 𝑠𝑖+1. The first and the last characters of 𝑠 both have only one adjacent character (unless |𝑠|=1). Consider the following example. Let 𝑠= bacabcab. During the first move, you can remove the first character 𝑠1= b because 𝑠2= a. Then the string becomes 𝑠= acabcab. During the second move, you can remove the fifth character 𝑠5= c because 𝑠4= b. Then the string becomes 𝑠= acabab. During the third move, you can remove the sixth character 𝑠6='b’ because 𝑠5= a. Then the string becomes 𝑠= acaba. During the fourth move, the only character you can remove is 𝑠4= b, because 𝑠3= a (or 𝑠5= a). The string becomes 𝑠= acaa and you cannot do anything with it. Your task is to find the maximum possible number of characters you can remove if you choose the sequence of operations optimally. ","date":"2020-03-02","objectID":"/2020/03/cf-1321c-remove-adjacent/:0:0","tags":null,"title":"[CF 1321C] Remove Adjacent 拓展","uri":"/2020/03/cf-1321c-remove-adjacent/"},{"categories":["code"],"content":"分析 换个视角来看消除，当有b时，我们就能保证所有能接触到这个b的c被消除。 所以从大往小了做，枚举每一个字母$s$，然后枚举s的位置去查询它左右是否有能够碰到它的$s+1$。 接下来是如何维护信息。当上一个字母使得上上个字母能够被消除后，就有可能使得原本无法接触到本次字母的上一个字母转而能够接触到该字母。使用并查集来做这种事情，并查集维护连续消除的区间l和r，以及这个区间存在字母（int状压即可）。 ","date":"2020-03-02","objectID":"/2020/03/cf-1321c-remove-adjacent/:1:0","tags":null,"title":"[CF 1321C] Remove Adjacent 拓展","uri":"/2020/03/cf-1321c-remove-adjacent/"},{"categories":["code"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003cmap\u003eusing namespace std; using pii=pair\u003cint,int\u003e; using ll=long long; const int MAXN=1000; struct UT { int fa[MAXN]; int dat[MAXN]; int l[MAXN], r[MAXN]; UT() { for (int i = 0; i \u003c MAXN; i++)fa[i] = i; for (int i = 0; i \u003c MAXN; i++)l[i] = r[i] = i; } int find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); } void con(int u, int v) { int uf = find(u), vf = find(v); dat[vf] |= dat[uf]; l[vf] = min(l[vf], l[uf]); r[vf] = max(r[vf], r[uf]); fa[uf] = vf; } bool isc(int u, int v) { return find(u) == find(v); } }; string inp; vector\u003cint\u003e pos[30]; UT ut; bool vis[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int nlen; cin \u003e\u003e nlen; cin \u003e\u003e inp; inp = \" \" + inp; for (int i = 1; i \u003c= nlen; i++) pos[inp[i] - \u0026#039;a\u0026#039;].push_back(i); for (int i = 1; i \u003c= nlen; i++) ut.dat[i] |= (1 \u003c\u003c (inp[i] - \u0026#039;a\u0026#039;)); for (int i = 25; i \u003e= 0; i--) { for (auto p:pos[i]) { if (p - 1 \u003e= 1) { if ((ut.dat[ut.find(p - 1)] \u0026 (1 \u003c\u003c (i + 1))) || (ut.dat[ut.find(p - 1)] \u0026 (1 \u003c\u003c i))) { ut.con(p - 1, p); } } if (p + 1 \u003c= inp.size()) { if ((ut.dat[ut.find(p + 1)] \u0026 (1 \u003c\u003c (i + 1))) || (ut.dat[ut.find(p + 1)] \u0026 (1 \u003c\u003c i))) { ut.con(p, p + 1); } } } } int ans = 0; for (int i = 1; i \u003c= nlen; i++) { int uf = ut.find(i); if (!vis[uf]) { vis[uf] = 1; int minn = 0; for (int i = 0; i \u003c 26; i++) { if (ut.dat[uf] \u0026 (1 \u003c\u003c i)) { minn = i; break; } } int off = 0; for (int i = ut.l[uf]; i \u003c= ut.r[uf]; i++) { off += (inp[i] == \u0026#039;a\u0026#039; + minn); } ans += max(0, ut.r[uf] - ut.l[uf] + 1 - off); } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-03-02","objectID":"/2020/03/cf-1321c-remove-adjacent/:2:0","tags":null,"title":"[CF 1321C] Remove Adjacent 拓展","uri":"/2020/03/cf-1321c-remove-adjacent/"},{"categories":["code"],"content":"Extra 这场比赛的B题挺好玩的…要求选出的数字满足 $$c_i-c_{i+1}=p_{c_i}-p_{c_{i+1}}$$ …一上来傻了不知道咋做，其实只要把公式左右交换一下就完事了。 ","date":"2020-03-02","objectID":"/2020/03/cf-1321c-remove-adjacent/:3:0","tags":null,"title":"[CF 1321C] Remove Adjacent 拓展","uri":"/2020/03/cf-1321c-remove-adjacent/"},{"categories":["code"],"content":"You are given a permutation 𝑝1,𝑝2,…,𝑝𝑛 (an array where each integer from 1 to 𝑛 appears exactly once). The weight of the 𝑖-th element of this permutation is 𝑎𝑖. At first, you separate your permutation into two non-empty sets — prefix and suffix. More formally, the first set contains elements 𝑝1,𝑝2,…,𝑝𝑘, the second — 𝑝𝑘+1,𝑝𝑘+2,…,𝑝𝑛, where 1≤𝑘\u003c𝑛. After that, you may move elements between sets. The operation you are allowed to do is to choose some element of the first set and move it to the second set, or vice versa (move from the second set to the first). You have to pay 𝑎𝑖 dollars to move the element 𝑝𝑖. Your goal is to make it so that each element of the first set is less than each element of the second set. Note that if one of the sets is empty, this condition is met. For example, if 𝑝=[3,1,2] and 𝑎=[7,1,4], then the optimal strategy is: separate 𝑝 into two parts [3,1] and [2] and then move the 2-element into first set (it costs 4). And if 𝑝=[3,5,1,6,2,4], 𝑎=[9,1,9,9,1,9], then the optimal strategy is: separate 𝑝 into two parts [3,5,1] and [6,2,4], and then move the 2-element into first set (it costs 1), and 5-element into second set (it also costs 1). Calculate the minimum number of dollars you have to spend. ","date":"2020-02-28","objectID":"/2020/02/cf-1295e-permutation-separation/:0:0","tags":null,"title":"[CF 1295E] Permutation Separation","uri":"/2020/02/cf-1295e-permutation-separation/"},{"categories":["code"],"content":"分析 首先要解决的问题是如何断开。枚举排列的某个位置断开，似乎没有什么好办法转移，枚举数值上断开的位置显得更可靠一些。不过断开数值后，仍然没有什么好办法去直接求得从排列的何处断开。 考虑再次枚举排列的断开位置。当确定排列的一个断点后，由于已经知道两个子集所包含的数，可以$O(N)$算出到达目标状态需要的代价，在此以左侧小右侧大为准。当向右移动断点后，注意到左侧原有的需要移动数字仍然需要移动。于是，针对一个子集的分割，能够用通过线段树$O(n\\lg n)$来求出在排列任何一个位置断开的代价。 接下来考虑数值上的断点移动后是否能够维护代价变化。当一个新的数字$a$被从大集合划归到小集合后，在排列中，以该数字$a$位置，左侧所有的断点都需要付出额外的代价将该数挪到左侧，而右侧所有的断点都不再需要支付代价来将该数挪到右侧。于是，这个代价也是可以维护的。 ","date":"2020-02-28","objectID":"/2020/02/cf-1295e-permutation-separation/:1:0","tags":null,"title":"[CF 1295E] Permutation Separation","uri":"/2020/02/cf-1295e-permutation-separation/"},{"categories":["code"],"content":"代码 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003climits\u003eusing namespace std; using ll=long long; const int MAXN=200010; int lc[MAXN*4],rc[MAXN*4]; ll flag[MAXN*4],dmin[MAXN*4]; int idx=0; void build(int \u0026n,int l,int r){ if(!n)n=++idx; if(l==r){ flag[n]=dmin[n]=0; return; } int mid=(l+r)/2; build(lc[n],l,mid); build(rc[n],mid+1,r); } void pushdown(int n){ if(!flag[n])return; flag[lc[n]]+=flag[n]; flag[rc[n]]+=flag[n]; dmin[lc[n]]+=flag[n]; dmin[rc[n]]+=flag[n]; flag[n]=0; } void collect(int n){ dmin[n]=min(dmin[lc[n]],dmin[rc[n]]); } void modify(ll x,int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ flag[n]+=x; dmin[n]+=x; return; } pushdown(n); int mid=(L+R)/2; if(l\u003c=mid)modify(x,l,r,L,mid,lc[n]); if(mid\u003cr)modify(x,l,r,mid+1,R,rc[n]); collect(n); } ll query(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ return dmin[n]; } pushdown(n); int mid=(L+R)/2; ll res=numeric_limits\u003cll\u003e::max(); if(l\u003c=mid)res=min(res,query(l,r,L,mid,lc[n])); if(mid\u003cr)res=min(res,query(l,r,mid+1,R,rc[n])); return res; } int root=0; int permu[MAXN]; ll wage[MAXN]; int pos[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int nlen;cin\u003e\u003enlen; for(int i=1;i\u003c=nlen;i++)cin\u003e\u003epermu[i]; for(int i=1;i\u003c=nlen;i++)pos[permu[i]]=i; for(int i=1;i\u003c=nlen;i++)cin\u003e\u003ewage[i]; int ptr=0; if(nlen==1){ cout\u003c\u003c0\u003c\u003cendl; return 0; } //init //以第i位切割，前i个为一个集合 build(root,1,nlen); for(int i=1;i\u003c=nlen-1;i++){ modify(wage[i],i,nlen-1,1,nlen,root); } ll ans=numeric_limits\u003cll\u003e::max(); while(ptr\u003c=nlen){ ans=min(ans,query(1,nlen-1,1,nlen,root)); ptr++; if(pos[ptr]-1\u003e=1) modify(wage[pos[ptr]],1,pos[ptr]-1,1,nlen,root); if(pos[ptr]\u003c=nlen-1) modify(-wage[pos[ptr]],pos[ptr],nlen-1,1,nlen,root); } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-02-28","objectID":"/2020/02/cf-1295e-permutation-separation/:2:0","tags":null,"title":"[CF 1295E] Permutation Separation","uri":"/2020/02/cf-1295e-permutation-separation/"},{"categories":["学习"],"content":"说实话,这一套东西东拼西凑到处取经,不过有些还挺香的. 目前对于14,17的特性,GCC和Clang都完成了很好的适配.在C++20上,下面提到的特性都在最新的版本里完成了绝大多数. 标准定得爽,到了实现就凉凉. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:0:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"auto 这个关键字…是真的…相信不久之后c++只需要下面一个参数. auto auto(auto...){ return auto; } 这个东西,就是把变量类型交给编译器来考虑.这个特性实际上早该有了,因为c++编译器原本就会检查右值和左值的类型是否匹配,那么顺便填一个左值的类型也不会累着它. 这个也挺常用的.for(auto it=vec.begin();...这种写法省了很大工夫. 和它配合很好的是新引入的语法糖for(auto item:var),写起来很爽.这玩意也支持引用.另外一个值得注意的是在C++17后,由模式绑定加成,这玩意能进一步写成for(const auto\u0026 [key,value] : map). 还有一个东西是auto用在函数签名的返回值时需要尾随返回值类型. auto f() -\u003e ???{ } 在C++14里不需要再尾随返回值类型了.不过另外还有一种写法decltype(auto),这两个的区别在于后者能够保留引用的类型信息.这个尾随返回值的用处就剩下在lambda表达式里用了.不过,尝试在签名里原本的返回类型位置写auto,转而把真实的返回类型尾随,这种写法越发像现代语言了. fn f()-\u003e i32 {} ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:1:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"Lambda 表达式 好用的东西. sort(vec.begin(),vec.end(),[](const Student \u0026a,const Student \u0026b){ return a.age\u003cb.age; }) 再也不需要cmp_1,cmp_2了. lambda表达式作为一个闭包,需要考虑其对于环境变量的捕捉类型. 按值捕获 按引用捕获 就如它们字面上的意思.实际实现时,将其写在[]内.例如[=],[\u0026],[foo,\u0026bar].一个要注意的问题是,按值捕获时,捕获的变量均为const,不能修改,后缀[]()mutable{}后可以修改,不过这种修改不会影响环境变量. 在C++14中可以借助auto实现lambda多态. auto func=[](auto a){return a+a;}; 然后这个func可以直接传很多参数. 另一个是在捕获时进行环境变量初始化,例如[x=0].不过这玩意是否有额外的考虑…大概能去看看RFC? 在C++20中,lambda可以携带模板[]\u003ctypename T\u003e(){}. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:2:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"using 以前,我们定义ll有这么两派. #define ll long long typedef long long ll; 现在,新的一派加入了战场. using ll=long long; 这几种办法如果非要分出个高低,那大概要从下面几个方面说 define是一种替换.它相对于另外两种来说,有些过于强大和随性,可能会带来问题. typedef是C风格的. using是C++风格的.另外using在内部的实现是基于模板的.这一点是否会带来好处我还没弄明白. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:3:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"nullptr 赋值给空指针的新值,用来取代NULL.这个关键字对于工程的用处更高.它用于处理和重载,泛型编程有关的问题. 一个空指针在C风格中定义为宏NULL,这个东西,它是0的别名.那么,一个泛型函数到底该把它看作int还是指针?这也是不推荐用define定义新类型的一个理由.说不定什么时候就踩进坑. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:4:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"decltype 对类型的运算,用于在编译时获取某个值的类型.算是个和auto配套的东西.因为auto了,你也不知道它到底是个什么,此时就可以 auto a=/*something weired*/; decltype(a) b=a; 怎么说呢…有了一种动态语言的调调. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:5:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"用以上这些东西,就能写出这种代码. //当然这段代码是没啥意义的,只是用一下新的特性 template \u003ctypename T\u003e auto func(string type)-\u003efunction\u003cT(T,T)\u003e{ if(type==\"add\"){ return [](auto x,auto y){ return x+y; }; }else{ return [](auto x,auto y){ return x-y; }; } } //可变参数 template \u003ctypename... T\u003e decltype(auto) reduce(auto f,const T... args){ const auto vec={args...}; auto res=*vec.begin(); for(auto ne=vec.begin()+1;ne!=vec.end();ne++){ res=f(res,*ne); } return res; } int main() { cout\u003c\u003creduce(func\u003cint\u003e(\"add\"),1,2,3)\u003c\u003cendl; return 0; } ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:6:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"constexpr 好了,现在对于 const int MAXN=10; int a[MAXN]; 我们有了新的写法. constexpr int MAXN=10; int a[MAXN]; 实际上,下面的写法才是对的.上面的写法按照标准应该是无法通过编译的,只不过它太常用,编译器知道你想干嘛,所以默默完成了操作,没有人抱怨,可喜可贺. constexpr用于在编译阶段进行求值.也可以用在函数.以往有些人在模板上玩花,在编译阶段就让编译器率先完成类似于打表之类的操作,以至于评测器陆续全部完善了编译时限制时间.现在再想玩这些操作,可以直接使用constexpr了.不过可惜的是它还C++11里比较菜,不能完成复杂运算.直到在C++14里,constexpr能够支持if甚至递归了. 在C++14里,constexpr能够和template配合实现对不同类型常量的初始化.这一点基本上就把#define PI 3.1415926535897932385打爆.推荐使用#define定义PI的原因就在于它的替换行为能够免去在常量定义过程中被类型精度影响. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:7:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"右值引用 这玩意的存在意义主要是消除不必要拷贝，并给泛型编程带来便利。 一般来讲，当我们执行如下的代码 Student student; student = Student(\u0026#039;Tiansuo Li\u0026#039;,24); 第二行的赋值过程中发生了内存的复制和销毁。对……这个学生的信息并没有直接给student。 据说现代编译器能够针对这种情况进行优化了。 右值有这么一个特性，只能被使用一次。这是非常重要的一个特性，例如字符串、常量，这些东西除了在作为右值赋值给左值的一瞬间，其他时候再无用处。那么在这种情况下，仍然对此类右值执行复制就显得很累赘。右值引用就是用于解决此类问题的。 右值引用使用\u0026\u0026标注。 为Student实现以下右值引用语义 Student\u0026 operator=(Student \u0026\u0026stu){ if(this !=\u0026str){ name=stu.name; age=stu.age; stu.name=\"\"; stu.age=0; } return *this; } 当然复制一个名字什么的还没有这么大区别。 std::move这个关键字和上面的右值引用有点关系。它指明对象的赋值带有资源的转移，也就是强制进行右值引用和资源移动（比如上例中学生名字的移动）。 这种感觉是不是和rust有点相似？不过很可惜这不是一种东西。至少它在最初设计上不是。但是当和一些智能指针例如unique_ptr一同使用时，确实达到了一种所有权移动的感觉。 大家想的都是差不多的嘛。 另外std::forward也是基于引用给出的工具。用来把数据按原样返回。左值引用归左值引用，右值的归右值。 ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:8:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"智能指针 这个对我来说不是很常用. std::unique_ptr是无法复制但是可以移动的智能指针,刚才已经说了. std::shared_ptr是可以在不同代码或者线程间共享的指针,是和上面的相对而言的.不过它不保证其内部保管的对象也可以线程安全…这让我想起来rust的Arc\u003cMutex\u003c...\u003e\u003e. 与shared_ptr配套使用的还有make_shared. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:9:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"内存模型 说实话,这个大概才是重点,不过对我来说不常用. 这意味着c++标准库将提供无关平台的一系列线程操作,包括线程,锁,原子操作,异步等. std::thread 来自标准库的线程 std::async c++也从c#那里搬来了async和await那套异步编程模型 ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:10:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"可变参数 也不常用… 想知道在没有可变参数的时候,printf是怎么实现的吗?那个模板嵌套是真的恐怖.直到今天C++也有可变参数了.其语法上是... 这玩意是用在模板里的 template \u003ctypename... T\u003e void printf(const char *pattern, const T... args){ //bula bula } 既然有了可变参数,就能有元组.与其同时而来的还有std::tie,用于解构元组. tie(name, age)=make_tuple(\"Tiansuo Li\",24); C++17里,这种解构被进一步提升为结构绑定. const auto [x, y]=make_tuple(\"Tiansuo Li\",24); ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:11:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"和面向对象有关的 目前又是不常用的东西. 显式方法重载.这个是面向对象里的概念.具体就是在重写虚函数时在函数签名最后注明override,编译器就会根据实际情况给出更多的提示和帮助. final封闭方法.这个也是面向对象概念.用于将一个虚函数封闭,不再让子类重写. =default默认方法.这个仍然是面向对象概念.显式的写明使用默认实现. =delete删除方法….还是.显式的注明从类中删除某个方法(例如默认方法),防止他人调用. 允许非静态成员变量自行初始化. 方法重载能够注明左右值的区分. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:12:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"array 不可变长的数组,需要在声明时就给出大小.这玩意很常用所以也搞出来. 与此相关的信息是vector的空间占用,这个东西的行为有如下两个特点 当需要新空间时,将重新申请原来两倍的空间. 将数据复制到新空间. 如果确定数据的大小,array显然是个更好的选择. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:13:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"std::optional 天 下 大 同. 这玩意和rust的Option是一个东西.你家C++也要变成unwrap,unwrap,unwrap,unwrap,unwrap了. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:14:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"Concepts 天 下 大 同 x 2. 这玩意用于限定模板中的类型.类似于rust内的+描述. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:15:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"其他信息 std::chrono 来自标准库的时间计算 unordered_xxx 基于哈希的无序容器,这个已经很常用了吧 std::begin/end …这个算是填坑?虽然各个容器都提供了类似的API,不过在泛型编程时,还是需要一个这种东西. 允许模板嵌套时右侧尖括号紧靠.这个其实很好.以及也要注意这个特性是在C++11里修订的. noexcept 放在函数签名里表示不抛异常 attribute 用[[]]来标注属性(注解),有点像rust的#[[]]一类的东西.在C++20里,有一个比较有趣的注解likely可以向编译器建议分支的预测结果,这个和CSAPP课程相关性很强. 二进制表示,在C++14中,这没啥可说的,0b010101. 带初始化的if.在C++17中,能够用类似于golang中的带初始化if了. 带初始化的rangefor.在C++20中,for(:)的玩意能够自带初始化语句了. utf-8支持.在C++17中,字符前缀u8能够获得utf-8的字符了.在C++20中,存在char8_t用于支持字符串. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:16:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"可能关注的其他东西 popcount.C++20提供的函数,可以数二进制数中1的个数.另外还有一些操作,位于\u003cbit\u003e中. 数学常数.例如std::numbers::pi.不过这个倒无所谓…应该都知道acos(-1). ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:17:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["学习"],"content":"C++走在现代化的路上 先提一个问题.GCC和Clang二者最新版本的编译器的安装可能会给你带来麻烦,尤其是Windows用户.MinGW,MinGW-w64,TDM-GCC都没有更新到最新版本.如果希望使用20标准,似乎最简单的办法是安装msys2. 其实在翻看完这些新标准后,我越发觉得我原来学的C++和现在的C++是不同的语言.你可以把C++当C来写,也可以停在11之前的标准来写,也可以大踏步来到20.三种风格写出来的代码完全不是一个东西. 另外,我一直没有注意智能指针,右值引用和移动概念,在了解Rust之后才意识到它们的重要性.除了没有Rust与生俱来的生命周期以及所有权的静态检查,C++把其他该有的似乎全有了.倒不如说Rust也从C++这里借鉴了大量东西,比如智能指针. 说实话,在此时我有点更倾向于使用C++了. C++的编译器也能在移动语义上进行较为宽松的静态检查,such as 已经move的变量再次使用会被warning. ","date":"2020-02-23","objectID":"/2020/02/new-standard-of-cpp/:18:0","tags":null,"title":"C++新标准特性初探","uri":"/2020/02/new-standard-of-cpp/"},{"categories":["闲扯"],"content":"本来这不是我现在该想的东西，被迫因为建模比赛看了一点。所学东西太过杂乱。 ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:0:0","tags":null,"title":"使用Python分析数据","uri":"/2020/02/python-in-data-processing/"},{"categories":["闲扯"],"content":"为什么不用Matlab、Mathematica 因为Mathematica被我卸了，Matlab没学过，也不喜欢。这只是一个排除法，我不知道该怎么从优势上比较。 R语言没学过，Julia也没有，所以回归工具齐全的Python。 ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:1:0","tags":null,"title":"使用Python分析数据","uri":"/2020/02/python-in-data-processing/"},{"categories":["闲扯"],"content":"Python 数据分析套装 建议目标就是分析数据的人直接安装anaconda，使用jupyter lab，不折腾。 对于数据读入和清洗：Pandas 对于矩阵等向量运算：numpy 对于计算机代数计算：sympy ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:2:0","tags":null,"title":"使用Python分析数据","uri":"/2020/02/python-in-data-processing/"},{"categories":["闲扯"],"content":"绘图 绘图的库就很多了。Matplotlib，Plotly，Seaborn，Altair这几个还不错。第一个比较底层，是直接参照Matlab的API设计的，Seaborn是在其基础上设计的更高层的绘图包,所以使用、配色、排版什么的都不错。Plotly和Altair都是具有一定交互能力的绘图包，在lab里是需要前端js配合绘图的（所以一旦图片数据太多，会卡得浏览器痛不欲生）。 我就胡乱选了个Plotly。不过现在看来大概是个错误的决定。 ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:2:1","tags":null,"title":"使用Python分析数据","uri":"/2020/02/python-in-data-processing/"},{"categories":["闲扯"],"content":"Plotly在国内配置的坑 看着npm和yarn这两个字眼就害怕现在。js那一堆乱七八糟的工具链，支持度各不相同的标准，这里可以import，那里又会ce必须用require，又let又var，到现在也整不清楚的this和that，有的包要求传正确的lambda表达式，有的又必须用function，还有一堆坑……看着就想躲着走，然而这plotly的构建是需要npm和yarn的。 ……为什么这破语言能用到现在。 在安装Plotly向Jupyter lab的支持库时，切勿在npm和yarn中使用镜像。镜像和源之间有一定的更新延迟并且存在同步错误而跳过某些包的问题。我就正好卡在了被跳过的包上，因为这个问题死活编译不过去浪费了很长时间。 其次，使用Plotly输出.pdf等格式的图片文件时，需要安装ocra，在服务器上配置时还需要安装xvfb，这些都在其文档中有写，不过视系统不同仍然需要自己补齐很多支持库。从这个角度上来说，似乎还是选择Seaborn+Matplotlab比较好，除非你有工具人，否则不要把时间浪费在莫名其妙的地方。 ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:2:2","tags":null,"title":"使用Python分析数据","uri":"/2020/02/python-in-data-processing/"},{"categories":["闲扯"],"content":"基本操作 numpy和pandas都有快速入门教程，花20分钟读一读，然后剩下的随用随查就好了。 这里记几个常用但是不太好找的东西。 ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:3:0","tags":null,"title":"使用Python分析数据","uri":"/2020/02/python-in-data-processing/"},{"categories":["闲扯"],"content":"如何遍历数据帧的所有行 标准操作是apply df[\u0026#039;pass\u0026#039;]=df.apply(lambda a:a[\u0026#039;grade\u0026#039;]\u003e=60,axis=1) 但是，这玩意的坑在于传给它的函数内部是只能get不能set的。即使set也没有作用。不过一般修改单列数据也没有问题，可以像上面一行一样。 另外时刻记住，筛选的数据帧结果也是不能set的。虽然不知道为什么，但是我在踩这个坑的时候，有些时候不但不会修改而且连错误也不会报。 不过如果是修改多行数据呢，上面的命令是不能简单推广的。当然可以用一些很丑陋的做法，比如for i in range(df.shape[0])（可能有稍微好看一点的写法）然后iloc一个个的改掉。不过实际上，仍然有使用apply的余地。 def fn(row): return math.sqrt(row[\u0026#039;计算机导♂论\u0026#039;])*10,math.sqrt(row[\u0026#039;高等♂数学\u0026#039;])*10 df[\u0026#039;计算机导♂论\u0026#039;],df[\u0026#039;高等♂数学\u0026#039;]=zip(*df.apply(fn,axis=1)) 开方乘十，标准的捞人方法要不要了解一下。 这种方案可读性较差，不过实测是快于手动遍历的。听说python不想让人管复杂度，事实却不大行啊。 ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:3:1","tags":null,"title":"使用Python分析数据","uri":"/2020/02/python-in-data-processing/"},{"categories":["闲扯"],"content":"Plotly的整体设计 Plotly的官方文档写得很好，看完概览后费点功夫就能找到自己想要的图的画法。再想自定义就去翻API。 总体来看，graph_object（好像是这么拼？）是最基础的绘图对象，设置好图例后加入到Figure里，就可以作为最终结果输出。express是一个更高层的工厂，能够满足一般情况常用的图的快速绘制。所以，先去express，满足不了再往下找。 如果看完概览了之后还能发现一个很重要的信息。设置图例属性时可能会遇到嵌套多层对象的那种参数，这时候可以直接使用_连接参数名，不需要一层层构造。 知道这些之后随便画就是了。 ","date":"2020-02-22","objectID":"/2020/02/python-in-data-processing/:3:2","tags":null,"title":"使用Python分析数据","uri":"/2020/02/python-in-data-processing/"},{"categories":["闲扯"],"content":"[music autoplay=\"0”]40915181[/music] 上面这个改编的交响乐还不错，顺便测试一下音乐盒 这个主题还可以，有一些比较比较有趣的东西。 其实是连系统都换了……不想折腾了，还是这样算了。 ","date":"2020-02-21","objectID":"/2020/02/change-theme/:0:0","tags":null,"title":"换个主题","uri":"/2020/02/change-theme/"},{"categories":["闲扯"],"content":"修改的地方 在head部分添加了浏览统计。 在pjax调用的jquery封装插件处添加了mathjax的重新渲染。 进一步启用了cdn严格模式的SSL/TLS。 关闭了主题自带的代码高亮，启用了Prism高亮，并且配置在pjax的重新渲染。(修改设计pjax.js和主题自身js,共两处;另外css内样式未去除) 修改了归档页面的部分语句……还有404页面的部分语句……（希望没有漏网的 如果你看到浏览器仍然提示不安全，是因为网站内仍然有一些图片使用了http，什么时候闲得没事再来修。另外图片加载这么慢我也没什么办法，毕竟世界上的互联网分为两部分。 服务器对中文url的支持貌似也有些问题。 ","date":"2020-02-21","objectID":"/2020/02/change-theme/:1:0","tags":null,"title":"换个主题","uri":"/2020/02/change-theme/"},{"categories":["闲扯"],"content":"假期将过 假期就这么没了。头秃。 ","date":"2020-02-21","objectID":"/2020/02/change-theme/:2:0","tags":null,"title":"换个主题","uri":"/2020/02/change-theme/"},{"categories":["学习"],"content":"树链剖分可以用来维护树上路径的信息。把树上的节点拆成不超过$O(\\log n)$段连续的路径（链），以映射到线段树或者什么的构来维护数据。 依照子树的大小，将最大子树作为重边，其他子树作为轻边，从而在树上拆分出多条链。为同一条链上的节点连续编号，完成剖分。至于剩下的，依照编号一条链可以连续的映射到数据结构的某个取间内，用类似于倍增LCA的方法在树上得到每一个询问所覆盖的链的起始与结尾然后继续其他操作就可以了。 ","date":"2020-02-18","objectID":"/2020/02/heavy-light-decomposition/:0:0","tags":null,"title":"树链剖分","uri":"/2020/02/heavy-light-decomposition/"},{"categories":["学习"],"content":"通常策略 对于子树的大小统计，dfs即可。 之后节点编号使用先序的dfs序，并且优先进入重边，以保证链上节点的编号连续。 为了在链上快速跳转，还需要记录每个节点所在链的头。 具体的代码可以看下面两个题目。其实我也是从别处抄了板子 ","date":"2020-02-18","objectID":"/2020/02/heavy-light-decomposition/:1:0","tags":null,"title":"树链剖分","uri":"/2020/02/heavy-light-decomposition/"},{"categories":["学习"],"content":"HDU 3966 Aragorn’s Story 题目要求区间修改某条路径上所有节点的权值，查询某个点的权值。 就剖，剖完线段树还是树状数组区间修改单点查询。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccmath\u003e#include \u003cmap\u003e#include \u003cqueue\u003e#include \u003ccstring\u003e#include \u003ccstdio\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXN=50010; vector\u003cint\u003e g[MAXN]; int vlen,elen,qlen; int tick=0; int fa[MAXN],sz[MAXN],dep[MAXN]; int son[MAXN],top[MAXN]; int dfn[MAXN],rnk[MAXN]; void dfs1(int u,int f){ fa[u]=f; dep[u]=dep[f]+1; sz[u]=1; son[u]=0; for(auto v:g[u]){ if(v==f)continue; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]\u003esz[son[u]]){ son[u]=v; } } } void dfs2(int u,int f){ top[u]=f; dfn[u]=++tick; rnk[tick]=u; if(son[u]==0)return; dfs2(son[u],f); for(auto v:g[u]){ if(v!=son[u] \u0026\u0026 v!=fa[u])dfs2(v,v); } } const int FTN=4*(MAXN+10); int ft[FTN]; int lowbit(int x){ return x\u0026-x; } void ftadd(int pos,int x){ if(pos\u003c=0)return; for(;pos\u003cFTN;pos+=lowbit(pos))ft[pos]+=x; } int ftget(int pos){ if(pos\u003c=0)return 0; int res=0; for(;pos;pos-=lowbit(pos))res+=ft[pos]; return res; } int query(int pos){ return ftget(dfn[pos]); } void modify(int l,int r,int x){ ftadd(l,x); ftadd(r+1,-x); } void solve(int x,int y,int delta){ int fx=top[x],fy=top[y]; while(fx!=fy){ if(dep[fx]\u003edep[fy])modify(dfn[fx],dfn[x],delta),x=fa[fx]; else modify(dfn[fy],dfn[y],delta),y=fa[fy]; fx=top[x]; fy=top[y]; } if(x!=y){ if(dfn[x]\u003cdfn[y])modify(dfn[x],dfn[y],delta); else modify(dfn[y],dfn[x],delta); }else modify(dfn[x],dfn[y],delta); } int num[MAXN]; int main(){ while(~scanf(\"%d%d%d\",\u0026vlen,\u0026elen,\u0026qlen)){ for(int i=0;i\u003c=vlen;i++)g[i].clear(); memset(ft,0,sizeof(ft)); memset(fa,0,sizeof(fa)); memset(sz,0,sizeof(sz)); memset(dep,0,sizeof(dep)); memset(son,0,sizeof(son)); memset(top,0,sizeof(top)); memset(dfn,0,sizeof(dfn)); memset(rnk,0,sizeof(rnk)); tick=0; for(int i=1;i\u003c=vlen;i++){ scanf(\"%d\",num+i); } for(int i=0;i\u003celen;i++){ int u,v; scanf(\"%d%d\",\u0026u,\u0026v); g[u].push_back(v); g[v].push_back(u); } dfs1(1,0); dfs2(1,1); /* for(int i=1;i\u003c=vlen;i++) cout\u003c\u003cdfn[i]\u003c\u003c\" \"; cout\u003c\u003cendl; */ for(int i=1;i\u003c=vlen;i++){ modify(dfn[i],dfn[i],num[i]); } /* for(int i=1;i\u003c=vlen;i++){ cout\u003c\u003cquery(i)\u003c\u003c\" \"; } cout\u003c\u003cendl; */ while(qlen--){ char opt[10]; scanf(\"%s\",opt); if(opt[0]=='I' || opt[0]=='D'){ int l,r,x; scanf(\"%d%d%d\",\u0026l,\u0026r,\u0026x); if(opt[0]=='D')x=-x; solve(l,r,x); }else{ int u; scanf(\"%d\",\u0026u); printf(\"%d\\n\",query(u)); } } } return 0; } ","date":"2020-02-18","objectID":"/2020/02/heavy-light-decomposition/:2:0","tags":null,"title":"树链剖分","uri":"/2020/02/heavy-light-decomposition/"},{"categories":["学习"],"content":"CF343D Water Tree 稍微有点不一样。修改1要求为点的整个子树打标记，修改2要求取消节点到根节点上的标记。 按照dfs序的编号方式，为每一个节点记录进入时间和离开时间，就能得到该节点子树映射后的连续区间。那么浇水就可以套一个线段树直接改了。清空水往根节点跳然后修改一路上经过的链。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccmath\u003e#include \u003cmap\u003e#include \u003cqueue\u003e#include \u003ccstring\u003e#include \u003ccstdio\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXN=500010; vector\u003cint\u003e g[MAXN]; int vlen,elen,qlen; int tick=0; int fa[MAXN],sz[MAXN],dep[MAXN]; int son[MAXN],top[MAXN]; int dfn[MAXN],outdfn[MAXN]; void dfs1(int u,int f){ fa[u]=f; dep[u]=dep[f]+1; sz[u]=1; son[u]=0; for(auto v:g[u]){ if(v==f)continue; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]\u003esz[son[u]]){ son[u]=v; } } } void dfs2(int u,int f){ top[u]=f; dfn[u]=++tick; if(son[u]==0){ outdfn[u]=++tick; return; } dfs2(son[u],f); for(auto v:g[u]){ if(v!=son[u] \u0026\u0026 v!=fa[u])dfs2(v,v); } outdfn[u]=++tick; } const int FTN=5*(MAXN*2+10); int dat[FTN]; int lc[FTN],rc[FTN]; int idx=0; int root=0; void build(int \u0026n,int l,int r){ if(!n)n=++idx; if(l\u003e=r){ dat[n]=2; return; } int mid=(l+r)/2; build(lc[n],l,mid); build(rc[n],mid+1,r); } void pushdown(int n){ if(dat[n]==0)return; dat[lc[n]]=dat[n]; dat[rc[n]]=dat[n]; dat[n]=0; } void fill_water(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ dat[n]=1; return; } pushdown(n); int mid=(L+R)/2; if(l\u003c=mid)fill_water(l,r,L,mid,lc[n]); if(mid\u003cr)fill_water(l,r,mid+1,R,rc[n]); } void f**k_water(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ dat[n]=2; return; } pushdown(n); int mid=(L+R)/2; if(l\u003c=mid)f**k_water(l,r,L,mid,lc[n]); if(mid\u003cr)f**k_water(l,r,mid+1,R,rc[n]); } void F**K_WATER(int u){ while(u!=0){ //cout\u003c\u003c\"clear \"\u003c\u003cdfn[u]\u003c\u003cendl; f**k_water(dfn[top[u]],dfn[u],1,tick,root); u=fa[top[u]]; } } int query(int pos,int L,int R,int n){ //1有水 if(L==pos \u0026\u0026 R==pos)return dat[n]==1; pushdown(n); int mid=(L+R)/2; if(pos\u003c=mid)return query(pos,L,mid,lc[n]); else return query(pos,mid+1,R,rc[n]); } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003evlen; elen=vlen-1; for(int i=1;i\u003c=elen;i++){ int u,v;cin\u003e\u003eu\u003e\u003ev; g[u].push_back(v); g[v].push_back(u); } dfs1(1,0); dfs2(1,1); build(root,1,tick); /* for(int i=1;i\u003c=vlen;i++){ cout\u003c\u003cdfn[i]\u003c\u003c\" \"; } cout\u003c\u003cendl; for(int i=1;i\u003c=vlen;i++){ cout\u003c\u003coutdfn[i]\u003c\u003c\" \"; } cout\u003c\u003cendl; */ int qlen;cin\u003e\u003eqlen; while(qlen--){ int opt,u;cin\u003e\u003eopt\u003e\u003eu; if(opt==1){ fill_water(dfn[u],outdfn[u]-1,1,tick,root); //cout\u003c\u003c\"add \"\u003c\u003cdfn[u]\u003c\u003c\"-\"\u003c\u003coutdfn[u]\u003c\u003cendl; }else if(opt==2){ F**K_WATER(u); }else{ cout\u003c\u003cquery(dfn[u],1,tick,root)\u003c\u003c\"\\n\"; } } return 0; } ","date":"2020-02-18","objectID":"/2020/02/heavy-light-decomposition/:3:0","tags":null,"title":"树链剖分","uri":"/2020/02/heavy-light-decomposition/"},{"categories":["code"],"content":"Ivan plays a computer game that contains some microtransactions to make characters look cooler. Since Ivan wants his character to be really cool, he wants to use some of these microtransactions — and he won’t start playing until he gets all of them. Each day (during the morning) Ivan earns exactly one burle. There are n types of microtransactions in the game. Each microtransaction costs 2 burles usually and 1 burle if it is on sale. Ivan has to order exactly ki microtransactions of the i-th type (he orders microtransactions during the evening). Ivan can order any (possibly zero) number of microtransactions of any types during any day (of course, if he has enough money to do it). If the microtransaction he wants to order is on sale then he can buy it for 1 burle and otherwise he can buy it for 2 burles. There are also m special offers in the game shop. The j-th offer (dj,tj) means that microtransactions of the tj-th type are on sale during the dj-th day. Ivan wants to order all microtransactions as soon as possible. Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing. ","date":"2020-01-21","objectID":"/2020/01/cf-1165f2microtransactions/:0:0","tags":null,"title":"[CF 1165F2]Microtransactions","uri":"/2020/01/cf-1165f2microtransactions/"},{"categories":["code"],"content":"分析 首先，不关注到底买了哪个商品，因为每种商品的价格都一样，记$i$种商品需要$k_i$，全体商品总数$K$。 首先，如果没有任何优惠，需要$2K$天。在有优惠时，我们需要尽可能在优惠当天买齐需要的商品。我们放开的天数越多，钱越多，同时也越有可能遇到优惠（花的钱减少）。以此，题目具有单调性。 二分时间$t$。得出哪种商品有优惠，并从$2K$元内抵消优惠部分。尽量将买商品的决策拖到该商品最后一次优惠进行，若商品有优惠，买比不买好，我们要尽可能将手中积攒的钱扔出去。唯一的问题是越靠后的商品我们能够用之后的钱去买，但是更靠前的优惠可能会因为买了前述那种商品而没有更多钱购买。因此将每种商品购买时机拖得越晚越好，这样我们顶多会遇到没钱买下一个优惠的问题，不过二者贡献一样，这对最终答案没有影响。因为这玩意wa了一发.. ","date":"2020-01-21","objectID":"/2020/01/cf-1165f2microtransactions/:1:0","tags":null,"title":"[CF 1165F2]Microtransactions","uri":"/2020/01/cf-1165f2microtransactions/"},{"categories":["code"],"content":"代码 #include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003e#include \u003cstack\u003e#include \u003cmap\u003e#include \u003cset\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXN=400010; // 商品数目 打折次数 int n,m; ll wanted[MAXN]; ll bwanted[MAXN]; vector\u003cint\u003e offs[MAXN]; int goodoff[MAXN];//第i种商品最后的打折时机 int maxday=0; ll summ=0; bool check(ll day){ memset(goodoff,0,sizeof(goodoff)); memcpy(wanted,bwanted,sizeof(wanted)); for(int i=1;i\u003c=min((ll)maxday,day);i++){ for(auto t:offs[i]){ goodoff[t]=i; } } /* cout\u003c\u003c\"end at \"\u003c\u003cday\u003c\u003cendl; for(int i=1;i\u003c=n;i++){ cout\u003c\u003cgoodoff[i]\u003c\u003c\" \"; } cout\u003c\u003cendl; */ ll cost=summ*2; ll free=0; for(int i=1;i\u003c=min((ll)maxday,day);i++){ free++; for(auto t:offs[i]){ if(goodoff[t]!=i)continue; if(free\u003ewanted[t]){ free-=wanted[t]; cost-=wanted[t]; wanted[t]=0; }else{ wanted[t]-=free; cost-=free; free=0; } } } return cost\u003c=day; } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ewanted[i]; summ+=wanted[i]; } memcpy(bwanted,wanted,sizeof(bwanted)); for(int i=1;i\u003c=m;i++){ int d,t;cin\u003e\u003ed\u003e\u003et; maxday=max(maxday,d); offs[d].push_back(t); } ll l=0,r=5e5; while(r-l\u003e1){ ll mid=(l+r)/2; if(check(mid)){ r=mid; }else l=mid; } cout\u003c\u003cr\u003c\u003cendl; return 0; } ","date":"2020-01-21","objectID":"/2020/01/cf-1165f2microtransactions/:2:0","tags":null,"title":"[CF 1165F2]Microtransactions","uri":"/2020/01/cf-1165f2microtransactions/"},{"categories":["code"],"content":"You have a bag which contains n cards. There is a number written on each card; the number on i-th card is ai. You are playing the following game. During each turn, you choose and remove a random card from the bag (all cards that are still left inside the bag are chosen equiprobably). Nothing else happens during the first turn — but during the next turns, after removing a card (let the number on it be x), you compare it with the card that was removed during the previous turn (let the number on it be y). Possible outcomes are: if x \u003c y, the game ends and you lose; if x = y, the game ends and you win; if x \u003e y, the game continues. If there are no cards left in the bag, you lose. Cards are not returned into the bag after you remove them. You have to calculate the probability of winning in this game. It can be shown that it is in the form of PQ where P and Q are non-negative integers and Q≠0, P≤Q. Output the value of P⋅Q−1 (mod 998244353). ","date":"2020-01-21","objectID":"/2020/01/cf-1156fcard-bag/:0:0","tags":null,"title":"[CF 1156F]Card Bag","uri":"/2020/01/cf-1156fcard-bag/"},{"categories":["code"],"content":"分析 数据范围足够通过累积每轮游戏中的胜率来算。先想办法算游戏运行到第$i$轮的概率。 定义$f(i,j)$为第i次抽卡抽出$j$且游戏将继续的概率，发现 $f(i,j)$只能从$f(i,0 \\to j-1)$转移。否则游戏结束。 由上条，第$i$次抽出$j$的概率也可知，因为前面抽卡没有抽过$j$。 记牌总数$n$，牌面为$i$的牌有$c(i)$张，有转移 $$ \\begin{aligned} f(i,j)=\\frac{c(j)}{n-i+1}\\sum_{0 \\leq k \\leq j-1}f(i-1,k) \\end{aligned} $$ 有答案 $$ \\text{ans}=\\sum_{1 \\leq i,j \\leq n} f(i,j)\\frac{c(j)-1}{n-i+1} $$ ","date":"2020-01-21","objectID":"/2020/01/cf-1156fcard-bag/:1:0","tags":null,"title":"[CF 1156F]Card Bag","uri":"/2020/01/cf-1156fcard-bag/"},{"categories":["code"],"content":"代码 #include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003e#include \u003cstack\u003e#include \u003cmap\u003e#include \u003cset\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXN=5010; const ll MOD=998244353; // 游戏进行到第i轮,抽出j且没有结束的概率 ll f[MAXN][MAXN]; int card[MAXN]; ll inv[MAXN]; ll qpow(ll a,ll b,ll p){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%p){ if(b\u00261)res=res*a%p; } return res; } inline ll get_inv(ll a,ll p){ return qpow(a,p-2,p); } void init_inv(int n){ for(int i=1;i\u003c=n;i++){ inv[i]=get_inv(i,MOD); } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n;cin\u003e\u003en; init_inv(n); for(int i=1;i\u003c=n;i++){ int x;cin\u003e\u003ex; card[x]++; } f[0][0]=1; ll ans=0; for(int i=1;i\u003c=n;i++){ ll cnt=0; for(int j=0;j\u003ci;j++)cnt=(cnt+f[i-1][j])%MOD; for(int j=i;j\u003c=n;j++){ f[i][j]=((cnt*card[j])%MOD*inv[n-i+1])%MOD; //cout\u003c\u003c\"f(\"\u003c\u003ci\u003c\u003c\",\"\u003c\u003cj\u003c\u003c\")\"\u003c\u003cf[i][j]\u003c\u003cendl; cnt=(cnt+f[i-1][j])%MOD; } for(int j=1;j\u003c=n;j++){ ans=ans+((f[i-1][j]*(card[j]-1))%MOD*inv[n-i+1])%MOD; ans%=MOD; } } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-01-21","objectID":"/2020/01/cf-1156fcard-bag/:2:0","tags":null,"title":"[CF 1156F]Card Bag","uri":"/2020/01/cf-1156fcard-bag/"},{"categories":["code"],"content":"You are given a tree (an undirected connected acyclic graph) consisting of n vertices and n−1 edges. A number is written on each edge, each number is either 0 (let’s call such edges 0-edges) or 1 (those are 1-edges). Let’s call an ordered pair of vertices (x,y) (x≠y) valid if, while traversing the simple path from x to y, we never go through a 0-edge after going through a 1-edge. Your task is to calculate the number of valid pairs in the tree. ","date":"2020-01-21","objectID":"/2020/01/cf-1156d-0-1-tree/:0:0","tags":null,"title":"[CF 1156D] 0-1 Tree","uri":"/2020/01/cf-1156d-0-1-tree/"},{"categories":["code"],"content":"分析 当经过一条1，就不能再经过0。所以路径只会有（称1为黑，0为白） 全0 全1 从某处划分后一半为1一半为0 维护从点u到其子树任意节点的白色路径，黑色路径总数。那么答案就可以统计了。 从子树到自己的黑，白路径 子树到子树的黑，白路径 以u为分界点的黑白路径。包括子树到子树，子树到非子树。 子树到非子树的黑白节点已经包括在第1，2部分。 ","date":"2020-01-21","objectID":"/2020/01/cf-1156d-0-1-tree/:1:0","tags":null,"title":"[CF 1156D] 0-1 Tree","uri":"/2020/01/cf-1156d-0-1-tree/"},{"categories":["code"],"content":"代码 #include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003e#include \u003cstack\u003e#include \u003cmap\u003e#include \u003cset\u003eusing namespace std; using ll=long long; using pii=pair\u003cint,int\u003e; const int MAXV=200010,MAXE=400020; struct Edge{ int v,n,c; }edges[MAXE]; int head[MAXV],idx=0; void adde(int u,int v,int c){ edges[++idx].v=v; edges[idx].n=head[u]; edges[idx].c=c; head[u]=idx; } //从子树到本节点为白色路径或黑色路径的总数. //不包括自己. ll white[MAXV],black[MAXV]; void dfsCal(int u,int fa){ for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; dfsCal(e.v,u); white[u]+=e.c==0; black[u]+=e.c==1; if(e.c==0)white[u]+=white[e.v]; if(e.c==1)black[u]+=black[e.v]; } } ll ans=0; void solve(int u,int fa,ll w,ll b){ //子树到我 ans+=black[u]*2; ans+=white[u]*2; //子树到子树 for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; if(e.c==1){ ans+=(black[e.v]+1)*(black[u]-(black[e.v]+1)); } if(e.c==0){ ans+=(white[e.v]+1)*(white[u]-(white[e.v]+1)); } if(e.c==0){ ans+=(white[e.v]+1)*black[u]; } } //跨过我 ans+=b*white[u]; ans+=w*black[u]; //cout\u003c\u003c\"arrive at \"\u003c\u003cu\u003c\u003c\" and collect \"\u003c\u003cans\u003c\u003cendl; for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; if(e.c==1){ solve(e.v,u,0,b+(black[u]-(black[e.v]+1)+1)); }else{ solve(e.v,u,w+(white[u]-(white[e.v]+1)+1),0); } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int nlen;cin\u003e\u003enlen; for(int i=1;i\u003c=nlen-1;i++){ int u,v,c; cin\u003e\u003eu\u003e\u003ev\u003e\u003ec; adde(u,v,c); adde(v,u,c); } dfsCal(1,0); for(int i=1;i\u003c=nlen;i++){ //cout\u003c\u003cwhite[i]\u003c\u003c\" \"\u003c\u003cblack[i]\u003c\u003cendl; } solve(1,0,0,0); cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-01-21","objectID":"/2020/01/cf-1156d-0-1-tree/:2:0","tags":null,"title":"[CF 1156D] 0-1 Tree","uri":"/2020/01/cf-1156d-0-1-tree/"},{"categories":["学习"],"content":"把先前信息低的两篇blog给拆了,这样好点. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:0:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["学习"],"content":"一点小插曲: 如何在windows上的rust使用gnu工具链 众所周知windows对编程的体验不如*nix和osx,rust甚至在Windows上的配置都麻烦一点.比如说,为了装个rust,可能需要另外准备vs2019.这两个东西的空间占用差了不止一点半点. 折腾了一天.如果能仔细阅读官方的rustup文档的话,说不定就不用这么头秃了. 主要的选项在于选好host和version.在rustup执行安装时,修改为 x86_64-pc-windows-gnu stable-gnu 这样安装的版本才会使用gnu工具链.但是如此做的后果,我还不太清楚. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:1:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["学习"],"content":"以C对撞Rust 自己主要还是C系语言用户,所以实际学习时,总是会相比较着进行. letx:i32=10; 首先,rust也使用分号.每个变量的声明开头使用let,并且将变量类型跟随名称后面. 随着时间发展,现代语言几乎都抛弃了变量类型在左侧的声明方式.这大概是一个实践上的经验.左侧的类型声明会在复杂状况下造成极大的理解障碍.比如 void (*signal(int, void (*fp)(int)))(int); 阅读此类东西,总会是让人头疼.你会发现,为了理解它在干嘛,这种声明方式使得阅读顺序必须是顺时针的螺旋式,显得很不自然和明确.一旦调整类型到右侧时,这个问题似乎就不存在了. 所以不但变量的声明类型位于名称左侧,包括函数参数类型和返回值也都是位于右侧. 剩下的.. //rust中的变量**默认为不可更改**.必须添加`mut`关键字才作为一般意义上的变量考虑. letmutx=9;x=6;lety=9;y=8;// this is not allowed. if\u003cexpr\u003e{//do something }elseif\u003cexpr\u003e{//do what }else{//yeah? }//特殊的死循环 loop{}while\u003cexpr\u003e{}//由于Rust的零代价抽象,迭代器的使用没有性能折扣. foriin1..9{}//这个是右闭区间 foriin1..=9{}//所有控制流都是表达式,能够返回值;所以我们也没有三元运算符了. //对于循环,可以使用break. letflag=ifa\u003e0{1//最后一行不写引号,代表返回该值.没记错的话应该是从别的语言那借鉴的. }else{-1};fn func(a:i32,b:i32)-\u003e i32{a+b} ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:2:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["学习"],"content":"包管理 rust发展太快了,各种文章各说各话.这里主要是一个crate(一个包)内的结构. rust使用mod来明确的标注一个模块.关键字默认为私有,使用pub来标注一个对外公开的关键字.在2018标准,目录也会作为一个模块路径,文件名作为模块名,文件内关键字同样默认私有.在这种情况,使用mod关键字来显式的引入某个模块.对于第三方模块,2018不再需要显式标注引入extern crate.(但是仍然需要use) 在一个包里,允许有多个crate.如果硬要说,类似于vs studio里的解决方案和项目之间的关系.但是,rust还有一些不那么显然的限制 最多有一个lib crate 可以有多个binary crate ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:3:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["学习"],"content":"一个最小(?)的HTTP服务器 实现这个服务器的过程中,会遭遇到很多Rust内的问题.假设我们已经对比C++掌握其基本语法了. usestd::thread;usestd::sync::mpsc;usestd::sync::Arc;usestd::sync::Mutex;pubstruct ThreadPool{workers:Vec\u003cWorker\u003e,sender: mpsc::Sender\u003cMessage\u003e,}type Job=Box\u003cdynFnOnce()+Send+'static\u003e;//? enum Message{NewJob(Job),Terminate,}implThreadPool{/// Create thread pool /// /// The number of threads in pool /// /// # Paincs /// /// `new` will panic when size is not great than 0. pubfn new(size:usize)-\u003eThreadPool{assert!(size\u003e0);let(sender,receiver)=mpsc::channel();letreceiver=Arc::new(Mutex::new(receiver));letmutworkers=Vec::with_capacity(size);foridin0..size{workers.push(Worker::new(id,receiver.clone()));}ThreadPool{workers,sender}}pubfn execute\u003cF\u003e(\u0026self,f:F)whereF:FnOnce()+Send+'static{letjob=Box::new(f);self.sender.send(Message::NewJob(job)).unwrap();}}implDropforThreadPool{fn drop(\u0026mutself){for_in\u0026mutself.workers{self.sender.send(Message::Terminate).unwrap();}forworkerin\u0026mutself.workers{println!(\"shutting down worker {}\",worker.id);ifletSome(thread)=worker.thread.take(){thread.join().unwrap();}}}}struct Worker{id: usize,thread: Option\u003cthread::JoinHandle\u003c()\u003e\u003e,}implWorker{fn new(id:usize,receiver: Arc\u003cMutex\u003cmpsc::Receiver\u003cMessage\u003e\u003e\u003e)-\u003eWorker{letthread=thread::spawn(move||{loop{letmessage=receiver.lock().unwrap().recv().unwrap();matchmessage{Message::NewJob(job)=\u003e{println!(\"Worker {} got job.\",id);job();},Message::Terminate=\u003e{println!(\"Worker {} is terminating.\",id);break;}}}});Worker{id,thread: Some(thread),}}} usestd::io::prelude::*;usestd::net::{TcpListener,TcpStream};usestd::fs;usestd::time::Duration;usestd::thread;useautoman::ThreadPool;fn main(){letlistener=TcpListener::bind(\"127.0.0.1:7878\").unwrap();letpool=ThreadPool::new(1);forstreaminlistener.incoming(){letstream=stream.unwrap();pool.execute(||{handler(stream);});}}fn handler(mutstream: TcpStream){letmutbuffer=[0;512];stream.read(\u0026mutbuffer).unwrap();letget=b\"GET / HTTP/1.1\\r\\n\";letsleep=b\"GET /sleep HTTP/1.1\\r\\n\";let(status_line,filename)=ifbuffer.starts_with(get){(\"HTTP/1.1 200 OK\\r\\n\\r\\n\",\"hello.html\")}elseifbuffer.starts_with(sleep){thread::sleep(Duration::from_secs(5));(\"HTTP/1.1 200 OK\\r\\n\\r\\n\",\"hello.html\")}else{(\"HTTP/1.1 404 NOT FOUND\\r\\n\\r\\n\",\"404.html\")};letcontents=fs::read_to_string(filename).unwrap();letresponse=format!(\"{}{}\",status_line,contents);stream.write(response.as_bytes()).unwrap();stream.flush().unwrap();} ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:4:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["学习"],"content":"FnOnce 在C++里,我们能够用Lambda表达式创建闭包,当需要保存一个闭包时,标准库提供了叫function的东西.在Rust里,我们也有闭包,而描述一个闭包类型的玩意,就是Fn***. type Job=Box\u003cdynFnOnce()+Send+\u0026#039;static\u003e; 得益于rust的内存模型,诞生出这个奇葩玩意.反正还是和变量的所有权有关系.FnOnce的闭包会获取其捕获变量的所有权.另外FnMut的闭包获得其捕获变量的可变借用,Fn获得不可变借用.勉强可以对比C++里的[],[\u0026]. 至于到底什么闭包会实现哪一个,是由编译器根据实际情况判断的.想要强制将变量挪进闭包时,可以前缀move,就像Worker的run里的代码一样.因为当run执行完,receiver将会被丢弃,从而影响到闭包里的引用. 其他的几个+号和Send,'static什么的.+就是+,要求该类型必须同时实现这三种trait.Send是个trait(Types that can be transferred across thread boundaries).'static等时间周期实际上也是trait. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:5:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["学习"],"content":"Box和dyn type Job=Box\u003cdynFnOnce()+Send+\u0026#039;static\u003e; ……没完..前面那个dyn玩意也是挺奇怪,需要和impl关键字对比理解. Rust的一大特点就是零代价抽象.例如对于泛型,一种实现0抽象的方法就是在编译阶段单例化.C++也是如此处理. 不过有一种情况目测C++无法实现零抽象:在C++中,如果存在父类A有虚方法f,而子类B重写了f,又有一个函数g(A a)会调用f.当把B作为参数传给g时,C++通过一种叫虚函数表的方式实现调用B写的f.这种行为是发生在运行时的. 对于Rust来讲,虽然没有类与继承,这种操作实际等价于trait.上面的情况对等于存在trait A,它定义了一个f,B实现了A,g同上.Rust能够在编译阶段就确定传给g的是谁,并且优化掉它.不过这种优化也是有限度的.如果把一堆实现A的结构的指针存到数组或者其他内存结构里,那Rust也是无能为力的,只能在运行时动态分发. 再回来看impl和dyn.它们分别对应了能够优化(静态分发)和动态分发的情景. 另外,采用动态分发的结构也不能在编译时确定大小,所以必须外包Box.这一点还是有点特殊的,C++似乎并不会抱怨这个问题. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:6:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["学习"],"content":"Arc和Mutex fn new(id:usize,receiver: Arc\u003cMutex\u003cmpsc::Receiver\u003cMessage\u003e\u003e\u003e)-\u003eWorker; 说真的,看到Worker的这个函数签名,当时就像吐.Rust这玩意,动不动就会嵌套上好几层的\u003c\u003e. 首先关于Arc…先Rc.一般情况下,一个变量的所有权是可以在编译阶段就确定下来的.但是总会有不如意的时候,当有多个结构同时享有某个变量的所有权(例如一棵树),就不太好确定其实际的销毁时机,而且Rust也不会给你机会共享所有权.Rc是一个引用计数指针,变量所有权由它保管,而它能够提供多份只读借用. 然而Rc线程不安全,Arc线程安全.不过Arc性能弱于Rc. 其次是Mutex…就是个锁… 至于为啥用锁,先看mpsc,Multi-producer, single-consumer FIFO queue communication primitives. 一头雾水的缩写…简而言之,这个东西的设定类似于go里channel,同时是多生产者,单消费者模式.本身使用没什么绕的地方.绕的地方在于多线程共享和单消费者模式的冲突,所以引入了锁,保证同时只有一个线程能够消费消息. 顺便吐槽一句这代码写的… letmessage=receiver.lock().unwrap().recv().unwrap(); 其实涉及到Rc时,还有另外一个外部可变,内部可变的麻烦事.这里没有提到. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:7:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["学习"],"content":"还有 unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap,unwrap… 当然它们本来会被替代成更复杂的错误处理. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:8:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["学习"],"content":"小结 用Rust写的程序,和自己脑袋斗智斗勇几回合,再和编译器斗智斗勇(单方面挨揍)几百回合,最后是真的难以出现bug,毕竟一切都被管的死死的.我还看到Rust里一个很有意思的玩意叫错误驱动,说是先把代码大概模样瞎糊上,然后让编译器check一遍,再一步步改掉编译器的报错顺便写代码,最后就能在编译器的吐槽下完美实现程序,再加点测试就齐全了… 虽然整个语法看起来复杂啰嗦,不过无法否认这些语句对于工程来讲实际上都是必要的.所以这玩意的气质决定它不太适合作为打比赛时用的语言.翻了翻CF好几场比赛,零星有几个Rust的代码也都没有涉及任何数据结构,本来还想瞻仰一下他们会怎么处理生命周期一类的问题. 如果有机会,拿Rust写课设应该可以玩一玩(大概会被强行用C系语言).至于原本想拿Rust写个本地评测器,还是算了,有空再说吧. ","date":"2020-01-18","objectID":"/2020/01/have-fun-with-rust/:9:0","tags":null,"title":"与Rust玩耍","uri":"/2020/01/have-fun-with-rust/"},{"categories":["code"],"content":"C 无脑DP.设状态$f(i,j,0/1)$表示已经设置了$i$位,用了$j$个偶数,第$i$位是偶数/奇数.然后 $$ \\begin{aligned} f(i,j,0)\u0026=\\min\\{f(i-1,j-1,0),f(i-1,j-1,1)+1\\} \\\\ f(i,j,1)\u0026=\\min\\{f(i-1,j,0)+1,f(i-1,j,1)\\} \\end{aligned} $$ 以$i=1$作为开始,因为第1位不能算代价. // missing? ","date":"2020-01-14","objectID":"/2020/01/codeforces-round-612-div-2/:1:0","tags":null,"title":"Codeforces Round #612 (Div. 2)","uri":"/2020/01/codeforces-round-612-div-2/"},{"categories":["code"],"content":"D 一个事实是,两棵子🌳的间大小关系不会影响其内部节点的既定关系. 以此,直接dfs,从底层向上构造相对大小顺序.合并时子树间的相对大小没有影响,所以直接前后接在一起就好,再把当前节点插到合适的位置使其满足c的条件. 全部完成后再对节点统一标号. 最开始先标了号,然后越写越麻烦,生气. #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003eusing namespace std; const int MAXN=2010; const int MAXV=2010,MAXE=4020; int tick=0; struct Edge{ int v,n; }edges[MAXE]; int head[MAXV]; int idx=0; int sz[MAXV]; void adde(int u,int v){ edges[++idx].v=v; edges[idx].n=head[u]; head[u]=idx; } int name[MAXV]; int cur[MAXV][MAXV]; int dfs0(int u,int fa){ sz[u]=1; for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; sz[u]+=dfs0(e.v,u); } if(sz[u]==1){ name[u]=tick; cur[u][tick]++; tick+=2000; } return sz[u]; } int target[MAXV]; bool ok=1; vector\u003cint\u003e dfs(int u,int fa){ vector\u003cint\u003e res; for(int ei=head[u];ei;ei=edges[ei].n){ Edge \u0026e=edges[ei]; if(e.v==fa)continue; vector\u003cint\u003e cur=dfs(e.v,u); for(auto it=cur.begin();it!=cur.end();it++){ res.push_back(*it); } } if(target[u]\u003eres.size())ok=0; else res.insert(res.begin()+target[u],u); return res; } int main(){ int vlen;cin\u003e\u003evlen; int root; for(int i=1;i\u003c=vlen;i++){ int fa; cin\u003e\u003efa\u003e\u003etarget[i]; if(fa!=0){ adde(fa,i); }else root=i; } vector\u003cint\u003e res=dfs(root,0); if(ok){ cout\u003c\u003c\"YES\"\u003c\u003cendl; for(int i=0;i\u003cres.size();i++){ name[res[i]]=i; } for(int i=1;i\u003c=vlen;i++){ cout\u003c\u003cname[i]+1\u003c\u003c\" \"; } cout\u003c\u003cendl; }else{ cout\u003c\u003c\"NO\"\u003c\u003cendl; } return 0; } ","date":"2020-01-14","objectID":"/2020/01/codeforces-round-612-div-2/:2:0","tags":null,"title":"Codeforces Round #612 (Div. 2)","uri":"/2020/01/codeforces-round-612-div-2/"},{"categories":["code"],"content":"Today, as a friendship gift, Bakry gave Badawy n integers a1,a2,…,an and challenged him to choose an integer X such that the value max1≤i≤n(ai⊕X) is minimum possible, where ⊕ denotes the bitwise XOR operation. As always, Badawy is too lazy, so you decided to help him and find the minimum possible value of max1≤i≤n(ai⊕X). ","date":"2020-01-13","objectID":"/2020/01/cf1285d-dr-evil-underscores/:0:0","tags":null,"title":"CF1285D Dr.Evil Underscores","uri":"/2020/01/cf1285d-dr-evil-underscores/"},{"categories":["code"],"content":"分析 将输入按照二进制位从高位开始建树,就能看出来,一旦确定了高位$i$填1还是0后,只会有一棵子树影响答案.另一棵子树的所有数字都因为$i$位上的异或结果为0而定小于另一个子树. 树不用真的建出来,这样就可以做了. ","date":"2020-01-13","objectID":"/2020/01/cf1285d-dr-evil-underscores/:1:0","tags":null,"title":"CF1285D Dr.Evil Underscores","uri":"/2020/01/cf1285d-dr-evil-underscores/"},{"categories":["code"],"content":"代码 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003climits\u003e#include \u003cvector\u003eusing namespace std; using ll=long long; const ll LMAX=numeric_limits\u003cll\u003e::max(); const int MAXN=100010; //int nlen; //int num[MAXN]; vector\u003cint\u003e num; int dfs(int ptr,const vector\u003cint\u003e \u0026vec){ if(ptr\u003c0)return 0; vector\u003cint\u003e one,zero; for(auto i:vec){ if((i\u003e\u003eptr)\u00261==1)one.push_back(i); else zero.push_back(i); } /* cout\u003c\u003c\"====vec====\"\u003c\u003cendl; for(auto i:one)cout\u003c\u003ci\u003c\u003c\",\"; cout\u003c\u003cendl; for(auto i:zero)cout\u003c\u003ci\u003c\u003c\",\"; cout\u003c\u003cendl; cout\u003c\u003c\"===========\"\u003c\u003cendl; */ if(one.size()==0) return dfs(ptr-1,zero); if(zero.size()==0) return dfs(ptr-1,one); //cout\u003c\u003c\"add\"\u003c\u003c(1\u003c\u003cptr)\u003c\u003cendl; return (1\u003c\u003cptr)+min(dfs(ptr-1,zero),dfs(ptr-1,one)); } int main(){ ios::sync_with_stdio(false); int nlen;cin\u003e\u003enlen; for(int i=0;i\u003cnlen;i++){ int x;cin\u003e\u003ex; num.push_back(x); } cout\u003c\u003cdfs(30,num)\u003c\u003cendl; return 0; } ","date":"2020-01-13","objectID":"/2020/01/cf1285d-dr-evil-underscores/:2:0","tags":null,"title":"CF1285D Dr.Evil Underscores","uri":"/2020/01/cf1285d-dr-evil-underscores/"},{"categories":["闲扯"],"content":"我觉得这件需要发一篇来庆祝一下。虽然从头到尾我就没怀疑过最终会是雪乃，（雪乃!）但是结局一出，还是非常欣慰。 真好啊.jpg。 是时候再买一套来收藏了。 ","date":"2019-11-19","objectID":"/2019/11/eight-years-for-chunwu/:0:0","tags":null,"title":"8年了，春物终于迎来了结局","uri":"/2019/11/eight-years-for-chunwu/"},{"categories":["学习"],"content":"例题-4 HDU2089 不要62 统计数位中没有出现4和62的数字个数。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:1:0","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"分析 不要4，可以在4时直接不转移。对于62，可以维护一个上一个数字填了啥，就可以像4一样判断了。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:1:1","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; constexpr int MAXN=20; ll cache[MAXN][MAXN]; int digits[20]; ll solve(int pos,int last,int lim){ if(pos==0)return 1; if(!lim \u0026\u0026 ~cache[pos][last])return cache[pos][last]; int maxd=9; if(lim)maxd=digits[pos]; ll res=0; for(int i=0;i\u003c=maxd;i++){ if(last*10+i==62 || i==4)continue; res+=solve(pos-1,i,lim \u0026\u0026 i==maxd); } if(!lim)cache[pos][last]=res; return res; } ll SOLVE(ll x){ int ptr=0; while(x){ digits[++ptr]=x%10; x/=10; } return solve(ptr,0,true); } int main(){ ll l,r; memset(cache,-1,sizeof(cache)); while(cin\u003e\u003el\u003e\u003er){ if(l==0 \u0026\u0026 r==0)break; cout\u003c\u003cSOLVE(r)-SOLVE(l-1)\u003c\u003cendl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:1:2","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"例题-3 HDU3555 统计所有出现过49的数字的个数。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:2:0","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"分析 统计所有没出现过49的数字，就和上一道一样了。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:2:1","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=50; int digits[MAXN]; ll f[MAXN][MAXN]; ll solve(int pos,int last,int lim){ if(pos==0)return 1; if(!lim \u0026\u0026 ~f[pos][last])return f[pos][last]; int maxd=9; if(lim)maxd=digits[pos]; ll res=0; for(int i=0;i\u003c=maxd;i++){ if(last*10+i==49)continue; res+=solve(pos-1,i,lim \u0026\u0026 i==maxd); } if(!lim)f[pos][last]=res; return res; } inline ll SOLVE(ll x){ int ptr=0; while(x){ digits[++ptr]=x%10; x/=10; } return solve(ptr,0,true); } int main(){ ios::sync_with_stdio(false); int kase;cin\u003e\u003ekase; memset(f,-1,sizeof(f)); while(kase--){ ll r;cin\u003e\u003er; cout\u003c\u003cr-SOLVE(r)+1\u003c\u003cendl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:2:2","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"例题-2 POJ3252 The cows, as you know, have no fingers or thumbs and thus are unable to play Scissors, Paper, Stone� (also known as �Rock, Paper, Scissors�, �Ro, Sham, Bo�, and a host of other names) in order to make arbitrary decisions such as who gets to be milked first. They can�t even flip a coin because it�s so hard to toss using hooves. They have thus resorted to “round number” matching. The first cow picks an integer less than two billion. The second cow does the same. If the numbers are both “round numbers”, the first cow wins, otherwise the second cow wins. A positive integer N is said to be a “round number” if the binary representation of N has as many or more zeroes than it has ones. For example, the integer 9, when written in binary form, is 1001. 1001 has two zeroes and two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since it has two zeroes and three ones, it is not a round number. Obviously, it takes cows a while to convert numbers to binary, so the winner takes a while to determine. Bessie wants to cheat and thinks she can do that if she knows how many “round numbers” are in a given range. Help her by writing a program that tells how many round numbers appear in the inclusive range given by the input (1 ≤ Start \u003c Finish ≤ 2,000,000,000). ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:3:0","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"分析 这道题目将上界拆解为二进制数位。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:3:1","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; typedef long long ll; const int MAXN=50; int digits[MAXN]; ll f[MAXN][MAXN][MAXN]; int len=0; ll solve(int pos,int one,int first, int lim){ if(pos==0){ //cout\u003c\u003cfirst\u003c\u003c\" \"\u003c\u003cone\u003c\u003cendl; if(first==0)return 0; if(first-one\u003e=one)return 1; return 0; } if(!lim \u0026\u0026 ~f[pos][one][first])return f[pos][one][first]; int maxd=1; if(lim)maxd=digits[pos]; ll res=0; for(int i=0;i\u003c=maxd;i++){ res+=solve(pos-1,one+(i==1),(i==1 \u0026\u0026 !first? pos : first),lim \u0026\u0026 i==maxd); } if(!lim)f[pos][one][first]=res; return res; } inline ll SOLVE(ll x){ int ptr=0; while(x){ digits[++ptr]=x%2; x/=2; } return solve(ptr,0,0,true); } int main(){ ios::sync_with_stdio(false); memset(f,-1,sizeof(f)); ll l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003cSOLVE(r)-SOLVE(l-1)\u003c\u003cendl; return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:3:2","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"例题-1 HDU3652 A wqb-number, or B-number for short, is a non-negative integer whose decimal form contains the sub- string “13” and can be divided by 13. For example, 130 and 2613 are wqb-numbers, but 143 and 2639 are not. Your task is to calculate how many wqb-numbers from 1 to n for a given integer n. ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:4:0","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"分析 维护额外2个状态，一个状态记录模13的余数，另一个进行编码：1为上一位为1，3为已经出现过13，0为其他。之后将转移条件描述清楚就可以了。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:4:1","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=20; int num[MAXN]; ll f[MAXN][5][20]; ll dfs(int ptr,int last,int mod,bool lim){ //cout\u003c\u003c\"arrive\"\u003c\u003cptr\u003c\u003c\" \"\u003c\u003clast\u003c\u003c\" \"\u003c\u003cmod\u003c\u003c\" \"\u003c\u003clim\u003c\u003cendl; if(ptr\u003c=0){ if(last==3 \u0026\u0026 mod==0)return 1; else return 0; } if(!lim \u0026\u0026 ~f[ptr][last][mod])return f[ptr][last][mod]; int maxx=lim?num[ptr]:9; ll res=0; for(int i=0;i\u003c=maxx;i++){ if(last==3)res+=dfs(ptr-1,3,(mod*10+i)%13,lim \u0026\u0026 i==maxx); else if(last==1 \u0026\u0026 i==3)res+=dfs(ptr-1,3,(mod*10+i)%13,lim \u0026\u0026 i==maxx); else if(i==1)res+=dfs(ptr-1,1,(mod*10+i)%13,lim\u0026\u0026i==maxx); else res+=dfs(ptr-1,0,(mod*10+i)%13,lim\u0026\u0026i==maxx); } if(!lim)f[ptr][last][mod]=res; return res; } ll solve(ll r){ int ptr=0; while(r){ num[++ptr]=r%10; r/=10; } return dfs(ptr,0,0,1); } int main(){ ios::sync_with_stdio(false); cin.tie(0); memset(f,-1,sizeof(f)); ll r; while(cin\u003e\u003er){ cout\u003c\u003csolve(r)\u003c\u003cendl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:4:2","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"例题0 HDU3709 A balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 42 + 11 = 9 and 9*1 = 9, for left part and right part, respectively. It�s your job to calculate the number of balanced numbers in a given range [x, y]. ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:5:0","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"分析 这题有点麻烦…… 将杠杆在哪与题目分离出来，枚举杠杆定在何处。再维护是否平衡。平衡与否还是挺好考虑的，以杠杆为0，左右各赋值正与负的权值，当到达边接后全杆重量为0时即为平衡。 有一个小坑，就是0。如果这个数字全tm填0的时候，不管杠杆定在哪，它都平衡……你当然可以维护一个前导零标志，将所有0都去掉最后再加上。还有一种办法就是最后再将重复的0减去，相比起来更加简单。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:5:1","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; int num[20]; ll f[20][20][2010]; ll dfs(int ptr,bool lim,int piv,int l){ if(ptr\u003c=0)return l==0; if(l\u003c0)return 0; if(!lim \u0026\u0026 ~f[ptr][piv][l])return f[ptr][piv][l]; int maxx=lim?num[ptr]:9; ll res=0; for(int i=0;i\u003c=maxx;i++){ res+=dfs(ptr-1,lim \u0026\u0026 i==maxx,piv,l+i*(ptr-piv)); } if(!lim)f[ptr][piv][l]=res; return res; } ll solve(ll r){ int ptr=0; while(r){ num[++ptr]=r%10; r/=10; } ll ans=0; for(int i=1;i\u003c=ptr;i++){ ans+=dfs(ptr,1,i,0); } return ans-ptr+1; } int main(){ ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); int kase;cin\u003e\u003ekase; while(kase--){ memset(f,-1,sizeof(f)); ll l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003csolve(r)+(l?-solve(l-1):0)\u003c\u003c'\\n'; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:5:2","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"例题1 CF55D Volodya is an odd boy and his taste is strange as well. It seems to him that a positive integer number is beautiful if and only if it is divisible by each of its nonzero digits. We will not argue with this and just count the quantity of beautiful numbers in given ranges. ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:6:0","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"分析 维护数字对0-9每个数字的模，但是这样还需要维护某些数字是否出现，继续考虑。当数字能同时被$a$和$b$整除，等价为其能够被它俩的最小公倍数整除。 那么我们的问题可以稍微简化一下了。维护已经填写的数位的最小公倍数，并维护数字和。到达边界时，只有满足条件才计数。 这道题还有一点麻烦，就是内存它不够用。按照分析，至少需要开$2520\\times 2520$，还要再加上个数位长度。内存就炸了。实际上，最小公倍数仅有了了几个，可以事先求出并先编码，就能降低一维状态。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:6:1","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003cmap\u003eusing namespace std; using ll = long long; const int MAXN = 2620; const int MAX_LCM = 2520; //pos位数余rest模·10·的方案 ll cache[20][MAXN][50]; int digits[20]; int idx = 0; int lcmref[MAXN]; ll gcd(ll a, ll b) { return !b ? a : gcd(b, a % b); } ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } void init_lcm() { for (int i = 0; i \u003c (1 \u003c\u003c 10); i++) { int temp = 1; for (int j = 1; j \u003c 10; j++) { if ((i \u003e\u003e j) \u0026 1) { temp = lcm(temp, j); } } if (!lcmref[temp]) { //cout \u003c\u003c temp \u003c\u003c endl; lcmref[temp]=++idx; } } } ll solve(int pos, int rest, int l, bool lim) { if (pos == 0) { if (rest % l == 0) return 1; return 0; } if (!lim \u0026\u0026 ~cache[pos][rest][lcmref[l]]) return cache[pos][rest][lcmref[l]]; ll res = 0; int maxd = 9; if (lim) maxd = digits[pos]; for (int i = 0; i \u003c= maxd; i++) { res += solve(pos - 1, (rest * 10 + i) % MAX_LCM, i == 0 ? l : lcm(l, i), lim \u0026\u0026 (i == maxd)); } if (!lim) cache[pos][rest][lcmref[l]] = res; return res; } ll SOLVE(ll x) { int ptr = 0; while (x) { digits[++ptr] = x % 10; x /= 10; } return solve(ptr, 0, 1, true); } int main() { ios::sync_with_stdio(false); init_lcm(); int kase; cin \u003e\u003e kase; memset(cache, -1, sizeof(cache)); while (kase--) { ll l, r; cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c SOLVE(r) - SOLVE(l - 1) \u003c\u003c endl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:6:2","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"例题2 求$[l,r]$区间内的所有满足以下要求的数的平方和。 数位上没有$7$ 不是$7$的倍数 数位和不是$7$的倍数 区间为$10^{18}$级别，请对答案取模$10^{9}+7$。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:7:0","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"分析 这题挺狠的……首先看如何判断上面的3个条件。 数位上没有$7$，可以直接在枚举填数时跳过$7$。 非 * 的倍数，可以维护已填数字的取模。取模为$0$则为倍数。 数位和，仍然可以直接维护。 这样就可以正确的判断某个数是不是满足条件。接下来是平方和。 当以数位来考虑平方和时，问题就稍微变得复杂了。假设我们已经知道了下一个状态的平方和为$x_n$，如何得到当前位$x$的平方和。 假设当前位$ptr$填了$i$。其数位所表达的意义是$10^{p}i$，那么以该位与下一状态的平方和，需要下一状态的和，定为$s_n$。可以得到 $$ (10^p i+s_n)^2=10^{2p}i^2+2 \\cdot 10^pis_n+s_n^2 $$ 另外，当前位的出现次数在实际计算时需要考虑进去。那么，还需要维护下一状态的个数，记$cnt$。那么，上式需要修改 $$ 10^{2p}i^2 \\cdot cnt_n+2 \\cdot 10^pis_n+s_n^2 $$ 后两项不乘以$cnt$是因为它们本身就已经是包括了下一状态的所有计数。这样，我们就得到了以数位为角度的平方和维护办法。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:7:1","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=22; const ll MOD=1e9+7; struct Status{ ll cnt; ll sum,sqsum; Status(ll cnt=-1,ll sum=0,ll sqsum=0):cnt(cnt),sum(sum),sqsum(sqsum){} } f[MAXN][9*20][10]; int num[MAXN]; ll qpow(ll a,ll b){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%MOD){ if(b\u00261)res=res*a%MOD; } return res; } Status dfs(int ptr,int sum,int mod,bool lim){ if(ptr\u003c=0){ return Status(sum%7!=0 \u0026\u0026 mod!=0); } if(!lim \u0026\u0026 ~f[ptr][sum][mod].cnt)return f[ptr][sum][mod]; int maxx=lim?num[ptr]:9; Status res(0); for(int i=0;i\u003c=maxx;i++){ if(i==7)continue; Status nex=dfs(ptr-1,sum+i,(mod*10+i)%7,lim\u0026\u0026i==maxx); res.cnt+=nex.cnt; res.cnt%=MOD; res.sum=(res.sum%MOD+qpow(10,ptr-1)*i%MOD*nex.cnt%MOD)%MOD; res.sum=(res.sum+nex.sum)%MOD; res.sqsum=(res.sqsum+nex.cnt%MOD*qpow(10,2*(ptr-1))%MOD*i%MOD*i%MOD)%MOD; res.sqsum=((res.sqsum+nex.sqsum)%MOD+2*qpow(10,ptr-1)%MOD*i%MOD*nex.sum%MOD)%MOD; } if(!lim)f[ptr][sum][mod]=res; return res; } ll solve(ll n){ int ptr=0; while(n){ num[++ptr]=n%10; n/=10; } return dfs(ptr,0,0,1).sqsum%MOD; } int main(){ ios::sync_with_stdio(false); cin.tie(0); int kase;cin\u003e\u003ekase; while(kase--){ ll l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003c((solve(r)-(l?solve(l-1):0))%MOD+MOD)%MOD\u003c\u003cendl; } return 0; } ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:7:2","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"数位DP 上面这道题目大概算是暴露了数位DP中需要考虑的事情。数位DP能够主要能够统计某2个数字区间内满足某些条件的数字的信息，比如个数、和、平方和…… 首先数位DP不是单独考虑每一个数字，而是以数位为单位的考虑。这样在考虑条件满足和各类信息的维护时，就需要转一转。 先来看记忆化搜索。比较直观（ ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:8:0","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"计数基础 初始化的值从何而来。当数位DP到达了边界，就是要考虑初始化的位置。一般为满足条件置$1$。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:8:1","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"满足条件 这是我们需要考虑的状态。例如上面提到的。 数位没有某数：直接不转移。 数位和：直接维护一维数位和。 倍数关系：以递推方式维护取模。 数字出现次数：使用状压来对次数编码。例如，对每一种数字维护空间为3的状态（0，奇数，偶数）。 其实还可能有很多，主要考虑的问题是该状态经过编码后能不能保存下来，两个状态之间能不能递推过去。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:8:2","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["学习"],"content":"计数 必须考虑$n-1$到$n$位之间的转移关系。首先一定会维护满足性质的数字个数，之后每一个位的计算都需要考虑下一状态的个数。 ","date":"2019-11-06","objectID":"/2019/11/digital-dp/:8:3","tags":null,"title":"数位DP","uri":"/2019/11/digital-dp/"},{"categories":["code"],"content":"Liaoning ship, which named after a province of China, is the first aircraft carrier commissioned into the People’s Liberation Army Navy. It was bought from Ukraine as a stripped hulk and was rebuilt by China as an important part of China’s blue water Navy plan. Liaoning ship has sailed far into the Pacific Ocean for serval times, which shows the power and resolve of China to defend her integrity of territory. Now Liaoning ship is on a new voyage to the Atlantic Ocean for a maneuver! The vast maneuver region on the ocean can be seen as an n×n grid which has n×n crosspoints. Each crosspoint stands for a check point of the maneuver region. Liaoning starts from the bottom-left check point whose coordinate is (0,0), and its destination is the upper-right checkpoint whose coordinate is (n-1,n-1). The positive side of the x axis points to the right, and the positive side of the y axis points up. All check points’ coordinates are integral. During each move, Liaoning can go from one check point to its adjacent 8 check points along a straight line, and each move takes Liaoning one day. Some check points are not available to go due to the bad weather. And, as you know, on the Atlantic Ocean, there is a Bermuda Triangle in which many ships and planes were missing. Liaoning can’t take risk to go into that triangle. Of course, Liaoning can’t go outside the maneuver region. Please figure out a route for Liaoning to reach its destination as soon as possible. ","date":"2019-10-27","objectID":"/2019/10/liaoning-ships-voyage/:0:0","tags":null,"title":"Liaoning Ship’s Voyage","uri":"/2019/10/liaoning-ships-voyage/"},{"categories":["code"],"content":"分析 实际上本体是个Dijkstra，但是两点是否相连需要使用到计算几何的东西。重点就在于如何判断行进过程是否穿过了百慕大三角。 然后就WA了8发。 实际判断时会有很多问题。例如从边上经过，从外界到边，从边到边，从边到外界，从外界到点，从点到外界，从边穿过点……如果一开始选择的判断方法有锅的话，之后就改不出来了，只能WA…… 最终想出来的解决办法是拿到行进线段与三角形三边的交点，连接交点构造新线段后，判断线段中点是否在三角形内；并同时判断起点终点是否在三角形内。这样就能避免掉复杂的讨论。 其次，顺便把已经在三角形内的整点全部标记了不能访问。 这样就过了。 ","date":"2019-10-27","objectID":"/2019/10/liaoning-ships-voyage/:1:0","tags":null,"title":"Liaoning Ship’s Voyage","uri":"/2019/10/liaoning-ships-voyage/"},{"categories":["code"],"content":"代码 板子判点在线段部分有问题，要改。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccmath\u003e#include \u003ccstdlib\u003e#include \u003cqueue\u003eusing namespace std; const int MAXN=30; bool fuck=false; const double EPS=1e-7; const double PI=acos(-1); int sgn(double x){ return (x\u003e-EPS)-(x\u003cEPS); } struct Vec{ double x,y;//never change it yourself unless you dont need polar angle. double _polar;// make cache to accumulate speed as atan is too slow. Vec(){ x=y=0; } Vec(double x,double y):x(x),y(y){ _polar=atan2(y,x); } double dot(const Vec \u0026b)const{ return x*b.x+y*b.y; } double cross(const Vec \u0026b)const{ return x*b.y-b.x*y; } double len(){ return sqrt(sqlen()); } double sqlen(){ return x*x+y*y; } Vec normalize(){ double l=len(); return Vec(x/l,y/l); } Vec rotate(double angle){ return Vec(x*cos(angle)-y*sin(angle),x*sin(angle)+y*cos(angle)); } Vec operator * (double factor)const{ return Vec(x*factor,y*factor); } double operator * (const Vec \u0026b)const{ return cross(b); } Vec operator - (const Vec \u0026b)const{ return Vec(x-b.x,y-b.y); } Vec operator +(const Vec \u0026b)const{ return Vec(x+b.x,y+b.y); } double polar()const{ return _polar; } bool leftby(const Vec \u0026b)const{ return sgn(b.cross(*this))\u003e0; } bool samed(const Vec \u0026b)const{ return sgn(this-\u003ecross(b))==0 \u0026\u0026 sgn(this-\u003edot(b))\u003e0; } bool operator\u003c(const Vec \u0026b)const{ return this-\u003epolar()\u003cb.polar(); } bool operator==(const Vec \u0026b)const{ return sgn(b.x-this-\u003ex)==0 \u0026\u0026sgn(b.y-this-\u003ey)==0; } }; ostream\u0026 operator\u003c\u003c(ostream\u0026 out,const Vec \u0026b){ out\u003c\u003c\"(\"\u003c\u003cb.x\u003c\u003c\",\"\u003c\u003cb.y\u003c\u003c\")\"; return out; } typedef Vec Point; struct Line{ Point pos; Vec dirc; Line(Point pos=Point(0,0),Vec dirc=Vec(0,0)):pos(pos),dirc(dirc){} static Line fromPoints(Point a,Point b){ return Line(a,b-a); } double getarea(const Line \u0026b)const{ return abs(dirc.cross(b.dirc)); } // 获得垂线 Line getppd(){ return Line(pos+dirc*0.5,dirc.rotate(PI/2)); } //TODO: what will happen if they have no intersection,-nan Point getintersection(const Line \u0026b)const{ Vec down=this-\u003epos-b.pos; double aa=b.dirc.cross(down); double bb=this-\u003edirc.cross(b.dirc); return this-\u003epos+this-\u003edirc*(aa/bb); } bool point_on_line(Point point){ if(!dirc.samed(point-pos)) return false; if(sgn((point-pos).sqlen()-dirc.sqlen())\u003e0) return false; return true; } bool on_ver(Point point){ if(sgn(point.x-pos.x)==0 \u0026\u0026 sgn(point.y-pos.y)==0)return true; if(sgn(point.x-(pos.x+dirc.x))==0 \u0026\u0026 sgn(point.y-(pos.y+dirc.y))==0)return true; return false; } double get_distance(Point point){ Line ppd=getppd(); ppd.pos=point; Point intersection=getintersection(ppd); ppd.dirc=intersection-point; Vec v=intersection-pos; return abs(v.cross(point-pos)/v.len()); } double get_distance(Line line){ return get_distance(line.pos); } }; Point points[3]; Line triangle[3]; char game[MAXN][MAXN]; double get_area(vector\u003cPoint\u003e \u0026points){ if(points.size()\u003c3){ return -1; } sort(points.begin(),points.end(),[](const Point \u0026a,const Point \u0026b){ return a.polar()\u003cb.polar(); }); Point base(0,0); Point last=points[0]; double res=0; for(int i=1;i\u003cpoints.size();i++){ Vec a=last-base,b=points[i]-base; res+=a.cross(b)/2; last=points[i]; } //add the last point(also the first point) Vec a=last-base,b=points[0]-base; res+=a.cross(b)/2; return fabs(res); } bool in_triangle(Point p){ if(fuck)return false; for(int i=0;i\u003c3;i++){ if(Line::fromPoints(points[i%3],points[(i+1)%3]).point_on_line(p))return false; } double areas=0; for(int i=0;i\u003c3;i++){ vector\u003cPoint\u003e ps; ps.push_back(points[i%3]); ps.push_back(points[(i+1)%3]); ps.push_back(p); areas+=get_area(ps); } vector\u003cPoint\u003e ps; for(int i=0;i\u003c3;i++)ps.push_back(points[i]); return sgn(areas-get_area(ps))==0; } bool has_intersetct(Line line){ if(fuck)return false; int cnt=0; Point p[3]; bool flg[3]={0,0,0}; for(int i=0;i\u003c3;i++){ if(sgn(line.dirc.cross(triangle[i].dirc))==0)continue; p[i]=line.getintersection(triangle[i]); if(line.point_on_line(p[i])||p[i]==line.pos) flg[i]=1; } if(in_triangle(line.pos)) return true; if(in_triangle(line.pos","date":"2019-10-27","objectID":"/2019/10/liaoning-ships-voyage/:2:0","tags":null,"title":"Liaoning Ship’s Voyage","uri":"/2019/10/liaoning-ships-voyage/"},{"categories":["code"],"content":"这题意太长了，我懒得复制。 ","date":"2019-10-23","objectID":"/2019/10/ccpc2017hangzhou-heathrock/:0:0","tags":["搜索"],"title":"[CCPC2017杭州] Heathrock","uri":"/2019/10/ccpc2017hangzhou-heathrock/"},{"categories":["code"],"content":"分析 额……其实就是爆搜模拟。但是状态比较多，需要记双方生命值，3个随从的生命，当前场数，魔力，体力，以及一些玄学优化。 自选目标的牌一定会放在回合的较后出，因为其不会累加魔力。 如果剩下的牌全踢脸也踢不死，直接返回。 之后就能跑得飞快。 {% asset_img “1.png” %} ","date":"2019-10-23","objectID":"/2019/10/ccpc2017hangzhou-heathrock/:1:0","tags":["搜索"],"title":"[CCPC2017杭州] Heathrock","uri":"/2019/10/ccpc2017hangzhou-heathrock/"},{"categories":["code"],"content":"代码 一开始输出了\"YES”，淦。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003cstack\u003e#include \u003cqueue\u003eusing namespace std; const int MAXN=10; struct Card{ int type; int damage; int cost; int power; Card(){} Card(int type,int damage,int cost,int power):type(type),damage(damage),cost(cost),power(power){} } cards[MAXN]; bool used[MAXN]; int nlen; int md1,md2,md3; int mx1,mx2,mx3; stack\u003cint\u003e ans_cards,ans_target; bool dfs(int stone,int power,int bl_me,int bl_en,int m1,int m2,int m3,int depth,bool nearend=false){ if(stone\u003c0)return false; if(depth\u003e=3)return false; if(bl_en\u003c=0)return true; if(depth\u003e=1 \u0026\u0026 stone==10){ if(m1\u003e0)bl_me-=md1; if(m2\u003e0)bl_me-=md2; if(m3\u003e0)bl_me-=md3; if(m1\u003c=0)m1=mx1; if(m2\u003c=0)m2=mx2; if(m3\u003c=0)m3=mx3; } if(bl_me\u003c=0)return false; //full attacking to owner cannot kill it. int fullattack=0; int fakepower=power; int unusd_lian=0; for(int i=0;i\u003cnlen;i++){ if(used[i])continue; fakepower+=cards[i].power; if(cards[i].type==1)continue; unusd_lian++; fullattack+=cards[i].damage; } if(fullattack+fakepower*(unusd_lian)\u003cbl_en)return false; for(int i=0;i\u003cnlen;i++){ if(used[i])continue; const Card \u0026card=cards[i]; int reald=card.damage+power; if(card.cost\u003estone)continue; used[i]=1; if(!nearend \u0026\u0026 card.type==1){ if(stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1-reald,m2-reald,m3-reald,depth)){ ans_cards.push(i+1); ans_target.push(-1); return true; } } if(!nearend \u0026\u0026 card.type==2){ if(stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en-reald,m1,m2,m3,depth)){ ans_cards.push(i+1); ans_target.push(-1); return true; } } if(card.type==3){ if(stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en-reald,m1,m2,m3,depth,1)){ ans_cards.push(i+1); ans_target.push(0); return true; } if(m1\u003e0 \u0026\u0026 stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1-reald,m2,m3,depth,1)){ ans_cards.push(i+1); ans_target.push(1); return true; } if(m2\u003e0 \u0026\u0026 stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1,m2-reald,m3,depth,1)){ ans_cards.push(i+1); ans_target.push(2); return true; } if(m3\u003e0 \u0026\u0026 stone-card.cost\u003e=0 \u0026\u0026 dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1,m2,m3-reald,depth,1)){ ans_cards.push(i+1); ans_target.push(3); return true; } } used[i]=0; } if(dfs(10,0,bl_me,bl_en,m1,m2,m3,depth+1)){ ans_cards.push(-1); ans_target.push(-1); return true; } return false; } int mc1,mc2,mc3; int bl_me,bl_en; int main(){ ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); int kase;cin\u003e\u003ekase; while(kase--){ memset(used,0,sizeof(used)); while(!ans_cards.empty())ans_cards.pop(); while(!ans_target.empty())ans_target.pop(); cin\u003e\u003enlen; cin\u003e\u003ebl_me\u003e\u003ebl_en; cin\u003e\u003emd1\u003e\u003emc1\u003e\u003emx1; cin\u003e\u003emd2\u003e\u003emc2\u003e\u003emx2; cin\u003e\u003emd3\u003e\u003emc3\u003e\u003emx3; for(int i=0;i\u003cnlen;i++){ cards[i].cost=cards[i].damage=cards[i].power=cards[i].type=0; int type;cin\u003e\u003etype; if(type==1 || type==2){ int cost,x,y; cin\u003e\u003ecost\u003e\u003ex\u003e\u003ey; cards[i].type=type; cards[i].cost=cost; cards[i].damage=x; cards[i].power=y; }else{ int cost,x; cin\u003e\u003ecost\u003e\u003ex; cards[i].type=type; cards[i].cost=cost; cards[i].damage=x; } } ans_cards.push(-1); ans_target.push(-1); if(dfs(10,0,bl_me,bl_en,mc1,mc2,mc3,0)){ cout\u003c\u003c\"Yes\\n\"; }else{ cout\u003c\u003c\"No\\n\"; continue; } int block=0; while(!ans_cards.empty()){ queue\u003cint\u003e pack_ans,pack_target; while(!ans_cards.empty() \u0026\u0026 ans_cards.top()!=-1){ pack_ans.push(ans_cards.top()); ans_cards.pop(); pack_target.push(ans_target.top()); ans_target.pop(); } if(!ans_cards.empty()){ ans_cards.pop(); ans_target.pop(); } if(pack_ans.empty())continue; cout\u003c\u003cpack_ans.size()\u003c\u003c\"\\n\"; while(!pack_ans.empty()){ cout\u003c\u003cpack_ans.front()\u003c\u003c\" \"; pack_ans.pop(); } cout\u003c\u003c\"\\n\"; while(!pack_target.empty()){ cout\u003c\u003cpack_target.front()\u003c\u003c\" \"; pack_target.pop(); } cout\u003c\u003c\"\\n\"; block++; } while(block\u003c3){ cout\u003c\u003c\"0\\n\"; block++; } } return 0; } ","date":"2019-10-23","objectID":"/2019/10/ccpc2017hangzhou-heathrock/:2:0","tags":["搜索"],"title":"[CCPC2017杭州] Heathrock","uri":"/2019/10/ccpc2017hangzhou-heathrock/"},{"categories":["code"],"content":"给出2个数列，${a_i},{b_i}$.要求支持以下操作 修改数列a的第i个为x 修改数列b的第i个为x 给出k，求最小的t，满足$\\sum \\lfloor \\frac {t-b_i}{a_i} \\rfloor \\ge k$ 操作数不多于100000，操作3不多于1000；数列长度不多于10000，a的值域不大于1000。 ","date":"2019-10-21","objectID":"/2019/10/ccpc-2017-master-of-sequence/:0:0","tags":null,"title":"[CCPC 2017] Master of Sequence","uri":"/2019/10/ccpc-2017-master-of-sequence/"},{"categories":["code"],"content":"分析 将$\\lfloor \\frac {t-b_i}{a_i} \\rfloor$拆开，观察前后可能出现的差。 $$ \\lfloor \\frac {t}{a_i} \\rfloor - \\lfloor \\frac {b_i}{a_i} \\rfloor $$ 设$t=k_1a_i+c_1,b_i=k_2a_i+c_2$，代入观察。 $$ \\begin{aligned} \\lfloor \\frac {t-b_i}{a_i} \\rfloor\u0026=\\lfloor \\frac {(k_1-k_2)a_i+c_1-c_2}{a_i} \\rfloor \\\\ \\end{aligned} $$ 可以发现，当把式子拆开时，有2种情况。 $c_1 \u003e c_2$，啥事没有。 $c_1 \u003c c_2$，拆开后会多统计一个1。 事先统计${b_i}$模$a$的余数，那么有$t$后就能快速数出第2种情况的数量。 ","date":"2019-10-21","objectID":"/2019/10/ccpc-2017-master-of-sequence/:1:0","tags":null,"title":"[CCPC 2017] Master of Sequence","uri":"/2019/10/ccpc-2017-master-of-sequence/"},{"categories":["code"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXA=1010,MAXB=100010; int nlen,mlen; int a[MAXB],acnt[MAXA]; int b[MAXB]; int fts[MAXA][MAXA]; int pre[MAXA][MAXA]; void force(int i){ pre[i][0]=fts[i][0]; for(int j=1;j\u003cMAXA;j++){ pre[i][j]=pre[i][j-1]+fts[i][j]; } } ll base=0; bool check(ll k,ll t){ ll res=-base; for(int i=1;i\u003c=1000;i++){ res+=(t/i)*acnt[i]; int c=t%i; ll offset=pre[i][1000]-pre[i][c]; res-=offset; } return res\u003e=k; } int main(){ ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); int kase;cin\u003e\u003ekase; while(kase--){ memset(acnt,0,sizeof(acnt)); memset(a,0,sizeof(a)); base=0; memset(fts,0,sizeof(fts)); cin\u003e\u003enlen\u003e\u003emlen; for(int i=1;i\u003c=nlen;i++){ cin\u003e\u003ea[i]; acnt[a[i]]+=1; } for(int i=1;i\u003c=nlen;i++){ cin\u003e\u003eb[i]; fts[a[i]][b[i]%a[i]]++; base+=b[i]/a[i]; } for(int i=1;i\u003c=1000;i++){ force(i); } for(int i=1;i\u003c=mlen;i++){ int opt; cin\u003e\u003eopt; if(opt==1){ int x,y; cin\u003e\u003ex\u003e\u003ey; acnt[a[x]]--; fts[a[x]][b[x]%a[x]]--; base-=b[x]/a[x]; force(a[x]); a[x]=y; fts[a[x]][b[x]%a[x]]++; acnt[a[x]]++; base+=b[x]/a[x]; force(a[x]); }else if(opt==2){ int x,y; cin\u003e\u003ex\u003e\u003ey; fts[a[x]][b[x]%a[x]]--; base-=b[x]/a[x]; force(a[x]); b[x]=y; fts[a[x]][b[x]%a[x]]++; force(a[x]); base+=b[x]/a[x]; }else if(opt==3){ int qk;cin\u003e\u003eqk; ll l=0,r=1e13; while(l+1\u003cr){ ll mid=(l+r)/2; if(check(qk,mid)){ r=mid; }else l=mid+1; } for(ll i=l;i\u003c=r;i++){ if(check(qk,i)){ cout\u003c\u003ci\u003c\u003c\"\\n\"; break; } } } } } return 0; } ","date":"2019-10-21","objectID":"/2019/10/ccpc-2017-master-of-sequence/:2:0","tags":null,"title":"[CCPC 2017] Master of Sequence","uri":"/2019/10/ccpc-2017-master-of-sequence/"},{"categories":["code"],"content":"当在使用一指禅键入一个字符串的时候，你需要不停的移动手指。比如说输入“af”，手指需要跨过3个键（包括终点）输入“a”和“f”。 针对一个经常输入的字符串，你可以定制一个长条键盘，使得在这个键盘上输入字符串需要移动的距离最短。 给出字符串长度$n$与字典大小$k$（小写字母的前$k$个），给出最优情况下手指需要移动的距离。 ","date":"2019-10-09","objectID":"/2019/10/cfedu74-e-keyboard-purchase/:0:0","tags":null,"title":"[CFEDU74 E] Keyboard Purchase","uri":"/2019/10/cfedu74-e-keyboard-purchase/"},{"categories":["code"],"content":"分析 这道题和之前那道marbles很像……或者说状压都挺像的。 题目即依次决定键盘的下一个按键装啥，并在原字符串里计算需要移动的次数。设$f(S)$表示已经考虑了集合$S$里所有的按键。不过仔细思考一下发现这个代价需要知道先前安装的按键的顺序，而这个顺序显然不能加入到状态里，这是无法接受的。必须要通过别的方式来计算。 然后我又卡了。 这是没见过的转移方式……考虑本轮没有排入键A，那么一定就排入了别的键B，那么，这次对于事件“排A”的一次delay会导致原串里A和相邻在键盘上已确定位置的字母间的转移多一个代价。 有种模糊的感觉。之前那个题目是计算当前元素和已有元素之间的代价；这个是计算已有元素和未有元素之间的累进式代价。搞不太清楚这个$f(S)$现在代表的是什么了…不知可否有人指导。 ","date":"2019-10-09","objectID":"/2019/10/cfedu74-e-keyboard-purchase/:1:0","tags":null,"title":"[CFEDU74 E] Keyboard Purchase","uri":"/2019/10/cfedu74-e-keyboard-purchase/"},{"categories":["code"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003cstring\u003eusing namespace std; using ll=long long; const int MAXK=21; int nlen,klen; string inp; int cost[MAXK][MAXK]; ll dp[1\u003c\u003c20]; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003enlen\u003e\u003eklen; cin\u003e\u003einp; for(int i=1;i\u003cnlen;i++){ cost[inp[i-1]-\u0026#039;a\u0026#039;][inp[i]-\u0026#039;a\u0026#039;]++; cost[inp[i]-\u0026#039;a\u0026#039;][inp[i-1]-\u0026#039;a\u0026#039;]++; } memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=0;i\u003c(1\u003c\u003cklen);i++){ ll scost=0; for(int j=0;j\u003cklen;j++){ if(!((i\u003e\u003ej)\u00261))continue; for(int k=0;k\u003cklen;k++){ if((i\u003e\u003ek)\u00261)continue; scost+=cost[j][k]; } } for(int j=0;j\u003cklen;j++){ if((i\u003e\u003ej)\u00261)continue; dp[i|(1\u003c\u003cj)]=min(dp[i|(1\u003c\u003cj)],dp[i]+scost); } } cout\u003c\u003cdp[(1\u003c\u003cklen)-1]\u003c\u003cendl; return 0; } ","date":"2019-10-09","objectID":"/2019/10/cfedu74-e-keyboard-purchase/:2:0","tags":null,"title":"[CFEDU74 E] Keyboard Purchase","uri":"/2019/10/cfedu74-e-keyboard-purchase/"},{"categories":["code"],"content":"You are given a directed graph with n vertices and m directed edges without self-loops or multiple edges. Let’s denote the k-coloring of a digraph as following: you color each edge in one of k colors. The k-coloring is good if and only if there no cycle formed by edges of same color. Find a good k-coloring of given digraph with minimum possible k. ","date":"2019-10-06","objectID":"/2019/10/cf-edu72d-coloring-edges/:0:0","tags":null,"title":"[CF EDU72D] Coloring Edges","uri":"/2019/10/cf-edu72d-coloring-edges/"},{"categories":["code"],"content":"分析 对我这个菜鸡来说，去染色返祖边的操作并不怎么显然……算了…… 没能坚持只有2种颜色的猜想。挂城墙。 没必要挂代码。 ","date":"2019-10-06","objectID":"/2019/10/cf-edu72d-coloring-edges/:1:0","tags":null,"title":"[CF EDU72D] Coloring Edges","uri":"/2019/10/cf-edu72d-coloring-edges/"},{"categories":["code"],"content":"Monocarp has arranged n colored marbles in a row. The color of the i-th marble is ai. Monocarp likes ordered things, so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment (and there is only one such segment for each color). In other words, Monocarp wants to rearrange marbles so that, for every color j, if the leftmost marble of color j is l-th in the row, and the rightmost marble of this color has position r in the row, then every marble from l to r has color j. To achieve his goal, Monocarp can do the following operation any number of times: choose two neighbouring marbles, and swap them. You have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles. Note that the order of segments of marbles having equal color does not matter, it is only required that, for every color, all the marbles of this color form exactly one contiguous segment. ","date":"2019-10-05","objectID":"/2019/10/cf585e-marbles/:0:0","tags":null,"title":"[CF585E] Marbles","uri":"/2019/10/cf585e-marbles/"},{"categories":["code"],"content":"分析 这道题的翻译就是“重新确定每个颜色的权值，使得逆序对最少”。 然后我就卡了，现在我也不是特别清楚为啥可以dp，只是知道能dp。 选择状态$f(S)$表示集合$S$已经全部分配权值时产生的最少逆序对。枚举下一个颜色，给予下一个（较小）权值，并计算代价。 $$ f(S+\\{i\\})=min\\{f(S)+w\\} $$ 接下来是w的处理。我们需要的是在当前颜色的所有点前的已经拥有新权值的点数目，这可以事先预处理。预处理颜色i前颜色j的pair数即可。 ","date":"2019-10-05","objectID":"/2019/10/cf585e-marbles/:1:0","tags":null,"title":"[CF585E] Marbles","uri":"/2019/10/cf585e-marbles/"},{"categories":["code"],"content":"代码 不小心把ptr扔到了里层循环里T了发… 明明第一步完事都很直白了，就是非得被卡一下。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ciomanip\u003e#include \u003cvector\u003e#include \u003cstack\u003e#include \u003ccstring\u003e#include \u003cstring\u003eusing namespace std; using ll=long long; const int MAXN = 400010; const int MAXC=21; int nlen; int num[MAXN]; vector\u003cint\u003e pos[MAXC]; ll cnt[MAXC][MAXC]; int tick=0; int newColor[MAXN]; ll dp[1\u003c\u003cMAXC]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003enlen; for(int i=0;i\u003cnlen;i++){ cin\u003e\u003enum[i]; } memset(newColor,-1,sizeof(newColor)); for(int i=0;i\u003cnlen;i++){ if(newColor[num[i]]==-1)newColor[num[i]]=tick++; pos[newColor[num[i]]].push_back(i); } for(int i=0;i\u003ctick;i++){ for(int j=0;j\u003ctick;j++){ if(i==j)continue; int ptr=0; for(int k=0;k\u003cpos[i].size();k++){ if(ptr\u003c0)ptr=0; while(ptr\u003cpos[j].size() \u0026\u0026 pos[j][ptr]\u003cpos[i][k])ptr++; ptr--; if(ptr\u003e=0 \u0026\u0026 pos[j][ptr]\u003cpos[i][k]){ cnt[i][j]+=ptr+1; } } } } memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=0;i\u003c(1\u003c\u003ctick);i++){ for(int j=0;j\u003ctick;j++){ if((i\u003e\u003ej)\u00261)continue; ll diff=0; for(int k=0;k\u003ctick;k++){ if((i\u003e\u003ek)\u00261)diff+=cnt[j][k]; } dp[i|(1\u003c\u003cj)]=min(dp[i|(1\u003c\u003cj)],dp[i]+diff); } } cout\u003c\u003cdp[(1\u003c\u003ctick)-1]\u003c\u003cendl; return 0; } ","date":"2019-10-05","objectID":"/2019/10/cf585e-marbles/:2:0","tags":null,"title":"[CF585E] Marbles","uri":"/2019/10/cf585e-marbles/"},{"categories":["code"],"content":"Monocarp and Bicarp live in Berland, where every bus ticket consists of n digits (n is an even number). During the evening walk Monocarp and Bicarp found a ticket where some of the digits have been erased. The number of digits that have been erased is even. Monocarp and Bicarp have decided to play a game with this ticket. Monocarp hates happy tickets, while Bicarp collects them. A ticket is considered happy if the sum of the first $\\frac n2$ digits of this ticket is equal to the sum of the last $\\frac n2$ digits. Monocarp and Bicarp take turns (and Monocarp performs the first of them). During each turn, the current player must replace any erased digit with any digit from 0 to 9. The game ends when there are no erased digits in the ticket. If the ticket is happy after all erased digits are replaced with decimal digits, then Bicarp wins. Otherwise, Monocarp wins. You have to determine who will win if both players play optimally. ","date":"2019-10-05","objectID":"/2019/10/cf585d-ticket-game/:0:0","tags":null,"title":"[CF585D] Ticket Game","uri":"/2019/10/cf585d-ticket-game/"},{"categories":["code"],"content":"分析 在做这道题的时候，我发现了实际上影响答案的只和两边的 已知数的和 以及未知位的数目有关，发现了获胜的根本是前后两部分和的差值大小，发现了先手的目的是扩大差值使得后手无法通过某种方式追赶。 但是到这我就卡住了。淦，为什么我这么菜。 接下来要考虑的是优势，在这道题里优势就是差值。先手的目的是扩大优势，在大的一边增大会加大优势，而在小的一边置0不会扩大优势；后手要减小优势，同样的办法就是在小的一侧置数来追赶另一侧，在大的一侧置0不会更好。 那么，又可以得出先手扩大优势最好的办法是置9（最大）。那么游戏最开始的几步，就是双方在两侧填写9。直到某侧不再有空位。 此时，如果空位在大的一侧，先手必赢。如果空位在小的一侧，继续讨论如下 $$ x_1+x_2+\\cdots+x_n=C $$ 首先$2|n$显然。 当C不是9的倍数时，先手总有办法让最终结果偏离。因此该情况只有当$\\frac n2 \\times 9 = n$时后手才能获胜。 ","date":"2019-10-05","objectID":"/2019/10/cf585d-ticket-game/:1:0","tags":null,"title":"[CF585D] Ticket Game","uri":"/2019/10/cf585d-ticket-game/"},{"categories":["code"],"content":"代码 嫖了队友的…我瞎xx搞的结论WA23了… #include\u003cbits/stdc++.h\u003eusing namespace std; char s[200005]; int main() { int n; scanf(\"%d\",\u0026n); scanf(\"%s\",s+1); int cnt=0; int sum=0; for(int i=1;i\u003c=n/2;i++) { if(s[i]==\u0026#039;?\u0026#039;) cnt++; else sum+=s[i]-\u0026#039;0\u0026#039;; } for(int i=n/2+1;i\u003c=n;i++) { if(s[i]==\u0026#039;?\u0026#039;) cnt--; else sum-=s[i]-\u0026#039;0\u0026#039;; } //cout\u003c\u003ccnt\u003c\u003c\" \"\u003c\u003csum\u003c\u003cendl; if(sum*2==-cnt*9) puts(\"Bicarp\"); else puts(\"Monocarp\"); } ","date":"2019-10-05","objectID":"/2019/10/cf585d-ticket-game/:2:0","tags":null,"title":"[CF585D] Ticket Game","uri":"/2019/10/cf585d-ticket-game/"},{"categories":["学习"],"content":"如你所见，后缀自动机。 然而就nm看不懂，先看不懂它的图是啥，又看不懂它的边是啥，现在还是看不懂它的边是咋找出来的。可是咱不想搞不清楚它是干嘛的就直接用啊靠。 后缀自动机首先是自动机。一个字符串S的后缀自动机能接受S的所有后缀。基于它的这个性质，它能够做到： 查询子串是否出现：这显然跑一次，能在自动机上跑完就是出现过。 统计不同子串的数量：自动机上每条不同的路径对应一个不同的子串。定义$d(x)$为以x为起点的路径数目，递推即可。 计算所有不同子串的长度总和：得到上面的$d$。以x为起点，每条路径都会让子串总长度增加路径个。依然是递推。 字典序第k小子串：当你有路径数了，只需要按照字典序对节点排序，然后像编码一样找。 最小循环移位：指将原字符串首尾相接移位，找到字典序最小的一个。将字符串$S$断环成链$SS$，然后建立SAM，贪心找最小直到长度达到$|S|$即可。 多组子串出现次数：dfs预处理每个节点的终点集合大小。在自动机上查找串$P$对应的节点,存在则答案为该节点的终点集合大小；不存在答案为$0$. 所有出现位置：遍历树，一旦发现终点直接输出。 ","date":"2019-10-04","objectID":"/2019/10/sam/:0:0","tags":null,"title":"后缀自动机","uri":"/2019/10/sam/"},{"categories":["学习"],"content":"建立 最暴力的方式是建立一个O(n^2)级别的自动机，不过那个复杂度就没什么意义了。后缀自动机需要满足状态数最少，为线性级别，且转移（边）也为线性级别。 然后，我们可以开始折腾了。 定义串S的$endpos(x)$为一个集合，元素为x在其内出现的所有位置的结尾下标。 ","date":"2019-10-04","objectID":"/2019/10/sam/:1:0","tags":null,"title":"后缀自动机","uri":"/2019/10/sam/"},{"categories":["学习"],"content":"资料 参考资料 2015年国家集训队论文 ","date":"2019-10-04","objectID":"/2019/10/sam/:2:0","tags":null,"title":"后缀自动机","uri":"/2019/10/sam/"},{"categories":["学习"],"content":"子串第一次出现的位置 对SAM中所有状态预处理firstpos（第一次出现该状态的末端位置，也就是endpos集合的最小元素）。 扩展源函数为sam_extend()。创建新状态cur时，令 $$ firstpos(cur)=len(cur)-1 $$ 当q复制到clone时，令 $$ firstpos(clone)=firstpos(q) $$ 需要的答案就是$firstpos(t)-|P|+1$，$t$为字符串$P$的状态。每次查询需要$O(|P|)$ ","date":"2019-10-04","objectID":"/2019/10/sam/:2:1","tags":null,"title":"后缀自动机","uri":"/2019/10/sam/"},{"categories":["学习"],"content":"最短未出现字符串 动态规划。 让$d_v$为节点$v$的答案。如果不存在使用字符集中至少一个字符的转移，那么$d_v=1$，否则 $$ d_v=1+\\min_{w:(v,w,c) \\in SAM} d_w $$ 字符串可以由转移推回去。 ","date":"2019-10-04","objectID":"/2019/10/sam/:2:2","tags":null,"title":"后缀自动机","uri":"/2019/10/sam/"},{"categories":["code"],"content":"设$primes(x)$为x的质因数的集合。 设$g(x,p)$表示可以整除x的最大的$p^k$。 设$f(x,y)$表示将x作分解后对每个质因子作用到1到y上求$g$的乘积。 求$f(x,n)$ ","date":"2019-09-30","objectID":"/2019/09/cf589c-primes-and-multiplication/:0:0","tags":null,"title":"[CF589C] primes and multiplication","uri":"/2019/09/cf589c-primes-and-multiplication/"},{"categories":["code"],"content":"分析 ……最后你会发现，这题就是求阶乘质因子的乘积。 ","date":"2019-09-30","objectID":"/2019/09/cf589c-primes-and-multiplication/:1:0","tags":null,"title":"[CF589C] primes and multiplication","uri":"/2019/09/cf589c-primes-and-multiplication/"},{"categories":["code"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003ccmath\u003eusing namespace std; const int MAXN=1010; using ll=long long; const ll P=1e9+7; vector\u003cll\u003e primes; void unpack(ll x){ ll b=x; for(int i=2;i\u003c=sqrt(b)+1;i++){ if(x%i==0)primes.push_back(i); while(x%i==0)x/=i; } if(x!=1)primes.push_back(x); } ll qpow(ll a,ll b,ll p){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%p){ if(b\u00261)res=res*a%p; } return res; } ll get(ll n,ll num){ ll res=0; while(n){ res=(res+n/num)%(P-1); n/=num; } return res; } int main(){ ios::sync_with_stdio(false); ll x,n;cin\u003e\u003ex\u003e\u003en; unpack(x); ll ans=1; for(ll item:primes){ ans=ans*qpow(item,get(n,item),P)%P; } cout\u003c\u003cans%P\u003c\u003cendl; return 0; } ","date":"2019-09-30","objectID":"/2019/09/cf589c-primes-and-multiplication/:2:0","tags":null,"title":"[CF589C] primes and multiplication","uri":"/2019/09/cf589c-primes-and-multiplication/"},{"categories":["code"],"content":"给出一些点，询问对于点$(x,y)$，求其能和已知点形成多少个直角三角形。 ","date":"2019-09-29","objectID":"/2019/09/ccpc2019-qinhuangdao-angel-beats/:0:0","tags":["计算几何"],"title":"[CCPC2019 秦皇岛] Angel Beats","uri":"/2019/09/ccpc2019-qinhuangdao-angel-beats/"},{"categories":["code"],"content":"分析 首先，对于询问的点，直接加入集合离线操作就可以。这道题就变成了单纯的求三角形。一开始我跟求锐角三角形那道题一样做，然后写得又恶心又不知道哪里出了bug改不出来。 后来，实际上可以事先直接枚举2点按照斜率统计边数，对每个查询$lg(n^2)$查询，会省很多事。 之后的就是很显然的：查询点作为直角扫一遍，查询点作为非直角扫一遍。 ","date":"2019-09-29","objectID":"/2019/09/ccpc2019-qinhuangdao-angel-beats/:1:0","tags":["计算几何"],"title":"[CCPC2019 秦皇岛] Angel Beats","uri":"/2019/09/ccpc2019-qinhuangdao-angel-beats/"},{"categories":["code"],"content":"代码 淦。 #include \u003ciostream\u003e#include \u003cmap\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; using ll = long long; const int MAXN = 2010; struct Point { ll x, y; Point(ll x, ll y) : x(x), y(y){}; Point(){} Point normalize() const { if (x \u003c 0 || (x == 0 \u0026\u0026 y \u003c 0)) return Point(-x, -y); return *this; } Point operator-(const Point \u0026other) const { return Point(x - other.x, y - other.y); } bool operator\u003c(const Point \u0026other) const { //将线按照斜率排序，以在map中统计到一起。 Point a = normalize(), b = other.normalize(); return a.y * b.x \u003c b.y * a.x; } }; using Vec = Point; Point origin[MAXN],queries[MAXN]; int ans[MAXN]; map\u003cVec,int\u003e mp; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int nlen, qlen; while (cin \u003e\u003e nlen \u003e\u003e qlen) { memset(ans,0,sizeof(ans)); for (int i = 0; i \u003c nlen; i++) { cin\u003e\u003eorigin[i].x\u003e\u003eorigin[i].y; } for (int i = 0; i \u003c qlen; i++) { cin\u003e\u003equeries[i].x\u003e\u003equeries[i].y; } for (int i = 0; i \u003c nlen; i++) { mp.clear(); for (int j = 0; j \u003c nlen; j++) { if (i == j) continue; Vec temp = origin[j] - origin[i]; mp[temp]++; } for (int j = 0; j \u003c qlen; j++) { Vec temp = queries[j] - origin[i]; ans[j] += mp[Vec(-temp.y, temp.x)]; } } /* cout\u003c\u003c\"====not====\"\u003c\u003cendl; for(int i=0;i\u003cqlen;i++){ cout\u003c\u003cans[i]\u003c\u003c\"\\t\"; } cout\u003c\u003cendl\u003c\u003c\"====not====\"\u003c\u003cendl; */ for (int i = 0; i \u003c qlen; i++) { mp.clear(); for (int j = 0; j \u003c nlen; j++) { Vec temp = origin[j] - queries[i]; ans[i] += mp[Vec(-temp.y, temp.x)]; mp[temp]++; } } for (int i = 0; i \u003c qlen; i++) { cout \u003c\u003c ans[i] \u003c\u003c \"\\n\"; } } return 0; } ","date":"2019-09-29","objectID":"/2019/09/ccpc2019-qinhuangdao-angel-beats/:2:0","tags":["计算几何"],"title":"[CCPC2019 秦皇岛] Angel Beats","uri":"/2019/09/ccpc2019-qinhuangdao-angel-beats/"},{"categories":["code"],"content":"Petya recently found a game “Choose a Square”. In this game, there are nn points numbered from 11 to nn on an infinite field. The ii-th point has coordinates (xi,yi) and cost ci. You have to choose a square such that its sides are parallel to coordinate axes, the lower left and upper right corners belong to the line y=x, and all corners have integer coordinates. The score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square. Note that the length of the side can be zero. Petya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square. {% asset_img a.png %} ","date":"2019-09-23","objectID":"/2019/09/cf1221f-choose-a-sequence/:0:0","tags":null,"title":"[CF1221F] Choose a Sequence","uri":"/2019/09/cf1221f-choose-a-sequence/"},{"categories":["code"],"content":"分析 这道题其实和多校的Snowy Smile（题文无关）挺像的。 需要转化条件。正方形全部位于坐标系第一象限的平分线上，可以表示为$(l,r)$这种形式。一个在正方形内的点$(x,y)$(假设$x \u003c y$,由于这个题目的特性，不满足时可以直接调换)满足的条件为 $$l \\leq x \\leq y \\leq r$$ 由此，这道题就变成了二维偏序。本来的本来，上个长得像树状数组一类的东西就解决了。 将点按照第一维排序，从大到小枚举，在数据结构中维护结尾到r的前缀和最大值，并查询，更新全局答案。不过这个题目还要求权值要减去正方形边长w。 $$f(r)-(r-l)=l+[f(r)-r]$$ 维护最大值，y分开，只在pushup时合在一起。 然后还要离散化…… ","date":"2019-09-23","objectID":"/2019/09/cf1221f-choose-a-sequence/:1:0","tags":null,"title":"[CF1221F] Choose a Sequence","uri":"/2019/09/cf1221f-choose-a-sequence/"},{"categories":["code"],"content":"代码 这题给我整自闭了，我想用线段树单点修改来魔幻维护我需要的数据，加加减减。结果发现2种维护方式都有无法解决的问题。最后只能打tag。 线段树维护$f(n)$为到$n$为止的前缀和。每次加点以$x$为组，对已有点减去新增线段的长度，再加上新点的影响。那么在线段树上维护的就是答案。取出最大值即可。 代码写得又长又丑，不过过了。 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; using ll=long long; const int MAXN=500010*4; ll tag[MAXN]; ll dMax[MAXN]; int dy[MAXN]; int lc[MAXN],rc[MAXN],idx=0; void build(int \u0026n,int l,int r){ if(!n)n=++idx; dy[n]=r; if(l\u003e=r){ tag[n]=0; return; } int mid=(l+r)/2; build(lc[n],l,mid); build(rc[n],mid+1,r); } void pushdown(int n,int l,int r){ if(!tag[n])return; tag[lc[n]]+=tag[n]; tag[rc[n]]+=tag[n]; dMax[lc[n]]+=tag[n]; dMax[rc[n]]+=tag[n]; tag[n]=0; } void collect(int n){ if(dMax[lc[n]]\u003edMax[rc[n]]){ dMax[n]=dMax[lc[n]]; dy[n]=dy[lc[n]]; }else{ dMax[n]=dMax[rc[n]]; dy[n]=dy[rc[n]]; } } void modify(int l,int r,int x,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ tag[n]+=x; dMax[n]+=x; return; } pushdown(n,L,R); int mid=(L+R)/2; if(l\u003c=mid)modify(l,r,x,L,mid,lc[n]); if(mid\u003cr)modify(l,r,x,mid+1,R,rc[n]); collect(n); } bool operator\u003c(const pair\u003cll,int\u003e \u0026a,const pair\u003cll,int\u003e \u0026b){ return a.first\u003cb.first; } pair\u003cll,int\u003e query(int l,int r,int L,int R,int n){ if(l\u003c=L \u0026\u0026 R\u003c=r){ return make_pair(dMax[n],dy[n]); } pushdown(n,L,R); int mid=(L+R)/2; pair\u003cll,int\u003e res=make_pair(-0x3f3f3f3f,0); if(l\u003c=mid)res=max(res,query(l,r,L,mid,lc[n])); if(mid\u003cr)res=max(res,query(l,r,mid+1,R,rc[n])); return res; } struct Point{ int x,y,w; } points[MAXN]; vector\u003cint\u003e nums; int root=0; int main(){ /* build(root,1,10); int opt; while(cin\u003e\u003eopt){ if(opt==1){ int l,r,x;cin\u003e\u003el\u003e\u003er\u003e\u003ex; modify(l,r,x,1,10,root); } if(opt==2){ int l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003cquery(l,r,1,10,root).first\u003c\u003c\" \"\u003c\u003cquery(l,r,1,10,root).second\u003c\u003cendl; } } */ int nlen;cin\u003e\u003enlen; for(int i=1;i\u003c=nlen;i++){ Point \u0026p=points[i]; cin\u003e\u003ep.x\u003e\u003ep.y\u003e\u003ep.w; if(p.x\u003ep.y)swap(p.x,p.y); nums.push_back(p.y); nums.push_back(p.x); } sort(nums.begin(),nums.end()); auto rit=unique(nums.begin(),nums.end()); for(int i=1;i\u003c=nlen;i++){ points[i].x=lower_bound(nums.begin(),rit,points[i].x)-nums.begin(); points[i].y=lower_bound(nums.begin(),rit,points[i].y)-nums.begin(); } sort(points+1,points+1+nlen,[](const Point \u0026a,const Point \u0026b){ if(a.x!=b.x)return a.x\u003eb.x; return a.y\u003cb.y; }); int len=rit-nums.begin()-1; build(root,0,len); vector\u003cint\u003e::iterator lastit=rit-1; pair\u003cll,int\u003e ans=make_pair(-0x3f3f3f3f,0); int pairl=-0x3f3f3f3f; for(int i=1;i\u003c=nlen;i++){ int thisx=points[i].x; //auto it=lower_bound(nums.begin(),rit,points[i].x); auto it=nums.begin()+thisx; for(;lastit!=it;lastit--){ modify(lastit-nums.begin(),len,*(lastit-1)-*lastit,0,len,root); //cout\u003c\u003c\"cost \"\u003c\u003c*(lastit-1)-*lastit\u003c\u003c\" from \"\u003c\u003clastit-nums.begin()\u003c\u003c\" to \"\u003c\u003clen\u003c\u003cendl; } /* for(int j=0;j\u003c=len;j++){ cout\u003c\u003cquery(j,j,0,len,root).first\u003c\u003c\"\\t\"; } cout\u003c\u003cendl; */ while(i\u003c=nlen \u0026\u0026 points[i].x==thisx){ const Point \u0026p=points[i]; modify(p.y,len,p.w,0,len,root); //cout\u003c\u003c\"add \"\u003c\u003cp.w\u003c\u003c\" from \"\u003c\u003cp.y\u003c\u003c\" to \"\u003c\u003clen\u003c\u003cendl; i++; } i--; /* for(int j=0;j\u003c=len;j++){ auto temp2=query(j,j,0,len,root); cout\u003c\u003ctemp2.first\u003c\u003c\",\"\u003c\u003ctemp2.second\u003c\u003c\"\\t\"; } cout\u003c\u003cendl; */ pair\u003cll,int\u003e temp=query(0,len,0,len,root); if(ans\u003c=temp){ ans=temp; pairl=nums[thisx]; } } if(ans.first\u003e0){ cout\u003c\u003cans.first\u003c\u003cendl; cout\u003c\u003cpairl\u003c\u003c\" \"\u003c\u003cpairl\u003c\u003c\" \"\u003c\u003cnums[ans.second]\u003c\u003c\" \"\u003c\u003cnums[ans.second]\u003c\u003cendl; }else{ cout\u003c\u003c0\u003c\u003cendl; cout\u003c\u003c*nums.rbegin()+1\u003c\u003c\" \"\u003c\u003c*nums.rbegin()+1\u003c\u003c\" \"\u003c\u003c*nums.rbegin()+1\u003c\u003c\" \"\u003c\u003c*nums.rbegin()+1\u003c\u003cendl; } return 0; } ","date":"2019-09-23","objectID":"/2019/09/cf1221f-choose-a-sequence/:2:0","tags":null,"title":"[CF1221F] Choose a Sequence","uri":"/2019/09/cf1221f-choose-a-sequence/"},{"categories":["闲扯"],"content":"Mathematica是个好东西。虽然早有耳闻功能强大，但是没想到强大到这种地步。 原本因为课程原因，研究了一下如何在Mathematica里绘制股票数据。不过现在停止，只完成了一小部分。剩下的……想折腾的话，按照已经有的代码，能容易改出来其他功能。 ","date":"2019-09-20","objectID":"/2019/09/mathematica-in-stocks/:0:0","tags":null,"title":"使用Mathematica绘制股票相关曲线","uri":"/2019/09/mathematica-in-stocks/"},{"categories":["闲扯"],"content":"数据来源 首先要说的是，Mathematica中自行提供了非权威的金融数据。这对我们很方便。 使用命令FinancialData,就可以获取大量需要的数据。具体可以查看文档。不过问题是，不知何种原因，该函数对深沪股票支持很差，所以在实际使用时，并不能直接使用该函数，比较可惜…… 我们需要实现自己的数据处理。 经过一番寻找后，我发现了一个基于Python的证券数据平台baostock。经过简单的封装后，Mathematica就可以使用Python从平台上拉取数据了。 这个例子只能拉取日K。 BeginPackage[\"StockLink`\"]StockLink::usage=\"StockLink\";CloseLink::usage=\"CloseLink\";DailyKLine::usage=\"Get KLine data\";CandlestickData::usage=\"adjust KLine data to fit Candlestick Chart\";TradingChartData::usage=\"adjust KLine data to fit Trading Chart\";Begin[\"`Private`\"]StockLink[]:=Module[{conn},conn=StartExternalSession[\"Python\"];ExternalEvaluate[conn,\"importbaostockasbslg=bs.login()\"];conn];CloseLink[conn_]:=Module[{},ExternalEvaluate[conn,\"bs.logout()\"];DeleteObject[conn];];MMAListToPythonList[list_]:=StringReplace[ToString[list,InputForm],{\"\\\"\"-\u003e\"'\",\"{\"-\u003e\"[\",\"}\"-\u003e\"]\"}];DateObjectToStr[date_]:=DateString[date,\"ISODate\"];DailyKLine[conn_,code_,startDate_,endDate_]:=Module[{},raw=ExternalEvaluate[conn,StringTemplate[\"rs=bs.query_history_k_data_plus('``','date,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,isST',start_date='``',end_date='``',frequency='d',adjustflag='3')data_list={}while(rs.error_code=='0')\u0026rs.next():temp=rs.get_row_data()data_list[temp[0]]=temp[1:];data_list\"][code,DateObjectToStr[startDate],DateObjectToStr[endDate]]];ToExpression[#]\u0026/@raw];CandlestickData[raw_]:=Table[{DateObject[key],raw[key][[1;;4]]},{key,Keys[raw]}];TradingChartData[raw_]:=Table[{DateObject[key],raw[key][[1;;5]]},{key,Keys[raw]}];End[]EndPackage[] ","date":"2019-09-20","objectID":"/2019/09/mathematica-in-stocks/:1:0","tags":null,"title":"使用Mathematica绘制股票相关曲线","uri":"/2019/09/mathematica-in-stocks/"},{"categories":["闲扯"],"content":"图表绘制 在实际使用时，首先需要导入该库，并且初始化链接后，灵活组合各部分功能即可。 \u003c\u003c(NotebookDirectory[]\u003c\u003e\"StockLink.wl\");conn=StockLink[];(:例如获取某个日期区间内的数据并转化，绘制交互图标:)DailyKLine[conn,\"ss.000001\",Today,Today]//TradingChartData//InteractiveTradingChart 输入日期时，可以直接按ctrl+=，在框中描述时间，比较方便。 ","date":"2019-09-20","objectID":"/2019/09/mathematica-in-stocks/:2:0","tags":null,"title":"使用Mathematica绘制股票相关曲线","uri":"/2019/09/mathematica-in-stocks/"},{"categories":["闲扯"],"content":"可能遇到的问题 如果python配置不对的话，可能会出现Mathematica找不到python。问题的解决方法在官方文档上非常清晰。 不过我不折腾股票，就这样了。 ","date":"2019-09-20","objectID":"/2019/09/mathematica-in-stocks/:3:0","tags":null,"title":"使用Mathematica绘制股票相关曲线","uri":"/2019/09/mathematica-in-stocks/"},{"categories":["学习"],"content":"技巧 ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:1:0","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"自然溢出 自然溢出不会影响低位数据,所以有的时候你不需要取模,而是一个unsigned. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:1:1","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"除法取模 对于式子 $$ \\frac {a \\times b}{c} \\mod p \\equiv \\frac{a \\times b \\mod cp}{c} $$ ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:1:2","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"细节 注意数据类型,例如6*(ll)(1\u003c\u003c30)是要出问题的 注意函数在$f(1)$位置的取值,不要忘记初始化 ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:2:0","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"单点$\\phi$的求解 ll euler_phi(ll n) { ll m = sqrt(n + 0.5); ll ans = n; for (ll i = 2; i \u003c= m; i++) if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } if (n \u003e 1) ans = ans / n * (n - 1); return ans; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:3:0","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"Divisor Given $n$ and $m$ ($1 \\leq n,m \\leq 5 \\times 10^4$), please calculate ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:4:0","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"分析 下面所有的除法都是舍去小数的整除. $$ \\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) \u0026= \\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}[p \\perp q] \\\\ \u0026=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d|(p,q)}\\mu(d) \\\\ \u0026=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d}\\mu(d)[d|p][d|q] \\\\ \u0026=\\sum_d \\mu(d)\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{pd} \\sum_{qd}[pd|i][qd|j] \\\\ \u0026=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd}\\sum_{i=1}^{n/pd}\\sum_{j=1}^{m/qd} \\\\ \u0026=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd} \\frac n {pd}\\frac m {qd} \\\\ \u0026=\\sum_d \\mu(d) \\sum_p^{n/d} \\frac n {pd} \\sum_q^{m/d} \\frac m {qd} \\\\ \\end{aligned} $$ 设$S(n)=\\sum_{1\\leq i \\leq n} \\frac n i$ $$ \\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) \u0026=\\sum_d \\mu(d)S(n/d)S(m/d) \\end{aligned} $$ $n/d$的取值在一个区间中是相同的,因此可以把这个求和公式分块计算.(在分块后,需要获知该段区域内$\\mu$的和,所以需要求前缀和)由于$n/d$的取值为$O(\\sqrt n)$的级别,因此在知道$S$的值的情况下,每个询问可以这个复杂度中计算出来. 对于$\\mu$,使用筛法,并求出其前缀和. 对于$S$,直接暴力计算. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:4:1","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; using ll=long long; const int MAXN=50010; bool isn_p[MAXN]; vector\u003cint\u003e primes; int mu[MAXN]; int premu[MAXN]; void init_prime(int len){ isn_p[1]=1; mu[1]=1; for(int i=2;i\u003c=len;i++){ if(!isn_p[i]){ primes.push_back(i); mu[i]=-1; } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=len;j++){ isn_p[i*primes[j]]=1; mu[i*primes[j]]=mu[i]*-1; if(i%primes[j]==0){ mu[i*primes[j]]=0; break; } } } premu[0]=0; for(int i=1;i\u003c=len;i++)premu[i]=premu[i-1]+mu[i]; } ll S[MAXN]; void init_S(int len){ for(int i=1;i\u003c=len;i++){ for(int l=1,r;l\u003c=i;l=r+1){ //remember this line r=i/(i/l); S[i]+=(ll)(r-l+1)*(i/l); } } } int main(){ ios::sync_with_stdio(false); init_prime(50000); init_S(50000); int kase;cin\u003e\u003ekase; while(kase--){ int n,m;cin\u003e\u003en\u003e\u003em; ll ans=0; // the minimum one will fastly approach to 0, leading the extra parts of bigger one do nothing to the answer. int minn=min(n,m); for(int l=1,r;l\u003c=minn;l=r+1){ r=min(n/(n/l),m/(m/l)); ans+=S[n/l]*S[m/l]*(premu[r]-premu[l-1]); } cout\u003c\u003cans\u003c\u003cendl; } return 0; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:4:2","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"table 给出多组$n,m,a$,求 $$ \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j))[\\sigma_1((i,j)) \\geq a] $$ ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:5:0","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"分析 这道题让谁都能看出来重点是如何处理条件 $$[\\sigma_1((i,j)) \\geq a]$$ 可是这我显然不知道该怎么做. 对询问作以$a$从小到大离线处理,询问前先处理新增$a$的影响. 在已经满足条件的前提下对公式作化简. $$ \\begin{aligned} \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j)) \u0026= \\sum_d \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1(d)[(i,j)=d] \\\\ \u0026=\\sum_d \\sum_{i\\leq \\frac nd}\\sum_{j\\leq \\frac md}\\sigma_1(d)[(i,j)=1] \\\\ \u0026=\\sum_d \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}}\\sigma_1(d) \\sum_t \\mu(t) \\\\ \u0026=\\sum_d \\sum_t \\mu(t) \\sigma_1(d) \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}} 1 \\\\ \u0026=\\sum_T \\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor \\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td) \\end{aligned} $$ 可以看到还是套路,引入d,引入$\\mu$,之后胡乱化简. 按照这个式子,需要计算的就是$g(x)=\\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)$的前缀和. 接下来是如何处理条件… 当$a$每扩大一点,就有一部分$\\mu(t)\\sigma_1(\\frac Td)$被加入到函数$g$的各个部分.使用一种数据结构来维护$g$的前缀和,例如树状数组.$a$最大到,每次受到影响的就是$d$的倍数,以此可以计算出总的时间复杂度为 $$ WTF $$ 至此,问题就解决了. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:5:1","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"代码 又丑又长. #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccassert\u003eusing namespace std; using ll=long long; const int MAXN=100010; const int MAXQ=100010; const int MAXFT=400010; const ll P=(ll)1\u003c\u003c31; ll FT[MAXFT]; ll lowbit(int x){ return x\u0026-x; } void ftadd(int pos,ll x){ for(int i=pos;i\u003cMAXN;i+=lowbit(i)){ FT[i]=(FT[i]+x); } } ll ftget(int pos){ ll res=0; for(int i=pos;i;i-=lowbit(i)){ res=(res+FT[i]); } return res; } ll qpow(ll a,ll b,ll p){ ll res=1; for(b;b;b\u003e\u003e=1,a=(a*a)%p){ if(b\u00261)res=(res*a)%p; } return res; } ll qpow(ll a,ll b){ ll res=1; for(b;b;b\u003e\u003e=1,a=(a*a)){ if(b\u00261)res=(res*a); } return res; } bool is_np[MAXN]; ll sigma[MAXN],mu[MAXN]; int t[MAXN]; vector\u003cint\u003e primes; struct Sig{ ll sigma; int x; Sig(){} Sig(int x,ll sigma):x(x),sigma(sigma){} }; vector\u003cSig\u003e sigma_vec; void init(int n){ is_np[1]=1; sigma[1]=1; mu[1]=1; for(int i=2;i\u003c=n;i++){ if(!is_np[i]){ primes.push_back(i); sigma[i]=i+1; t[i]=1; mu[i]=-1; } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=n;j++){ is_np[i*primes[j]]=1; sigma[i*primes[j]]=sigma[i]*sigma[primes[j]]; t[i*primes[j]]=1; mu[i*primes[j]]=mu[i]*-1; if(i%primes[j]==0){ t[i*primes[j]]=t[i]+1; sigma[i*primes[j]]=sigma[i/qpow(primes[j],t[i])]*((ll)1-qpow(primes[j],(t[i]+1)+1))/(1-primes[j]); mu[i*primes[j]]=0; break; } } } for(int i=1;i\u003c=n;i++){ sigma_vec.push_back(Sig(i,sigma[i])); } } struct Q{ int n,m,a; int i; ll ans; bool operator\u003c(const Q \u0026b)const{ return a\u003cb.a; } } qs[MAXQ]; ll f(int n){ return ftget(n); } int curidx=0; void mergea(int newa){ for(;curidx\u003csigma_vec.size();curidx++){ Sig \u0026sig=sigma_vec[curidx]; if(sig.sigma\u003enewa)break; for(int i=sig.x;i\u003cMAXN;i+=sig.x){ ftadd(i,mu[i/sig.x]*sig.sigma%P); } } } int main(){ init(100000); sort(sigma_vec.begin(),sigma_vec.end(),[](Sig \u0026a,Sig \u0026b){ return a.sigma\u003cb.sigma; }); int qlen;cin\u003e\u003eqlen; for(int i=0;i\u003cqlen;i++){ Q \u0026q=qs[i]; scanf(\"%d%d%d\",\u0026q.n,\u0026q.m,\u0026q.a); q.i=i; } sort(qs,qs+qlen,[](Q \u0026a,Q \u0026b){ return a.a\u003cb.a; }); for(int i=0;i\u003cqlen;i++){ Q \u0026q=qs[i]; int n=q.n,m=q.m,a=q.a; ll \u0026ans=q.ans=0; mergea(a); for(int l=1,r;l\u003c=min(n,m);l=r+1){ r=min(n/(n/l),m/(m/l)); ans=ans+(n/l)*(m/l)*(f(r)-f(l-1)); } } sort(qs,qs+qlen,[](Q \u0026a,Q \u0026b){ return a.i\u003cb.i; }); for(int i=0;i\u003cqlen;i++){ printf(\"%lld\\n\",qs[i].ans%P); } return 0; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:5:2","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"product 定义斐波纳妾(?)(linux这输入法够魔性)函数$f(x)$ 求 $$ \\prod_{i=1}^n \\prod_{j=1}^m f((i,j)) $$ ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:6:0","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"分析 首先,先引个$d$是没错了. 但是 这道题,我又不会.我不知道该怎么处理$\\prod$…蔡就完事了. 现在来看,当引入一个$d$后,在该求积公式里出现了相同项相乘.将该部分的计算调整为幂,剩下的就又都一样了. $$ \\begin{aligned} \\prod_{i=1}^n \\prod_{j=1}^m f((i,j)) \u0026= \\prod_d f(d)^{\\sum_{i\\leq n} \\sum_{j \\leq m} [(i,j)=d]} \\\\ \u0026=\\prod_d f(d)^{\\sum_{i\\leq \\frac nd} \\sum_{j \\leq \\frac md} [(i,j)=1]} \\\\ \u0026=\\prod_d f(d)^{\\sum_t \\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\ \u0026=\\prod_d \\prod_t f(d)^{\\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\ \u0026=\\prod_T (\\prod_{d|T} f(d)^{\\mu(\\frac Tt)})^{\\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor } \\end{aligned} $$ 设$g(x)=\\prod_{d|T} f(d)^{\\mu(\\frac Tt)}$,求前缀和就完事了. 这道题需要使用欧拉定理来优化求幂的速度. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:6:1","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"欧拉定理 当$(a,p)=1$,有以下式子 $$ a^b \\equiv a^{b \\mod \\phi(p)} \\pmod p $$ 当$(a,p)\\neq 1$,有扩展欧拉定理 $$ a^b \\equiv a^{b \\mod \\phi(p)+ \\phi(p)} \\pmod p $$ 根据这2个式子,可以在快速降幂,来加快运算. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:6:2","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=1000010; const ll P=1e9+7; inline ll qpow(ll a,ll b,ll p){ ll res=1; for(;b;b\u003e\u003e=1,a=a*a%p){ if(b\u00261)res=res*a%p; } return res; } inline ll get_inv(ll a,ll p){ return qpow(a,p-2,p); } bool is_np[MAXN]; vector\u003cint\u003e primes; ll f[MAXN], g[MAXN]; ll inv_f[MAXN]; ll preg[MAXN],inv_pg[MAXN]; ll mu[MAXN]; void init(int n){ is_np[1]=1; mu[1]=1; for(int i=2;i\u003c=n;i++){ if(!is_np[i]){ primes.push_back(i); mu[i]=-1; } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=n;j++){ is_np[i*primes[j]]=1; mu[i*primes[j]]=mu[i]*-1; if(i%primes[j]==0){ mu[i*primes[j]]=0; break; } } } f[1]=f[2]=1; for(int i=3;i\u003c=n;i++){ f[i]=(f[i-1]+f[i-2])%P; } for(int i=1;i\u003c=n;i++){ inv_f[i]=get_inv(f[i],P); } for(int i=1;i\u003c=n;i++)g[i]=1; for(int i=1;i\u003c=n;i++){ for(int j=i;j\u003c=n;j+=i){ if(mu[j/i]==-1)g[j]=(g[j]*inv_f[i])%P; else if(mu[j/i]==1)g[j]=(g[j]*f[i])%P; //when mu==0,nothing happens } } preg[0]=1; for(int i=1;i\u003c=n;i++)preg[i]=preg[i-1]*g[i]%P; inv_pg[0]=1; for(int i=1;i\u003c=n;i++)inv_pg[i]=get_inv(preg[i],P)%P; } int main(){ init(1000000); //cout\u003c\u003c\"done\"\u003c\u003cendl; /* for(auto i:primes){ cout\u003c\u003ci\u003c\u003c\" \"; } cout\u003c\u003cendl; for(int i=1;i\u003c=20;i++){ cout\u003c\u003cg[i]\u003c\u003c\" \"; } cout\u003c\u003cendl; */ int kase; scanf(\"%d\",\u0026kase); while(kase--){ ll n,m; scanf(\"%d%d\",\u0026n,\u0026m); if(n\u003em)swap(n,m); ll ans=1; for(ll l=1,r;l\u003c=n;l=r+1){ r=min(n/(n/l),m/(m/l)); ll sum=preg[r]*inv_pg[l-1]%P; ans=ans*qpow(sum,(n/l)*(m/l)%(P-1),P)%P; } printf(\"%lld\\n\",ans); } return 0; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:6:3","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"phi3 给出$n$,求 $$ (\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n \\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)} \\phi((i,j,k))) \\mod 2^{30} $$ ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:7:0","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"分析 这道题重点在于 $$\\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)}$$ 这堆东西的化简.很显然,我又不会. 观察$\\phi(n)$的公式 $$ \\phi(n)=n\\prod_i(1-\\frac 1{\\phi(i)}) $$ 可以得出上面那一堆等于$jk^2$.剩下的就又都一样了. $$ \\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi((i,j,k)) \u0026=\\sum_d\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi(d)[(i,j,k)=d] \\\\ \u0026=\\sum_d \\sum_{t} \\phi(d) \\mu(t) t^3d^3 \\sum_{i\\leq \\frac n{td}}\\sum_{j \\leq \\frac n{td}}\\sum_{k \\leq \\frac n{td}} jk^2 \\\\ \u0026=\\sum_T \\sum_{i\\leq \\frac nT}\\sum_{j \\leq \\frac nT} j\\sum_{k \\leq \\frac nT}k^2 (T^3 \\sum_{d|T} \\phi(d) \\mu(\\frac Td)) \\end{aligned} $$ 设$g(n)=\\sum_{d|T} \\phi(d) \\mu(\\frac Td)$,直接筛.最后计算前缀和的时候再乘上$n^3$就可以了. 这道题的取模还有这种处理方法: 直接取数组为unsigned并自然溢出.二进制后30位不会受到影响. ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:7:1","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["学习"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cstring\u003e#include \u003cvector\u003eusing namespace std; using ull=unsigned long long; using ll=long long; const int MAXN=10000010; const unsigned P=1\u003c\u003c30; bool isnp[MAXN]; vector\u003cint\u003e primes; int t[MAXN],M[MAXN]; unsigned Mt[MAXN]; unsigned g[MAXN]; ll preg[MAXN]; void init(int n){ isnp[1]=1; g[1]=1; for(int i=2;i\u003c=n;i++){ if(!isnp[i]){ primes.push_back(i); g[i]=i-1-1; t[i]=1; M[i]=Mt[i]=i; } for(int j=0;j\u003cprimes.size() \u0026\u0026 i*primes[j]\u003c=n;j++){ int newone=i*primes[j]; isnp[newone]=1; g[newone]=g[i]*g[primes[j]]%P; t[newone]=1; M[newone]=Mt[newone]=primes[j]; if(i%primes[j]==0){ t[newone]=t[i]+1; Mt[newone]=Mt[i]*primes[j]%P; g[newone]=g[i/Mt[i]]*(Mt[newone]+Mt[i]/primes[j]-2*Mt[i])%P; break; } } } for(int i=1;i\u003c=n;i++){ preg[i]=preg[i-1]+(ll)i*i%P*i%P*g[i]%P; preg[i]%=P; } } int main(){ init(10000000); int kase; scanf(\"%d\",\u0026kase); while(kase--){ int n; scanf(\"%d\",\u0026n); ll ans=0; for(int l=1,r;l\u003c=n;l=r+1){ r=n/(n/l); ull lim=n/l; ull sum1=lim*(lim+1)%(2*P)/2; ull sum2=lim*(lim+1)%(6*P)*(2*lim+1)%(6*P)/6; ans=ans+lim*sum1%P*sum2%P*(preg[r]-preg[l-1])%P; } printf(\"%lld\\n\",ans%P); } return 0; } ","date":"2019-09-05","objectID":"/2019/09/some-sieve/:7:2","tags":null,"title":"一些筛法的题","uri":"/2019/09/some-sieve/"},{"categories":["code"],"content":"You are given a string S consisting of only lowercase english letters and some queries. For each query (l,r,k), please output the starting position of the k-th occurence of the substring SlSl+1…Sr in S. ","date":"2019-08-25","objectID":"/2019/08/hdu-6704-kth-occurrence/:0:0","tags":null,"title":"[HDU 6704] Kth Occurrence","uri":"/2019/08/hdu-6704-kth-occurrence/"},{"categories":["code"],"content":"分析 第一个问题是快速找出所有出现的子串的位置,可以使用后缀数组.这些字串出现在sa的一个连续的区间中. 第二个问题是找出这些出现位置中的第k大,可以使用主席树,以sa建树. ","date":"2019-08-25","objectID":"/2019/08/hdu-6704-kth-occurrence/:1:0","tags":null,"title":"[HDU 6704] Kth Occurrence","uri":"/2019/08/hdu-6704-kth-occurrence/"},{"categories":["code"],"content":"代码 思路清晰,但这代码它不好写 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003cstring\u003e#include \u003ccstdlib\u003e#include \u003ccmath\u003eusing namespace std; const int MAXN=100060; using ull=unsigned long long; int n; int sa[MAXN], x[MAXN], c[MAXN], y[MAXN]; char a[MAXN]; inline void SA() { int m = 128; for (int i = 0; i \u003c= m; i++) c[i] = 0; for (int i = 1; i \u003c= n; i++) c[x[i]]++; for (int i = 1; i \u003c= m; i++) c[i] += c[i - 1]; for (int i = n; i; i--) sa[c[x[i]]--] = i; for (int k = 1, p; k \u003c= n; k \u003c\u003c= 1) { p = 0; for (int i = n; i \u003e n - k; i--) y[++p] = i; for (int i = 1; i \u003c= n; i++) if (sa[i] \u003e k) y[++p] = sa[i] - k; for (int i = 0; i \u003c= m; i++) c[i] = 0; for (int i = 1; i \u003c= n; i++) c[x[i]]++; for (int i = 1; i \u003c= m; i++) c[i] += c[i - 1]; for (int i = n; i; i--) sa[c[x[y[i]]]--] = y[i]; p = y[sa[1]] = 1; for (int i = 2, a, b; i \u003c= n; i++) { a = sa[i] + k \u003e n ? -1 : x[sa[i] + k]; b = sa[i - 1] + k \u003e n ? -1 : x[sa[i - 1] + k]; y[sa[i]] = (x[sa[i]] == x[sa[i - 1]]) \u0026\u0026 (a == b) ? p : ++p; } swap(x, y); m = p; } } int tot; int sum[(MAXN \u003c\u003c 5) + 10], rt[MAXN + 10], ls[(MAXN \u003c\u003c 5) + 10], rs[(MAXN \u003c\u003c 5) + 10]; int build(int l, int r) //建树 { int root = ++tot; if (l == r) return root; int mid = l + r \u003e\u003e 1; ls[root] = build(l, mid); rs[root] = build(mid + 1, r); return root; //返回该子树的根节点 } int update(int k, int l, int r, int root) //插入操作 { int dir = ++tot; ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + 1; if (l == r) return dir; int mid = l + r \u003e\u003e 1; if (k \u003c= mid) ls[dir] = update(k, l, mid, ls[dir]); else rs[dir] = update(k, mid + 1, r, rs[dir]); return dir; } //left root, right root, querying l,r, the k-th int query(int u, int v, int l, int r, int k) //查询操作 { int mid = l + r \u003e\u003e 1, x = sum[ls[v]] - sum[ls[u]]; //通过区间减法得到左儿子的信息 if (l == r){ return l; } if (k \u003c= x) //说明在左儿子中 return query(ls[u], ls[v], l, mid, k); else //说明在右儿子中 return query(rs[u], rs[v], mid + 1, r, k - x); } int height[MAXN]; int st[20][MAXN]; inline void get_height() { int k = 0; for (int i = 1; i \u003c= n; ++i) { if (x[i] == 1) continue; if (k) --k; int j = sa[x[i] - 1]; while (j + k \u003c= n \u0026\u0026 i + k \u003c= n \u0026\u0026 a[i + k] == a[j + k]) ++k; height[x[i]] = k; } } void build_st() { for (int i = 1; i \u003c= n; i++) st[0][i] = height[i]; for (int k = 1; k \u003c= 19; k++) { for (int i = 1; i + (1 \u003c\u003c k) - 1 \u003c= n; i++) { st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 \u003c\u003c k - 1)]); } } } int lcp(int ll, int rr) { int l = x[ll], r = x[rr]; if (l \u003e r) swap(l, r); if (l == r) return n - sa[l]+1; int t = log2(r - l); return min(st[t][l + 1], st[t][r - (1 \u003c\u003c t) + 1]); } int main(){ int kase;cin\u003e\u003ekase; while(kase--){ int nlen,qlen;cin\u003e\u003enlen\u003e\u003eqlen; scanf(\"%s\",a+1); for(int i=0;i\u003cMAXN;i++)x[i]=a[i]; n=nlen; SA(); n=nlen; get_height(); build_st(); /* for(int i=1;i\u003c=nlen;i++)cout\u003c\u003csa[i]\u003c\u003c\" \"; cout\u003c\u003cendl; for(int i=1;i\u003c=nlen;i++)cout\u003c\u003cx[i]\u003c\u003c\" \"; cout\u003c\u003cendl; */ tot=0; memset(sum,0,sizeof(sum)); rt[0] = build(1, nlen); for (int i = 1; i \u003c= n; ++i) rt[i] = update(sa[i], 1, nlen, rt[i - 1]); while(qlen--){ int ql,qr,qk; scanf(\"%d%d%d\",\u0026ql,\u0026qr,\u0026qk); int sublen=qr-ql+1; int ex_l,ex_r; //binary search { int l=1,r=x[ql]; while(r-l\u003e1){ int mid=(l+r)/2; if(lcp(sa[mid], ql) \u003e= sublen){ r=mid; }else l=mid+1; } for(l;l\u003c=r;l++){ if(lcp(sa[l], ql) \u003e= sublen){ ex_l=l; break; } } } { int l=x[ql],r=nlen; while(r-l\u003e1){ int mid=(l+r)/2; if(lcp(sa[mid], ql) \u003e= sublen){ l=mid; }else r=mid-1; } for(r;r\u003e=l;r--){ if(lcp(sa[r], ql) \u003e= sublen){ ex_r=r; break; } } } //cout\u003c\u003cex_l\u003c\u003c\" \"\u003c\u003cex_r\u003c\u003cendl; if(ex_r-ex_l+1\u003cqk){ cout\u003c\u003c-1\u003c\u003cendl; } else cout\u003c\u003cquery(rt[ex_l - 1], rt[ex_r], 1, nlen, qk)\u003c\u003cendl; } } return 0; } ","date":"2019-08-25","objectID":"/2019/08/hdu-6704-kth-occurrence/:2:0","tags":null,"title":"[HDU 6704] Kth Occurrence","uri":"/2019/08/hdu-6704-kth-occurrence/"},{"categories":["code"],"content":"You are given an array a1,a2,…,an(∀i∈[1,n],1≤ai≤n). Initially, each element of the array is unique. Moreover, there are m instructions. Each instruction is in one of the following two formats: (1,pos),indicating to change the value of apos to apos+10,000,000; (2,r,k),indicating to ask the minimum value which is not equal to any ai ( 1≤i≤r ) and **not less ** than k. Please print all results of the instructions in format 2. ","date":"2019-08-24","objectID":"/2019/08/a-wonderful-bug/:0:0","tags":null,"title":"记一个bug (HDU 6703)","uri":"/2019/08/a-wonderful-bug/"},{"categories":["code"],"content":"分析 这题强制在线.首先1操作相当于删除了这个数. dalao自闭了一会get到了它的正确做法,我就直接拿来用了. 维护一权值线段树,位置i存其在a中出现的位置.那么当1到r区间内出现位置的最大值超过了r,根据鸽巢原理,至少有一个数未被限制. 加上不小于k的条件,就是k到r中,找到最小的一个r,使得它满足上面的条件,输出这个r. ","date":"2019-08-24","objectID":"/2019/08/a-wonderful-bug/:1:0","tags":null,"title":"记一个bug (HDU 6703)","uri":"/2019/08/a-wonderful-bug/"},{"categories":["code"],"content":"代码 一个奇葩的bug… 当使用了fread这种先读完缓冲区再处理的快速读入而删漏了cin时…会显而易见的遇到bug. 但是,因为缓冲区的存在,小范围数据被快乐的读入了缓冲区,cin并不会实际影响什么.一旦遇到大范围数据,cin提前读入了接下来的数据,导致第一个缓冲区之外的数据全部出错… 艹. #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; const int MAXN = 400000; namespace IO { const int MAXSIZE = 1 \u003c\u003c 20; char buf[MAXSIZE], *p1, *p2; #define gc() \\ (p1 == p2 \u0026\u0026 (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++) inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == '-') f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f; } char pbuf[1 \u003c\u003c 20], *pp = pbuf; inline void push(const char \u0026c) { if (pp - pbuf == 1 \u003c\u003c 20) fwrite(pbuf, 1, 1 \u003c\u003c 20, stdout), pp = pbuf; *pp++ = c; } inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } } // namespace IO /////////////////////////////////////////////////////////////////////////////////////// int dat[MAXN]; int a[MAXN]; int lc[MAXN], rc[MAXN], idx = 0; inline int imax(int a,int b){ if(a\u003eb)return a; return b; } void collect(int n) { dat[n] = max(dat[lc[n]], dat[rc[n]]); } int build(int \u0026n, int l, int r) { if (!n) n = ++idx; dat[n] = a[l]; if (l == r) return dat[n]; int mid = (l + r) / 2; return dat[n] = imax(build(lc[n], l, mid), build(rc[n], mid + 1, r)); } void modify(int x, int l, int r, int L, int R, int n) { if (l \u003c= L \u0026\u0026 R \u003c= r) { dat[n] = x; return; } int mid = (L + R) / 2; if (l \u003c= mid) modify(x, l, r, L, mid, lc[n]); if (mid \u003c r) modify(x, l, r, mid + 1, R, rc[n]); collect(n); } int query(int l, int r,int target, int L, int R, int n) { if(L\u003er || R\u003cl || dat[n]\u003c=target)return -1; if(L==R)return L; int mid = (L + R) / 2; int res=query(l,r,target,L,mid,lc[n]); return ~res?res:query(l,r,target,mid+1,R,rc[n]); } int root; int num[MAXN]; int main() { int kase=IO::rd(); while (kase--) { int nlen, qlen; nlen=IO::rd(); qlen=IO::rd(); for (int i = 1; i \u003c= nlen; i++) { num[i] = IO::rd(); a[num[i]] = i; } build(root, 1, nlen); int lastans = 0; while (qlen--) { int opt=IO::rd(); if (opt == 1) { int pos=IO::rd(); pos ^= lastans; if(num[pos]==0 || num[pos]\u003enlen)continue; modify(0x3f3f3f3f, num[pos], num[pos], 1, nlen, root); } else { int t2, t3; t2=IO::rd(); t3=IO::rd(); //cin \u003e\u003e t2 \u003e\u003e t3; int r = t2 ^ lastans, k = t3 ^ lastans; int t=query(k,nlen,r,1,nlen,root); cout\u003c\u003c(lastans=(~t?t:nlen+1))\u003c\u003cendl; } } } return 0; } ","date":"2019-08-24","objectID":"/2019/08/a-wonderful-bug/:2:0","tags":null,"title":"记一个bug (HDU 6703)","uri":"/2019/08/a-wonderful-bug/"},{"categories":["code"],"content":"内容有复制和参考。 这篇文章主要用于记录在探索评测系统Reef期间我所学的东西,以便之后查阅. Reef预计主要支持远程评测 加一点本地评测….. 结果主要的东西都特么是本地评测的. ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:0:0","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"总体架构 Reef预计将采用seccomp作为第一道安全关卡,使用多线程检测程序耗时/内存等信息. 在外层使用docker封装并再次限制资源,接入队列以能够方便的横向扩展. ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:1:0","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"seccomp seccomp为linux系统上才有的安全技术,因此必须使用linux.在安装必要的安装包后 $ sudo apt install libseccomp2 libseccomp-dev seccomp 即可使用. 当然,在windows下的Jobs似乎也可以利用,但是我不太懂,微软文档写得也奇怪,而且还得是服务器版本的windows才能用. ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:0","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"基本使用 seccomp需要由程序主动加载.其使用方法基本为下 //g++ -g test.c -o o -lseccomp #include \u003cunistd.h\u003e#include \u003cseccomp.h\u003e#include \u003clinux/seccomp.h\u003e int main(void){ //初始化筛选器 scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW);//flag指明默认通过 //添加拦截,并指明一旦拦截就将程序kill掉. seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); //将规则加载注入. seccomp_load(ctx); char * filename = \"/bin/sh\"; char * argv[] = {\"/bin/sh\",NULL}; char * envp[] = {NULL}; write(1,\"i will give you a shell\\n\",24); //程序将会在此行崩溃. syscall(59,filename,argv,envp);//execve return 0; } seccomp_init是初始化的过滤状态,这里用的是SCMP_ACT_ALLOW,表示默认允许所有的syscacll.如果初始化状态为SCMP_ACT_KILL,则表示默认不允许所有的syscall. /** * Kill the process */ #define SCMP_ACT_KILL 0x00000000U /** * Throw a SIGSYS signal */ #define SCMP_ACT_TRAP 0x00030000U /** * Return the specified error code */ #define SCMP_ACT_ERRNO(x) (0x00050000U | ((x) \u0026 0x0000ffffU)) /** * Notify a tracing process with the specified value */ #define SCMP_ACT_TRACE(x) (0x7ff00000U | ((x) \u0026 0x0000ffffU)) /** * Allow the syscall to be executed after the action has been logged */ #define SCMP_ACT_LOG 0x7ffc0000U /** * Allow the syscall to be executed */ #define SCMP_ACT_ALLOW 0x7fff0000U 规则添加 /** * Add a new rule to the filter * @param ctx the filter context * @param action the filter action * @param syscall the syscall number * @param arg_cnt the number of argument filters in the argument filter chain * @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended) * * This function adds a series of new argument/value checks to the seccomp * filter for the given syscall; multiple argument/value checks can be * specified and they will be chained together (AND\u0026#039;d together) in the filter. * If the specified rule needs to be adjusted due to architecture specifics it * will be adjusted without notification. Returns zero on success, negative * values on failure. * */ int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, ...); seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);,arg_cnt为0,表示直接限制execve,不管他什么参数. 如果arg_cnt不为0,那arg_cnt表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截syscall. seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write),1,SCMP_A2(SCMP_CMP_EQ,0x10));//第2(从0)个参数等于0x10 /** * Specify an argument comparison struct for use in declaring rules * @param arg the argument number, starting at 0 * @param op the comparison operator, e.g. SCMP_CMP_* * @param datum_a dependent on comparison * @param datum_b dependent on comparison, optional */ #define SCMP_CMP(...) ((struct scmp_arg_cmp){__VA_ARGS__}) /** * Specify an argument comparison struct for argument 0 */ #define SCMP_A0(...) SCMP_CMP(0, __VA_ARGS__) /** * Specify an argument comparison struct for argument 1 */ #define SCMP_A1(...) SCMP_CMP(1, __VA_ARGS__) /** * Specify an argument comparison struct for argument 2 */ #define SCMP_A2(...) SCMP_CMP(2, __VA_ARGS__) /** * Specify an argument comparison struct for argument 3 */ #define SCMP_A3(...) SCMP_CMP(3, __VA_ARGS__) /** * Specify an argument comparison struct for argument 4 */ #define SCMP_A4(...) SCMP_CMP(4, __VA_ARGS__) /** * Specify an argument comparison struct for argument 5 */ #define SCMP_A5(...) SCMP_CMP(5, __VA_ARGS__) /** * Comparison operators */ enum scmp_compare { _SCMP_CMP_MIN = 0, SCMP_CMP_NE = 1, /**\u003c not equal */ SCMP_CMP_LT = 2, /**\u003c less than */ SCMP_CMP_LE = 3, /**\u003c less than or equal */ SCMP_CMP_EQ = 4, /**\u003c equal */ SCMP_CMP_GE = 5, /**\u003c greater than or equal */ SCMP_CMP_GT = 6, /**\u003c greater than */ SCMP_CMP_MASKED_EQ = 7, /**\u003c masked equality */ _SCMP_CMP_MAX, }; /** * Argument datum */ typedef uint64_t scmp_datum_t; /** * Argument / Value comparison definition */ struct scmp_arg_cmp { unsigned int arg; /**\u003c argument number, starting at 0 */ enum scmp_compare op; /**\u003c the comparison op, e.g. SCMP_CMP_* */ scmp_datum_t datum_a; scmp_datum_t datum_b; }; ctx的内容可以使用函数dump出来,之后可以直接使用prctl命令相关直接载入,方便使用? ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:1","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"seccomp调试 使用如下命令导出所有可能的命令 file=syscall-names.h echo \"static const char *syscall_names[] = {\" \u003e $file echo \"#include \u003csys/syscall.h\u003e\" | cpp -dM | grep \u0026#039;^#define __NR_\u0026#039; | LC_ALL=C sed -r -n -e \u0026#039;s/^\\#define[ \\t]+__NR_([a-z0-9_]+)[ \\t]+([0-9]+)(.*)/ [\\2] = \"\\1\",/p\u0026#039; \u003e\u003e $file echo \"};\" \u003e\u003e $file 使用如下代码导出一段代码所需要的权限.遵循最小权限原则,试验代码运行所需要的最少权限. #define __USE_GNU 1 #define _GNU_SOURCE 1 #include \u003csignal.h\u003e#include \u003csys/prctl.h\u003e#include \u003clinux/types.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/seccomp.h\u003e#include \u003cseccomp.h\u003e#include \u003cunistd.h\u003e#include \u003cstring.h\u003e#include \u003cstddef.h\u003e#include \"syscall-names.h\"#if defined(__i386__) #define REG_RESULT REG_EAX #define REG_SYSCALL REG_EAX #define REG_ARG0 REG_EBX #define REG_ARG1 REG_ECX #define REG_ARG2 REG_EDX #define REG_ARG3 REG_ESI #define REG_ARG4 REG_EDI #define REG_ARG5 REG_EBP #elif defined(__x86_64__) #define REG_RESULT REG_RAX #define REG_SYSCALL REG_RAX #define REG_ARG0 REG_RDI #define REG_ARG1 REG_RSI #define REG_ARG2 REG_RDX #define REG_ARG3 REG_R10 #define REG_ARG4 REG_R8 #define REG_ARG5 REG_R9 #endif #ifndef SYS_SECCOMP #define SYS_SECCOMP 1 #endif const char *const msg=\"system call invalid: \"; static void write_uint(char *buf, unsigned int val) { int width = 0; unsigned int tens; if (val == 0) { strcpy(buf, \"0\"); return; } for (tens = val; tens; tens /= 10) ++ width; buf[width] = \u0026#039;\\0\u0026#039;; for (tens = val; tens; tens /= 10) buf[--width] = (char) (\u0026#039;0\u0026#039; + (tens % 10)); } static void helper(int nr, siginfo_t *info, void *void_context) { char buf[255]; ucontext_t *ctx = (ucontext_t *)(void_context); unsigned int syscall; if (info-\u003esi_code != SYS_SECCOMP) return; if (!ctx) return; syscall = (unsigned int) ctx-\u003euc_mcontext.gregs[REG_SYSCALL]; strcpy(buf, msg); if (syscall \u003c sizeof(syscall_names)) { strcat(buf, syscall_names[syscall]); strcat(buf, \"(\"); } write_uint(buf + strlen(buf), syscall); if (syscall \u003c sizeof(syscall_names)) strcat(buf, \")\"); strcat(buf, \"\\n\"); write(STDOUT_FILENO, buf, strlen(buf)); _exit(1); } static int install_helper() { struct sigaction act; sigset_t mask; memset(\u0026act, 0, sizeof(act)); sigemptyset(\u0026mask); sigaddset(\u0026mask, SIGSYS); act.sa_sigaction = \u0026helper; act.sa_flags = SA_SIGINFO; if (sigaction(SIGSYS, \u0026act, NULL) \u003c 0) { perror(\"sigaction\"); return -1; } if (sigprocmask(SIG_UNBLOCK, \u0026mask, NULL)) { perror(\"sigprocmask\"); return -1; } return 0; } #include \u003cstdio.h\u003eint main(){ if(install_helper()){ printf(\"install helper failed\"); return 1; } scmp_filter_ctx ctx = NULL; ctx = seccomp_init(SCMP_ACT_ALLOW); seccomp_rule_add(ctx, SCMP_ACT_TRAP, SCMP_SYS(execve), 0); seccomp_load(ctx); seccomp_release(ctx); fprintf(stdout, \"something to stdout\\n\"); char * filename = \"/bin/sh\"; char * argv[] = {\"/bin/sh\",NULL}; char * envp[] = {NULL}; write(1,\"i will give you a shell\\n\",24); syscall(59,filename,argv,envp);//execve return 0; } ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:2","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"注入程序 刚刚提到了seccomp必须由程序主动加载,因此需要有一个办法将代码注入到用户的代码中. 等待完成 ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:3","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"其他语言 这玩意貌似至少能方便的用在c系语言,java和python上. ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:2:4","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"Docker 准备使用Docker重构整个OJ ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:3:0","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"多阶段构建 使用Docker,将OJ分解为多个阶段来构建. 前端构建 后端构建 运行环境构建与代码整合 nginx构建 命令 #...# 使用php作为基础,指明该构建阶段为codeislandFROMphp:alpine as codeisland# 在容器打包阶段安装数据库驱动RUN docker-php-ext-install pdo pdo_pgsqlARG PATH=/app/laravel# 从其他阶段复制代码到本阶段COPY --from=DELETED /app/ ${PATH}# 执行其他初始化命令# [DELETED]# 指明容器的工作路径WORKDIR${PATH}#... ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:3:1","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"容器协调 使用Docker-compose来协调各个容器的关系. 数据库容器 redis容器 网站后端容器 评测器容器 评测代理容器 nginx容器 限制评测器容器的资源消耗的例子 deploy:resources:limits:cpus:\u0026#039;0.50\u0026#039;memory:1024M ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:3:2","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"网络 …学校网关的登录状态根本没法维持,卡死. ","date":"2019-08-22","objectID":"/2019/08/backend-of-oj/:3:3","tags":null,"title":"OJ的后端","uri":"/2019/08/backend-of-oj/"},{"categories":["code"],"content":"n个有标号的球围成一个圈。每个球有两种颜色可以选择黑或白染色。问有多少种方案使得没有出现连续白球7个或连续黑球7个。 对方案数mod 2015，球最多有100000个。 分析 考虑对于非环状球的答案计算，可以设$sum(i,k)$表示第i个球为k色时的方案数。其计算非常显然 $$ sum(i,k)=\\sum_{1\\leq j \\leq 6}{sum(i-j,1-k)} $$ 接下来考虑收尾相接后需要排除的情况，即收尾同色球长度相加超过6的情况，这可以直接枚举。 首取i个末取j个同色，从答案中删除此时剩下球的方案数，注意剩下的球的首末球颜色不能和已经枚举的颜色同色。鉴于这种要求，我们退回到sum的递推公式处，决定sum的边界条件为首个球固定为黑色，这样就能很方便的确定球的颜色，且根据对称性答案可以直接x2得到。 题就做完了。 代码 淦，为什么当时没写。 #include \u003ciostream\u003eusing namespace std; const int MAXN=100010; const int P=2015; int sum[MAXN][2]; int main(){ int kase;cin\u003e\u003ekase; sum[0][1]=1; for(int i=1;i\u003c=100000;i++){ for(int j=1;j\u003c=min(i,6);j++){ (sum[i][1]+=sum[i-j][0])%=P; (sum[i][0]+=sum[i-j][1])%=P; } } sum[0][1]=0; int cnt=0; while(kase--){ int nlen;cin\u003e\u003enlen; int ans=(sum[nlen][0]+sum[nlen][1])%P; if(nlen\u003e=7) for(int i=1;i\u003c=6;i++) for(int j=1;j\u003c=6;j++) if(i+j\u003e=7 \u0026\u0026 nlen-i-j\u003e=0) ans=(ans-sum[nlen-i-j][0])%P; cout\u003c\u003c\"Case #\"\u003c\u003c++cnt\u003c\u003c\": \"\u003c\u003c((ans*2)%P+2015)%P\u003c\u003cendl; } return 0; } ","date":"2019-08-10","objectID":"/2019/08/fzu-2204seven/:0:0","tags":null,"title":"[FZU 2204]Seven","uri":"/2019/08/fzu-2204seven/"},{"categories":["code"],"content":"There are n pirate chests buried in Byteland, labeled by 1,2,…,n. The i-th chest’s location is (xi,yi), and its value is wi, wi can be negative since the pirate can add some poisonous gases into the chest. When you open the i-th pirate chest, you will get wi value. You want to make money from these pirate chests. You can select a rectangle, the sides of which are all paralleled to the axes, and then all the chests inside it or on its border will be opened. Note that you must open all the chests within that range regardless of their values are positive or negative. But you can choose a rectangle with nothing in it to get a zero sum. Please write a program to find the best rectangle with maximum total value. The first line of the input contains an integer T(1≤T≤100), denoting the number of test cases. In each test case, there is one integer n(1≤n≤2000) in the first line, denoting the number of pirate chests. For the next n lines, each line contains three integers xi,yi,wi(−109≤xi,yi,wi≤109), denoting each pirate chest. It is guaranteed that ∑n≤10000. ","date":"2019-08-07","objectID":"/2019/08/hdu6638-snowy-smile/:0:0","tags":null,"title":"[HDU6638] Snowy Smile","uri":"/2019/08/hdu6638-snowy-smile/"},{"categories":["code"],"content":"分析 首先，我没做出来。 这道题实际上就是在要求你用小于$O(N^3)$的复杂度求出最大和子矩阵。注意到该题的点稀疏，所以以点为考虑对象。 三方的做法，枚举矩阵的上边界和下边界，维护纵向上的和，求最大字段和。当以点考虑时，上下边界就可以直接由排序后的点决定。之后，使用线段树维护最大子段和。 ","date":"2019-08-07","objectID":"/2019/08/hdu6638-snowy-smile/:1:0","tags":null,"title":"[HDU6638] Snowy Smile","uri":"/2019/08/hdu6638-snowy-smile/"},{"categories":["code"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; constexpr int MAXN=400010; ll d_sub[MAXN],d_pre[MAXN],d_suf[MAXN]; ll d_sum[MAXN]; int lc[MAXN],rc[MAXN]; int idx=0; void build(int \u0026n,int l,int r){ if(!n)n=++idx; d_sum[n]=d_sub[n]=d_pre[n]=d_suf[n]=0; if(l==r){ return; } int mid=(l+r)/2; build(lc[n],l,mid); build(rc[n],mid+1,r); //combine data } void collect(int node){ d_sum[node]=d_sum[lc[node]]+d_sum[rc[node]]; d_pre[node]=max(d_pre[lc[node]],d_sum[lc[node]]+d_pre[rc[node]]); d_suf[node]=max(d_suf[rc[node]],d_sum[rc[node]]+d_suf[lc[node]]); d_sub[node]=max(max(d_sub[lc[node]],d_sub[rc[node]]),d_suf[lc[node]]+d_pre[rc[node]]); } void modify(int x,int l,int r,int L,int R,int node){ if(l\u003c=L \u0026\u0026 R\u003c=r){ //only single point to modify d_sub[node]=d_sub[node]+x; d_pre[node]=d_pre[node]+x; d_suf[node]=d_suf[node]+x; d_sum[node]+=x; return; } int mid=(L+R)/2; if(l\u003c=mid)modify(x,l,r,L,mid,lc[node]); if(mid\u003cr)modify(x,l,r,mid+1,R,rc[node]); collect(node); } int root; ll query_all(){ return d_sub[root]; } struct Chest{ int x,y,v; bool operator\u003c(const Chest \u0026other)const{ if(x==other.x)return y\u003cother.y; return x\u003cother.x; } } chests[MAXN]; vector\u003cint\u003e refy; int main(){ ios::sync_with_stdio(false); int kase;cin\u003e\u003ekase; while(kase--){ int nlen;cin\u003e\u003enlen; refy.clear(); for(int i=0;i\u003cnlen;i++){ Chest \u0026chest=chests[i]; cin\u003e\u003echest.x\u003e\u003echest.y\u003e\u003echest.v; refy.push_back(chest.y); } sort(chests,chests+nlen); sort(refy.begin(),refy.end()); auto refyend=unique(refy.begin(),refy.end()); int maxy=0; for(int i=0;i\u003cnlen;i++){ chests[i].y=lower_bound(refy.begin(),refyend,chests[i].y)-refy.begin()+1; maxy=max(maxy,chests[i].y); } int lastx=0; ll ans=0; for(int i=0;i\u003cnlen;i++){ if(lastx==chests[i].x)continue; lastx=chests[i].x; //cout\u003c\u003c\"start from \"\u003c\u003clastx\u003c\u003cendl; build(root,1,maxy); int nextx=chests[i].x; for(int j=i;j\u003cnlen;j++){ if(chests[j].x!=nextx){ nextx=chests[j].x; ans=max(ans,query_all()); } modify(chests[j].v,chests[j].y,chests[j].y,1,maxy,root); } ans=max(ans,query_all()); } cout\u003c\u003cmax(0ll,ans)\u003c\u003cendl; } return 0; } ","date":"2019-08-07","objectID":"/2019/08/hdu6638-snowy-smile/:2:0","tags":null,"title":"[HDU6638] Snowy Smile","uri":"/2019/08/hdu6638-snowy-smile/"},{"categories":["学习"],"content":"对于可以离线的区间询问问题，莫队算法提出了一种可以在$O(n\\sqrt n)$(无修改)，$O(n^{5/3})$(带修改)内得出答案的方法。 主要的思路是对询问离线并分块，利用在2个区间间答案的快速转移（如果无法找到快速转移的方法，就没法用了）降低复杂度。 ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:0:0","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"1 算法思想 莫队算法是由莫涛提出的算法，可以解决一类离线区间询问问题，适用性极为广泛。即,能够使用莫队算法处理的问题一般具有如下特征 区间询问 可以离线 不同区间间的答案能够较快的互推. 在满足以上条件是,通过合理的安排询问的处理顺序,能够获得一个优秀的总体复杂度。以下，假设区间的转移需要$O(1)$ 假设已知区间$[l,r]$答案，有下一个需要处理的区间$[l’,r’]$。进行答案在区间间的单步转移需要复杂度$O(|l-l'|+|r-r'|)$，即转移的复杂度为二者的曼哈顿距离。那么，将所有询问点铺平在二维平面上，按曼哈顿距离生成最小生成树，如此所得到的转移代价最小。 但是一般情况下这种做法代码量较大，在代码量和时间复杂度间的妥协诞生了一个优秀的替代方案。分块。 对区间长度按根号分块，以左端点所在的分块的序号为第一关键字，右端点为第二关键字排序。那么 在同一分块，右端点递增，处理该分块所有询问右端点需要$O(N)$，总体为$O(N \\sqrt N)$。 在分块转移，右端点最多变化$N$，于是也有$O(N \\sqrt N)$。 在同一分块，左端点变化最多$\\sqrt N$，不同分块间最多变化$\\sqrt N$，于是N个询问有$O(N \\sqrt N)$。 总体复杂度$O(N\\sqrt N)$ ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:1:0","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"2 无修改莫队 以$B=\\sqrt{n}$，按照$(l/B,r)$对询问排序。 之后枚举每一个询问，将答案在相邻询问区间间暴力的+1-1转移。 ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:2:0","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"Problem: 小Y的袜子 作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命…… 具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。 你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。 袜子的数量最多为50000（是真的🐂🍺） 分析 这似乎是莫队的例题（ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstdlib\u003e#include \u003ccstring\u003e#include \u003ccmath\u003eusing namespace std; using ll=long long; const int MAXN=50010,MAXQ=50010; ll gcd(ll a,ll b){ return !b?a:gcd(b,a%b); } ll c2(ll n){ if(n\u003c2)return 0; return n*(n-1)/2; } int a[MAXN]; int block=0; struct Q{ int l,r; int i; ll ansu,ansd; bool operator\u003c(const Q \u0026b)const{ if(l/block!=b.l/block)return l/block\u003cb.l/block; return r\u003cb.r; } }qs[MAXQ]; int cnt[MAXN]; ll cup=0,cdown=0; void remove(int ptr){ cup-=c2(cnt[a[ptr]]); cnt[a[ptr]]--; cdown--; cup+=c2(cnt[a[ptr]]); } void add(int ptr){ cup-=c2(cnt[a[ptr]]); cnt[a[ptr]]++; cdown++; cup+=c2(cnt[a[ptr]]); } int main(){ int nlen,qlen;cin\u003e\u003enlen\u003e\u003eqlen; for(int i=1;i\u003c=nlen;i++)cin\u003e\u003ea[i]; for(int i=0;i\u003cqlen;i++)cin\u003e\u003eqs[i].l\u003e\u003eqs[i].r; for(int i=0;i\u003cqlen;i++)qs[i].i=i; block=sqrt(nlen); sort(qs,qs+qlen); /* cout\u003c\u003c\"current queries:\"\u003c\u003cendl; for(auto q:qs){ cout\u003c\u003cq.l\u003c\u003c\" \"\u003c\u003cq.r\u003c\u003cendl; } cout\u003c\u003c\"=====\"\u003c\u003cendl; */ int l=1,r=1; add(1); for(int i=0;i\u003cqlen;i++){ Q \u0026q=qs[i]; if(q.l==q.r){ q.ansu=0;q.ansd=1; continue; } while(q.l\u003cl)add(--l); while(r\u003cq.r)add(++r); while(l\u003cq.l)remove(l++); while(q.r\u003cr)remove(r--); q.ansu=cup; q.ansd=cdown; //cout\u003c\u003ccup/c2(cdown)\u003c\u003cendl; } sort(qs,qs+qlen,[](const Q \u0026a,const Q \u0026b){ return a.i\u003cb.i; }); for(int i=0;i\u003cqlen;i++){ if(qs[i].ansd\u003c2){ cout\u003c\u003c\"0/1\"\u003c\u003cendl; continue; } ll u=qs[i].ansu; ll d=c2(qs[i].ansd); ll g=gcd(u,d); if(g!=0)u/=g,d/=g; cout\u003c\u003cu\u003c\u003c\"/\"\u003c\u003cd\u003c\u003cendl; } return 0; } ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:2:1","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"3 带修改莫队 如果对区间的查询之余，还会修改区间，且这种修改也可以快速修改、撤销。那么，可以使用莫队的一个扩展——带修改莫队实现。 假设有$m$个询问，将修改操作平铺在时间线上，计算每次询问所处的时间点。将时间也作为查询的一个参数，参与分块和转移。按照$(l/B_1,r/B_2,time)$对询问排序。分块有$n^2/B_1B_2$个。 对于每个块，$time$最多变化$m$次，有$O(m)$。总体有$O(\\frac{n^2m}{B_1B_2})$。 对于每个询问内，$l$和$r$最多变化$B_1$、$B_2$。有$O(mB_1+mB_2)$。 对于不同块转移，有最大复杂度$O(n)$。有$O(\\frac{n^3}{B_1B_2})$ 当m和n同阶，取$B_1=B_2=n^{2/3}$，达到复杂度$O(n^{5/3})$。 枚举每一个询问，将答案在不同时间线间暴力+1-1跳转，再暴力在相邻询问的区间间+1-1转移。 听起来有点长寿的意思。 ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:3:0","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"Problem: Game Again Alice and Bob is playing a game with stones. There are N piles of stones labelled from 1 to N, the i th pile has ai stones. First Alice will choose piles of stones with consecutive labels, whose leftmost is labelled with L and the rightmost one is R. After, Bob will choose another consecutive piles labelled from l to r (L≤l≤r≤R). Then they’re going to play game within these piles. Here’s the rules of the game: Alice takes first and the two will take turn to make a move: choose one pile with nonegetive stones and take at least one stone and at most all away. One who cant make a move will lose. Bob thinks this game is not so intersting because Alice always take first. So they add a new rule, which is that Bob can swap the number of two adjacent piles’ stones whenever he want before a new round. That is to say, if the i th and i+1 pile have ai and ai+1 stones respectively, after this swapping there will be ai+1 and ai. Before today’s game with Bob, Alice wants to know, if both they play game optimally when she choose the piles from L to R, there are how many pairs (l, r) chosed by Bob that will make Alice win. 分析 nim游戏输赢就是看异或和，异或和可以看前缀异或和内有多少个值相同的点。所以它就是在问一个区间里有多少个相同点对。 带单点修改的区间点对计数。 代码 #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cvector\u003eusing namespace std; using ll=long long; const int MAXN=100010,MAXQ=100010; const int MAXPOS=2e6+11; int nlen,qlen; int game[MAXN]; int pre[MAXN]; int modified[MAXQ],midx=0,belong[MAXN]; int block=0; struct Q{ int i; int l,r; int tick; bool operator\u003c(const Q \u0026b)const{ // if(l/block!=b.l/block)return l/block\u003cb.l/block; // if(r/block!=b.r/block)return r/block\u003cb.r/block; if(belong[l]!=belong[b.l]) return belong[l]\u003cbelong[b.l]; if(belong[r]!=belong[b.r]) return belong[r]\u003cbelong[b.r]; return tick\u003cb.tick; } }q[MAXQ]; int qidx=0; ll cache=0; int cnt[MAXPOS]; inline void add(int pos){ int \u0026c=cnt[pre[pos]]; cache-=(ll)c*(c-1)/2; c++; cache+=(ll)c*(c-1)/2; } inline void rm(int pos){ int \u0026c=cnt[pre[pos]]; cache-=(ll)c*(c-1)/2; c--; cache+=(ll)c*(c-1)/2; } int l=1,r=1,curt=0; inline void jumpup(int tim){ if(tim==0)return; int pos=modified[tim]; int a=game[pos]; int b=game[pos+1]; swap(game[pos],game[pos+1]); if(l\u003c=pos \u0026\u0026 pos\u003c=r){ rm(pos); } pre[pos]^=a; pre[pos]^=b; if(l\u003c=pos \u0026\u0026 pos\u003c=r){ add(pos); } } inline void jumpdown(int tim){ jumpup(tim); } ll qans[MAXQ]; int main(){ //freopen(\"00.in\",\"r\",stdin); while(~scanf(\"%d%d\",\u0026nlen,\u0026qlen)){ block=pow(nlen,2.0/3); for(int i=1;i\u003c=nlen;i++){ scanf(\"%d\",\u0026game[i]); belong[i]=(i-1)/block; } pre[0]=0; for(int i=1;i\u003c=nlen;i++)pre[i]=pre[i-1]^game[i]; qidx=0,midx=0; for(int i=1;i\u003c=qlen;i++){ int opt; scanf(\"%d\",\u0026opt); if(opt==1){ int l,r; scanf(\"%d%d\",\u0026l,\u0026r); q[qidx].i=qidx; q[qidx].l=l; q[qidx].l--; q[qidx].r=r; q[qidx].tick=midx; qidx++; }else if(opt==2){ scanf(\"%d\",\u0026modified[++midx]); } } sort(q,q+qidx); memset(cnt,0,sizeof(cnt)); cache=0; l=r=1;curt=0; add(1); for(int i=0;i\u003cqidx;i++){ if(q[i].r-q[i].l+1\u003c2){ qans[q[i].i]=0; continue; } while(curt\u003cq[i].tick)jumpup(++curt); while(q[i].tick\u003ccurt)jumpdown(curt--); while(q[i].l\u003cl)add(--l); while(r\u003cq[i].r)add(++r); while(l\u003cq[i].l)rm(l++); while(q[i].r\u003cr)rm(r--); //qans[q[i].i]=cache; ll len=r-l+1; qans[q[i].i]=len*(len-1)/2-cache; } for(int i=0;i\u003cqidx;i++){ printf(\"%lld\\n\",qans[i]); } } return 0; } Problem 3289. – Mato的文件管理 ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:3:1","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"4 树上莫队/转化 当对于树上的路径查询，每个点的贡献也能够快速加入/删除，那么莫队仍然可以做。 一种思路是把树转化为dfs序列。 将询问$u \\to v$先按照dfs序列对u和v换位，使得小的在前。 u是v的祖先，取u和v第一次出现的区间。 如果u不是v的祖先，取u最后一次和v的第一次出现，还需要加入lca(u,v)。 注意处理在u和v决定的区间内节点出现两次的情况。此时应认为该点不存在。 ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:4:0","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"WC2013 糖果公园 这道题就是典型的树上莫队.简单来说,在一个树上不同节点有不同的糖果,第$i$种糖果本身有美味度$V_i$,人们会在书上走简单路径,并品尝每个节点的糖果.同一种糖果吃多次可能会腻,定义第$i$次吃同种糖果的新奇度$W_i$,所以吃掉一个糖果的愉悦(偷税)度表示为糖果美味度和新奇度的乘积.在某些时刻,某些节点发的糖的类型会改变. 代码写得太长了…不过还是比较清晰的 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ccassert\u003e#include \u003ccstring\u003e#include \u003ccmath\u003eusing namespace std; using ll = long long; const int XN = 200010, XM = 200010; vector\u003cint\u003e g[XN]; int delicious[XM]; int w[XM]; int kind[XN]; int origin[XN]; struct Q { int idx; int u, v; int l, r; }qs[XN]; int in[XN], out[XN]; int ref_tick[XN]; int fa[XN][25]; int dep[XN]; int tick = 0; void dfs(int u, int f) { fa[u][0] = f; dep[u] = dep[f] + 1; in[u] = ++tick; ref_tick[tick] = u; for (auto v : g[u]) { if (v == f)continue; dfs(v, u); } out[u] = ++tick; ref_tick[tick] = u; } int lca(int u, int v) { if (dep[u] \u003c dep[v])swap(u, v); for (int p = 20; p\u003e=0; p--) { if (dep[fa[u][p]] \u003e= dep[v]) u = fa[u][p]; } if (u == v)return u; for (int p = 20; p\u003e=0; p--) { if (fa[u][p] != fa[v][p]) { u = fa[u][p]; v = fa[v][p]; } } return fa[u][0]; } pair\u003cint,int\u003e modified[XN]; int cnt[XM],inq[XN]; ll ans[XN]; int belongs[XN]; vector\u003cint\u003e his[XN]; int main() { ios::sync_with_stdio(false); memset(ans, -1, sizeof(ans)); int n, m, q; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; for (int i = 1; i \u003c= m; i++)cin \u003e\u003e delicious[i]; for (int i = 1; i \u003c= n; i++)cin \u003e\u003e w[i]; for (int i = 0; i \u003c n-1; i++) { int u, v; cin \u003e\u003e u \u003e\u003e v; g[u].push_back(v); g[v].push_back(u); } for (int i = 1; i \u003c= n; i++)cin \u003e\u003e kind[i]; for (int i = 1; i \u003c= n; i++)origin[i] = kind[i]; for (int i = 0; i \u003c q; i++) { int opt, u, v; cin \u003e\u003e opt \u003e\u003e u \u003e\u003e v; if (opt == 0) { modified[i].first = u; modified[i].second = v; } else { qs[i].idx = i; qs[i].u = u; qs[i].v = v; } } dfs(1, 0); //for (int i = 1; i \u003c= tick; i++)cout \u003c\u003c ref_tick[i] \u003c\u003c \" \"; //cout \u003c\u003c endl; for (int p = 1; p \u003c 20; p++) { for (int i = 1; i \u003c= n; i++) { fa[i][p] = fa[fa[i][p - 1]][p - 1]; } } //区间[) for (int i = 0; i \u003c q; i++) { Q\u0026 cur = qs[i]; if (cur.u == 0)continue; if (in[cur.u] \u003e in[cur.v])swap(cur.u, cur.v); if (lca(cur.u, cur.v) == cur.u) { cur.l = in[cur.u]; cur.r = in[cur.v]+1; } else { cur.l = out[cur.u]; cur.r = in[cur.v] + 1; } //cout \u003c\u003c cur.l \u003c\u003c \" \" \u003c\u003c cur.r \u003c\u003c endl; } int B = pow(tick, 2.0 / 3); for (int i = 0; i \u003c XN; i++) { belongs[i] = i / B; } sort(qs, qs + q, [=](const Q\u0026 a, const Q\u0026 b) { if (belongs[a.l] != belongs[b.l])return belongs[a.l] \u003c belongs[b.l]; if (belongs[a.r] != belongs[b.r])return belongs[a.r] \u003c belongs[b.r]; return a.idx \u003c b.idx; }); int L = 1, R = 1, T = 0;//T) ll wage=0; for (int i = 0; i \u003c q; i++) { Q\u0026 cur = qs[i]; //cout \u003c\u003ccur.idx\u003c\u003c\",\"\u003c\u003c \"from [\" \u003c\u003c L \u003c\u003c \",\" \u003c\u003c R \u003c\u003c \") to [\" \u003c\u003c cur.l \u003c\u003c \",\" \u003c\u003c cur.r \u003c\u003c \")\" \u003c\u003c endl; if (cur.l == cur.r \u0026\u0026 cur.r == 0)continue; //time while (cur.idx \u003c T) { T--; if (modified[T].first == 0) { continue; } int u = modified[T].first, v = modified[T].second; if (inq[u]) { wage -= (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"remove \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c kind[u] \u003c\u003c \")\" \u003c\u003c (ll)delicious[kind[u]] * w[cnt[kind[u]]] \u003c\u003c endl; cnt[kind[u]]--; } kind[u] = his[u].back(); his[u].pop_back(); if (inq[u]) { cnt[kind[u]]++; wage += (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"add \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c kind[u] \u003c\u003c \")\" \u003c\u003c (ll)delicious[kind[u]] * w[cnt[kind[u]]] \u003c\u003c endl; } } while (cur.idx \u003e T) { if (modified[T].first == 0) { T++; continue; } int u = modified[T].first, v = modified[T].second; if (inq[u]) { wage -= (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"remove \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c kind[u] \u003c\u003c \")\" \u003c\u003c (ll)delicious[kind[u]] * w[cnt[kind[u]]] \u003c\u003c endl; cnt[kind[u]]--; } his[u].push_back(kind[u]); kind[modified[T].first] = modified[T].second; if (inq[u]) { cnt[kind[u]]++; wage += (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"add \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c kind[u] \u003c\u003c \")\" \u003c\u003c (ll)delicious[kind[u]] * w[cnt[kind[u]]] \u003c\u003c endl; } T++; } //L and R //[) while (cur.l \u003c L) { L--; int u = ref_tick[L]; if (!inq[u]) { cnt[kind[u]]++; wage += (ll)delicious[kind[u]] * w[cnt[kind[u]]]; //cout \u003c\u003c \"add \" \u003c\u003c u \u003c\u003c \"(\" \u003c\u003c","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:4:1","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"5 树上莫队 “一般来讲,树上莫队属于比较边缘化的东西,因为其所依赖的树分块处于比较尴尬的境地.” 为了进行下一种树上莫队,也就是真的直接在树上分块做莫队,我们第一个需要解决的问题是如何给树分块.我们对于块的要求仍然没有大的改变. 块内点间距离不能超过块大小 块内点数目适中 块编号相邻,块也需要连续 ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:5:0","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"树分块 BZOJ 1086 [SCOI2005]王室联邦 他想把他的国家划分成若干个省，每个省都由他们王室联邦的一个成员来管理。他的国家有 个城市，编号为 。一些城市之间有道路相连，任意两个不同的城市之间有且仅有一条直接或间接的道路。 每个省至少要有$B$个城市，最多只有$3B$个城市。 每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。但是该省的任意一个城市到达省会所经过的道路上的城市（除了最后一个城市，即该省省会）都必须属于该省。 一个城市可以作为多个省的省会。 这题貌似是树分块的起源.而它的做法,就是我们将要使用的树分块的基础.其做法如下. 总体做法是使用dfs维护由子树节点组成的栈.当进入u时,记录当前栈顶,将子节点加入栈.当栈顶和之前记录的栈顶差达到分块界限时,就把它们弹出并组成一个块.这保证了块间联通,块不经过其他节点.这种做法总能保证分块大小在$[B,2B]$,最后一个块大小在$[B,3B]$. 当v不形成新块时,说明v的栈大小小于B.而栈合并前,v的父节点u的栈也小于B,因此总体大小小于2B. DFS完成后,可能剩余小于B个节点.这些节点加入最后一个块,从而大小小于3B. ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:5:1","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"回到莫队 终于我们对树完成了分块.我们的总体思路仍然是离线排序,暴力转移. 设$T_u$为$u$到根节点的边集合.那么u到v的路径为$T_u \\Delta T_v$. 我们的目标是从$T_u \\Delta T_v$到$T_u’\\Delta T_v'$。由于对称差满足交换律和结合律，有 $$ T_u \\Delta T_v \\Delta (T_u \\Delta T_u’) \\Delta (T_v\\Delta T_v’)=T_u’\\Delta T_v’ $$ 所以，我们可以记录每个点是否有被算入答案，然后暴力转移从$u \\leadsto u'$，从$v \\leadsto v'$，对于在答案中的删除，对于不在答案中的加入。 ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:5:2","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["学习"],"content":"6 注意 关于记录当前问题的区间的开闭问题，需要谨慎安排。 在确认了区间开闭后，关于最初始的状态，需要谨慎安排。 ","date":"2019-08-03","objectID":"/2019/08/mo-s-algorithm/:6:0","tags":["莫队","分块","LCA"],"title":"莫队算法","uri":"/2019/08/mo-s-algorithm/"},{"categories":["code"],"content":"zz6d likes reading very much, so he bought a lot of books. One day, zz6d brought n books to a classroom in school. The books of zz6d is so popular that K students in the classroom want to borrow his books to read. Every book of zz6d has a number i (1\u003c=i\u003c=n). Every student in the classroom wants to get a continuous number books. Every book has a pleasure value, which can be 0 or even negative (causing discomfort). Now zz6d needs to distribute these books to K students. The pleasure value of each student is defined as the sum of the pleasure values of all the books he obtains.Zz6d didn’t want his classmates to be too happy, so he wanted to minimize the maximum pleasure of the K classmates. zz6d can hide some last numbered books and not distribute them,which means he can just split the first x books into k parts and ignore the rest books, every part is consecutive and no two parts intersect with each other.However,every classmate must get at least one book.Now he wonders how small can the maximum pleasure of the K classmates be. 1\u003c=T\u003c=10 1\u003c=n\u003c=2*105 1\u003c=k\u003c=n -109\u003c=ai\u003c=109 分析 最大值最小，考虑二分答案。思考题目是否具有单调性：当最大值极大时，书可以随便分，当最大值极小时，可能会出现无法凑齐的状况，目测满足。 题目要求分书时必须连续分，可以使用动态规划来做。假设二分的答案为lim $$f(i)=\\max \\{ f(j) | \\sum_{k=j+1}^i a_k \\leq lim \\}+1$$ 将求和改为前缀和，$pre(i)$。 $$f(i)=\\max \\{ f(j) | pre(i)-pre(j-1) \\leq lim \\}+1$$ 动态规划的复杂度为$O(n^2)$，太慢，考虑优化。 每次转移都从先前已经出现的满足要求的f中转移。限制条件转一下，就是 $$pre(i)-lim \\leq pre(?)$$ 当有2个f对应的前缀和相同，我们选择更大的那个 所以可以直接维护已经出现的每种前缀和所对应的最大f。可以离散化后使用权值线段树。复杂度变为$O(n\\lg n)$ 总复杂度为$O(n\\lg n \\lg n)$。 代码 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; using ll=long long; const int MAXN=900010; ll dat[MAXN]; int lc[MAXN],rc[MAXN]; int idx=0; int build(int \u0026n,int l,int r){ if(!n)n=++idx; dat[n]=-0x3f3f3f3f; if(l\u003e=r)return dat[n]; int mid=(l+r)/2; dat[n]=max(build(lc[n],l,mid),build(rc[n],mid+1,r)); return dat[n]; } void collectchild(int node){ dat[node]=max(dat[lc[node]],dat[rc[node]]); } int query_n(int l,int r,int L,int R,int node){ if(l\u003c=L \u0026\u0026 R\u003c=r)return dat[node]; int mid=(L+R)/2; int res=-0x3f3f3f3f; if(l\u003c=mid)res=max(res,query_n(l,r,L,mid,lc[node])); if(mid\u003cr)res=max(res,query_n(l,r,mid+1,R,rc[node])); return res; } void modify(int l,int r,ll x,int L,int R,int node){ if(L\u003e=R){ dat[node]=max(dat[node],x); return; } int mid=(L+R)/2; if(l\u003c=mid)modify(l,r,x,L,mid,lc[node]); if(mid\u003cr)modify(l,r,x,mid+1,R,rc[node]); collectchild(node); } ll prefix[MAXN]; ll bprefix[MAXN]; ll num[MAXN]; int nlen,sel; int rlen; int root; bool check(ll x){ build(root,0,rlen-1); int zero=lower_bound(bprefix,bprefix+rlen,0)-bprefix; modify(zero,zero,0,0,rlen-1,root); for(int i=1;i\u003c=nlen;i++){ int start=lower_bound(bprefix,bprefix+rlen,bprefix[prefix[i]]-x)-bprefix; int dp=query_n(start,rlen-1,0,rlen-1,root)+1; if(dp\u003e=sel)return true; modify(prefix[i],prefix[i],dp,0,rlen-1,root); } return false; } int main(){ //debug /* int opt; build(root,0,10-1); while(cin\u003e\u003eopt){ if(opt==1){ int pos,x;cin\u003e\u003epos\u003e\u003ex; modify(pos,pos,x,0,10-1,root); }else{ int l,r;cin\u003e\u003el\u003e\u003er; cout\u003c\u003cquery_n(l,r,0,10-1,root)\u003c\u003cendl; } } */ int kase;cin\u003e\u003ekase; while(kase--){ cin\u003e\u003enlen\u003e\u003esel; for(int i=1;i\u003c=nlen;i++){ cin\u003e\u003enum[i]; } bprefix[0]=prefix[0]=0; for(int i=1;i\u003c=nlen;i++)bprefix[i]=prefix[i]=prefix[i-1]+num[i]; //discrete sort(bprefix,bprefix+nlen+1); rlen=unique(bprefix,bprefix+nlen+1)-bprefix; for(int i=0;i\u003c=nlen;i++)prefix[i]=lower_bound(bprefix,bprefix+rlen,prefix[i])-bprefix; //binary ll l=-1e15,r=1e15; while(l+1\u003cr){ ll mid=(l+r)/2; if(check(mid)){ r=mid; }else l=mid; } for(ll i=l;i\u003c=r;i++){ if(check(i)){ cout\u003c\u003ci\u003c\u003cendl; break; } } } return 0; } 多组询问没有清理干净数组，WA了好几发。 ","date":"2019-08-01","objectID":"/2019/08/distribution-of-books/:0:0","tags":null,"title":"Distribution of Books","uri":"/2019/08/distribution-of-books/"},{"categories":["code"],"content":"Farmer John keeps a website called ‘FansBlog’ .Everyday , there are many people visited this blog.One day, he find the visits has reached P , which is a prime number.He thinks it is a interesting fact.And he remembers that the visits had reached another prime number.He try to find out the largest prime number Q ( Q \u003c P ) ,and get the answer of Q! Module P.But he is too busy to find out the answer. So he ask you for help. ( Q! is the product of all positive integers less than or equal to n: n! = n * (n-1) * (n-2) * (n-3) *… * 3 * 2 * 1 . For example, 4! = 4 * 3 * 2 * 1 = 24 ) First line contains an number T(1\u003c=T\u003c=10) indicating the number of testcases. Then T line follows, each contains a positive prime number P (1e9≤p≤1e14) 分析 这题得知道2个结论，然而我都不知道。 ","date":"2019-08-01","objectID":"/2019/08/fansblog/:0:0","tags":null,"title":"Fansblog","uri":"/2019/08/fansblog/"},{"categories":["code"],"content":"威尔逊定理 当P为质数时，$(P-1)! \\equiv -1 \\pmod P$. 注意这里$!$是阶乘，不是取反的意思。 ","date":"2019-08-01","objectID":"/2019/08/fansblog/:1:0","tags":null,"title":"Fansblog","uri":"/2019/08/fansblog/"},{"categories":["code"],"content":"素数分布 当范围变大时，素数的出现频率增高，寻找一素数的相邻素数复杂度逐渐趋近于线性。 所以，寻找素数P的前一个素数可以直接暴力找。找到之后利用$(P-1)! \\equiv -1 \\pmod P$即可快速由$P-1$的阶乘通过逆元转到$Q$的阶乘，这题就做完了。 因为在计算逆元时会爆ll，使用快速乘法来避免，复杂度符合要求。 代码 #include \u003ciostream\u003e#include \u003ccmath\u003e#include \u003ccstdlib\u003e#include \u003calgorithm\u003eusing namespace std; using ll=long long; inline ll qmul(ll x,ll y,ll q){ ll res=0; for(;y;y\u003e\u003e=1,x=(x+x)%q){ if(y\u00261)res=(res+x)%q; } return res; } inline ll qpow(ll x,ll a,ll q){ ll res=1; for(a;a;a\u003e\u003e=1,x=qmul(x,x,q)){ if(a\u00261)res=qmul(res,x,q); } return res; } inline ll get_rev(ll x,ll q){ return qpow(x,q-2,q); } inline bool is_prime(ll x){ for(ll i=2;i\u003c=sqrt(x);i++){ if(x%i==0)return false; } return true; } inline ll factor(ll l,ll r,ll q){ ll res=1; for(ll i=l;i\u003c=r;i++)res=qmul(res,i,q); return res; } int main(){ ios::sync_with_stdio(false); int kase;cin\u003e\u003ekase; while(kase--){ ll x;cin\u003e\u003ex; ll prex=x-1; while(!is_prime(prex))prex--; ll ans=qmul(x-1,get_rev(factor(prex+1,x-1,x),x),x); cout\u003c\u003cans\u003c\u003cendl; } return 0; } ","date":"2019-08-01","objectID":"/2019/08/fansblog/:2:0","tags":null,"title":"Fansblog","uri":"/2019/08/fansblog/"},{"categories":["code"],"content":"一些结论 $N!$的质因数分解中某质数的指数为$\\sum_{r=1}^{\\inf}n/p^r $ 约数个数为质因数指数+1的乘积，和为质因数枚举指数次和的乘积。 费马小定理要求p是质数 ","date":"2019-07-22","objectID":"/2019/07/salt-fish-playing-number/:1:0","tags":null,"title":"咸鱼数论","uri":"/2019/07/salt-fish-playing-number/"},{"categories":["code"],"content":"欧拉函数 小于x且与其互质的数的个数 $$ \\phi(x)=x\\prod_{k=1}^n(1-\\frac{1}{p_k}) $$ $phi(1)=1$ $phi(p)=p-1$,当p为质数 $phi(2n)=phi(n)$ $phi(phi(phi…))))=1$ 对于任意积性函数$f(xy)=f(x)f(y)$，可以筛。欧拉函数非完全积性函数。 $phi(xy)=phi(x)(y-1)$,当x与y互质 $phi(xy)=phi(x)y$,当x与y不互质 for(int i=2;i\u003c=n;i++){ if(!no[i]){ p[++cnt]=i; phi[i]=i-1; } for(int j=1;j\u003c=cnt\u0026\u0026p[j]*i\u003c=n;j++){ no[p[j]*i]=1; if(i%p[j]==0){ phi[p[j]*i]=phi[i]*p[j]; break; } phi[p[j]*i]=phi[i]*(p[j]-1); } } ","date":"2019-07-22","objectID":"/2019/07/salt-fish-playing-number/:2:0","tags":null,"title":"咸鱼数论","uri":"/2019/07/salt-fish-playing-number/"},{"categories":["code"],"content":"扩展欧几里得 存在x，y使得ax+by=gcd（a，b） 求逆元，要求x与模数互质 void exgcd(ll a,ll b,ll \u0026x,ll \u0026y){ if(!b){ x=1,y=0; }else{ exgcd(b,a%b,y,x); y-=(a/b)*x; } } ","date":"2019-07-22","objectID":"/2019/07/salt-fish-playing-number/:3:0","tags":null,"title":"咸鱼数论","uri":"/2019/07/salt-fish-playing-number/"},{"categories":["code"],"content":"递推逆元 inv(i) = inv(mod % i) * (mod-mod/i) % mod; 阶乘的逆元：inv(i)=inv(i+1)*(i+1) ","date":"2019-07-22","objectID":"/2019/07/salt-fish-playing-number/:4:0","tags":null,"title":"咸鱼数论","uri":"/2019/07/salt-fish-playing-number/"},{"categories":["code"],"content":"集合挑选 从给定的N个集合中各挑出一个数并求和，求出前$K$大的$K$个和。 考虑如何从2个集合$A$,$B$中选出前$K$大。降序排序后$a_1$和$b_1$显然是最大，第二大则是$(a_1,b_2)$或者$(a_2,b_1)$。不妨以$(a_1,b_2)$来讲，那么第三大竞争者除$(a_2,b_1)$还有$(a_1,b_3)$，$(a_2,b_3)$……每对组合都能找到直接小于它的2个组合，而这种后继关系显然取遍了所有组合。仅需要前K大的我们按需扩展这一棵树即可。2个集合的前K大可与第3个集合执行相同的操作，从而得到最终答案。实际编写时，按照一定顺序限制扩展方向来保证每个方案仅访问一次，使用优先队列维护，复杂度为$O(\\sum^N{K\\log n_k}) \\leq O(KN)$ ","date":"2019-07-22","objectID":"/2019/07/water-series/:1:0","tags":null,"title":"水的合集 1","uri":"/2019/07/water-series/"},{"categories":["code"],"content":"LIS优化 $$f(i)=max\\{f(j)| j 可以发现，一旦有$a(k) \u003c a(j), f(k) \\geq f(j)$，j这个位置就没有用了。按照该规律维护一个单调栈记录，以长度单调（则数字a结尾的LIS自然单调）。此后转移 ","date":"2019-07-22","objectID":"/2019/07/water-series/:2:0","tags":null,"title":"水的合集 1","uri":"/2019/07/water-series/"},{"categories":["code"],"content":"给出一个$N \\times N$的非负整数矩阵，要求找到一条从左上角数字到右下角数字的路线，且 只能向右或者下走。 将经过数字相乘后得到的结果，使其末尾的“0”最少。 $$ N \\leq 1000 $$ ","date":"2019-07-20","objectID":"/2019/07/bupt-warmupcf-milktea/:0:0","tags":["动态规划"],"title":"[BUPT WARMUP|CF] 珍珠奶茶","uri":"/2019/07/bupt-warmupcf-milktea/"},{"categories":["code"],"content":"分析 大概是因为末尾的0长得像珍珠。 思考0是怎么出现的，可以发现结果中因数10的指数越小越好，即，使得经过的路上凑出的因数10最少即可。10的质因数分解为$2 \\times 5$，以矩阵中每个数所含因数2和5的数目分别DP一遍求路径，再在两次DP的结果中取小。 一个特殊情况是数字里有0，那么经过0的路的末尾0一定是1个……一开始脑袋抽了以为是0个。如果其他情况的路径末尾0都多于1个的话，就特判走0。 ","date":"2019-07-20","objectID":"/2019/07/bupt-warmupcf-milktea/:1:0","tags":["动态规划"],"title":"[BUPT WARMUP|CF] 珍珠奶茶","uri":"/2019/07/bupt-warmupcf-milktea/"},{"categories":["code"],"content":"代码 #include \u003ciostream\u003e#include \u003calgorithm\u003eusing namespace std; constexpr int MAXN=1010; int game[MAXN][MAXN]; int num[2][MAXN][MAXN]; int cal(int x,int fac){ if(x==0)return 0; int res=0; while(x%fac==0){ x/=fac; res++; } return res; } int n; int dp[MAXN][MAXN]; int from[MAXN][MAXN]; void dodp(int fac){ for(int i=0;i\u003cMAXN;i++){ for(int j=0;j\u003cMAXN;j++){ dp[i][j]=0x3f3f3f3f; } } dp[0][1]=dp[1][0]=0; for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n;j++){ if(dp[i-1][j]\u003cdp[i][j-1]){ from[i][j]=2; dp[i][j]=dp[i-1][j]; }else{ from[i][j]=1; dp[i][j]=dp[i][j-1]; } dp[i][j]+=num[fac][i][j]; } } } string genpath(){ string res=\"\"; int i=n,j=n; for(int p=from[i][j];i!=1 || j!=1 ;p=from[i][j]){ if(p==2){ res+=\"D\"; i--; }else{ res+=\"R\"; j--; } } reverse(res.begin(),res.end()); return res; } int main(){ ios::sync_with_stdio(false); cin\u003e\u003en; bool haszero=false; int zeroi,zeroj; for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n;j++){ cin\u003e\u003egame[i][j]; if(game[i][j]==0){ haszero=1; zeroi=i,zeroj=j; } } } for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=n;j++){ num[0][i][j]=cal(game[i][j],2); num[1][i][j]=cal(game[i][j],5); } } int ans=0x7f7f7f7f; dodp(0); string P; if(ans\u003edp[n][n]){ ans=dp[n][n]; P=genpath(); } dodp(1); if(ans\u003edp[n][n]){ ans=dp[n][n]; P=genpath(); } if(haszero \u0026\u0026 ans\u003e1){ cout\u003c\u003c1\u003c\u003cendl; for(int i=1;i\u003czeroi;i++)cout\u003c\u003c\"D\"; for(int j=1;j\u003czeroj;j++)cout\u003c\u003c\"R\"; for(int i=zeroi+1;i\u003c=n;i++)cout\u003c\u003c\"D\"; for(int j=zeroj+1;j\u003c=n;j++)cout\u003c\u003c\"R\"; cout\u003c\u003cendl; return 0; } cout\u003c\u003cans\u003c\u003cendl; cout\u003c\u003cP\u003c\u003cendl; return 0; } ","date":"2019-07-20","objectID":"/2019/07/bupt-warmupcf-milktea/:2:0","tags":["动态规划"],"title":"[BUPT WARMUP|CF] 珍珠奶茶","uri":"/2019/07/bupt-warmupcf-milktea/"},{"categories":["code"],"content":"There is a tree having n nodes, the i-th node of which has a type of color, denoted by an integer $c_i$ The path between every two nodes is unique, of which we define the value is the number of distinct types of colors appearing on it. Calculate the sum of values of all possible paths, $\\frac{n(n-1)}{2}$ in total, between two different nodes on the tree. ","date":"2019-07-12","objectID":"/2019/07/colorful-tree/:0:0","tags":null,"title":"Colorful Tree","uri":"/2019/07/colorful-tree/"},{"categories":["code"],"content":"输入范围 多组数据,约50;节点数$2 \\times 10^5$. 分析 没想出来该怎么做.统计路径颜色的答案没有什么合并的好方法,同时也不能按照每种颜色单独考虑. 后来经过dalao点拨,该题中的\"统计一条路径上颜色种类\"的要求可以转化为求其反面“没有某种颜色的路径有多少种”. 如此,对于每一种颜色就可以使用$n(n-1)/2-size$来求其对答案的贡献了.So,来解决这个问题. 原图是一棵树,如果某点$N$为颜色$c$,那么经过$N$的子树任意点跨越$N$的路径都有该颜色.所有不包括该颜色$c$的路径只能出现在以$N$为切点的其他2部分.考虑其中一个部分,任意选中其中2个节点即可构建一条路径,但还是必须满足刚刚的条件(不能跨越颜色$c$的节点).以dfs递归进去即可. 考虑能否递归合并已有答案.能够得到的数据有子节点中2部分的节点数目,显然能够合并出以当前节点为界划分的2部分中的一部分,自然可以在递归返回后推出另一部分. 代码 #include \u003ciostream\u003e#include \u003cset\u003e#include \u003calgorithm\u003e#include \u003ccstdlib\u003e#include \u003ccstring\u003e#include \u003ccmath\u003e#include \u003cvector\u003eusing namespace std; typedef long long ll; const int MAXV=200010; vector\u003cint\u003e g[MAXV]; inline void adde(int u,int v){ g[u].push_back(v); } int color[MAXV]; ll sz[MAXV]; ll gsz; ll res=0; void dfs(int u,int fa){ gsz++; for(auto v:g[u]){ if(v==fa)continue; ll b_gsz=gsz; ll b_sz=sz[color[u]]; dfs(v,u); ll d=(gsz-b_gsz)-(sz[color[u]]-b_sz); res+=d*(d-1)/2; sz[color[u]]+=d; } sz[color[u]]++; } int flag[MAXV]; int main(){ ios::sync_with_stdio(false); int n; int kase=0; while(cin\u003e\u003en){ for(int i=1;i\u003c=n;i++)g[i].clear(); memset(sz,0,sizeof(sz)); gsz=0; res=0; vector\u003cint\u003e discol; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ecolor[i]; flag[color[i]]=1; } for(int i=1;i\u003c=n;i++){ if(flag[i])discol.push_back(i); } for(int i=0;i\u003cn-1;i++){ int u,v;cin\u003e\u003eu\u003e\u003ev; adde(u,v); adde(v,u); } int disnum=discol.size(); dfs(1,0); ll ans=(ll)disnum*n*(n-1)/2; for(auto i:discol){ ll t=n-sz[i]; ans-=t*(t-1)/2; } cout\u003c\u003c\"Case #\"\u003c\u003c++kase\u003c\u003c\": \"\u003c\u003cans-res\u003c\u003cendl; } return 0; } ","date":"2019-07-12","objectID":"/2019/07/colorful-tree/:1:0","tags":null,"title":"Colorful Tree","uri":"/2019/07/colorful-tree/"},{"categories":["学习"],"content":" 写代码是不可能写代码的,今下午是不想写代码的.不想写代码,又不想咸鱼,就只能靠学点新东西来假装自己在工作的样子,心里才能好受些. 窃格码拉 几乎可以肯定,下面的内容肯定会出锅. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:0:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"傅里叶变换的实际意义 ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:1:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"从电压说起 被模电折磨的同学都知道,有种东西叫做傅里叶级数,可以将成周期性变化的电压分解为数个三角函数波的叠加. 在这里,我们提出另一个问题,如果不知道周期,该如何将这些叠加在一起的信号拆分为单纯的三角波? 三角波叠加图象周期并不那么显然,也许你可以试一试. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:1:1","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"一种缠绕机 有一种奇特的方法,我们将一段时域图象在笛卡尔坐标系上以原点为圆心绕起来,一圈一圈缠起来,然后调整源图象缠绕的速率(几秒一圈),观察整个图形的质心变化. 这个质心会随着图象缠绕的频率而发生位移.取质心的x坐标为y轴,以缠绕的频率为横轴,作出图象B.在这个图象上,会观测到一个现象:(假设我们已知原图像的分解三角波频率)当缠绕频率接近某个源三角波的频率时,缠绕图象出现重合,质心相对原点出现较大位移,图象出现一个峰值. 继续调整缠绕频率,峰值消失,图象回归到小范围波动. 通过观察图象B,可以认为,出现峰值的频率对应着一个频率的源三角波.如此,就将叠加图象还原了回去. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:1:2","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"傅里叶变换的数学实现 现在,考虑如何通过的数学的方法来实现这个缠绕. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:2:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"如何缠绕 将$g(t)$的图象缠绕到圆上听起来挺奇怪的,有这样的数学方法吗. 有一个东西,叫做$y=e^{ix}$.当其图象画在复平面时,就出现了有趣的事情:一个圆.对这个公式做一些加工. $$ y=g(t)e^{-2\\pi i ft} $$ 如此,就能够将$g(t)$以$f$频率缠绕. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:2:1","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"关于质心 上文我们取质心的x坐标作图,现在需要稍微修改一下. 实际上,我们关心的是质心相对于原点的偏移距离.同样,以复平面的方式来表示质心位置就能够同时保留x和y坐标信息. 关于如何求取质心,其实也很直观.选取缠绕图象上的数个点,取平均,就是质心的大约位置.当点的数目达到极限,求和公式化为积分,所求即为质心. $$ \\hat g(f)=\\frac{1}{t_2-t_1} \\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}} $$ ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:2:2","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"? 目前为止,这几乎已经是傅里叶变换了.在数学应用时,傅里叶变换会去掉取均值,即 $$ \\hat g(f)=\\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}} $$ 也就是说,取样的时域信号越长,该质心的偏移倾向越大,这和我们想要的效果一致. 这就是傅里叶变换,实现了时域信号到频域信号的转换. 此外,还有方法将频域信号再次逆变换为时域信号的方法. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:2:3","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"应用 傅里叶变换在很多领域都有重要作用.只要问题能转换为时域频域之间的变化,就有傅里叶变换的用武之处. 比如,在音频处理软件中,常常有一个功能叫做消除人声.基于傅里叶变换我们可以设计一个(至少理论上有用)的算法. 首先,任何声音都是相应频率的波对气压变化引起的,也就是不同频率的波在时间上叠加在一起,产生了声音.将源波使用傅里叶变换拆分到多个三角波上去.删除人声所在的频域,再将频域信号逆变换为时域信号.人声便消失了. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:3:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"离散傅里叶变换 连续意义下的傅里叶变换先到此为止.在计算机中所处理的数据一般都是离散的.我们需要的是离散傅里叶变换. 离散意义下的时域信号和频域信号就都变成了点集.当从连续向离散过渡时,可以这样思考: 在连续的图象上以一定间隔取样得到离散点集.使用该点集进行傅里叶变换. 这也是我们一开始采取的质心求解方法,只不过,这次我们从缠绕时就取样.(质点依然是真正的质点) 对于点集$g(0\\leq n \u003c N)$,它的傅里叶变化就是 $$ \\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk} $$ 简单粗暴. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:4:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"快速傅里叶变换 在了解了关于傅里叶变换的一系列背景与一个应用后,我们再回来解决一些重要的问题. 根据傅里叶变换的公式定义 $$ \\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk} $$ 其朴素算法的时间复杂度为$O(N^2)$ 这个复杂度还不够优秀.一种快速傅里叶变换算法利用$e^{ix}$的性质,将复杂度降低到了$O(N\\lg N)$. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:5:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"单位根 给$e^{ix}$个名字. 在数学上, $n$次单位根是 $n$次幂为1的复数.它们位于复平面的单位圆上,构成正n边形的顶点,其中一个顶点是1. 记 $$ \\omega_{n,k}=-e^{i\\frac{2\\pi}{n}k} $$ 其几何意义为单位圆上的n等分点的顺时针第k个. 一般来说,单位根取逆时针,不过这里为了方便,取顺时针. 如同三角函数一样,单位根存在一些显然的定理. **折半:**$\\omega_{2n,2k}=\\omega_{n,k}$ **化简:**$\\omega_{n,k+\\frac 2n}=-\\omega_{n,k}$ 修改公式 来看原本的离散傅里叶变换公式 $$ \\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk} $$ 使用单位根来替换一下 $$ \\hat g(k)=\\sum_{n=0}^{N-1}\\omega_{N,nk} g(n) $$ 按照化简公式的指引,将求和公式按照单位根奇偶拆分为2部分. $$ \\begin{aligned} \\hat g(k) \u0026= \\sum_{n=0}^{N-1}\\omega_{N,nk} g(n) \\\\ \u0026= \\sum_{0 \\leq n 注意到不管是$\\hat g_{even}(k)$还是$\\hat g_{even}(k)$,它们都以$N/2$为周期.接下来,应用化简定理 $$ \\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k) $$ 将这2个式子放在一起 $$ \\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\ \\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k) $$ 当k取遍原问题规模的一半时,可以直接由第二个式子得到另一半.问题的规模减半.递归求解,最终的复杂度就降到了$O(N \\lg N)$. 这就是Cooley-Turkey快速傅里叶变换算法. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:5:1","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"快速乘法 定义多项式$A(x)=\\sum_k a_kx^{k+1}$,$B(x)$同理,求解$C(x)=A(x)B(x)$. 很容易看出,朴素算法的复杂度为$O(N^2)$. 现在,来看如何使用FFT快速计算. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:6:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"点值表示 对于一个次数为$n-1$的多项式,其图象上互不相同的$n$个点可以唯一确定该多项式. … 如同确定混合在一起的几个波一样. 至于为什么是对的,大可在Google上搜索一番. 取$x$为数个单位根,在$A(x)$和$B(x)$上利用单位根的性质得到$A$和$B$的点值表示,将点值相乘得到$C$的点值表示.之后,将$C$的点值表示再转换为系数表示. 嗯?FFT在哪? 其实在这里, $$ \\hat g(\\omega)=A(\\omega)=\\sum_{n}\\omega A[x^{n+1}] $$ ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:6:1","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"离散卷积 有一种数学运算,叫做卷积.现在只讨论它的离散情况. $$ (f * g)(n)=\\sum_{\\tau=-\\inf}^{inf}f(\\tau)g(n-\\tau) $$ 这玩意的意义…实在是不怎么明显.不过好在我们只是想算个多项式乘法,也就是把多项式的系数算来算去: $C[x^n]$ 表示多项式$C$中$x^n$项的系数. $$ C[x^{n}]=\\sum_{\\tau=0}^{n}A[x^\\tau]B[x^{n-\\tau}] $$ 嗯? 如果我们设多项式中不存在的项的系数为0的话. $$ C[x^{n}]=\\sum_{\\tau=-\\inf}^{\\inf}A[x^\\tau]B[x^{n-\\tau}] $$ 哈, $$ C[x^n]=(A*B)[x^n] $$ ### 卷积定理 卷积定理指出: 一个域中的卷积对应于另一个域中的乘积. 这意味着,上面这个计算(卷积)对应着另一个域里的乘积.也就是 $$ F(C[x^n])=F(A[x^n]) \\cdot F(B[x^n]) $$ 这便是深层原理.对A和B的取样(频域)称为A和B的点值表示,最终以乘积的方式得到了C的点值表示(频域).用FFT来计算乘法的说法是对的. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:6:2","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"傅里叶逆变换 如何从一个频域信号再得到时域信号? $$ g(n)=\\frac 1N\\sum_{k=0}^{N-1}e^{i\\frac{2\\pi}{N}nk} \\hat g(k) $$ 注意:此处的1/N与上面的变换是相匹配的. 这个式子可以理解成对变换后的式子再变换,意味着它同样可以用变换时的思想来加速. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:7:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"FFT的C++实现 一个值得注意的问题就是,对于单位根的运算涉及到了精度的问题.但目前还不需要讨论. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:8:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"翻转操作 可以观察到,按照上面的算法实现,我们需要在每次递归按照奇和偶将取样分组.且每次递归都会分组.每次分组都会涉及到数组的复制,常数较大. 观察分组操作中下标的变化. (表示下标) 0 1 2 3 4 5 6 7 0 2 4 6 | 1 3 5 7 0 4 | 2 6 | 1 5 | 3 7 将其转换为二进制 000 001 010 011 100 101 110 111 000 100 010 110 001 101 011 111 可以发现,最终的分组结果就是将原下标二进制翻转.所以可以直接一次完成分组. 注意,这要求取样为2的幂次. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:8:1","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"🦋蝴蝶操作 解决了递归中由顶至底的分组后,接下来优化子问题合并时的数组复制. 观察原来的合并式子 $$ \\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\ \\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k) $$ 按照算法中的实现方法,其为 $$ \\hat g(k)=\\hat g(k)+\\omega_{N,k} \\hat g(k+\\frac N2) \\\\ \\hat g(k+\\frac N2)=\\hat g(k)-\\omega_{N,k} \\hat g(k+\\frac N2) $$ 想要省略数组复制,进行原地合并,问题出在新数值太早地替换掉了我们需要的数值. 取辅助变量,修改原式 $$ t=\\omega_{N,k} \\hat g(k+\\frac N2)\\\\ \\hat g(k+\\frac N2)=\\hat g(k)-t\\\\ \\hat g(k)=\\hat g(k)+t $$ 这个操作被称为\"蝴蝶操作”,名字很有意思. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:8:2","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"代码 在这段代码中同时去掉了递归. const double PI=acos(-1); inline complex\u003cdouble\u003e gomega(int n,int k,bool rev=false){ complex\u003cdouble\u003e res(cos(2*PI/n*k),sin(2*PI/n*k)); if(rev)return conj(res); else return res; } const int MAXN=10; struct FFT{ complex\u003cdouble\u003e omega[MAXN],omegaI[MAXN]; FFT(int n){ for(int i=0;i\u003cn;i++){ omega[i]=gomega(n,i); omegaI[i]=gomega(n,i,1); } } void transform(complex\u003cdouble\u003e *a,int n,const complex\u003cdouble\u003e *omega){ for(int i=0,j=0;i\u003cn;i++){ if(i\u003ej)swap(a[i],a[j]); //二进制换位 for(int l=n/2;(j^=l)\u003cl;l\u003e\u003e=1); } for(int l=2;l\u003c=n;l\u003c\u003c=1){ int m=l/2; for(complex\u003cdouble\u003e *p=a;p!=a+n;p+=l){ for(int i=0;i\u003cm;i++){ //蝴蝶操作 complex\u003cdouble\u003e t=omega[n/l*i]*p[m+i]; p[m+i]=p[i]-t; p[i]+=t; } } } } void dft(complex\u003cdouble\u003e *a,int n){ transform(a,n,omega); } void idft(complex\u003cdouble\u003e *a,int n){ transform(a,n,omegaI); for(int i=0;i\u003cn;i++)a[i]/=n; } }; 如果想要实现快速乘法,只要将2个多项式的系数函数传入进行变换,变换结果相乘并逆变换即可. ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:8:3","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"应用 ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:9:0","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"快速乘法 指快速大数乘法。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccomplex\u003e#include \u003ccmath\u003eusing namespace std; const int MAXN=300000; const double PI=acos(-1); inline complex\u003cdouble\u003e gomega(int n,int k,bool rev=false){ complex\u003cdouble\u003e res(cos(2*PI/n*k),sin(2*PI/n*k)); if(rev)return conj(res); else return res; } struct FFT{ complex\u003cdouble\u003e omega[MAXN],omegaI[MAXN]; FFT(){ } void init(int n){ for(int i=0;i\u003cn;i++){ omega[i]=gomega(n,i); omegaI[i]=gomega(n,i,1); } } void transform(complex\u003cdouble\u003e *a,int n,const complex\u003cdouble\u003e *omega){ for(int i=0,j=0;i\u003cn;i++){ if(i\u003ej)swap(a[i],a[j]); //二进制换位 for(int l=n/2;(j^=l)\u003cl;l\u003e\u003e=1); } for(int l=2;l\u003c=n;l\u003c\u003c=1){ int m=l/2; for(complex\u003cdouble\u003e *p=a;p!=a+n;p+=l){ for(int i=0;i\u003cm;i++){ //蝴蝶操作 complex\u003cdouble\u003e t=omega[n/l*i]*p[m+i]; p[m+i]=p[i]-t; p[i]+=t; } } } } void dft(complex\u003cdouble\u003e *a,int n){ transform(a,n,omega); } void idft(complex\u003cdouble\u003e *a,int n){ transform(a,n,omegaI); for(int i=0;i\u003cn;i++)a[i]/=n; } }; complex\u003cdouble\u003e a[2][MAXN]; int ans[MAXN]; FFT fft; int main(){ int nlen;cin\u003e\u003enlen; int n=1; //根据原理，n必须取大于2nlen的数，才能满足取样要求和反转操作要求 while(n\u003c2*nlen)n*=2; fft.init(n); for(int i=0;i\u003c2;i++){ string inp;cin\u003e\u003einp; for(int j=0,k=inp.size()-1;j\u003cinp.size();j++,k--){ a[i][j]=complex\u003cdouble\u003e(inp[j]-\u0026#039;0\u0026#039;,0); } fft.dft(a[i],n); } for(int i=0;i\u003cn;i++)a[0][i]=a[0][i]*a[1][i]; fft.idft(a[0],n); int reslen=nlen+nlen-1; for(int i=reslen-1,k=0;i\u003e=0;i--,k++) ans[k]=(int)floor(a[0][i].real()+0.5); /* for(int i=0;i\u003creslen;i++)cout\u003c\u003cans[i]\u003c\u003c\" \"; cout\u003c\u003cendl; */ for(int i=0;i\u003cMAXN;i++){ ans[i+1]+=ans[i]/10; ans[i]%=10; } int ptr=MAXN-1; while(ans[ptr]==0)ptr--; for(;ptr\u003e=0;ptr--)cout\u003c\u003cans[ptr]; cout\u003c\u003cendl; return 0; } ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:9:1","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["学习"],"content":"实际意义 但是更加值得关心的是其广义上的物理意义。N个采样点拿到的N个值到底对应着什么。 设采样率为$F$，采样间隔为$T=\\frac{1}{F}$。设采样次数$N$。那么显然不管是数据下标还是结果下标，都不是其原有意义。 有如下对应关系 采样时长为$TN$或者$N/F$（采样区间长度） 数据下标很显然 结果略有一点点绕。对于「在$N$个点中出现了$k$个周期」的基信号，一个周期$N/k$个点，一个周期时长$\\frac{N}{kF}$。如果不想把你的频域图像画爆那就倒过来取周期频率$\\frac{F}{N}k$。 即结果的点下标$x$对应着频率为$\\frac{F}{N}x$的基信号。 ","date":"2019-07-12","objectID":"/2019/07/fast-fourier-transform/:9:2","tags":["FFT"],"title":"快速傅里叶变换","uri":"/2019/07/fast-fourier-transform/"},{"categories":["闲扯"],"content":"众所周知，快速排序的时间复杂度是$O(n\\lg n)$的。然而因为我太菜，写出来的快速排序一不小心就成了$O(n^2)$… ","date":"2019-07-12","objectID":"/2019/07/do-i-write-qsort-right/:0:0","tags":null,"title":"我把快排写错了?","uri":"/2019/07/do-i-write-qsort-right/"},{"categories":["闲扯"],"content":"这个辣鸡问题 这个应该都知道，当待排序数组已经有序时，固定选择某一个位置的数字当哨兵的快排会变成$O(n^2)$。一个解决方法就是随机选择哨兵，或者干脆将输入的数组打乱后再排序。 然而，如果输入的数组数字全部相同呢？ 当然这在实际中很少见，但是在实现的时候就要小心。在这种情况下，所实现的快排必须对于相同数字也交换位置，否则就会退化为$O(n^2)$。 比如说，这个 void quicksort(int left,int right) { int i,j,t,temp; if(left\u003eright) return; temp=a[left]; //temp中存的就是基准数 i=left; j=right; while(i!=j) { //顺序很重要，要先从右边开始找 while(a[j]\u003e=temp \u0026\u0026 i\u003cj) j--; //再找右边的 while(a[i]\u003c=temp \u0026\u0026 i\u003cj) i++; //交换两个数在数组中的位置 if(i\u003cj) { t=a[i]; a[i]=a[j]; a[j]=t; } } //最终将基准数归位 a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1,right);//继续处理右边的 ，这里是一个递归的过程 } 还有这个， void quick_sort(int s[], int l, int r) { if (l \u003c r) { //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1 int i = l, j = r, x = s[l]; while (i \u003c j) { while(i \u003c j \u0026\u0026 s[j] \u003e= x) // 从右向左找第一个小于x的数 j--; if(i \u003c j) s[i++] = s[j]; while(i \u003c j \u0026\u0026 s[i] \u003c x) // 从左向右找第一个大于等于x的数 i++; if(i \u003c j) s[j--] = s[i]; } s[i] = x; quick_sort(s, l, i - 1); // 递归调用 quick_sort(s, i + 1, r); } } 它们都会跳过相同的数字，每次排序后哨兵总会在边界上，导致算法劣化到$O(n^2)$。 大概就是这回事，没别的了。这种情况当然有改进的快速排序可以直接避免这种罕见的情况，在不大幅度改动算法的前提下，就要对相同的元素也进行换位才可以，即使会增加交换次数。 ","date":"2019-07-12","objectID":"/2019/07/do-i-write-qsort-right/:1:0","tags":null,"title":"我把快排写错了?","uri":"/2019/07/do-i-write-qsort-right/"}]