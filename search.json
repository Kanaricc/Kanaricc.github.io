[{"title":"音乐盒测试","url":"%2F2019%2F09%2F27%2Ftest-music-player%2F","content":"\n我还没搞明白为什么在首页上没法加载，看起来是插件内部有bug。\n\n就拿东方的同人BGM来做个测试吧。\n\n{% aplayer \"万年置き傘にご注意を\" \"k-waves LAB\" \"k-waves.m4a\" \"music.jpg\" %}","categories":["闲扯"]},{"title":"[CF1221F] Choose a Sequence","url":"%2F2019%2F09%2F23%2Fproblem-choose-a-sequence%2F","content":"\nPetya recently found a game \"Choose a Square\". In this game, there are nn points numbered from 11 to nn on an infinite field. The ii-th point has coordinates (xi,yi) and cost ci.\n\nYou have to choose a square such that its sides are parallel to coordinate axes, the lower left and upper right corners belong to the line y=x, and all corners have integer coordinates.\n\nThe score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square. Note that the length of the side can be zero.\n\nPetya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square.\n\n{% asset_img a.png %}\n\n## 分析\n\n这道题其实和多校的Snowy Smile（题文无关）挺像的。\n\n<!--more-->\n\n需要转化条件。正方形全部位于坐标系第一象限的平分线上，可以表示为$(l,r)$这种形式。一个在正方形内的点$(x,y)$(假设$x < y$,由于这个题目的特性，不满足时可以直接调换)满足的条件为\n\n$$l \\leq x \\leq y \\leq r$$\n\n由此，这道题就变成了二维偏序。本来的本来，上个长得像树状数组一类的东西就解决了。\n\n将点按照第一维排序，从大到小枚举，在数据结构中维护结尾到r的前缀和最大值，并查询，更新全局答案。不过这个题目还要求权值要减去正方形边长w。\n\n$$f(r)-(r-l)=l+[f(r)-r]$$\n\n维护最大值，y分开，只在pushup时合在一起。\n\n然后还要离散化……\n\n## 代码\n\n这题给我整自闭了，我想用线段树单点修改来魔幻维护我需要的数据，加加减减。结果发现2种维护方式都有无法解决的问题。最后只能打tag。\n\n线段树维护$f(n)$为到$n$为止的前缀和。每次加点以$x$为组，对已有点减去新增线段的长度，再加上新点的影响。那么在线段树上维护的就是答案。取出最大值即可。\n\n代码写得又长又丑，不过过了。\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=500010*4;\n\nll tag[MAXN];\nll dMax[MAXN];\nint dy[MAXN];\nint lc[MAXN],rc[MAXN],idx=0;\nvoid build(int &n,int l,int r){\n    if(!n)n=++idx;\n    dy[n]=r;\n    if(l>=r){\n        tag[n]=0;\n        return;\n    }\n\n    int mid=(l+r)/2;\n    build(lc[n],l,mid);\n    build(rc[n],mid+1,r);\n}\nvoid pushdown(int n,int l,int r){\n    if(!tag[n])return;\n    tag[lc[n]]+=tag[n];\n    tag[rc[n]]+=tag[n];\n    dMax[lc[n]]+=tag[n];\n    dMax[rc[n]]+=tag[n];\n\n    tag[n]=0;\n}\nvoid collect(int n){\n    if(dMax[lc[n]]>dMax[rc[n]]){\n        dMax[n]=dMax[lc[n]];\n        dy[n]=dy[lc[n]];\n    }else{\n        dMax[n]=dMax[rc[n]];\n        dy[n]=dy[rc[n]];\n    }\n}\nvoid modify(int l,int r,int x,int L,int R,int n){\n    if(l<=L && R<=r){\n        tag[n]+=x;\n        dMax[n]+=x;\n        return;\n    }\n    pushdown(n,L,R);\n\n    int mid=(L+R)/2;\n    if(l<=mid)modify(l,r,x,L,mid,lc[n]);\n    if(mid<r)modify(l,r,x,mid+1,R,rc[n]);\n    collect(n);\n}\n\nbool operator<(const pair<ll,int> &a,const pair<ll,int> &b){\n    return a.first<b.first;\n}\n\npair<ll,int> query(int l,int r,int L,int R,int n){\n    if(l<=L && R<=r){\n        return make_pair(dMax[n],dy[n]);\n    }\n    pushdown(n,L,R);\n    \n    int mid=(L+R)/2;\n    pair<ll,int> res=make_pair(-0x3f3f3f3f,0);\n    if(l<=mid)res=max(res,query(l,r,L,mid,lc[n]));\n    if(mid<r)res=max(res,query(l,r,mid+1,R,rc[n]));\n\n    return res;\n}\nstruct Point{\n    int x,y,w;\n} points[MAXN];\nvector<int> nums;\nint root=0;\nint main(){\n    /*\n    build(root,1,10);\n    int opt;\n    while(cin>>opt){\n        if(opt==1){\n            int l,r,x;cin>>l>>r>>x;\n            modify(l,r,x,1,10,root);\n        }\n        if(opt==2){\n            int l,r;cin>>l>>r;\n            cout<<query(l,r,1,10,root).first<<\" \"<<query(l,r,1,10,root).second<<endl;\n        }\n    }\n    */\n    \n\n    int nlen;cin>>nlen;\n\n    for(int i=1;i<=nlen;i++){\n        Point &p=points[i];\n        cin>>p.x>>p.y>>p.w;\n        if(p.x>p.y)swap(p.x,p.y);\n        nums.push_back(p.y);\n        nums.push_back(p.x);\n    }\n    sort(nums.begin(),nums.end());\n    auto rit=unique(nums.begin(),nums.end());\n    for(int i=1;i<=nlen;i++){\n        points[i].x=lower_bound(nums.begin(),rit,points[i].x)-nums.begin();\n        points[i].y=lower_bound(nums.begin(),rit,points[i].y)-nums.begin();\n    }\n\n    sort(points+1,points+1+nlen,[](const Point &a,const Point &b){\n        if(a.x!=b.x)return a.x>b.x;\n        return a.y<b.y;\n    });\n\n    int len=rit-nums.begin()-1;\n    build(root,0,len);\n    vector<int>::iterator lastit=rit-1;\n    pair<ll,int> ans=make_pair(-0x3f3f3f3f,0);\n    int pairl=-0x3f3f3f3f;\n    for(int i=1;i<=nlen;i++){\n        int thisx=points[i].x;\n        //auto it=lower_bound(nums.begin(),rit,points[i].x);\n        auto it=nums.begin()+thisx;\n        for(;lastit!=it;lastit--){\n            modify(lastit-nums.begin(),len,*(lastit-1)-*lastit,0,len,root);\n            //cout<<\"cost \"<<*(lastit-1)-*lastit<<\" from \"<<lastit-nums.begin()<<\" to \"<<len<<endl;\n        }\n        /*\n        for(int j=0;j<=len;j++){\n            cout<<query(j,j,0,len,root).first<<\"\\t\";\n        }\n        cout<<endl;\n        */\n        while(i<=nlen && points[i].x==thisx){\n            const Point &p=points[i];\n            modify(p.y,len,p.w,0,len,root);\n            //cout<<\"add \"<<p.w<<\" from \"<<p.y<<\" to \"<<len<<endl;\n            i++;\n        }\n        i--;\n        /*\n        for(int j=0;j<=len;j++){\n            auto temp2=query(j,j,0,len,root);\n            cout<<temp2.first<<\",\"<<temp2.second<<\"\\t\";\n        }\n        cout<<endl;\n        */\n\n        pair<ll,int> temp=query(0,len,0,len,root);\n        if(ans<=temp){\n            ans=temp;\n            pairl=nums[thisx];\n        }\n    }\n\n    if(ans.first>0){\n        cout<<ans.first<<endl;\n        cout<<pairl<<\" \"<<pairl<<\" \"<<nums[ans.second]<<\" \"<<nums[ans.second]<<endl;\n    }else{\n        cout<<0<<endl;\n        cout<<*nums.rbegin()+1<<\" \"<<*nums.rbegin()+1<<\" \"<<*nums.rbegin()+1<<\" \"<<*nums.rbegin()+1<<endl;\n    }\n    return 0;\n}\n```","tags":["线段树"],"categories":["coding"]},{"title":"来康康Gatsby.js","url":"%2F2019%2F09%2F21%2Fstarting-gatsbyjs%2F","content":"\n昨天发现notion用学生邮箱可以免费领personal plan，所以非常开心的玩了一会。东西确实挺不错的。\n\n* 完善的附件管理，包括图片，pdf，excel等\n* 并不太喜欢的block编辑方式，还是更喜欢markdown\n* 不错的风格\n* 强大的database\n* 不错的内容链接\n* 各种embed\n* 垃圾数学公式编辑，为啥编辑框不能换行\n\n既然排版效果很好……这玩意，能不能做成个人博客。\n\n去github上搜了一发，居然真的有，名字叫gine-blog。\n\n## 已有项目初探\n研究了这个小巧的项目之后，有些激动。它使用了目前很新的几个技术（相比Hexo等传统生成器）。\n\n* webpack\n* react\n* graphql\n\n实际上，这些主要都来自另一个项目`Gatsby.js`，意在使用新技术快速构建网站。它能够汇总数据，使用graphql为react提供内容，并将内容固化，产生能够离开后端运行的纯网页。\n\n非常适合作为个人博客生成使用。\n\n之后我便忘了最开始的目的。\n\n## 好像少了些什么\n生成的方式似乎没有什么问题了，不过好像少了些什么。\n\ngine-blog项目从notion拉取脏数据经过复杂处理填充到react中……作者实现了一个爬虫去从notion的网页上爬取源码…\n\n\n\n我部署试了一下这个blog，效果还可以，也有些bug。比如bookmark丢失url，作者的文档新旧有些分不清楚。还是继续坚持hexo。\n\n~~不过，这个`gatsby.js`有一些意思，可以研究一下。~~\n\n## 关于blog\n\n仔细思考了一下，相比于选择什么主题，选择什么模板，选择什么技术，这些都是次要的事情。最重要的是填充在里面的内容。所以这个事情就先这么放下了，如果要开始的话，有一系列的东西都需要学习，和我现在要干的事情有些冲突。\n\n听说学长们在搞新的oj，给我的锅实际上很小，不需要负多大责任。那么oj也可以暂时放一放了。\n\nblog继续维持使用hexo。\n\n也许未来的哪天，会回来尝试一下使用rust+那时候的前端技术来构造一个不知道是什么的项目。","tags":["gatsby"],"categories":["闲扯"]},{"title":"使用Mathematica绘制股票相关曲线","url":"%2F2019%2F09%2F20%2Fstock-with-mathematica%2F","content":"\nMathematica是个好东西。虽然早有耳闻功能强大，但是没想到强大到这种地步。\n\n原本因为课程原因，研究了一下如何在Mathematica里绘制股票数据。不过现在**停止**，只完成了一小部分。剩下的……想折腾的话，按照已经有的代码，能容易改出来其他功能。\n\n## 数据来源\n\n首先要说的是，Mathematica中**自行提供**了非权威的金融数据。这对我们很方便。\n\n使用命令`FinancialData`,就可以获取大量需要的数据。具体可以查看文档。不过问题是，不知何种原因，该函数对深沪股票支持很差，所以在实际使用时，并不能直接使用该函数，比较可惜……\n\n我们需要实现自己的数据处理。\n\n经过一番寻找后，我发现了一个基于Python的证券数据平台`baostock`。经过简单的封装后，Mathematica就可以使用Python从平台上拉取数据了。\n\n这个例子只能拉取日K。\n\n```mathematica\n\nBeginPackage[\"StockLink`\"]\n\nStockLink::usage=\"StockLink\";\nCloseLink::usage=\"CloseLink\";\n\nDailyKLine::usage=\"Get KLine data\";\n\nCandlestickData::usage=\"adjust KLine data to fit Candlestick Chart\";\nTradingChartData::usage=\"adjust KLine data to fit Trading Chart\";\n\nBegin[\"`Private`\"]\n\nStockLink[]:=Module[{conn},\nconn=StartExternalSession[\"Python\"];\nExternalEvaluate[conn,\"\nimport baostock as bs\nlg=bs.login()\n\"];\nconn\n];\n\nCloseLink[conn_]:=Module[{},\nExternalEvaluate[conn,\"\nbs.logout()\n\"];\nDeleteObject[conn];\n];\n\nMMAListToPythonList[list_]:=StringReplace[ToString[list,InputForm],{\"\\\" \"->\"'\",\"{\"->\"[\",\"}\"->\"]\"}];\nDateObjectToStr[date_]:=DateString[date,\"ISODate\"];\n\nDailyKLine[conn_,code_,startDate_,endDate_]:=Module[{},\nraw=ExternalEvaluate[conn,\nStringTemplate[\"\nrs = bs.query_history_k_data_plus('``',\n    'date,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,isST',\n    start_date='``', end_date='``',\n    frequency='d', adjustflag='3')\ndata_list = {}\nwhile (rs.error_code == '0') & rs.next():\n    temp=rs.get_row_data()\n    data_list[temp[0]]=temp[1:];\ndata_list\"][code,DateObjectToStr[startDate],DateObjectToStr[endDate]]];\nToExpression[#]& /@ raw\n];\n\nCandlestickData[raw_]:=Table[{DateObject[key],raw[key][[1;;4]]},{key,Keys[raw]}];\nTradingChartData[raw_]:=Table[{DateObject[key],raw[key][[1;;5]]},{key,Keys[raw]}];\n\nEnd[]\n\nEndPackage[]\n```\n\n## 图表绘制\n\n在实际使用时，首先需要导入该库，并且初始化链接后，灵活组合各部分功能即可。\n\n```mathematica\n<< (NotebookDirectory[] <> \"StockLink.wl\");\nconn = StockLink[];\n\n(:例如获取某个日期区间内的数据并转化，绘制交互图标:)\nDailyKLine[conn, \"ss.000001\", Today, Today] // TradingChartData // InteractiveTradingChart\n```\n\n输入日期时，可以直接按`ctrl+=`，在框中描述时间，比较方便。\n\n## 可能遇到的问题\n\n如果python配置不对的话，可能会出现Mathematica找不到python。问题的解决方法在官方文档上非常清晰。\n\n不过我不折腾股票，就这样了。","tags":["mathematica"],"categories":["闲扯"]},{"title":"一些筛法的题","url":"%2F2019%2F09%2F05%2Fsome-sieves%2F","content":"\n\n## 技巧\n\n### 自然溢出\n\n* 自然溢出不会影响低位数据,所以有的时候你不需要取模,而是一个unsigned.\n\n### 除法取模\n对于式子\n\n$$\n\\frac {a \\times b}{c} \\mod p \\equiv \\frac{a \\times b \\mod cp}{c}\n$$\n\n\n\n## 细节\n* 注意数据类型,例如`6*(ll)(1<<30)`是要出问题的\n* 注意函数在$f(1)$位置的取值,不要忘记初始化\n\n## Divisor\n\nGiven $n$ and $m$ ($1 \\leq n,m \\leq 5 \\times 10^4$),  please calculate\n\n<!--more-->\n\n### 分析\n下面所有的除法都是舍去小数的整除.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) &= \\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}[p \\perp q] \\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d|(p,q)}\\mu(d) \\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d}\\mu(d)[d|p][d|q] \\\\\n&=\\sum_d \\mu(d)\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{pd} \\sum_{qd}[pd|i][qd|j] \\\\\n&=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd}\\sum_{i=1}^{n/pd}\\sum_{j=1}^{m/qd} \\\\\n&=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd} \\frac n {pd}\\frac m {qd} \\\\\n&=\\sum_d \\mu(d) \\sum_p^{n/d} \\frac n {pd} \\sum_q^{m/d} \\frac m {qd} \\\\\n\\end{aligned}\n$$\n\n设$S(n)=\\sum_{1\\leq i \\leq n} \\frac n i$\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) &=\\sum_d \\mu(d)S(n/d)S(m/d)\n\\end{aligned}\n$$\n\n$n/d$的取值在一个区间中是相同的,因此可以把这个求和公式分块计算.(在分块后,需要获知该段区域内$\\mu$的和,所以需要求前缀和)由于$n/d$的取值为$O(\\sqrt n)$的级别,因此在知道$S$的值的情况下,每个询问可以这个复杂度中计算出来.\n\n对于$\\mu$,使用筛法,并求出其前缀和.\n\n对于$S$,直接暴力计算.\n\n### 代码\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50010;\n\nbool isn_p[MAXN];\nvector<int> primes;\nint mu[MAXN];\nint premu[MAXN];\nvoid init_prime(int len){\n    isn_p[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=len;i++){\n        if(!isn_p[i]){\n            primes.push_back(i);\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=len;j++){\n            isn_p[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n    premu[0]=0;\n    for(int i=1;i<=len;i++)premu[i]=premu[i-1]+mu[i];\n}\n\n\nll S[MAXN];\nvoid init_S(int len){\n    for(int i=1;i<=len;i++){\n        for(int l=1,r;l<=i;l=r+1){\n\t        //remember this line\n            r=i/(i/l);\n            S[i]+=(ll)(r-l+1)*(i/l);\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    init_prime(50000);\n    init_S(50000);\n    int kase;cin>>kase;\n    while(kase--){\n        int n,m;cin>>n>>m;\n        ll ans=0;\n        // the minimum one will fastly approach to 0, leading the extra parts of bigger one do nothing to the answer.\n        int minn=min(n,m);\n        for(int l=1,r;l<=minn;l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ans+=S[n/l]*S[m/l]*(premu[r]-premu[l-1]);\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n```\n\n## table\n给出多组$n,m,a$,求\n\n$$\n\\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j))[\\sigma_1((i,j)) \\geq a]\n$$\n\n### 分析\n> 这道题让谁都能看出来重点是如何处理条件\n>\n> $$[\\sigma_1((i,j)) \\geq a]$$\n\n可是这我显然不知道该怎么做.\n\n对询问作以$a$从小到大离线处理,询问前先处理新增$a$的影响.\n\n在已经满足条件的前提下对公式作化简.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j)) &= \\sum_d \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1(d)[(i,j)=d] \\\\\n&=\\sum_d \\sum_{i\\leq \\frac nd}\\sum_{j\\leq \\frac md}\\sigma_1(d)[(i,j)=1] \\\\\n&=\\sum_d \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}}\\sigma_1(d) \\sum_t \\mu(t) \\\\\n&=\\sum_d \\sum_t \\mu(t) \\sigma_1(d)  \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}} 1 \\\\\n&=\\sum_T \\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor \\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)\n\\end{aligned}\n$$\n\n可以看到还是套路,引入d,引入$\\mu$,之后胡乱化简.\n\n按照这个式子,需要计算的就是$g(x)=\\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)$的前缀和.\n\n接下来是如何处理条件...\n\n当$a$每扩大一点,就有一部分$\\mu(t)\\sigma_1(\\frac Td)$被加入到函数$g$的各个部分.使用一种数据结构来维护$g$的前缀和,例如树状数组.$a$最大到,每次受到影响的就是$d$的倍数,以此可以计算出总的时间复杂度为\n\n$$\nWTF\n$$\n\n至此,问题就解决了.\n\n### 代码\n又丑又长.\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cassert>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=100010;\nconst int MAXQ=100010;\nconst int MAXFT=400010;\nconst ll P=(ll)1<<31;\n\n\nll FT[MAXFT];\nll lowbit(int x){\n    return x&-x;\n}\nvoid ftadd(int pos,ll x){\n    for(int i=pos;i<MAXN;i+=lowbit(i)){\n        FT[i]=(FT[i]+x);\n    }\n}\nll ftget(int pos){\n    ll res=0;\n    for(int i=pos;i;i-=lowbit(i)){\n        res=(res+FT[i]);\n    }\n    return res;\n}\n\nll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(b;b;b>>=1,a=(a*a)%p){\n        if(b&1)res=(res*a)%p;\n    }\n    return res;\n}\nll qpow(ll a,ll b){\n    ll res=1;\n    for(b;b;b>>=1,a=(a*a)){\n        if(b&1)res=(res*a);\n    }\n    return res;\n}\n\nbool is_np[MAXN];\nll sigma[MAXN],mu[MAXN];\nint t[MAXN];\nvector<int> primes;\nstruct Sig{\n    ll sigma;\n    int x;\n    Sig(){}\n    Sig(int x,ll sigma):x(x),sigma(sigma){}\n};\nvector<Sig> sigma_vec;\n\nvoid init(int n){\n    is_np[1]=1;\n    sigma[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=n;i++){\n        if(!is_np[i]){\n            primes.push_back(i);\n            sigma[i]=i+1;\n            t[i]=1;\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            is_np[i*primes[j]]=1;\n            sigma[i*primes[j]]=sigma[i]*sigma[primes[j]];\n            t[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                t[i*primes[j]]=t[i]+1;\n                sigma[i*primes[j]]=sigma[i/qpow(primes[j],t[i])]*((ll)1-qpow(primes[j],(t[i]+1)+1))/(1-primes[j]);\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++){\n        sigma_vec.push_back(Sig(i,sigma[i]));\n    }\n}\n\nstruct Q{\n    int n,m,a;\n    int i;\n    ll ans;\n    bool operator<(const Q &b)const{\n        return a<b.a;\n    }\n} qs[MAXQ];\n\nll f(int n){\n    return ftget(n);\n}\n\nint curidx=0;\nvoid mergea(int newa){\n    for(;curidx<sigma_vec.size();curidx++){\n        Sig &sig=sigma_vec[curidx];\n        if(sig.sigma>newa)break;\n        for(int i=sig.x;i<MAXN;i+=sig.x){\n            ftadd(i,mu[i/sig.x]*sig.sigma%P);\n        }\n    }\n}\n\nint main(){\n    init(100000);\n    sort(sigma_vec.begin(),sigma_vec.end(),[](Sig &a,Sig &b){\n        return a.sigma<b.sigma;\n    });\n\n    int qlen;cin>>qlen;\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        scanf(\"%d%d%d\",&q.n,&q.m,&q.a);\n        q.i=i;\n    }\n    sort(qs,qs+qlen,[](Q &a,Q &b){\n        return a.a<b.a;\n    });\n\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        int n=q.n,m=q.m,a=q.a;\n        ll &ans=q.ans=0;\n        mergea(a);\n        for(int l=1,r;l<=min(n,m);l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ans=ans+(n/l)*(m/l)*(f(r)-f(l-1));\n        }\n        \n    }\n    sort(qs,qs+qlen,[](Q &a,Q &b){\n        return a.i<b.i;\n    });\n    for(int i=0;i<qlen;i++){\n        printf(\"%lld\\n\",qs[i].ans%P);\n    }\n    return 0;\n}\n```\n\n## product\n定义斐波纳妾(?)(linux这输入法够魔性)函数$f(x)$\n\n求\n\n$$\n\\prod_{i=1}^n \\prod_{j=1}^m f((i,j))\n$$\n\n### 分析\n首先,先引个$d$是没错了.\n\n但是\n\n这道题,我又不会.我不知道该怎么处理$\\prod$...蔡就完事了.\n\n现在来看,当引入一个$d$后,在该求积公式里出现了相同项相乘.将该部分的计算调整为幂,剩下的就又都一样了.\n\n$$\n\\begin{aligned}\n\\prod_{i=1}^n \\prod_{j=1}^m f((i,j)) &= \\prod_d f(d)^{\\sum_{i\\leq n} \\sum_{j \\leq m} [(i,j)=d]} \\\\\n&=\\prod_d f(d)^{\\sum_{i\\leq \\frac nd} \\sum_{j \\leq \\frac md} [(i,j)=1]} \\\\\n&=\\prod_d f(d)^{\\sum_t \\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\\n&=\\prod_d \\prod_t f(d)^{\\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\\n&=\\prod_T (\\prod_{d|T}  f(d)^{\\mu(\\frac Tt)})^{\\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor }\n\\end{aligned}\n$$\n\n设$g(x)=\\prod_{d|T}  f(d)^{\\mu(\\frac Tt)}$,求前缀和就完事了.\n\n> 这道题需要使用**欧拉定理**来优化求幂的速度.\n\n### 欧拉定理\n当$(a,p)=1$,有以下式子\n\n$$\na^b \\equiv a^{b \\mod \\phi(p)} \\pmod p\n$$\n\n当$(a,p)\\neq 1$,有扩展欧拉定理\n\n$$\na^b \\equiv a^{b \\mod \\phi(p)+ \\phi(p)} \\pmod p\n$$\n\n根据这2个式子,可以在快速降幂,来加快运算.\n\n### 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=1000010;\nconst ll P=1e9+7;\n\ninline ll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(;b;b>>=1,a=a*a%p){\n        if(b&1)res=res*a%p;\n    }\n    return res;\n}\n\ninline ll get_inv(ll a,ll p){\n    return qpow(a,p-2,p);\n}\n\nbool is_np[MAXN];\nvector<int> primes;\nll f[MAXN], g[MAXN];\nll inv_f[MAXN];\nll preg[MAXN],inv_pg[MAXN];\nll mu[MAXN];\nvoid init(int n){\n    is_np[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=n;i++){\n        if(!is_np[i]){\n            primes.push_back(i);\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            is_np[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n\n    f[1]=f[2]=1;\n    for(int i=3;i<=n;i++){\n        f[i]=(f[i-1]+f[i-2])%P;\n    }\n    for(int i=1;i<=n;i++){\n        inv_f[i]=get_inv(f[i],P);\n    }\n\n    for(int i=1;i<=n;i++)g[i]=1;\n    for(int i=1;i<=n;i++){\n        for(int j=i;j<=n;j+=i){\n            if(mu[j/i]==-1)g[j]=(g[j]*inv_f[i])%P;\n            else if(mu[j/i]==1)g[j]=(g[j]*f[i])%P;\n            //when mu==0,nothing happens\n        }\n    }\n    preg[0]=1;\n    for(int i=1;i<=n;i++)preg[i]=preg[i-1]*g[i]%P;\n    inv_pg[0]=1;\n    for(int i=1;i<=n;i++)inv_pg[i]=get_inv(preg[i],P)%P;\n}\n\nint main(){\n    init(1000000);\n    //cout<<\"done\"<<endl;\n    /*\n    \n    for(auto i:primes){\n        cout<<i<<\" \";\n    }\n    cout<<endl;\n    \n    for(int i=1;i<=20;i++){\n        cout<<g[i]<<\" \";\n    }\n    cout<<endl;\n    */\n    \n\n    int kase;\n    scanf(\"%d\",&kase);\n    while(kase--){\n        ll n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(n>m)swap(n,m);\n\n        ll ans=1;\n        for(ll l=1,r;l<=n;l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ll sum=preg[r]*inv_pg[l-1]%P;\n            ans=ans*qpow(sum,(n/l)*(m/l)%(P-1),P)%P;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n## phi3\n给出$n$,求\n\n$$\n(\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n \\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)} \\phi((i,j,k))) \\mod 2^{30}\n$$\n\n### 分析\n这道题重点在于\n\n$$\\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)}$$\n\n这堆东西的化简.很显然,我又不会.\n\n观察$\\phi(n)$的公式\n\n$$\n\\phi(n)=n\\prod_i(1-\\frac 1{\\phi(i)})\n$$\n\n可以得出上面那一堆等于$jk^2$.剩下的就又都一样了.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi((i,j,k)) &=\\sum_d\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi(d)[(i,j,k)=d] \\\\\n&=\\sum_d \\sum_{t} \\phi(d) \\mu(t) t^3d^3 \\sum_{i\\leq \\frac n{td}}\\sum_{j \\leq \\frac n{td}}\\sum_{k \\leq \\frac n{td}} jk^2 \\\\\n&=\\sum_T \\sum_{i\\leq \\frac nT}\\sum_{j \\leq \\frac nT} j\\sum_{k \\leq \\frac nT}k^2 (T^3 \\sum_{d|T} \\phi(d) \\mu(\\frac Td))\n\\end{aligned} \n$$\n\n设$g(n)=\\sum_{d|T} \\phi(d) \\mu(\\frac Td)$,直接筛.最后计算前缀和的时候再乘上$n^3$就可以了.\n\n> 这道题的取模还有这种处理方法: 直接取数组为`unsigned`并自然溢出.**二进制后30位**不会受到影响.\n\n### 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\nusing ull=unsigned long long;\nusing ll=long long;\nconst int MAXN=10000010;\nconst unsigned P=1<<30;\n\nbool isnp[MAXN];\nvector<int> primes;\nint t[MAXN],M[MAXN];\nunsigned Mt[MAXN];\nunsigned g[MAXN];\nll preg[MAXN];\n\nvoid init(int n){\n    isnp[1]=1;\n    g[1]=1;\n\n    for(int i=2;i<=n;i++){\n        if(!isnp[i]){\n            primes.push_back(i);\n            g[i]=i-1-1;\n\n            t[i]=1;\n            M[i]=Mt[i]=i;\n        }\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            int newone=i*primes[j];\n            isnp[newone]=1;\n            g[newone]=g[i]*g[primes[j]]%P;\n            t[newone]=1;\n            M[newone]=Mt[newone]=primes[j];\n            if(i%primes[j]==0){\n                t[newone]=t[i]+1;\n                Mt[newone]=Mt[i]*primes[j]%P;\n                \n                g[newone]=g[i/Mt[i]]*(Mt[newone]+Mt[i]/primes[j]-2*Mt[i])%P;\n                break;\n            }\n        }\n    }\n\n    for(int i=1;i<=n;i++){\n        preg[i]=preg[i-1]+(ll)i*i%P*i%P*g[i]%P;\n        preg[i]%=P;\n    }\n}\n\nint main(){\n    init(10000000);\n\n    int kase;\n    scanf(\"%d\",&kase);\n    while(kase--){\n        int n;\n        scanf(\"%d\",&n);\n        ll ans=0;\n        for(int l=1,r;l<=n;l=r+1){\n            r=n/(n/l);\n            ull lim=n/l;\n            ull sum1=lim*(lim+1)%(2*P)/2;\n            ull sum2=lim*(lim+1)%(6*P)*(2*lim+1)%(6*P)/6;\n            ans=ans+lim*sum1%P*sum2%P*(preg[r]-preg[l-1])%P;\n        }\n        printf(\"%lld\\n\",ans%P);\n    }\n    return 0;\n}\n```","tags":["筛法"]},{"title":"[HDU 6704] Kth Occurrence","url":"%2F2019%2F08%2F25%2Fproblem-kth-occurrence%2F","content":"\n\nYou are given a string S consisting of only lowercase english letters and some queries.\n\nFor each query (l,r,k), please output the starting position of the k-th occurence of the substring SlSl+1...Sr in S.\n\n## 分析\n第一个问题是快速找出所有出现的子串的位置,可以使用后缀数组.这些字串出现在sa的一个连续的区间中.\n\n<!--more-->\n\n第二个问题是找出这些出现位置中的第k大,可以使用主席树,以sa建树.\n\n\n## 代码\n思路清晰,但这代码它不好写\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\nconst int MAXN=100060;\nusing ull=unsigned long long;\n\nint n;\nint sa[MAXN], x[MAXN], c[MAXN], y[MAXN];\nchar a[MAXN];\n\ninline void SA()\n{\n    int m = 128;\n    for (int i = 0; i <= m; i++)\n        c[i] = 0;\n    for (int i = 1; i <= n; i++)\n        c[x[i]]++;\n    for (int i = 1; i <= m; i++)\n        c[i] += c[i - 1];\n    for (int i = n; i; i--)\n        sa[c[x[i]]--] = i;\n\n    for (int k = 1, p; k <= n; k <<= 1)\n    {\n        p = 0;\n        for (int i = n; i > n - k; i--)\n            y[++p] = i;\n        for (int i = 1; i <= n; i++)\n            if (sa[i] > k)\n                y[++p] = sa[i] - k;\n\n        for (int i = 0; i <= m; i++)\n            c[i] = 0;\n        for (int i = 1; i <= n; i++)\n            c[x[i]]++;\n        for (int i = 1; i <= m; i++)\n            c[i] += c[i - 1];\n        for (int i = n; i; i--)\n            sa[c[x[y[i]]]--] = y[i];\n\n        p = y[sa[1]] = 1;\n        for (int i = 2, a, b; i <= n; i++)\n        {\n            a = sa[i] + k > n ? -1 : x[sa[i] + k];\n            b = sa[i - 1] + k > n ? -1 : x[sa[i - 1] + k];\n            y[sa[i]] = (x[sa[i]] == x[sa[i - 1]]) && (a == b) ? p : ++p;\n        }\n        swap(x, y);\n        m = p;\n    }\n}\n\nint tot;\nint sum[(MAXN << 5) + 10], rt[MAXN + 10], ls[(MAXN << 5) + 10],\n    rs[(MAXN << 5) + 10];\n\nint build(int l, int r) //建树\n{\n    int root = ++tot;\n    if (l == r)\n        return root;\n    int mid = l + r >> 1;\n    ls[root] = build(l, mid);\n    rs[root] = build(mid + 1, r);\n    return root; //返回该子树的根节点\n}\nint update(int k, int l, int r, int root) //插入操作\n{\n    int dir = ++tot;\n    ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + 1;\n    if (l == r)\n        return dir;\n    int mid = l + r >> 1;\n    if (k <= mid)\n        ls[dir] = update(k, l, mid, ls[dir]);\n    else\n        rs[dir] = update(k, mid + 1, r, rs[dir]);\n    return dir;\n}\n//left root, right root, querying l,r, the k-th\nint query(int u, int v, int l, int r, int k) //查询操作\n{\n    int mid = l + r >> 1,\n        x = sum[ls[v]] - sum[ls[u]]; //通过区间减法得到左儿子的信息\n    if (l == r){\n        return l;\n    }\n    if (k <= x) //说明在左儿子中\n        return query(ls[u], ls[v], l, mid, k);\n    else //说明在右儿子中\n        return query(rs[u], rs[v], mid + 1, r, k - x);\n}\n\nint height[MAXN];\nint st[20][MAXN];\ninline void get_height() {\n    int k = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (x[i] == 1) continue;\n        if (k) --k;\n        int j = sa[x[i] - 1];\n        while (j + k <= n && i + k <= n && a[i + k] == a[j + k]) ++k;\n        height[x[i]] = k;\n    }\n}\nvoid build_st() {\n    for (int i = 1; i <= n; i++) st[0][i] = height[i];\n    for (int k = 1; k <= 19; k++) {\n        for (int i = 1; i + (1 << k) - 1 <= n; i++) {\n            st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 << k - 1)]);\n        }\n    }\n}\nint lcp(int ll, int rr) {\n    int l = x[ll], r = x[rr];\n    if (l > r) swap(l, r);\n    if (l == r) return n - sa[l]+1;\n    int t = log2(r - l);\n    return min(st[t][l + 1], st[t][r - (1 << t) + 1]);\n}\n\nint main(){\n    int kase;cin>>kase;\n    while(kase--){\n        int nlen,qlen;cin>>nlen>>qlen;\n        scanf(\"%s\",a+1);\n        for(int i=0;i<MAXN;i++)x[i]=a[i];\n        n=nlen;\n        SA();\n        n=nlen;\n\n        get_height();\n        build_st();\n        \n        /*\n        for(int i=1;i<=nlen;i++)cout<<sa[i]<<\" \";\n        cout<<endl;\n        for(int i=1;i<=nlen;i++)cout<<x[i]<<\" \";\n        cout<<endl;\n        */\n\n        tot=0;\n        memset(sum,0,sizeof(sum));\n        rt[0] = build(1, nlen);\n        for (int i = 1; i <= n; ++i)\n            rt[i] = update(sa[i], 1, nlen, rt[i - 1]);\n\n        while(qlen--){\n            int ql,qr,qk;\n            scanf(\"%d%d%d\",&ql,&qr,&qk);\n            int sublen=qr-ql+1;\n\n            int ex_l,ex_r;\n            //binary search\n            {\n                int l=1,r=x[ql];\n                while(r-l>1){\n                    int mid=(l+r)/2;\n                    if(lcp(sa[mid], ql) >= sublen){\n                        r=mid;\n                    }else l=mid+1;\n                }\n                for(l;l<=r;l++){\n                    if(lcp(sa[l], ql) >= sublen){\n                        ex_l=l;\n                        break;\n                    }\n                }\n            }\n            {\n                int l=x[ql],r=nlen;\n                while(r-l>1){\n                    int mid=(l+r)/2;\n                    if(lcp(sa[mid], ql) >= sublen){\n                        l=mid;\n                    }else r=mid-1;\n                }\n                for(r;r>=l;r--){\n                    if(lcp(sa[r], ql) >= sublen){\n                        ex_r=r;\n                        break;\n                    }\n                }\n            }\n            //cout<<ex_l<<\" \"<<ex_r<<endl;\n            if(ex_r-ex_l+1<qk){\n                cout<<-1<<endl;\n            } else cout<<query(rt[ex_l - 1], rt[ex_r], 1, nlen, qk)<<endl;\n        }\n    }\n\n    return 0;\n}\n```\n\n\n","tags":["RMQ"],"categories":["coding"]},{"title":"记一个bug (HDU 6703)","url":"%2F2019%2F08%2F24%2Fa-wonderful-bug%2F","content":"\nYou are given an array a1,a2,...,an(∀i∈[1,n],1≤ai≤n). Initially, each element of the array is **unique**. \n\nMoreover, there are m instructions. \n\nEach instruction is in one of the following two formats: \n\n1. (1,pos),indicating to change the value of apos to apos+10,000,000; \n2. (2,r,k),indicating to ask the minimum value which is **not equal** to any ai ( 1≤i≤r ) and **not less ** than k. \n\nPlease print all results of the instructions in format 2. \n\n## 分析\n这题强制在线.首先1操作相当于删除了这个数.\n\ndalao自闭了一会get到了它的正确做法,我就直接拿来用了.\n\n维护一权值线段树,位置i存其在a中出现的位置.那么当1到r区间内出现位置的最大值超过了r,根据鸽巢原理,至少有一个数未被限制.\n\n加上不小于k的条件,就是k到r中,找到最小的一个r,使得它满足上面的条件,输出这个r.\n\n## 代码\n一个奇葩的bug...\n\n当使用了fread这种先读完缓冲区再处理的快速读入而删漏了cin时...会显而易见的遇到bug.\n\n但是,因为缓冲区的存在,**小范围数据被快乐的读入了缓冲区,cin并不会实际影响什么**.一旦遇到大范围数据,cin提前读入了接下来的数据,导致第一个缓冲区之外的数据全部出错...\n\n艹.\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst int MAXN = 400000;\n\nnamespace IO\n{\nconst int MAXSIZE = 1 << 20;\nchar buf[MAXSIZE], *p1, *p2;\n#define gc()                                                                 \\\n    (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\\n         ? EOF                                                               \\\n         : *p1++)\ninline int rd()\n{\n    int x = 0, f = 1;\n    char c = gc();\n    while (!isdigit(c))\n    {\n        if (c == '-')\n            f = -1;\n        c = gc();\n    }\n    while (isdigit(c))\n        x = x * 10 + (c ^ 48), c = gc();\n    return x * f;\n}\nchar pbuf[1 << 20], *pp = pbuf;\ninline void push(const char &c)\n{\n    if (pp - pbuf == 1 << 20)\n        fwrite(pbuf, 1, 1 << 20, stdout), pp = pbuf;\n    *pp++ = c;\n}\ninline void write(int x)\n{\n    static int sta[35];\n    int top = 0;\n    do\n    {\n        sta[top++] = x % 10, x /= 10;\n    } while (x);\n    while (top)\n        push(sta[--top] + '0');\n}\n} // namespace IO\n///////////////////////////////////////////////////////////////////////////////////////\n\nint dat[MAXN];\nint a[MAXN];\nint lc[MAXN], rc[MAXN], idx = 0;\n\ninline int imax(int a,int b){\n    if(a>b)return a;\n    return b;\n}\nvoid collect(int n)\n{\n    dat[n] = max(dat[lc[n]], dat[rc[n]]);\n}\n\nint build(int &n, int l, int r)\n{\n    if (!n)\n        n = ++idx;\n    dat[n] = a[l];\n    if (l == r)\n        return dat[n];\n    int mid = (l + r) / 2;\n    return dat[n] = imax(build(lc[n], l, mid), build(rc[n], mid + 1, r));\n}\n\nvoid modify(int x, int l, int r, int L, int R, int n)\n{\n    if (l <= L && R <= r)\n    {\n        dat[n] = x;\n        return;\n    }\n    int mid = (L + R) / 2;\n    if (l <= mid)\n        modify(x, l, r, L, mid, lc[n]);\n    if (mid < r)\n        modify(x, l, r, mid + 1, R, rc[n]);\n\n    collect(n);\n}\n\nint query(int l, int r,int target, int L, int R, int n)\n{\n    if(L>r || R<l || dat[n]<=target)return -1;\n    if(L==R)return L;\n\n    int mid = (L + R) / 2;\n    int res=query(l,r,target,L,mid,lc[n]);\n    return ~res?res:query(l,r,target,mid+1,R,rc[n]);\n}\nint root;\nint num[MAXN];\nint main()\n{\n    int kase=IO::rd();\n    while (kase--)\n    {\n        int nlen, qlen;\n        nlen=IO::rd();\n        qlen=IO::rd();\n        for (int i = 1; i <= nlen; i++)\n        {\n            num[i] = IO::rd();\n            a[num[i]] = i;\n        }\n        build(root, 1, nlen);\n        int lastans = 0;\n        while (qlen--)\n        {\n            int opt=IO::rd();\n            if (opt == 1)\n            {\n                int pos=IO::rd();\n                pos ^= lastans;\n                if(num[pos]==0 || num[pos]>nlen)continue;\n                modify(0x3f3f3f3f, num[pos], num[pos], 1, nlen, root);\n            }\n            else\n            {\n                int t2, t3;\n                t2=IO::rd();\n                t3=IO::rd();\n                //cin >> t2 >> t3;\n                int r = t2 ^ lastans, k = t3 ^ lastans;\n\n                int t=query(k,nlen,r,1,nlen,root);\n                cout<<(lastans=(~t?t:nlen+1))<<endl;\n            }\n        }\n    }\n    return 0;\n}\n```","tags":["线段树"],"categories":["coding"]},{"title":"OJ的后端","url":"%2F2019%2F08%2F22%2Fsandbox-reef%2F","content":"\n内容有复制和参考。\n\n这篇文章主要用于记录在探索评测系统Reef期间我所学的东西,以便之后查阅.\n\nReef预计主要支持远程评测\n\n加一点本地评测.....\n\n<!--more-->\n\n结果主要的东西都特么是本地评测的.\n\n## 总体架构\nReef预计将采用seccomp作为第一道安全关卡,使用多线程检测程序耗时/内存等信息.\n\n在外层使用docker封装并再次限制资源,接入队列以能够方便的横向扩展.\n\n## seccomp\nseccomp为linux系统上才有的安全技术,因此必须使用linux.在安装必要的安装包后\n\n```bash\n$ sudo apt install libseccomp2 libseccomp-dev seccomp\n```\n\n即可使用.\n\n当然,在windows下的Jobs似乎也可以利用,但是我不太懂,微软文档写得也奇怪,而且还得是服务器版本的windows才能用.\n\n### 基本使用\nseccomp需要由程序主动加载.其使用方法基本为下\n\n```cpp\n//g++ -g test.c -o o -lseccomp\n#include <unistd.h>\n#include <seccomp.h>\n#include <linux/seccomp.h>\n\nint main(void){\n\t//初始化筛选器\n\tscmp_filter_ctx ctx;\n\tctx = seccomp_init(SCMP_ACT_ALLOW);//flag指明默认通过\n\t//添加拦截,并指明一旦拦截就将程序kill掉.\n\tseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);\n\t//将规则加载注入.\n\tseccomp_load(ctx);\n\n\tchar * filename = \"/bin/sh\";\n\tchar * argv[] = {\"/bin/sh\",NULL};\n\tchar * envp[] = {NULL};\n\twrite(1,\"i will give you a shell\\n\",24);\n\t//程序将会在此行崩溃.\n\tsyscall(59,filename,argv,envp);//execve\n\treturn 0;\n}\n```\n\nseccomp_init是初始化的过滤状态,这里用的是SCMP_ACT_ALLOW,表示默认允许所有的syscacll.如果初始化状态为SCMP_ACT_KILL,则表示默认不允许所有的syscall.\n\n```cpp\n/**\n * Kill the process\n */\n#define SCMP_ACT_KILL\t\t0x00000000U\n/**\n * Throw a SIGSYS signal\n */\n#define SCMP_ACT_TRAP\t\t0x00030000U\n/**\n * Return the specified error code\n */\n#define SCMP_ACT_ERRNO(x)\t(0x00050000U | ((x) & 0x0000ffffU))\n/**\n * Notify a tracing process with the specified value\n */\n#define SCMP_ACT_TRACE(x)\t(0x7ff00000U | ((x) & 0x0000ffffU))\n/**\n * Allow the syscall to be executed after the action has been logged\n */\n#define SCMP_ACT_LOG\t\t0x7ffc0000U\n/**\n * Allow the syscall to be executed\n */\n#define SCMP_ACT_ALLOW\t\t0x7fff0000U\n```\n\n规则添加\n```cpp\n/**\n * Add a new rule to the filter\n * @param ctx the filter context\n * @param action the filter action\n * @param syscall the syscall number\n * @param arg_cnt the number of argument filters in the argument filter chain\n * @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended)\n *\n * This function adds a series of new argument/value checks to the seccomp\n * filter for the given syscall; multiple argument/value checks can be\n * specified and they will be chained together (AND'd together) in the filter.\n * If the specified rule needs to be adjusted due to architecture specifics it\n * will be adjusted without notification.  Returns zero on success, negative\n * values on failure.\n *\n */\nint seccomp_rule_add(scmp_filter_ctx ctx,\n\t\t     uint32_t action, int syscall, unsigned int arg_cnt, ...);\n```\n\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);,arg_cnt为0,表示直接限制execve,不管他什么参数.\n\n如果arg_cnt不为0,那arg_cnt表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截syscall.\n\n```\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write),1,SCMP_A2(SCMP_CMP_EQ,0x10));//第2(从0)个参数等于0x10\n```\n\n```cpp\n/**\n * Specify an argument comparison struct for use in declaring rules\n * @param arg the argument number, starting at 0\n * @param op the comparison operator, e.g. SCMP_CMP_*\n * @param datum_a dependent on comparison\n * @param datum_b dependent on comparison, optional\n */\n#define SCMP_CMP(...)\t\t((struct scmp_arg_cmp){__VA_ARGS__})\n\n/**\n * Specify an argument comparison struct for argument 0\n */\n#define SCMP_A0(...)\t\tSCMP_CMP(0, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 1\n */\n#define SCMP_A1(...)\t\tSCMP_CMP(1, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 2\n */\n#define SCMP_A2(...)\t\tSCMP_CMP(2, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 3\n */\n#define SCMP_A3(...)\t\tSCMP_CMP(3, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 4\n */\n#define SCMP_A4(...)\t\tSCMP_CMP(4, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 5\n */\n#define SCMP_A5(...)\t\tSCMP_CMP(5, __VA_ARGS__)\n\n\n\n/**\n * Comparison operators\n */\nenum scmp_compare {\n\t_SCMP_CMP_MIN = 0,\n\tSCMP_CMP_NE = 1,\t\t/**< not equal */\n\tSCMP_CMP_LT = 2,\t\t/**< less than */\n\tSCMP_CMP_LE = 3,\t\t/**< less than or equal */\n\tSCMP_CMP_EQ = 4,\t\t/**< equal */\n\tSCMP_CMP_GE = 5,\t\t/**< greater than or equal */\n\tSCMP_CMP_GT = 6,\t\t/**< greater than */\n\tSCMP_CMP_MASKED_EQ = 7,\t\t/**< masked equality */\n\t_SCMP_CMP_MAX,\n};\n\n/**\n * Argument datum\n */\ntypedef uint64_t scmp_datum_t;\n\n/**\n * Argument / Value comparison definition\n */\nstruct scmp_arg_cmp {\n\tunsigned int arg;\t/**< argument number, starting at 0 */\n\tenum scmp_compare op;\t/**< the comparison op, e.g. SCMP_CMP_* */\n\tscmp_datum_t datum_a;\n\tscmp_datum_t datum_b;\n};\n```\n\nctx的内容可以使用函数dump出来,之后可以直接使用prctl命令相关直接载入,方便使用?\n\n### seccomp调试\n\n使用如下命令导出所有可能的命令\n```bash\nfile=syscall-names.h\necho \"static const char *syscall_names[] = {\" > $file\necho \"#include <sys/syscall.h>\" | cpp -dM | grep '^#define __NR_' | LC_ALL=C sed -r -n -e 's/^\\#define[ \\t]+__NR_([a-z0-9_]+)[ \\t]+([0-9]+)(.*)/ [\\2] = \"\\1\",/p' >> $file\necho \"};\" >> $file\n```\n\n使用如下代码导出一段代码所需要的权限.遵循最小权限原则,试验代码运行所需要的最少权限.\n```cpp\n#define __USE_GNU 1\n#define _GNU_SOURCE 1\n#include <signal.h>\n#include <sys/prctl.h>\n#include <linux/types.h>\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n#include <seccomp.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"syscall-names.h\"\n#if defined(__i386__)\n#define REG_RESULT\tREG_EAX\n#define REG_SYSCALL\tREG_EAX\n#define REG_ARG0\tREG_EBX\n#define REG_ARG1\tREG_ECX\n#define REG_ARG2\tREG_EDX\n#define REG_ARG3\tREG_ESI\n#define REG_ARG4\tREG_EDI\n#define REG_ARG5\tREG_EBP\n#elif defined(__x86_64__)\n#define REG_RESULT\tREG_RAX\n#define REG_SYSCALL\tREG_RAX\n#define REG_ARG0\tREG_RDI\n#define REG_ARG1\tREG_RSI\n#define REG_ARG2\tREG_RDX\n#define REG_ARG3\tREG_R10\n#define REG_ARG4\tREG_R8\n#define REG_ARG5\tREG_R9\n#endif\n#ifndef SYS_SECCOMP\n#define SYS_SECCOMP 1\n#endif\n\nconst char *const msg=\"system call invalid: \";\n\nstatic void write_uint(char *buf, unsigned int val)\n{\n    int width = 0;\n    unsigned int tens;\n    if (val == 0) {\n        strcpy(buf, \"0\");\n        return;\n    }\n    for (tens = val; tens; tens /= 10)\n        ++ width;\n    buf[width] = '\\0';\n    for (tens = val; tens; tens /= 10)\n        buf[--width] = (char) ('0' + (tens % 10));\n}\nstatic void helper(int nr, siginfo_t *info, void *void_context) {\n    char buf[255];\n    ucontext_t *ctx = (ucontext_t *)(void_context);\n    unsigned int syscall;\n    if (info->si_code != SYS_SECCOMP)\n        return;\n    if (!ctx)\n        return;\n    syscall = (unsigned int) ctx->uc_mcontext.gregs[REG_SYSCALL];\n    strcpy(buf, msg);\n    if (syscall < sizeof(syscall_names)) {\n        strcat(buf, syscall_names[syscall]);\n        strcat(buf, \"(\");\n    }\n    write_uint(buf + strlen(buf), syscall);\n    if (syscall < sizeof(syscall_names))\n        strcat(buf, \")\");\n    strcat(buf, \"\\n\");\n    write(STDOUT_FILENO, buf, strlen(buf));\n    _exit(1);\n}\nstatic int install_helper() {\n    struct sigaction act;\n    sigset_t mask;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGSYS);\n    act.sa_sigaction = &helper;\n    act.sa_flags = SA_SIGINFO;\n    if (sigaction(SIGSYS, &act, NULL) < 0) {\n        perror(\"sigaction\");\n        return -1;\n    }\n    if (sigprocmask(SIG_UNBLOCK, &mask, NULL)) {\n        perror(\"sigprocmask\");\n        return -1;\n    }\n    return 0;\n}\n\n#include <stdio.h>\nint main(){\n\tif(install_helper()){\n\t\tprintf(\"install helper failed\");\n\t\treturn 1;\n\t}\n\n\tscmp_filter_ctx ctx = NULL;\n\tctx = seccomp_init(SCMP_ACT_ALLOW);\n\n\tseccomp_rule_add(ctx, SCMP_ACT_TRAP, SCMP_SYS(execve), 0);\n\tseccomp_load(ctx);\n\tseccomp_release(ctx);\n\tfprintf(stdout, \"something to stdout\\n\");\n\tchar * filename = \"/bin/sh\";\n\tchar * argv[] = {\"/bin/sh\",NULL};\n\tchar * envp[] = {NULL};\n\twrite(1,\"i will give you a shell\\n\",24);\n\tsyscall(59,filename,argv,envp);//execve\n\n\treturn 0;\n}\n```\n\n### 注入程序\n刚刚提到了seccomp必须由程序主动加载,因此需要有一个办法将代码注入到用户的代码中.\n\n> 等待完成\n\n### 其他语言\n这玩意貌似至少能方便的用在c系语言,java和python上.\n\n## Docker\n准备使用Docker重构整个OJ\n\n### 多阶段构建\n使用Docker,将OJ分解为多个阶段来构建.\n\n1. 前端构建\n2. 后端构建\n3. 运行环境构建与代码整合\n4. nginx构建\n\n#### 命令\n```Dockerfile\n#...\n\n# 使用php作为基础,指明该构建阶段为codeisland\nFROM php:alpine as codeisland\n# 在容器打包阶段安装数据库驱动\nRUN docker-php-ext-install pdo pdo_pgsql\n\nARG PATH=/app/laravel\n\n# 从其他阶段复制代码到本阶段\nCOPY --from=DELETED /app/ ${PATH}\n\n# 执行其他初始化命令\n# [DELETED]\n\n# 指明容器的工作路径\nWORKDIR ${PATH}\n\n#...\n```\n\n### 容器协调\n使用Docker-compose来协调各个容器的关系.\n\n* 数据库容器\n* redis容器\n* 网站后端容器\n* 评测器容器\n* 评测代理容器\n* nginx容器\n\n限制评测器容器的资源消耗的例子\n\n```yml\ndeploy:\n  resources:\n    limits:\n      cpus: '0.50'\n      memory: 1024M\n```\n\n### 网络\n...学校网关的登录状态根本没法维持,卡死.\n","tags":["code island"],"categories":["闲扯"]},{"title":"[FZU 2204]Seven","url":"%2F2019%2F08%2F10%2Fproblem-seven%2F","content":"\nn个有标号的球围成一个圈。每个球有两种颜色可以选择黑或白染色。问有多少种方案使得没有出现连续白球7个或连续黑球7个。\n\n对方案数mod 2015，球最多有100000个。\n\n# 分析\n考虑对于非环状球的答案计算，可以设$sum(i,k)$表示第i个球为k色时的方案数。其计算非常显然\n\n$$\nsum(i,k)=\\sum_{1\\leq j \\leq 6}{sum(i-j,1-k)}\n$$\n\n接下来考虑收尾相接后需要排除的情况，即收尾同色球长度相加超过6的情况，这可以直接枚举。\n\n首取i个末取j个同色，从答案中删除此时剩下球的方案数，注意剩下的球的首末球颜色**不能**和已经枚举的颜色同色。鉴于这种要求，我们退回到sum的递推公式处，决定sum的边界条件为首个球固定为黑色，这样就能很方便的确定球的颜色，且根据对称性答案可以直接x2得到。\n\n题就做完了。\n\n# 代码\n> 淦，为什么当时没写。\n\n```cpp\n#include <iostream>\nusing namespace std;\nconst int MAXN=100010;\nconst int P=2015;\n\nint sum[MAXN][2];\nint main(){\n    int kase;cin>>kase;\n    sum[0][1]=1;\n    for(int i=1;i<=100000;i++){\n        for(int j=1;j<=min(i,6);j++){\n            (sum[i][1]+=sum[i-j][0])%=P;\n            (sum[i][0]+=sum[i-j][1])%=P;\n        }\n    }\n    sum[0][1]=0;\n    int cnt=0;\n    while(kase--){\n        int nlen;cin>>nlen;\n        int ans=(sum[nlen][0]+sum[nlen][1])%P;\n        if(nlen>=7)\n            for(int i=1;i<=6;i++)\n                for(int j=1;j<=6;j++)\n                    if(i+j>=7 && nlen-i-j>=0)\n                        ans=(ans-sum[nlen-i-j][0])%P;\n        cout<<\"Case #\"<<++cnt<<\": \"<<((ans*2)%P+2015)%P<<endl;\n    }\n    return 0;\n}\n```\n","tags":["计数"],"categories":["coding"]},{"title":"[HDU6638] Snowy Smile","url":"%2F2019%2F08%2F07%2Fproblem-snowy-smile%2F","content":"\nThere are n pirate chests buried in Byteland, labeled by 1,2,…,n. The i-th chest's location is (xi,yi), and its value is wi, wi can be negative since the pirate can add some poisonous gases into the chest. When you open the i-th pirate chest, you will get wi value.\n\nYou want to make money from these pirate chests. You can select a rectangle, the sides of which are all paralleled to the axes, and then all the chests inside it or on its border will be opened. Note that you must open all the chests within that range regardless of their values are positive or negative. But you can choose a rectangle with nothing in it to get a zero sum.\n\nPlease write a program to find the best rectangle with maximum total value.\n\nThe first line of the input contains an integer T(1≤T≤100), denoting the number of test cases.\n\nIn each test case, there is one integer n(1≤n≤2000) in the first line, denoting the number of pirate chests.\n\nFor the next n lines, each line contains three integers xi,yi,wi(−109≤xi,yi,wi≤109), denoting each pirate chest.\n\nIt is guaranteed that ∑n≤10000.\n\n\n## 分析\n首先，我没做出来。\n\n<!--more-->\n\n这道题实际上就是在要求你用小于$O(N^3)$的复杂度求出最大和子矩阵。注意到该题的点**稀疏**，所以以点为考虑对象。\n\n三方的做法，枚举矩阵的上边界和下边界，维护纵向上的和，求最大字段和。当以点考虑时，上下边界就可以直接由**排序后**的点决定。之后，使用线段树维护最大子段和。\n\n## 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconstexpr int MAXN=400010;\n\nll d_sub[MAXN],d_pre[MAXN],d_suf[MAXN];\nll d_sum[MAXN];\nint lc[MAXN],rc[MAXN];\nint idx=0;\nvoid build(int &n,int l,int r){\n    if(!n)n=++idx;\n    d_sum[n]=d_sub[n]=d_pre[n]=d_suf[n]=0;\n    if(l==r){\n        return;\n    }\n    int mid=(l+r)/2;\n    build(lc[n],l,mid);\n    build(rc[n],mid+1,r);\n    //combine data\n}\nvoid collect(int node){\n    d_sum[node]=d_sum[lc[node]]+d_sum[rc[node]];\n\n    d_pre[node]=max(d_pre[lc[node]],d_sum[lc[node]]+d_pre[rc[node]]);\n    d_suf[node]=max(d_suf[rc[node]],d_sum[rc[node]]+d_suf[lc[node]]);\n\n    d_sub[node]=max(max(d_sub[lc[node]],d_sub[rc[node]]),d_suf[lc[node]]+d_pre[rc[node]]);\n}\n\nvoid modify(int x,int l,int r,int L,int R,int node){\n    if(l<=L && R<=r){\n        //only single point to modify\n        d_sub[node]=d_sub[node]+x;\n        d_pre[node]=d_pre[node]+x;\n        d_suf[node]=d_suf[node]+x;\n        d_sum[node]+=x;\n        return;\n    }\n    int mid=(L+R)/2;\n    if(l<=mid)modify(x,l,r,L,mid,lc[node]);\n    if(mid<r)modify(x,l,r,mid+1,R,rc[node]);\n\n    collect(node);\n}\nint root;\nll query_all(){\n    return d_sub[root];\n}\n\nstruct Chest{\n    int x,y,v;\n    bool operator<(const Chest &other)const{\n        if(x==other.x)return y<other.y;\n        return x<other.x;\n    }\n} chests[MAXN];\n\nvector<int> refy;\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    while(kase--){\n        int nlen;cin>>nlen;\n        refy.clear();\n        for(int i=0;i<nlen;i++){\n            Chest &chest=chests[i];\n            cin>>chest.x>>chest.y>>chest.v;\n            refy.push_back(chest.y);\n        }\n        sort(chests,chests+nlen);\n\n        sort(refy.begin(),refy.end());\n        auto refyend=unique(refy.begin(),refy.end());\n        int maxy=0;\n        for(int i=0;i<nlen;i++){\n            chests[i].y=lower_bound(refy.begin(),refyend,chests[i].y)-refy.begin()+1;\n            maxy=max(maxy,chests[i].y);\n        }\n\n        int lastx=0;\n        ll ans=0;\n\n        for(int i=0;i<nlen;i++){\n            if(lastx==chests[i].x)continue;\n            lastx=chests[i].x;\n            //cout<<\"start from \"<<lastx<<endl;\n\n            build(root,1,maxy);\n            int nextx=chests[i].x;\n            for(int j=i;j<nlen;j++){\n                if(chests[j].x!=nextx){\n                    nextx=chests[j].x;\n                    ans=max(ans,query_all());\n                }\n                modify(chests[j].v,chests[j].y,chests[j].y,1,maxy,root);\n            }\n            ans=max(ans,query_all());\n        }\n        cout<<max(0ll,ans)<<endl;\n    }\n\n    return 0;\n}\n```\n\n\n","tags":["线段树"],"categories":["coding"]},{"title":"莫队算法","url":"%2F2019%2F08%2F03%2Fmo-s-algorithm%2F","content":"\n对于可以离线的区间询问问题，莫队算法提出了一种可以在$O(n\\sqrt n)$(无修改)，$n^{3/5}$(带修改)内得出答案的方法。\n\n主要的思路是对询问离线并分块，利用在2个区间间答案的**快速转移**（如果无法找到快速转移的方法，就没法用了）降低复杂度。\n\n<!--more-->\n\n## 无修改莫队\n以$B=\\sqrt{n}$，按照$(l/B,r)$对询问排序。\n\n之后枚举每一个询问，将答案在相邻询问区间间暴力的+1-1转移。\n\n### Problem: 小Y的袜子\n没有在针对哪个人。\n\n作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……\n\n具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。\n\n你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。\n\n袜子的数量最多为50000（是真的🐂🍺）\n\n#### 分析\n这似乎是莫队的例题（\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50010,MAXQ=50010;\n\nll gcd(ll a,ll b){\n    return !b?a:gcd(b,a%b);\n}\nll c2(ll n){\n    if(n<2)return 0;\n    return n*(n-1)/2;\n}\nint a[MAXN];\nint block=0;\nstruct Q{\n    int l,r;\n    int i;\n    ll ansu,ansd;\n    bool operator<(const Q &b)const{\n        if(l/block!=b.l/block)return l/block<b.l/block;\n        return r<b.r;\n    }\n}qs[MAXQ];\n\nint cnt[MAXN];\nll cup=0,cdown=0;\nvoid remove(int ptr){\n    cup-=c2(cnt[a[ptr]]);\n    cnt[a[ptr]]--;\n    cdown--;\n    cup+=c2(cnt[a[ptr]]);\n}\nvoid add(int ptr){\n    cup-=c2(cnt[a[ptr]]);\n    cnt[a[ptr]]++;\n    cdown++;\n    cup+=c2(cnt[a[ptr]]);\n}\nint main(){\n    int nlen,qlen;cin>>nlen>>qlen;\n    for(int i=1;i<=nlen;i++)cin>>a[i];\n    for(int i=0;i<qlen;i++)cin>>qs[i].l>>qs[i].r;\n    for(int i=0;i<qlen;i++)qs[i].i=i;\n    block=sqrt(nlen);\n    sort(qs,qs+qlen);\n    /*\n    cout<<\"current queries:\"<<endl;\n    for(auto q:qs){\n        cout<<q.l<<\" \"<<q.r<<endl;\n    }\n    cout<<\"=====\"<<endl;\n*/\n    int l=1,r=1;\n    add(1);\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        if(q.l==q.r){\n            q.ansu=0;q.ansd=1;\n            continue;\n        }\n        while(q.l<l)add(--l);\n        while(r<q.r)add(++r);\n        while(l<q.l)remove(l++);\n        while(q.r<r)remove(r--);\n\n        q.ansu=cup;\n        q.ansd=cdown;\n        //cout<<cup/c2(cdown)<<endl;\n    }\n    sort(qs,qs+qlen,[](const Q &a,const Q &b){\n            return a.i<b.i;\n            });\n    for(int i=0;i<qlen;i++){\n        if(qs[i].ansd<2){\n            cout<<\"0/1\"<<endl;\n            continue;\n        }\n        ll u=qs[i].ansu;\n        ll d=c2(qs[i].ansd);\n        ll g=gcd(u,d);\n        if(g!=0)u/=g,d/=g;\n        cout<<u<<\"/\"<<d<<endl;\n    }\n\n\n    return 0;\n}\n```\n\n## 带修改莫队\n> 一切都是石x门的选择！\n\n将修改操作平铺在时间线上，计算每次询问所处的时间点，以$B=\\sqrt{n}$，按照$(l/B,r/B,time)$对询问排序。\n\n之后枚举每一个询问，将答案在不同时间线间暴力+1-1跳转，再暴力在相邻询问的区间间+1-1转移。\n\n~~听起来有点中二的意思。~~\n\n### Problem: Game\nAgain Alice and Bob is playing a game with stones. There are N piles of stones labelled from 1 to N, the i th pile has ai stones. \n\nFirst Alice will choose piles of stones with consecutive labels, whose leftmost is labelled with L and the rightmost one is R. After, Bob will choose another consecutive piles labelled from l to r (L≤l≤r≤R). Then they're going to play game within these piles.\n\nHere's the rules of the game: Alice takes first and the two will take turn to make a move: choose one pile with nonegetive stones and take at least one stone and at most all away. One who cant make a move will lose.\n\nBob thinks this game is not so intersting because Alice always take first. So they add a new rule, which is that Bob can swap the number of two adjacent piles' stones whenever he want before a new round. That is to say, if the i th and i+1 pile have ai and ai+1 stones respectively, after this swapping there will be ai+1 and ai.\n\nBefore today's game with Bob, Alice wants to know, if both they play game optimally when she choose the piles from L to R, there are how many pairs (l, r) chosed by Bob that will make Alice *win*.\n\n#### 分析\nnim游戏输赢就是看异或和，异或和可以看前缀异或和内有多少个值相同的点。所以它就是在问一个区间里有多少个相同点对。\n\n带单点修改的区间点对计数。\n\n#### 代码\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=100010,MAXQ=100010;\nconst int MAXPOS=2e6+11;\n\nint nlen,qlen;\nint game[MAXN];\nint pre[MAXN];\nint modified[MAXQ],midx=0,belong[MAXN];\nint block=0;\nstruct Q{\n    int i;\n    int l,r;\n    int tick;\n\n    bool operator<(const Q &b)const{\n //       if(l/block!=b.l/block)return l/block<b.l/block;\n   //     if(r/block!=b.r/block)return r/block<b.r/block;\n        if(belong[l]!=belong[b.l])\n            return belong[l]<belong[b.l];\n        if(belong[r]!=belong[b.r])\n            return belong[r]<belong[b.r];\n        return  tick<b.tick;\n    }\n}q[MAXQ];\nint qidx=0;\nll cache=0;\nint cnt[MAXPOS];\n\ninline void add(int pos){\n    int &c=cnt[pre[pos]];\n    cache-=(ll)c*(c-1)/2;\n    c++;\n    cache+=(ll)c*(c-1)/2;\n}\ninline void rm(int pos){\n    int &c=cnt[pre[pos]];\n    cache-=(ll)c*(c-1)/2;\n    c--;\n    cache+=(ll)c*(c-1)/2;\n}\n\nint l=1,r=1,curt=0;\ninline void jumpup(int tim){\n    if(tim==0)return;\n    int pos=modified[tim];\n    int a=game[pos];\n    int b=game[pos+1];\n    swap(game[pos],game[pos+1]);\n    if(l<=pos && pos<=r){\n        rm(pos);\n    }\n    pre[pos]^=a;\n    pre[pos]^=b;\n    if(l<=pos && pos<=r){\n        add(pos);\n    }\n}\ninline void jumpdown(int tim){\n    jumpup(tim);\n}\n\nll qans[MAXQ];\n\nint main(){\n    //freopen(\"00.in\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&nlen,&qlen)){\n        block=pow(nlen,2.0/3);\n        for(int i=1;i<=nlen;i++){\n            scanf(\"%d\",&game[i]);\n            belong[i]=(i-1)/block;\n        }\n        pre[0]=0;\n        for(int i=1;i<=nlen;i++)pre[i]=pre[i-1]^game[i];\n\n        qidx=0,midx=0;\n        for(int i=1;i<=qlen;i++){\n            int opt;\n            scanf(\"%d\",&opt);\n            if(opt==1){\n                int l,r;\n                scanf(\"%d%d\",&l,&r);\n                q[qidx].i=qidx;\n                q[qidx].l=l;\n                q[qidx].l--;\n                q[qidx].r=r;\n                q[qidx].tick=midx;\n                qidx++;\n            }else if(opt==2){\n                scanf(\"%d\",&modified[++midx]);\n            }\n        }\n        sort(q,q+qidx);\n\n        memset(cnt,0,sizeof(cnt));\n        cache=0;\n        l=r=1;curt=0;\n        add(1);\n        for(int i=0;i<qidx;i++){\n            if(q[i].r-q[i].l+1<2){\n                qans[q[i].i]=0;\n                continue;\n            }\n            while(curt<q[i].tick)jumpup(++curt);\n            while(q[i].tick<curt)jumpdown(curt--);\n\n            while(q[i].l<l)add(--l);\n            while(r<q[i].r)add(++r);\n            while(l<q[i].l)rm(l++);\n            while(q[i].r<r)rm(r--);\n \n            //qans[q[i].i]=cache;\n            ll len=r-l+1;\n            qans[q[i].i]=len*(len-1)/2-cache;\n        }\n        for(int i=0;i<qidx;i++){\n            printf(\"%lld\\n\",qans[i]);\n        }\n    }\n    return 0;\n}\n```\n\n## 注意\n* 关于记录当前问题的区间的开闭问题，需要谨慎安排。\n* 在确认了区间开闭后，关于最初始的状态，需要谨慎安排。","tags":["莫队"],"categories":["study"]},{"title":"Distribution of Books","url":"%2F2019%2F08%2F01%2Fproblem-distribution-of-books%2F","content":"zz6d likes reading very much, so he bought a lot of books. One day, zz6d brought n books to a classroom in school. The books of zz6d is so popular that K students in the classroom want to borrow his books to read. Every book of zz6d has a number i (1<=i<=n). Every student in the classroom wants to get a continuous number books. Every book has a pleasure value, which can be 0 or even negative (causing discomfort). Now zz6d needs to distribute these books to K students. The pleasure value of each student is defined as the sum of the pleasure values of all the books he obtains.Zz6d didn't want his classmates to be too happy, so he wanted to minimize the maximum pleasure of the K classmates. zz6d can hide some last numbered books and not distribute them,which means he can just split the first x books into k parts and ignore the rest books, every part is consecutive and no two parts intersect with each other.However,every classmate must get at least one book.Now he wonders how small can the maximum pleasure of the K classmates be.\n\n1<=T<=10\n\n1<=n<=2*105 \n\n1<=k<=n \n\n-109<=ai<=109\n\n# 分析\n最大值最小，考虑二分答案。思考题目是否具有单调性：当最大值极大时，书可以随便分，当最大值极小时，可能会出现无法凑齐的状况，目测满足。\n\n题目要求分书时必须连续分，可以使用动态规划来做。假设二分的答案为lim\n\n$$f(i)=\\max \\{ f(j) | \\sum_{k=j+1}^i a_k \\leq lim  \\}+1$$\n\n将求和改为前缀和，$pre(i)$。\n\n$$f(i)=\\max \\{ f(j) | pre(i)-pre(j-1) \\leq lim  \\}+1$$\n\n动态规划的复杂度为$O(n^2)$，太慢，考虑优化。\n\n每次转移都从先前已经出现的满足要求的f中转移。限制条件转一下，就是\n\n$$pre(i)-lim \\leq pre(?)$$\n\n* 当有2个f对应的前缀和相同，我们选择更大的那个\n\n所以可以直接维护已经出现的每种前缀和所对应的最大f。可以离散化后使用权值线段树。复杂度变为$O(n\\lg n)$\n\n总复杂度为$O(n\\lg n \\lg n)$。\n\n# 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=900010;\n\nll dat[MAXN];\nint lc[MAXN],rc[MAXN];\nint idx=0;\nint build(int &n,int l,int r){\n    if(!n)n=++idx;\n    dat[n]=-0x3f3f3f3f;\n    if(l>=r)return dat[n];\n\n    int mid=(l+r)/2;\n    dat[n]=max(build(lc[n],l,mid),build(rc[n],mid+1,r));\n    return dat[n];\n}\nvoid collectchild(int node){\n    dat[node]=max(dat[lc[node]],dat[rc[node]]);\n}\n\nint query_n(int l,int r,int L,int R,int node){\n    if(l<=L && R<=r)return dat[node];\n    int mid=(L+R)/2;\n    int res=-0x3f3f3f3f;\n    if(l<=mid)res=max(res,query_n(l,r,L,mid,lc[node]));\n    if(mid<r)res=max(res,query_n(l,r,mid+1,R,rc[node]));\n    return res;\n}\n\nvoid modify(int l,int r,ll x,int L,int R,int node){\n    if(L>=R){\n        dat[node]=max(dat[node],x);\n        return;\n    }\n    int mid=(L+R)/2;\n    if(l<=mid)modify(l,r,x,L,mid,lc[node]);\n    if(mid<r)modify(l,r,x,mid+1,R,rc[node]);\n    collectchild(node);\n}\nll prefix[MAXN];\nll bprefix[MAXN];\nll num[MAXN];\n\nint nlen,sel;\nint rlen;\nint root;\nbool check(ll x){\n    build(root,0,rlen-1);\n\n    int zero=lower_bound(bprefix,bprefix+rlen,0)-bprefix;\n    modify(zero,zero,0,0,rlen-1,root);\n\n    for(int i=1;i<=nlen;i++){\n        int start=lower_bound(bprefix,bprefix+rlen,bprefix[prefix[i]]-x)-bprefix;\n        int dp=query_n(start,rlen-1,0,rlen-1,root)+1;\n        if(dp>=sel)return true;\n        modify(prefix[i],prefix[i],dp,0,rlen-1,root);\n    }\n    return false;\n}\n\n\nint main(){\n    //debug\n    /*\n    int opt;\n    build(root,0,10-1);\n    while(cin>>opt){\n        if(opt==1){\n            int pos,x;cin>>pos>>x;\n            modify(pos,pos,x,0,10-1,root);\n        }else{\n            int l,r;cin>>l>>r;\n            cout<<query_n(l,r,0,10-1,root)<<endl;\n        }\n    }\n    */\n\n    int kase;cin>>kase;\n    while(kase--){\n        cin>>nlen>>sel;\n        for(int i=1;i<=nlen;i++){\n            cin>>num[i];\n        }\n        bprefix[0]=prefix[0]=0;\n        for(int i=1;i<=nlen;i++)bprefix[i]=prefix[i]=prefix[i-1]+num[i];\n        //discrete\n        sort(bprefix,bprefix+nlen+1);\n        rlen=unique(bprefix,bprefix+nlen+1)-bprefix;\n        for(int i=0;i<=nlen;i++)prefix[i]=lower_bound(bprefix,bprefix+rlen,prefix[i])-bprefix;\n\n        \n\n\n        //binary\n        ll l=-1e15,r=1e15;\n        while(l+1<r){\n            ll mid=(l+r)/2;\n            if(check(mid)){\n                r=mid;\n            }else l=mid;\n        }\n        for(ll i=l;i<=r;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n多组询问没有清理干净数组，WA了好几发。","tags":["离散化"],"categories":["coding"]},{"title":"Fansblog","url":"%2F2019%2F08%2F01%2FFansblog%2F","content":"Farmer John keeps a website called ‘FansBlog’ .Everyday , there are many people visited this blog.One day, he find the visits has reached P , which is a prime number.He thinks it is a interesting fact.And he remembers that the visits had reached another prime number.He try to find out the largest prime number Q ( Q < P ) ,and get the answer of Q! Module P.But he is too busy to find out the answer. So he ask you for help. ( Q! is the product of all positive integers less than or equal to n: n! = n * (n-1) * (n-2) * (n-3) *… * 3 * 2 * 1 . For example, 4! = 4 * 3 * 2 * 1 = 24 )\n\n\nFirst line contains an number T(1<=T<=10) indicating the number of testcases.\nThen T line follows, each contains a positive prime number P (1e9≤p≤1e14)\n\n<!--more-->\n\n\n# 分析\n这题得知道2个结论，然而我都不知道。\n\n## 威尔逊定理\n当P为质数时，$(P-1)! \\equiv -1 \\pmod P$.\n\n注意这里$!$是阶乘，不是取反的意思。\n\n## 素数分布\n当范围变大时，素数的出现频率增高，寻找一素数的相邻素数复杂度逐渐趋近于线性。\n\n所以，寻找素数P的前一个素数可以直接暴力找。找到之后利用$(P-1)! \\equiv -1 \\pmod P$即可快速由$P-1$的阶乘通过逆元转到$Q$的阶乘，这题就做完了。\n\n因为在计算逆元时会爆ll，使用快速乘法来避免，复杂度符合要求。\n\n# 代码\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\ninline ll qmul(ll x,ll y,ll q){\n    ll res=0;\n    for(;y;y>>=1,x=(x+x)%q){\n        if(y&1)res=(res+x)%q;\n    }\n    return res;\n}\n\n\ninline ll qpow(ll x,ll a,ll q){\n    ll res=1;\n    for(a;a;a>>=1,x=qmul(x,x,q)){\n        if(a&1)res=qmul(res,x,q);\n    }\n    return res;\n}\n\ninline ll get_rev(ll x,ll q){\n    return qpow(x,q-2,q);\n}\n\ninline bool is_prime(ll x){\n    for(ll i=2;i<=sqrt(x);i++){\n        if(x%i==0)return false;\n    }\n    return true;\n}\n\ninline ll factor(ll l,ll r,ll q){\n    ll res=1;\n    for(ll i=l;i<=r;i++)res=qmul(res,i,q);\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    while(kase--){\n        ll x;cin>>x;\n        ll prex=x-1;\n        while(!is_prime(prex))prex--;\n\n        ll ans=qmul(x-1,get_rev(factor(prex+1,x-1,x),x),x);\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n```","tags":["威尔逊定理"],"categories":["coding"]},{"title":"咸鱼数论","url":"%2F2019%2F07%2F22%2Fnumeric-water%2F","content":"\n## 一些结论\n* $N!$的质因数分解中某质数的指数为$\\sum_{r=1}^{\\inf}n/p^r $\n* 约数个数为质因数指数+1的乘积，和为质因数枚举指数次和的乘积。\n* 费马小定理要求p是质数\n\n## 欧拉函数\n小于x且与其互质的数的个数\n$$\n\\phi(x)=x\\prod_{k=1}^n(1-\\frac{1}{p_k})\n$$\n\n* $phi(1)=1$\n* $phi(p)=p-1$,当p为质数\n* $phi(2n)=phi(n)$\n* $phi(phi(phi...))))=1$\n\n对于任意积性函数$f(xy)=f(x)f(y)$，可以筛。欧拉函数非完全积性函数。\n\n* $phi(xy)=phi(x)(y-1)$,当x与y互质\n* $phi(xy)=phi(x)y$,当x与y不互质\n\n```cpp\nfor(int i=2;i<=n;i++){\n    if(!no[i]){\n        p[++cnt]=i;\n        phi[i]=i-1;\n    }\n    for(int j=1;j<=cnt&&p[j]*i<=n;j++){\n        no[p[j]*i]=1;\n        if(i%p[j]==0){\n            phi[p[j]*i]=phi[i]*p[j];\n            break;\n        }\n        phi[p[j]*i]=phi[i]*(p[j]-1);\n    }\n}\n```\n\n## 扩展欧几里得\n* 存在x，y使得ax+by=gcd（a，b）\n* 求逆元，要求x与模数互质\n\n```cpp\nvoid exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){\n        x=1,y=0;\n    }else{\n        exgcd(b,a%b,y,x);\n        y-=(a/b)*x;\n    }\n}\n```\n\n## 递推逆元\ninv(i) = inv(mod % i) * (mod-mod/i) % mod;\n\n* 阶乘的逆元：inv(i)=inv(i+1)*(i+1)\n","tags":["数论"],"categories":["study"]},{"title":"水的合集 1","url":"%2F2019%2F07%2F22%2Fwaterful-summary-1%2F","content":"\n\n## 集合挑选\n从给定的N个集合中各挑出一个数并求和，求出前$K$大的$K$个和。\n\n考虑如何从2个集合$A$,$B$中选出前$K$大。降序排序后$a_1$和$b_1$显然是最大，第二大则是$(a_1,b_2)$或者$(a_2,b_1)$。不妨以$(a_1,b_2)$来讲，那么第三大竞争者除$(a_2,b_1)$还有$(a_1,b_3)$，$(a_2,b_3)$……每对组合都能找到直接小于它的2个组合，而这种后继关系显然取遍了所有组合。仅需要前K大的我们按需扩展这一棵树即可。2个集合的前K大可与第3个集合执行相同的操作，从而得到最终答案。实际编写时，按照一定顺序限制扩展方向来保证每个方案仅访问一次，使用优先队列维护，复杂度为$O(\\sum^N{K\\log n_k}) \\leq O(KN)$\n\n## LIS优化\n$$f(i)=max\\{f(j)| j < i, a(j) < a(i) \\}+1$$\n\n可以发现，一旦有$a(k) < a(j), f(k) \\geq f(j)$，j这个位置就没有用了。按照该规律维护一个单调栈记录，以长度单调（则数字a结尾的LIS自然单调）。此后转移\n","categories":["study"]},{"title":"明日方舟工具","url":"%2F2019%2F07%2F20%2Farknights-tools%2F","content":"\n{% asset_img img.jpg Penguin Logistics %}\n\n虽然类型完全不一样，但明日方舟大概是我继玩爆Minecraft之后另一个喜欢的游戏了。\n\n<!--more-->\n\nta的设定、剧情、美术、塔防玩法都很对我口味，庞大的世界观以及复杂的人物关系也值得称赞。而且我认为这个游戏很出众的一点是ta的故事不以玩家为中心，一切自有其发展。\n\n## 掉落统计\n已经有非常完善的轮子了……掉落统计改为掉落识别统计，收归到辅助工具内。\n\n## 资源规划\n已经有非常完善的轮子了……\n\n初步设想为基于线性规划的关卡规划安排。正在思考是否有更好的方法或者改进。\n\n## 辅助工具\n这个辅助工具绝不可破坏掉“我认为”的有乐趣的部分，它的开发也会一直坚持这个想法。\n\n独断而带有偏见的思考后，它的功能目前规划为：\n\n1. 单一关卡的重复性战斗代理\n2. 掉落物品自动统计与上传\n\n### 物品识别\n工具目前可以在关卡结束时自动识别屏内的掉落物品和掉落数量，但不稳定。\n\n掉落检测从灰度匹配改为基于特征点的匹配。首先能够自动将掉落物品图片进行突出特征的处理后拆分生成物品特征图，并使用SIFT从特征图中取出不受图像缩放与色差影响的特征点。\n\n此后再次使用时，与预设特征点比较从而找到对应的掉落物品编码，从数据库中提取出名称。\n\n掉落数量是对切分出来的数字图片调用`tesseract`进行OCR识别，然而这个准确率实在堪忧。对图片的预处理似乎效果并不怎么好，之后（也许）会想办法再改改。\n\n物品掉落的统计信息未来也许能够实现向已有的数据库对接。\n\n## 关卡压力分析\n进攻重放与防守压力的分析工具。\n\n## ？\n非常远期的目标：\n\n* 研究能够研究关卡过法的算法大概率有乐趣","tags":["小工具"],"categories":["projects"]},{"title":"[BUPT WARMUP|CF] 珍珠奶茶","url":"%2F2019%2F07%2F20%2Fproblem-bupt-milk-tea%2F","content":"\n\n给出一个$N \\times N$的非负整数矩阵，要求找到一条从左上角数字到右下角数字的路线，且\n\n* 只能向右或者下走。\n* 将经过数字相乘后得到的结果，使其末尾的“0”最少。\n\n$$\nN \\leq 1000\n$$\n\n<!--more-->\n\n## 分析\n大概是因为末尾的0长得像珍珠。\n\n思考0是怎么出现的，可以发现结果中因数10的指数越小越好，即，使得经过的路上凑出的因数10最少即可。10的质因数分解为$2 \\times 5$，以矩阵中每个数所含因数2和5的数目分别DP一遍求路径，再在两次DP的结果中取小。\n\n一个特殊情况是数字里有0，那么经过0的路的末尾0一定是1个……一开始脑袋抽了以为是0个。如果其他情况的路径末尾0都多于1个的话，就特判走0。\n\n## 代码 \n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconstexpr int MAXN=1010;\n\nint game[MAXN][MAXN];\nint num[2][MAXN][MAXN];\nint cal(int x,int fac){\n    if(x==0)return 0;\n    int res=0;\n    while(x%fac==0){\n        x/=fac;\n        res++;\n    }\n    return res;\n}\nint n;\nint dp[MAXN][MAXN];\nint from[MAXN][MAXN];\nvoid dodp(int fac){\n    for(int i=0;i<MAXN;i++){\n        for(int j=0;j<MAXN;j++){\n            dp[i][j]=0x3f3f3f3f;\n        }\n    }\n    dp[0][1]=dp[1][0]=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(dp[i-1][j]<dp[i][j-1]){\n                from[i][j]=2;\n                dp[i][j]=dp[i-1][j];\n            }else{\n                from[i][j]=1;\n                dp[i][j]=dp[i][j-1];\n            }\n            dp[i][j]+=num[fac][i][j];\n        }\n    }\n}\nstring genpath(){\n    string res=\"\";\n    int i=n,j=n;\n    for(int p=from[i][j];i!=1 || j!=1 ;p=from[i][j]){\n        if(p==2){\n            res+=\"D\";\n            i--;\n        }else{\n            res+=\"R\";\n            j--;\n        }\n    }\n    reverse(res.begin(),res.end());\n    return res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin>>n;\n    bool haszero=false;\n    int zeroi,zeroj;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cin>>game[i][j];\n            if(game[i][j]==0){\n                haszero=1;\n                zeroi=i,zeroj=j;\n            }\n        }\n    }\n    \n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            num[0][i][j]=cal(game[i][j],2);\n            num[1][i][j]=cal(game[i][j],5);\n        }\n    }\n    int ans=0x7f7f7f7f;\n    dodp(0);\n    string P;\n    if(ans>dp[n][n]){\n        ans=dp[n][n];\n        P=genpath();\n    }\n    dodp(1);\n    if(ans>dp[n][n]){\n        ans=dp[n][n];\n        P=genpath();\n    }\n\n    if(haszero && ans>1){\n        cout<<1<<endl;\n        for(int i=1;i<zeroi;i++)cout<<\"D\";\n        for(int j=1;j<zeroj;j++)cout<<\"R\";\n        for(int i=zeroi+1;i<=n;i++)cout<<\"D\";\n        for(int j=zeroj+1;j<=n;j++)cout<<\"R\";\n        cout<<endl;\n        return 0;\n    }\n\n    cout<<ans<<endl;\n    cout<<P<<endl;\n\n    return 0;\n}\n```\n","tags":["动态规划"],"categories":["coding"]},{"title":"blog迁移","url":"%2F2019%2F07%2F13%2Fblog-upgrade%2F","content":"\n{% asset_img girl.jpg %}\n\n又回到了静态blog😀.果然这样才是最吼的.\n\n## 静态blog编译器\n现在流行的静态blog编译器大概有这么几种\n\n* `Node.js`的`Hexo`\n* `Python`的`Pelican`\n* `Ruby`的`Jekyll`\n* `Golang`的`Hugo`\n\n<!--more-->\n\n## 使用Github pages\nGithub为用户准备了免费的pages服务,能够展示静态页面,满足我们的要求.\n\n为了使用Github pages,需要新建项目`<username>.github.io`,将文件push上去后,访问相应的域名`https://<username>.github.io`就能看到.\n\n使用github提供的域名也可以,一般来说为了~~装逼~~达到更好的展示效果,会将pages再和自己的域名绑定.\n\n### 域名解析过程\n当访问一个网站时,经过了这么几个过程.\n\n1. 用户访问域名`DOMAIN`\n2. 系统向DNS服务器询问`DOMAIN`所对应的IP(或者其他域名)地址.\n3. 浏览器向该IP地址发送请求.\n4. 浏览器将该IP返回的数据渲染为网页.\n\n因此为了让自己的域名指向pages服务,需要这么几步.\n\n#### 在DNS服务器配置记录\n对DNS服务器说明域名所指向的地址.在此,我们将域名指向pages的域名`<username>.github.io`.该类记录的类型为`CNAME`,按照页面相关提示填写即可.\n\n#### 在Github配置接收来源\n之后,要告诉github当其接收到标注自我们的域名的请求时,要做出对应的相应.\n\n在项目中添加文件`CNAME`,内写一行,为我们的域名.\n\n## 启用SSL\n启用SSL治疗各种劫持.\n\n因为pages不原生支持SSL,可以使用cloudflare的服务来启用SSL.\n\n注册cloudflare后,按照指示,将域名的解析服务器改为cloudflare,一段时间后解析生效即可开启SSL.\n\n你还可以加一条Rule,强制把HTTP转到HTTPS,治疗一下剥离攻击."},{"title":"Colorful Tree","url":"%2F2019%2F07%2F12%2Fcolorful-tree%2F","content":"\n\nThere is a tree having n nodes, the i-th node of which has a type of color, denoted by an integer $c_i$\n\nThe path between every two nodes is unique, of which we define the value is the number of distinct types of colors appearing on it.\n\nCalculate the sum of values of all possible paths, $\\frac{n(n-1)}{2}$ in total, between two different nodes on the tree.\n\n## 输入范围\n多组数据,约50;节点数$2 \\times 10^5$.\n\n# 分析\n没想出来该怎么做.统计路径颜色的答案没有什么合并的好方法,同时也不能按照每种颜色单独考虑.\n\n后来经过dalao点拨,该题中的\"统计一条路径上颜色种类\"的要求可以转化为求其**反面**\"没有某种颜色的路径有多少种\".\n\n如此,对于每一种颜色就可以使用$n(n-1)/2-size$来求其对答案的贡献了.So,来解决这个问题.\n\n原图是一棵树,如果某点$N$为颜色$c$,那么经过$N$的子树任意点跨越$N$的路径都有该颜色.所有不包括该颜色$c$的路径只**能**出现在以$N$为切点的其他2部分.考虑其中一个部分,任意选中其中2个节点即可构建一条路径,但还是必须满足刚刚的条件(不能跨越颜色$c$的节点).以dfs递归进去即可.\n\n考虑能否递归合并已有答案.能够得到的数据有*子节点中2部分的节点数目*,显然能够合并出以当前节点为界划分的2部分中的一部分,自然可以在递归返回后推出另一部分.\n\n# 代码\n```cpp\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXV=200010;\nvector<int> g[MAXV];\ninline void adde(int u,int v){\n    g[u].push_back(v);\n}\nint color[MAXV];\nll sz[MAXV];\nll gsz;\nll res=0;\nvoid dfs(int u,int fa){\n    gsz++;\n    for(auto v:g[u]){\n        if(v==fa)continue;\n        ll b_gsz=gsz;\n        ll b_sz=sz[color[u]];\n        dfs(v,u);\n\n        ll d=(gsz-b_gsz)-(sz[color[u]]-b_sz);\n        res+=d*(d-1)/2;\n        sz[color[u]]+=d;\n    }\n    sz[color[u]]++;\n}\nint flag[MAXV];\nint main(){\n    ios::sync_with_stdio(false);\n    int n;\n    int kase=0;\n    while(cin>>n){\n        for(int i=1;i<=n;i++)g[i].clear();\n        memset(sz,0,sizeof(sz));\n        gsz=0;\n        res=0;\n\n        vector<int> discol;\n        for(int i=1;i<=n;i++){\n            cin>>color[i];\n            flag[color[i]]=1;\n        }\n        for(int i=1;i<=n;i++){\n            if(flag[i])discol.push_back(i);\n        }\n        for(int i=0;i<n-1;i++){\n            int u,v;cin>>u>>v;\n            adde(u,v);\n            adde(v,u);\n        }\n\n        int disnum=discol.size();\n        dfs(1,0);\n        ll ans=(ll)disnum*n*(n-1)/2;\n        for(auto i:discol){\n            ll t=n-sz[i];\n            ans-=t*(t-1)/2;\n        }\n        cout<<\"Case #\"<<++kase<<\": \"<<ans-res<<endl;\n    }\n\n    return 0;\n}\n```","categories":["coding"]},{"title":"快速傅里叶变换","url":"%2F2019%2F07%2F12%2Ffft%2F","content":"\n> 写代码是不可能写代码的,今下午是不想写代码的.不想写代码,又不想咸鱼,就只能靠学点新东西来假装自己在工作的样子,心里才能好受些.\n>\n> > 窃格码拉\n\n把2年前就听过但是没学的FFT这次看看吧.\n\n几乎可以肯定,下面的内容肯定会出锅.\n\n<!--more-->\n\n## 傅里叶变换的实际意义\n### 从电压说起\n被模电折磨的同学都知道,有种东西叫做傅里叶级数,可以将成周期性变化的电压分解为数个三角函数波的叠加.\n\n在这里,我们提出另一个问题,如果不知道周期,该如何将这些叠加在一起的信号拆分为单纯的三角波?\n\n> 三角波叠加图象周期并不那么显然,也许你可以试一试.\n\n### 一种缠绕机\n有一种奇特的方法,我们将一段`时域图象`在笛卡尔坐标系上以原点为圆心**绕**起来,一圈一圈缠起来,然后调整源图象缠绕的速率(几秒一圈),观察整个图形的**质心**变化.\n\n这个质心会随着图象缠绕的频率而发生位移.取质心的x坐标为y轴,以缠绕的频率为横轴,作出图象`B`.在这个图象上,会观测到一个现象:(假设我们已知原图像的分解三角波频率)当缠绕频率接近某个源三角波的频率时,缠绕图象出现**重合**,质心相对原点出现较大位移,图象出现一个**峰值**.\n\n继续调整缠绕频率,峰值消失,图象回归到小范围波动.\n\n通过观察图象`B`,可以认为,出现峰值的频率对应着一个频率的源三角波.如此,就将叠加图象还原了回去.\n\n## 傅里叶变换的数学实现\n现在,考虑如何通过的数学的方法来实现这个缠绕.\n\n### 如何缠绕\n将$g(t)$的图象缠绕到圆上听起来挺奇怪的,有这样的数学方法吗.\n\n有一个东西,叫做$y=e^{ix}$.当其图象画在复平面时,就出现了有趣的事情:一个圆.对这个公式做一些加工.\n\n$$\ny=g(t)e^{-2\\pi i ft}\n$$\n\n如此,就能够将$g(t)$以$f$频率缠绕.\n\n### 关于质心\n上文我们取质心的x坐标作图,现在需要稍微修改一下.\n\n实际上,我们关心的是质心相对于原点的偏移**距离**.同样,以复平面的方式来表示质心位置就能够同时保留x和y坐标信息.\n\n关于如何求取质心,其实也很直观.选取缠绕图象上的数个点,取平均,就是质心的大约位置.当点的数目达到极限,求和公式化为积分,所求即为质心.\n\n$$\n\\hat g(f)=\\frac{1}{t_2-t_1} \\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}}\n$$\n\n### ?\n目前为止,这几乎已经是傅里叶变换了.在数学应用时,傅里叶变换会去掉取均值,即\n\n$$\n\\hat g(f)=\\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}}\n$$\n\n也就是说,取样的时域信号越长,该质心的偏移倾向越大,这和我们想要的效果一致.\n\n这就是傅里叶变换,实现了`时域信号`到`频域信号`的转换.\n\n此外,还有方法将频域信号再次逆变换为时域信号的方法.\n\n## 应用\n傅里叶变换在很多领域都有重要作用.只要问题能转换为时域频域之间的变化,就有傅里叶变换的用武之处.\n\n比如,在音频处理软件中,常常有一个功能叫做`消除人声`.基于傅里叶变换我们可以设计一个(至少理论上有用)的算法.\n\n首先,任何声音都是相应频率的波对气压变化引起的,也就是不同**频率**的波在**时间**上叠加在一起,产生了声音.将源波使用傅里叶变换拆分到多个三角波上去.**删除人声所在的频域**,再将频域信号逆变换为时域信号.人声便消失了.\n\n## 离散傅里叶变换\n连续意义下的傅里叶变换先到此为止.在计算机中所处理的数据一般都是离散的.我们需要的是离散傅里叶变换.\n\n离散意义下的时域信号和频域信号就都变成了点集.当从连续向离散过渡时,可以这样思考:\n\n> 在连续的图象上以一定间隔**取样**得到离散点集.使用该点集进行傅里叶变换.\n\n这也是我们一开始采取的质心求解方法,只不过,这次我们从缠绕时就取样.(质点依然是真正的质点)\n对于点集$g(0\\leq n < N)$,它的傅里叶变化就是\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\n简单粗暴.\n\n## 快速傅里叶变换\n在了解了关于傅里叶变换的一系列背景与一个应用后,我们再回来解决一些重要的问题.\n\n根据傅里叶变换的公式定义\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\n其朴素算法的时间复杂度为$O(N^2)$ 这个复杂度还不够优秀.一种快速傅里叶变换算法利用$e^{ix}$的性质,将复杂度降低到了$O(N\\lg N)$.\n\n### 单位根\n给$e^{ix}$个名字.\n\n在数学上, $n$次**单位根**是 $n$次幂为1的复数.它们位于复平面的单位圆上,构成正n边形的顶点,其中一个顶点是1.\n\n记\n\n$$\n\\omega_{n,k}=-e^{i\\frac{2\\pi}{n}k}\n$$\n\n其几何意义为单位圆上的n等分点的顺时针第k个.\n\n> 一般来说,单位根取逆时针,不过这里为了方便,取顺时针.\n\n如同三角函数一样,单位根存在一些显然的定理.\n\n**折半:**$\\omega_{2n,2k}=\\omega_{n,k}$\n\n**化简:**$\\omega_{n,k+\\frac 2n}=-\\omega_{n,k}$\n\n#### 修改公式\n来看原本的离散傅里叶变换公式\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\n使用单位根来替换一下\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}\\omega_{N,nk} g(n)\n$$\n\n按照~~神~~化简公式的指引,将求和公式按照单位根奇偶拆分为2部分.\n\n​                                                                                                              \n$$\n\\begin{aligned}\n\\hat g(k) &= \\sum_{n=0}^{N-1}\\omega_{N,nk} g(n) \\\\\n&= \\sum_{0 \\leq n < N}\\omega_{N,nk} g(n) \\\\\n&= \\sum_{0 \\leq 2n < N}\\omega_{N,2nk} g(2n) + \\sum_{0 \\leq 2n+1 < N}\\omega_{N,(2n+1)k} g(2n+1) \\\\\n&=\\sum_{0 \\leq 2n < N}\\omega_{N,2nk} g(2n) + \\sum_{0 \\leq 2n+1 < N}\\omega_{N,2nk+k} g(2n+1) \\\\\n&=\\sum_{0 \\leq 2n < N}\\omega_{\\frac N2,nk} g(2n) + \\omega_{N,k}\\sum_{0 \\leq 2n+1 < N}\\omega_{\\frac N2,nk} g(2n+1) \\\\\n&=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k)\n\\end{aligned}\n$$\n\n注意到不管是$\\hat g_{even}(k)$还是$\\hat g_{even}(k)$,它们都以$N/2$为周期.接下来,应用化简定理\n\n$$\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\n将这2个式子放在一起\n\n$$\n\\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\n当k取遍原问题规模的一半时,可以直接由第二个式子得到另一半.问题的规模减半.递归求解,最终的复杂度就降到了$O(N \\lg N)$.\n\n这就是`Cooley-Turkey`快速傅里叶变换算法.\n\n## 快速乘法\n定义多项式$A(x)=\\sum_k a_kx^{k+1}$,$B(x)$同理,求解$C(x)=A(x)B(x)$.\n\n很容易看出,朴素算法的复杂度为$O(N^2)$.\n\n现在,来看如何使用FFT快速计算.\n\n### 点值表示\n> 对于一个次数为$n-1$的多项式,其图象上互不相同的$n$个点可以唯一确定该多项式.\n> ...\n> 如同确定混合在一起的几个波一样.\n\n至于为什么是对的,大可在Google上搜索一番.\n\n取$x$为数个单位根,在$A(x)$和$B(x)$上利用单位根的性质得到$A$和$B$的点值表示,将点值相乘得到$C$的点值表示.之后,将$C$的点值表示再转换为系数表示.\n\n嗯?FFT在哪?\n\n其实在这里,\n\n$$\n\\hat g(\\omega)=A(\\omega)=\\sum_{n}\\omega A[x^{n+1}]\n$$\n\n### 离散卷积\n有一种**数学运算**,叫做**卷积**.现在只讨论它的离散情况.\n\n$$\n(f * g)(n)=\\sum_{\\tau=-\\inf}^{inf}f(\\tau)g(n-\\tau)\n$$\n\n这玩意的意义...实在是不怎么明显.不过好在我们只是想算个多项式乘法,也就是把多项式的**系数**算来算去:\n\n$C[x^n]$ 表示多项式$C$中$x^n$项的系数.\n\n$$\nC[x^{n}]=\\sum_{\\tau=0}^{n}A[x^\\tau]B[x^{n-\\tau}]\n$$\n\n嗯?\n\n如果我们设多项式中不存在的项的系数为0的话.\n\n$$\nC[x^{n}]=\\sum_{\\tau=-\\inf}^{\\inf}A[x^\\tau]B[x^{n-\\tau}]\n$$\n\n哈,\n\n$$\nC[x^n]=(A*B)[x^n]\n$$\n### 卷积定理\n卷积定理指出:\n\n> 一个域中的卷积对应于另一个域中的乘积.\n\n这意味着,上面这个计算(卷积)对应着另一个域里的乘积.也就是\n\n$$\nF(C[x^n])=F(A[x^n]) \\cdot F(B[x^n])\n$$\n\n这便是深层原理.对A和B的取样(频域)称为A和B的点值表示,最终以乘积的方式得到了C的点值表示(频域).用FFT来计算乘法的说法是对的.\n\n## 傅里叶逆变换\n如何从一个频域信号再得到时域信号?\n\n$$\ng(n)=\\frac 1N\\sum_{k=0}^{N-1}e^{i\\frac{2\\pi}{N}nk} \\hat g(k)\n$$\n\n> 注意:此处的1/N与上面的变换是相匹配的.\n\n这个式子可以理解成对变换后的式子再变换,意味着它同样可以用变换时的思想来加速.\n\n## FFT的C++实现\n一个值得注意的问题就是,对于单位根的运算涉及到了精度的问题.但目前还不需要讨论.\n\n### 翻转操作\n可以观察到,按照上面的算法实现,我们需要在每次递归按照奇和偶将取样分组.且每次递归都会分组.每次分组都会涉及到数组的复制,常数较大.\n\n观察分组操作中下标的变化.\n\n```\n(表示下标)\n0 1 2 3 4 5 6 7\n0 2 4 6 | 1 3 5 7\n0 4 | 2 6 | 1 5 | 3 7\n```\n\n将其转换为二进制\n```\n000 001 010 011 100 101 110 111\n000 100 010 110 001 101 011 111\n```\n\n可以发现,最终的分组结果就是将原下标二进制翻转.所以可以直接一次完成分组.\n\n注意,**这要求取样为2的幂次**.\n\n### 🦋蝴蝶操作\n解决了递归中由顶至底的分组后,接下来优化子问题合并时的数组复制.\n\n观察原来的合并式子\n\n$$\n\\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\n按照算法中的实现方法,其为\n\n$$\n\\hat g(k)=\\hat g(k)+\\omega_{N,k} \\hat g(k+\\frac N2) \\\\\n\\hat g(k+\\frac N2)=\\hat g(k)-\\omega_{N,k} \\hat g(k+\\frac N2)\n$$\n\n想要省略数组复制,进行原地合并,问题出在新数值太早地替换掉了我们需要的数值.\n\n取辅助变量,修改原式\n\n$$\nt=\\omega_{N,k} \\hat g(k+\\frac N2)\\\\\n\\hat g(k+\\frac N2)=\\hat g(k)-t\\\\\n\\hat g(k)=\\hat g(k)+t\n$$\n\n这个操作被称为\"蝴蝶操作\",名字很有意思.\n\n### 代码\n在这段代码中同时去掉了递归.\n\n```cpp\nconst double PI=acos(-1);\n\ninline complex<double> gomega(int n,int k,bool rev=false){\n    complex<double> res(cos(2*PI/n*k),sin(2*PI/n*k));\n    if(rev)return conj(res);\n    else return res;\n}\nconst int MAXN=10;\nstruct FFT{\n    complex<double> omega[MAXN],omegaI[MAXN];\n\n    FFT(int n){\n        for(int i=0;i<n;i++){\n            omega[i]=gomega(n,i);\n            omegaI[i]=gomega(n,i,1);\n        }\n    }\n    void transform(complex<double> *a,int n,const complex<double> *omega){\n        for(int i=0,j=0;i<n;i++){\n            if(i>j)swap(a[i],a[j]);\n            //二进制换位\n            for(int l=n/2;(j^=l)<l;l>>=1);\n        }\n        for(int l=2;l<=n;l<<=1){\n            int m=l/2;\n            for(complex<double> *p=a;p!=a+n;p+=l){\n                for(int i=0;i<m;i++){\n                //蝴蝶操作\n                    complex<double> t=omega[n/l*i]*p[m+i];\n                    p[m+i]=p[i]-t;\n                    p[i]+=t;\n                }\n            }\n        }\n    }\n    void dft(complex<double> *a,int n){\n        transform(a,n,omega);\n    }\n    void idft(complex<double> *a,int n){\n        transform(a,n,omegaI);\n        for(int i=0;i<n;i++)a[i]/=n;\n    }\n};\n```\n\n如果想要实现快速乘法,只要将2个多项式的系数函数传入进行变换,变换结果相乘并逆变换即可.\n\n#### 应用\n\n##### 快速乘法\n指快速大数乘法。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN=300000;\nconst double PI=acos(-1);\n\ninline complex<double> gomega(int n,int k,bool rev=false){\n    complex<double> res(cos(2*PI/n*k),sin(2*PI/n*k));\n    if(rev)return conj(res);\n    else return res;\n}\nstruct FFT{\n    complex<double> omega[MAXN],omegaI[MAXN];\n\n    FFT(){\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            omega[i]=gomega(n,i);\n            omegaI[i]=gomega(n,i,1);\n        }\n    }\n\n    void transform(complex<double> *a,int n,const complex<double> *omega){\n        for(int i=0,j=0;i<n;i++){\n            if(i>j)swap(a[i],a[j]);\n            //二进制换位\n            for(int l=n/2;(j^=l)<l;l>>=1);\n        }\n        for(int l=2;l<=n;l<<=1){\n            int m=l/2;\n            for(complex<double> *p=a;p!=a+n;p+=l){\n                for(int i=0;i<m;i++){\n                    //蝴蝶操作\n                    complex<double> t=omega[n/l*i]*p[m+i];\n                    p[m+i]=p[i]-t;\n                    p[i]+=t;\n                }\n            }\n        }\n    }\n    void dft(complex<double> *a,int n){\n        transform(a,n,omega);\n    }\n    void idft(complex<double> *a,int n){\n        transform(a,n,omegaI);\n        for(int i=0;i<n;i++)a[i]/=n;\n    }\n};\n\ncomplex<double> a[2][MAXN];\nint ans[MAXN];\nFFT fft;\nint main(){\n\n    int nlen;cin>>nlen;\n    int n=1;\n    //根据原理，\b\bn必须取大于2nlen的数，才能满足取样要求和反转操作要求\n    while(n<2*nlen)n*=2;\n    fft.init(n);\n\n\n    for(int i=0;i<2;i++){\n        string inp;cin>>inp;\n        for(int j=0,k=inp.size()-1;j<inp.size();j++,k--){\n            a[i][j]=complex<double>(inp[j]-'0',0);\n        }\n        fft.dft(a[i],n);\n    }\n    for(int i=0;i<n;i++)a[0][i]=a[0][i]*a[1][i];\n    fft.idft(a[0],n);\n    int reslen=nlen+nlen-1;\n    for(int i=reslen-1,k=0;i>=0;i--,k++)\n        ans[k]=(int)floor(a[0][i].real()+0.5);\n    /*\n    for(int i=0;i<reslen;i++)cout<<ans[i]<<\" \";\n    cout<<endl;\n    */\n    for(int i=0;i<MAXN;i++){\n        ans[i+1]+=ans[i]/10;\n        ans[i]%=10;\n    }\n    int ptr=MAXN-1;\n    while(ans[ptr]==0)ptr--;\n    for(;ptr>=0;ptr--)cout<<ans[ptr];\n    cout<<endl;\n\n    return 0;\n}\n```","categories":["study"]},{"title":"did-i-write-qsort-right","url":"%2F2019%2F07%2F12%2Fdid-i-write-qsort-right%2F","content":"众所周知，快速排序的时间复杂度是$O(n\\lg n)$的。然而因为我太菜，写出来的快速排序一不小心就成了$O(n^2)$...\n\n<!--more-->\n\n## 这个辣鸡问题\n这个应该都知道，当待排序数组已经有序时，固定选择某一个位置的数字当哨兵的快排会变成$O(n^2)$。一个解决方法就是随机选择哨兵，或者干脆将输入的数组打乱后再排序。\n\n然而，如果输入的数组数字全部相同呢？\n\n当然这在实际中很少见，但是在实现的时候就要小心。在这种情况下，所实现的快排必须对于相同数字也交换位置，否则就会退化为$O(n^2)$。\n\n比如说，这个\n```cpp\n    void quicksort(int left,int right)\n    {\n    int i,j,t,temp;\n    if(left>right)\n       return;\n\n    temp=a[left]; //temp中存的就是基准数\n    i=left;\n    j=right;\n    while(i!=j)\n    {\n       //顺序很重要，要先从右边开始找\n       while(a[j]>=temp && i<j)\n    j--;\n       //再找右边的\n       while(a[i]<=temp && i<j)\n    i++;\n       //交换两个数在数组中的位置\n       if(i<j)\n       {\n    t=a[i];\n    a[i]=a[j];\n    a[j]=t;\n       }\n    }\n    //最终将基准数归位\n    a[left]=a[i];\n    a[i]=temp;\n\n    quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程\n    quicksort(i+1,right);//继续处理右边的 ，这里是一个递归的过程\n    }\n```\n还有这个，\n```cpp\nvoid quick_sort(int s[], int l, int r)\n{\n    if (l < r)\n    {\n\t\t//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1\n        int i = l, j = r, x = s[l];\n        while (i < j)\n        {\n            while(i < j && s[j] >= x) // 从右向左找第一个小于x的数\n\t\t\t\tj--;  \n            if(i < j) \n\t\t\t\ts[i++] = s[j];\n\t\t\t\n            while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数\n\t\t\t\ti++;  \n            if(i < j) \n\t\t\t\ts[j--] = s[i];\n        }\n        s[i] = x;\n        quick_sort(s, l, i - 1); // 递归调用 \n        quick_sort(s, i + 1, r);\n    }\n}\n\n```\n它们都会跳过相同的数字，每次排序后哨兵总会在边界上，导致算法劣化到$O(n^2)$。\n\n大概就是这回事，没别的了。这种情况当然有改进的快速排序可以直接避免这种罕见的情况，在不大幅度改动算法的前提下，就要对相同的元素也进行换位才可以，即使会增加交换次数。","tags":["排序"],"categories":["闲扯"]},{"title":"基于PBDS的splay","url":"%2F2019%2F07%2F12%2Fimplment-of-splay-based-on-PBDS%2F","content":"\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntree<int,null_type,greater<int>,rb_tree_tag,tree_order_statistics_node_update> bbt;\nmap<int,string> ef;\nint main(){\n    int n;cin>>n;\n    while(n--){\n        int op;\n        cin>>op;\n        if(op==1){\n            string name;\n            int value;\n            cin>>name>>value;\n            ef[value]=name;\n            bbt.insert(value);\n        }else if(op==2){\n            int v;cin>>v;\n            if(!bbt.erase(v))cout<<\"NO\"<<endl;\n            else cout<<ef[v]<<endl;\n        }else if(op==3){\n            int v;cin>>v;\n            if(bbt.find(v)==bbt.end())cout<<\"NO\"<<endl;\n            else cout<<bbt.order_of_key(v)+1<<endl;\n        }else if(op==4){\n            int r;cin>>r;\n            r--;\n            auto it=bbt.find_by_order(r);\n            if(it!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }else if(op==5){\n            int v;cin>>v;\n            auto it=bbt.find(v);\n            if(it!=bbt.end() && (--it)!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }else if(op==6){\n            int v;cin>>v;\n            auto it=bbt.find(v);\n            if(it!=bbt.end() &&(++it)!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }\n    }\n    return 0;\n}\n\n```","tags":["splay"]}]