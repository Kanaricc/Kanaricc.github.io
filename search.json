[{"title":"ä¸€äº›ç­›æ³•çš„é¢˜","url":"%2F2019%2F09%2F05%2Fsome-sieves%2F","content":"\n\n## æŠ€å·§\n\n### è‡ªç„¶æº¢å‡º\n\n* è‡ªç„¶æº¢å‡ºä¸ä¼šå½±å“ä½ä½æ•°æ®,æ‰€ä»¥æœ‰çš„æ—¶å€™ä½ ä¸éœ€è¦å–æ¨¡,è€Œæ˜¯ä¸€ä¸ªunsigned.\n\n### é™¤æ³•å–æ¨¡\nå¯¹äºå¼å­\n\n$$\n\\frac {a \\times b}{c} \\mod p \\equiv \\frac{a \\times b \\mod cp}{c}\n$$\n\n\n\n## ç»†èŠ‚\n* æ³¨æ„æ•°æ®ç±»å‹,ä¾‹å¦‚`6*(ll)(1<<30)`æ˜¯è¦å‡ºé—®é¢˜çš„\n* æ³¨æ„å‡½æ•°åœ¨$f(1)$ä½ç½®çš„å–å€¼,ä¸è¦å¿˜è®°åˆå§‹åŒ–\n\n## Divisor\n\nGiven $n$ and $m$ ($1 \\leq n,m \\leq 5 \\times 10^4$),  please calculate\n\n<!--more-->\n\n### åˆ†æ\nä¸‹é¢æ‰€æœ‰çš„é™¤æ³•éƒ½æ˜¯èˆå»å°æ•°çš„æ•´é™¤.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) &= \\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}[p \\perp q] \\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d|(p,q)}\\mu(d) \\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d}\\mu(d)[d|p][d|q] \\\\\n&=\\sum_d \\mu(d)\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{pd} \\sum_{qd}[pd|i][qd|j] \\\\\n&=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd}\\sum_{i=1}^{n/pd}\\sum_{j=1}^{m/qd} \\\\\n&=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd} \\frac n {pd}\\frac m {qd} \\\\\n&=\\sum_d \\mu(d) \\sum_p^{n/d} \\frac n {pd} \\sum_q^{m/d} \\frac m {qd} \\\\\n\\end{aligned}\n$$\n\nè®¾$S(n)=\\sum_{1\\leq i \\leq n} \\frac n i$\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) &=\\sum_d \\mu(d)S(n/d)S(m/d)\n\\end{aligned}\n$$\n\n$n/d$çš„å–å€¼åœ¨ä¸€ä¸ªåŒºé—´ä¸­æ˜¯ç›¸åŒçš„,å› æ­¤å¯ä»¥æŠŠè¿™ä¸ªæ±‚å’Œå…¬å¼åˆ†å—è®¡ç®—.(åœ¨åˆ†å—å,éœ€è¦è·çŸ¥è¯¥æ®µåŒºåŸŸå†…$\\mu$çš„å’Œ,æ‰€ä»¥éœ€è¦æ±‚å‰ç¼€å’Œ)ç”±äº$n/d$çš„å–å€¼ä¸º$O(\\sqrt n)$çš„çº§åˆ«,å› æ­¤åœ¨çŸ¥é“$S$çš„å€¼çš„æƒ…å†µä¸‹,æ¯ä¸ªè¯¢é—®å¯ä»¥è¿™ä¸ªå¤æ‚åº¦ä¸­è®¡ç®—å‡ºæ¥.\n\nå¯¹äº$\\mu$,ä½¿ç”¨ç­›æ³•,å¹¶æ±‚å‡ºå…¶å‰ç¼€å’Œ.\n\nå¯¹äº$S$,ç›´æ¥æš´åŠ›è®¡ç®—.\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50010;\n\nbool isn_p[MAXN];\nvector<int> primes;\nint mu[MAXN];\nint premu[MAXN];\nvoid init_prime(int len){\n    isn_p[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=len;i++){\n        if(!isn_p[i]){\n            primes.push_back(i);\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=len;j++){\n            isn_p[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n    premu[0]=0;\n    for(int i=1;i<=len;i++)premu[i]=premu[i-1]+mu[i];\n}\n\n\nll S[MAXN];\nvoid init_S(int len){\n    for(int i=1;i<=len;i++){\n        for(int l=1,r;l<=i;l=r+1){\n\t        //remember this line\n            r=i/(i/l);\n            S[i]+=(ll)(r-l+1)*(i/l);\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    init_prime(50000);\n    init_S(50000);\n    int kase;cin>>kase;\n    while(kase--){\n        int n,m;cin>>n>>m;\n        ll ans=0;\n        // the minimum one will fastly approach to 0, leading the extra parts of bigger one do nothing to the answer.\n        int minn=min(n,m);\n        for(int l=1,r;l<=minn;l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ans+=S[n/l]*S[m/l]*(premu[r]-premu[l-1]);\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n```\n\n## table\nç»™å‡ºå¤šç»„$n,m,a$,æ±‚\n\n$$\n\\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j))[\\sigma_1((i,j)) \\geq a]\n$$\n\n### åˆ†æ\n> è¿™é“é¢˜è®©è°éƒ½èƒ½çœ‹å‡ºæ¥é‡ç‚¹æ˜¯å¦‚ä½•å¤„ç†æ¡ä»¶\n>\n> $$[\\sigma_1((i,j)) \\geq a]$$\n\nå¯æ˜¯è¿™æˆ‘æ˜¾ç„¶ä¸çŸ¥é“è¯¥æ€ä¹ˆåš.\n\nå¯¹è¯¢é—®ä½œä»¥$a$ä»å°åˆ°å¤§ç¦»çº¿å¤„ç†,è¯¢é—®å‰å…ˆå¤„ç†æ–°å¢$a$çš„å½±å“.\n\nåœ¨å·²ç»æ»¡è¶³æ¡ä»¶çš„å‰æä¸‹å¯¹å…¬å¼ä½œåŒ–ç®€.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j)) &= \\sum_d \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1(d)[(i,j)=d] \\\\\n&=\\sum_d \\sum_{i\\leq \\frac nd}\\sum_{j\\leq \\frac md}\\sigma_1(d)[(i,j)=1] \\\\\n&=\\sum_d \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}}\\sigma_1(d) \\sum_t \\mu(t) \\\\\n&=\\sum_d \\sum_t \\mu(t) \\sigma_1(d)  \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}} 1 \\\\\n&=\\sum_T \\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor \\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)\n\\end{aligned}\n$$\n\nå¯ä»¥çœ‹åˆ°è¿˜æ˜¯å¥—è·¯,å¼•å…¥d,å¼•å…¥$\\mu$,ä¹‹åèƒ¡ä¹±åŒ–ç®€.\n\næŒ‰ç…§è¿™ä¸ªå¼å­,éœ€è¦è®¡ç®—çš„å°±æ˜¯$g(x)=\\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)$çš„å‰ç¼€å’Œ.\n\næ¥ä¸‹æ¥æ˜¯å¦‚ä½•å¤„ç†æ¡ä»¶...\n\nå½“$a$æ¯æ‰©å¤§ä¸€ç‚¹,å°±æœ‰ä¸€éƒ¨åˆ†$\\mu(t)\\sigma_1(\\frac Td)$è¢«åŠ å…¥åˆ°å‡½æ•°$g$çš„å„ä¸ªéƒ¨åˆ†.ä½¿ç”¨ä¸€ç§æ•°æ®ç»“æ„æ¥ç»´æŠ¤$g$çš„å‰ç¼€å’Œ,ä¾‹å¦‚æ ‘çŠ¶æ•°ç»„.$a$æœ€å¤§åˆ°,æ¯æ¬¡å—åˆ°å½±å“çš„å°±æ˜¯$d$çš„å€æ•°,ä»¥æ­¤å¯ä»¥è®¡ç®—å‡ºæ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º\n\n$$\nWTF\n$$\n\nè‡³æ­¤,é—®é¢˜å°±è§£å†³äº†.\n\n### ä»£ç \nåˆä¸‘åˆé•¿.\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cassert>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=100010;\nconst int MAXQ=100010;\nconst int MAXFT=400010;\nconst ll P=(ll)1<<31;\n\n\nll FT[MAXFT];\nll lowbit(int x){\n    return x&-x;\n}\nvoid ftadd(int pos,ll x){\n    for(int i=pos;i<MAXN;i+=lowbit(i)){\n        FT[i]=(FT[i]+x);\n    }\n}\nll ftget(int pos){\n    ll res=0;\n    for(int i=pos;i;i-=lowbit(i)){\n        res=(res+FT[i]);\n    }\n    return res;\n}\n\nll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(b;b;b>>=1,a=(a*a)%p){\n        if(b&1)res=(res*a)%p;\n    }\n    return res;\n}\nll qpow(ll a,ll b){\n    ll res=1;\n    for(b;b;b>>=1,a=(a*a)){\n        if(b&1)res=(res*a);\n    }\n    return res;\n}\n\nbool is_np[MAXN];\nll sigma[MAXN],mu[MAXN];\nint t[MAXN];\nvector<int> primes;\nstruct Sig{\n    ll sigma;\n    int x;\n    Sig(){}\n    Sig(int x,ll sigma):x(x),sigma(sigma){}\n};\nvector<Sig> sigma_vec;\n\nvoid init(int n){\n    is_np[1]=1;\n    sigma[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=n;i++){\n        if(!is_np[i]){\n            primes.push_back(i);\n            sigma[i]=i+1;\n            t[i]=1;\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            is_np[i*primes[j]]=1;\n            sigma[i*primes[j]]=sigma[i]*sigma[primes[j]];\n            t[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                t[i*primes[j]]=t[i]+1;\n                sigma[i*primes[j]]=sigma[i/qpow(primes[j],t[i])]*((ll)1-qpow(primes[j],(t[i]+1)+1))/(1-primes[j]);\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++){\n        sigma_vec.push_back(Sig(i,sigma[i]));\n    }\n}\n\nstruct Q{\n    int n,m,a;\n    int i;\n    ll ans;\n    bool operator<(const Q &b)const{\n        return a<b.a;\n    }\n} qs[MAXQ];\n\nll f(int n){\n    return ftget(n);\n}\n\nint curidx=0;\nvoid mergea(int newa){\n    for(;curidx<sigma_vec.size();curidx++){\n        Sig &sig=sigma_vec[curidx];\n        if(sig.sigma>newa)break;\n        for(int i=sig.x;i<MAXN;i+=sig.x){\n            ftadd(i,mu[i/sig.x]*sig.sigma%P);\n        }\n    }\n}\n\nint main(){\n    init(100000);\n    sort(sigma_vec.begin(),sigma_vec.end(),[](Sig &a,Sig &b){\n        return a.sigma<b.sigma;\n    });\n\n    int qlen;cin>>qlen;\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        scanf(\"%d%d%d\",&q.n,&q.m,&q.a);\n        q.i=i;\n    }\n    sort(qs,qs+qlen,[](Q &a,Q &b){\n        return a.a<b.a;\n    });\n\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        int n=q.n,m=q.m,a=q.a;\n        ll &ans=q.ans=0;\n        mergea(a);\n        for(int l=1,r;l<=min(n,m);l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ans=ans+(n/l)*(m/l)*(f(r)-f(l-1));\n        }\n        \n    }\n    sort(qs,qs+qlen,[](Q &a,Q &b){\n        return a.i<b.i;\n    });\n    for(int i=0;i<qlen;i++){\n        printf(\"%lld\\n\",qs[i].ans%P);\n    }\n    return 0;\n}\n```\n\n## product\nå®šä¹‰æ–æ³¢çº³å¦¾(?)(linuxè¿™è¾“å…¥æ³•å¤Ÿé­”æ€§)å‡½æ•°$f(x)$\n\næ±‚\n\n$$\n\\prod_{i=1}^n \\prod_{j=1}^m f((i,j))\n$$\n\n### åˆ†æ\né¦–å…ˆ,å…ˆå¼•ä¸ª$d$æ˜¯æ²¡é”™äº†.\n\nä½†æ˜¯\n\nè¿™é“é¢˜,æˆ‘åˆä¸ä¼š.æˆ‘ä¸çŸ¥é“è¯¥æ€ä¹ˆå¤„ç†$\\prod$...è”¡å°±å®Œäº‹äº†.\n\nç°åœ¨æ¥çœ‹,å½“å¼•å…¥ä¸€ä¸ª$d$å,åœ¨è¯¥æ±‚ç§¯å…¬å¼é‡Œå‡ºç°äº†ç›¸åŒé¡¹ç›¸ä¹˜.å°†è¯¥éƒ¨åˆ†çš„è®¡ç®—è°ƒæ•´ä¸ºå¹‚,å‰©ä¸‹çš„å°±åˆéƒ½ä¸€æ ·äº†.\n\n$$\n\\begin{aligned}\n\\prod_{i=1}^n \\prod_{j=1}^m f((i,j)) &= \\prod_d f(d)^{\\sum_{i\\leq n} \\sum_{j \\leq m} [(i,j)=d]} \\\\\n&=\\prod_d f(d)^{\\sum_{i\\leq \\frac nd} \\sum_{j \\leq \\frac md} [(i,j)=1]} \\\\\n&=\\prod_d f(d)^{\\sum_t \\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\\n&=\\prod_d \\prod_t f(d)^{\\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\\n&=\\prod_T (\\prod_{d|T}  f(d)^{\\mu(\\frac Tt)})^{\\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor }\n\\end{aligned}\n$$\n\nè®¾$g(x)=\\prod_{d|T}  f(d)^{\\mu(\\frac Tt)}$,æ±‚å‰ç¼€å’Œå°±å®Œäº‹äº†.\n\n> è¿™é“é¢˜éœ€è¦ä½¿ç”¨**æ¬§æ‹‰å®šç†**æ¥ä¼˜åŒ–æ±‚å¹‚çš„é€Ÿåº¦.\n\n### æ¬§æ‹‰å®šç†\nå½“$(a,p)=1$,æœ‰ä»¥ä¸‹å¼å­\n\n$$\na^b \\equiv a^{b \\mod \\phi(p)} \\pmod p\n$$\n\nå½“$(a,p)\\neq 1$,æœ‰æ‰©å±•æ¬§æ‹‰å®šç†\n\n$$\na^b \\equiv a^{b \\mod \\phi(p)+ \\phi(p)} \\pmod p\n$$\n\næ ¹æ®è¿™2ä¸ªå¼å­,å¯ä»¥åœ¨å¿«é€Ÿé™å¹‚,æ¥åŠ å¿«è¿ç®—.\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=1000010;\nconst ll P=1e9+7;\n\ninline ll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(;b;b>>=1,a=a*a%p){\n        if(b&1)res=res*a%p;\n    }\n    return res;\n}\n\ninline ll get_inv(ll a,ll p){\n    return qpow(a,p-2,p);\n}\n\nbool is_np[MAXN];\nvector<int> primes;\nll f[MAXN], g[MAXN];\nll inv_f[MAXN];\nll preg[MAXN],inv_pg[MAXN];\nll mu[MAXN];\nvoid init(int n){\n    is_np[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=n;i++){\n        if(!is_np[i]){\n            primes.push_back(i);\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            is_np[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n\n    f[1]=f[2]=1;\n    for(int i=3;i<=n;i++){\n        f[i]=(f[i-1]+f[i-2])%P;\n    }\n    for(int i=1;i<=n;i++){\n        inv_f[i]=get_inv(f[i],P);\n    }\n\n    for(int i=1;i<=n;i++)g[i]=1;\n    for(int i=1;i<=n;i++){\n        for(int j=i;j<=n;j+=i){\n            if(mu[j/i]==-1)g[j]=(g[j]*inv_f[i])%P;\n            else if(mu[j/i]==1)g[j]=(g[j]*f[i])%P;\n            //when mu==0,nothing happens\n        }\n    }\n    preg[0]=1;\n    for(int i=1;i<=n;i++)preg[i]=preg[i-1]*g[i]%P;\n    inv_pg[0]=1;\n    for(int i=1;i<=n;i++)inv_pg[i]=get_inv(preg[i],P)%P;\n}\n\nint main(){\n    init(1000000);\n    //cout<<\"done\"<<endl;\n    /*\n    \n    for(auto i:primes){\n        cout<<i<<\" \";\n    }\n    cout<<endl;\n    \n    for(int i=1;i<=20;i++){\n        cout<<g[i]<<\" \";\n    }\n    cout<<endl;\n    */\n    \n\n    int kase;\n    scanf(\"%d\",&kase);\n    while(kase--){\n        ll n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(n>m)swap(n,m);\n\n        ll ans=1;\n        for(ll l=1,r;l<=n;l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ll sum=preg[r]*inv_pg[l-1]%P;\n            ans=ans*qpow(sum,(n/l)*(m/l)%(P-1),P)%P;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n## phi3\nç»™å‡º$n$,æ±‚\n\n$$\n(\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n \\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)} \\phi((i,j,k))) \\mod 2^{30}\n$$\n\n### åˆ†æ\nè¿™é“é¢˜é‡ç‚¹åœ¨äº\n\n$$\\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)}$$\n\nè¿™å †ä¸œè¥¿çš„åŒ–ç®€.å¾ˆæ˜¾ç„¶,æˆ‘åˆä¸ä¼š.\n\nè§‚å¯Ÿ$\\phi(n)$çš„å…¬å¼\n\n$$\n\\phi(n)=n\\prod_i(1-\\frac 1{\\phi(i)})\n$$\n\nå¯ä»¥å¾—å‡ºä¸Šé¢é‚£ä¸€å †ç­‰äº$jk^2$.å‰©ä¸‹çš„å°±åˆéƒ½ä¸€æ ·äº†.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi((i,j,k)) &=\\sum_d\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi(d)[(i,j,k)=d] \\\\\n&=\\sum_d \\sum_{t} \\phi(d) \\mu(t) t^3d^3 \\sum_{i\\leq \\frac n{td}}\\sum_{j \\leq \\frac n{td}}\\sum_{k \\leq \\frac n{td}} jk^2 \\\\\n&=\\sum_T \\sum_{i\\leq \\frac nT}\\sum_{j \\leq \\frac nT} j\\sum_{k \\leq \\frac nT}k^2 (T^3 \\sum_{d|T} \\phi(d) \\mu(\\frac Td))\n\\end{aligned} \n$$\n\nè®¾$g(n)=\\sum_{d|T} \\phi(d) \\mu(\\frac Td)$,ç›´æ¥ç­›.æœ€åè®¡ç®—å‰ç¼€å’Œçš„æ—¶å€™å†ä¹˜ä¸Š$n^3$å°±å¯ä»¥äº†.\n\n> è¿™é“é¢˜çš„å–æ¨¡è¿˜æœ‰è¿™ç§å¤„ç†æ–¹æ³•: ç›´æ¥å–æ•°ç»„ä¸º`unsigned`å¹¶è‡ªç„¶æº¢å‡º.**äºŒè¿›åˆ¶å30ä½**ä¸ä¼šå—åˆ°å½±å“.\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\nusing ull=unsigned long long;\nusing ll=long long;\nconst int MAXN=10000010;\nconst unsigned P=1<<30;\n\nbool isnp[MAXN];\nvector<int> primes;\nint t[MAXN],M[MAXN];\nunsigned Mt[MAXN];\nunsigned g[MAXN];\nll preg[MAXN];\n\nvoid init(int n){\n    isnp[1]=1;\n    g[1]=1;\n\n    for(int i=2;i<=n;i++){\n        if(!isnp[i]){\n            primes.push_back(i);\n            g[i]=i-1-1;\n\n            t[i]=1;\n            M[i]=Mt[i]=i;\n        }\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            int newone=i*primes[j];\n            isnp[newone]=1;\n            g[newone]=g[i]*g[primes[j]]%P;\n            t[newone]=1;\n            M[newone]=Mt[newone]=primes[j];\n            if(i%primes[j]==0){\n                t[newone]=t[i]+1;\n                Mt[newone]=Mt[i]*primes[j]%P;\n                \n                g[newone]=g[i/Mt[i]]*(Mt[newone]+Mt[i]/primes[j]-2*Mt[i])%P;\n                break;\n            }\n        }\n    }\n\n    for(int i=1;i<=n;i++){\n        preg[i]=preg[i-1]+(ll)i*i%P*i%P*g[i]%P;\n        preg[i]%=P;\n    }\n}\n\nint main(){\n    init(10000000);\n\n    int kase;\n    scanf(\"%d\",&kase);\n    while(kase--){\n        int n;\n        scanf(\"%d\",&n);\n        ll ans=0;\n        for(int l=1,r;l<=n;l=r+1){\n            r=n/(n/l);\n            ull lim=n/l;\n            ull sum1=lim*(lim+1)%(2*P)/2;\n            ull sum2=lim*(lim+1)%(6*P)*(2*lim+1)%(6*P)/6;\n            ans=ans+lim*sum1%P*sum2%P*(preg[r]-preg[l-1])%P;\n        }\n        printf(\"%lld\\n\",ans%P);\n    }\n    return 0;\n}\n```","tags":["ç­›æ³•"]},{"title":"[HDU 6704] Kth Occurrence","url":"%2F2019%2F08%2F25%2Fproblem-kth-occurrence%2F","content":"\n\nYou are given a string S consisting of only lowercase english letters and some queries.\n\nFor each query (l,r,k), please output the starting position of the k-th occurence of the substring SlSl+1...Sr in S.\n\n## åˆ†æ\nç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯å¿«é€Ÿæ‰¾å‡ºæ‰€æœ‰å‡ºç°çš„å­ä¸²çš„ä½ç½®,å¯ä»¥ä½¿ç”¨åç¼€æ•°ç»„.è¿™äº›å­—ä¸²å‡ºç°åœ¨saçš„ä¸€ä¸ªè¿ç»­çš„åŒºé—´ä¸­.\n\n<!--more-->\n\nç¬¬äºŒä¸ªé—®é¢˜æ˜¯æ‰¾å‡ºè¿™äº›å‡ºç°ä½ç½®ä¸­çš„ç¬¬kå¤§,å¯ä»¥ä½¿ç”¨ä¸»å¸­æ ‘,ä»¥saå»ºæ ‘.\n\n\n## ä»£ç \næ€è·¯æ¸…æ™°,ä½†è¿™ä»£ç å®ƒä¸å¥½å†™\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\nconst int MAXN=100060;\nusing ull=unsigned long long;\n\nint n;\nint sa[MAXN], x[MAXN], c[MAXN], y[MAXN];\nchar a[MAXN];\n\ninline void SA()\n{\n    int m = 128;\n    for (int i = 0; i <= m; i++)\n        c[i] = 0;\n    for (int i = 1; i <= n; i++)\n        c[x[i]]++;\n    for (int i = 1; i <= m; i++)\n        c[i] += c[i - 1];\n    for (int i = n; i; i--)\n        sa[c[x[i]]--] = i;\n\n    for (int k = 1, p; k <= n; k <<= 1)\n    {\n        p = 0;\n        for (int i = n; i > n - k; i--)\n            y[++p] = i;\n        for (int i = 1; i <= n; i++)\n            if (sa[i] > k)\n                y[++p] = sa[i] - k;\n\n        for (int i = 0; i <= m; i++)\n            c[i] = 0;\n        for (int i = 1; i <= n; i++)\n            c[x[i]]++;\n        for (int i = 1; i <= m; i++)\n            c[i] += c[i - 1];\n        for (int i = n; i; i--)\n            sa[c[x[y[i]]]--] = y[i];\n\n        p = y[sa[1]] = 1;\n        for (int i = 2, a, b; i <= n; i++)\n        {\n            a = sa[i] + k > n ? -1 : x[sa[i] + k];\n            b = sa[i - 1] + k > n ? -1 : x[sa[i - 1] + k];\n            y[sa[i]] = (x[sa[i]] == x[sa[i - 1]]) && (a == b) ? p : ++p;\n        }\n        swap(x, y);\n        m = p;\n    }\n}\n\nint tot;\nint sum[(MAXN << 5) + 10], rt[MAXN + 10], ls[(MAXN << 5) + 10],\n    rs[(MAXN << 5) + 10];\n\nint build(int l, int r) //å»ºæ ‘\n{\n    int root = ++tot;\n    if (l == r)\n        return root;\n    int mid = l + r >> 1;\n    ls[root] = build(l, mid);\n    rs[root] = build(mid + 1, r);\n    return root; //è¿”å›è¯¥å­æ ‘çš„æ ¹èŠ‚ç‚¹\n}\nint update(int k, int l, int r, int root) //æ’å…¥æ“ä½œ\n{\n    int dir = ++tot;\n    ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + 1;\n    if (l == r)\n        return dir;\n    int mid = l + r >> 1;\n    if (k <= mid)\n        ls[dir] = update(k, l, mid, ls[dir]);\n    else\n        rs[dir] = update(k, mid + 1, r, rs[dir]);\n    return dir;\n}\n//left root, right root, querying l,r, the k-th\nint query(int u, int v, int l, int r, int k) //æŸ¥è¯¢æ“ä½œ\n{\n    int mid = l + r >> 1,\n        x = sum[ls[v]] - sum[ls[u]]; //é€šè¿‡åŒºé—´å‡æ³•å¾—åˆ°å·¦å„¿å­çš„ä¿¡æ¯\n    if (l == r){\n        return l;\n    }\n    if (k <= x) //è¯´æ˜åœ¨å·¦å„¿å­ä¸­\n        return query(ls[u], ls[v], l, mid, k);\n    else //è¯´æ˜åœ¨å³å„¿å­ä¸­\n        return query(rs[u], rs[v], mid + 1, r, k - x);\n}\n\nint height[MAXN];\nint st[20][MAXN];\ninline void get_height() {\n    int k = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (x[i] == 1) continue;\n        if (k) --k;\n        int j = sa[x[i] - 1];\n        while (j + k <= n && i + k <= n && a[i + k] == a[j + k]) ++k;\n        height[x[i]] = k;\n    }\n}\nvoid build_st() {\n    for (int i = 1; i <= n; i++) st[0][i] = height[i];\n    for (int k = 1; k <= 19; k++) {\n        for (int i = 1; i + (1 << k) - 1 <= n; i++) {\n            st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 << k - 1)]);\n        }\n    }\n}\nint lcp(int ll, int rr) {\n    int l = x[ll], r = x[rr];\n    if (l > r) swap(l, r);\n    if (l == r) return n - sa[l]+1;\n    int t = log2(r - l);\n    return min(st[t][l + 1], st[t][r - (1 << t) + 1]);\n}\n\nint main(){\n    int kase;cin>>kase;\n    while(kase--){\n        int nlen,qlen;cin>>nlen>>qlen;\n        scanf(\"%s\",a+1);\n        for(int i=0;i<MAXN;i++)x[i]=a[i];\n        n=nlen;\n        SA();\n        n=nlen;\n\n        get_height();\n        build_st();\n        \n        /*\n        for(int i=1;i<=nlen;i++)cout<<sa[i]<<\" \";\n        cout<<endl;\n        for(int i=1;i<=nlen;i++)cout<<x[i]<<\" \";\n        cout<<endl;\n        */\n\n        tot=0;\n        memset(sum,0,sizeof(sum));\n        rt[0] = build(1, nlen);\n        for (int i = 1; i <= n; ++i)\n            rt[i] = update(sa[i], 1, nlen, rt[i - 1]);\n\n        while(qlen--){\n            int ql,qr,qk;\n            scanf(\"%d%d%d\",&ql,&qr,&qk);\n            int sublen=qr-ql+1;\n\n            int ex_l,ex_r;\n            //binary search\n            {\n                int l=1,r=x[ql];\n                while(r-l>1){\n                    int mid=(l+r)/2;\n                    if(lcp(sa[mid], ql) >= sublen){\n                        r=mid;\n                    }else l=mid+1;\n                }\n                for(l;l<=r;l++){\n                    if(lcp(sa[l], ql) >= sublen){\n                        ex_l=l;\n                        break;\n                    }\n                }\n            }\n            {\n                int l=x[ql],r=nlen;\n                while(r-l>1){\n                    int mid=(l+r)/2;\n                    if(lcp(sa[mid], ql) >= sublen){\n                        l=mid;\n                    }else r=mid-1;\n                }\n                for(r;r>=l;r--){\n                    if(lcp(sa[r], ql) >= sublen){\n                        ex_r=r;\n                        break;\n                    }\n                }\n            }\n            //cout<<ex_l<<\" \"<<ex_r<<endl;\n            if(ex_r-ex_l+1<qk){\n                cout<<-1<<endl;\n            } else cout<<query(rt[ex_l - 1], rt[ex_r], 1, nlen, qk)<<endl;\n        }\n    }\n\n    return 0;\n}\n```\n\n\n","tags":["RMQ"],"categories":["coding"]},{"title":"è®°ä¸€ä¸ªbug (HDU 6703)","url":"%2F2019%2F08%2F24%2Fa-wonderful-bug%2F","content":"\nYou are given an array a1,a2,...,an(âˆ€iâˆˆ[1,n],1â‰¤aiâ‰¤n). Initially, each element of the array is **unique**. \n\nMoreover, there are m instructions. \n\nEach instruction is in one of the following two formats: \n\n1. (1,pos),indicating to change the value of apos to apos+10,000,000; \n2. (2,r,k),indicating to ask the minimum value which is **not equal** to any ai ( 1â‰¤iâ‰¤r ) and **not less ** than k. \n\nPlease print all results of the instructions in format 2. \n\n## åˆ†æ\nè¿™é¢˜å¼ºåˆ¶åœ¨çº¿.é¦–å…ˆ1æ“ä½œç›¸å½“äºåˆ é™¤äº†è¿™ä¸ªæ•°.\n\ndalaoè‡ªé—­äº†ä¸€ä¼šgetåˆ°äº†å®ƒçš„æ­£ç¡®åšæ³•,æˆ‘å°±ç›´æ¥æ‹¿æ¥ç”¨äº†.\n\nç»´æŠ¤ä¸€æƒå€¼çº¿æ®µæ ‘,ä½ç½®iå­˜å…¶åœ¨aä¸­å‡ºç°çš„ä½ç½®.é‚£ä¹ˆå½“1åˆ°råŒºé—´å†…å‡ºç°ä½ç½®çš„æœ€å¤§å€¼è¶…è¿‡äº†r,æ ¹æ®é¸½å·¢åŸç†,è‡³å°‘æœ‰ä¸€ä¸ªæ•°æœªè¢«é™åˆ¶.\n\nåŠ ä¸Šä¸å°äºkçš„æ¡ä»¶,å°±æ˜¯kåˆ°rä¸­,æ‰¾åˆ°æœ€å°çš„ä¸€ä¸ªr,ä½¿å¾—å®ƒæ»¡è¶³ä¸Šé¢çš„æ¡ä»¶,è¾“å‡ºè¿™ä¸ªr.\n\n## ä»£ç \nä¸€ä¸ªå¥‡è‘©çš„bug...\n\nå½“ä½¿ç”¨äº†freadè¿™ç§å…ˆè¯»å®Œç¼“å†²åŒºå†å¤„ç†çš„å¿«é€Ÿè¯»å…¥è€Œåˆ æ¼äº†cinæ—¶...ä¼šæ˜¾è€Œæ˜“è§çš„é‡åˆ°bug.\n\nä½†æ˜¯,å› ä¸ºç¼“å†²åŒºçš„å­˜åœ¨,**å°èŒƒå›´æ•°æ®è¢«å¿«ä¹çš„è¯»å…¥äº†ç¼“å†²åŒº,cinå¹¶ä¸ä¼šå®é™…å½±å“ä»€ä¹ˆ**.ä¸€æ—¦é‡åˆ°å¤§èŒƒå›´æ•°æ®,cinæå‰è¯»å…¥äº†æ¥ä¸‹æ¥çš„æ•°æ®,å¯¼è‡´ç¬¬ä¸€ä¸ªç¼“å†²åŒºä¹‹å¤–çš„æ•°æ®å…¨éƒ¨å‡ºé”™...\n\nè‰¹.\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst int MAXN = 400000;\n\nnamespace IO\n{\nconst int MAXSIZE = 1 << 20;\nchar buf[MAXSIZE], *p1, *p2;\n#define gc()                                                                 \\\n    (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\\n         ? EOF                                                               \\\n         : *p1++)\ninline int rd()\n{\n    int x = 0, f = 1;\n    char c = gc();\n    while (!isdigit(c))\n    {\n        if (c == '-')\n            f = -1;\n        c = gc();\n    }\n    while (isdigit(c))\n        x = x * 10 + (c ^ 48), c = gc();\n    return x * f;\n}\nchar pbuf[1 << 20], *pp = pbuf;\ninline void push(const char &c)\n{\n    if (pp - pbuf == 1 << 20)\n        fwrite(pbuf, 1, 1 << 20, stdout), pp = pbuf;\n    *pp++ = c;\n}\ninline void write(int x)\n{\n    static int sta[35];\n    int top = 0;\n    do\n    {\n        sta[top++] = x % 10, x /= 10;\n    } while (x);\n    while (top)\n        push(sta[--top] + '0');\n}\n} // namespace IO\n///////////////////////////////////////////////////////////////////////////////////////\n\nint dat[MAXN];\nint a[MAXN];\nint lc[MAXN], rc[MAXN], idx = 0;\n\ninline int imax(int a,int b){\n    if(a>b)return a;\n    return b;\n}\nvoid collect(int n)\n{\n    dat[n] = max(dat[lc[n]], dat[rc[n]]);\n}\n\nint build(int &n, int l, int r)\n{\n    if (!n)\n        n = ++idx;\n    dat[n] = a[l];\n    if (l == r)\n        return dat[n];\n    int mid = (l + r) / 2;\n    return dat[n] = imax(build(lc[n], l, mid), build(rc[n], mid + 1, r));\n}\n\nvoid modify(int x, int l, int r, int L, int R, int n)\n{\n    if (l <= L && R <= r)\n    {\n        dat[n] = x;\n        return;\n    }\n    int mid = (L + R) / 2;\n    if (l <= mid)\n        modify(x, l, r, L, mid, lc[n]);\n    if (mid < r)\n        modify(x, l, r, mid + 1, R, rc[n]);\n\n    collect(n);\n}\n\nint query(int l, int r,int target, int L, int R, int n)\n{\n    if(L>r || R<l || dat[n]<=target)return -1;\n    if(L==R)return L;\n\n    int mid = (L + R) / 2;\n    int res=query(l,r,target,L,mid,lc[n]);\n    return ~res?res:query(l,r,target,mid+1,R,rc[n]);\n}\nint root;\nint num[MAXN];\nint main()\n{\n    int kase=IO::rd();\n    while (kase--)\n    {\n        int nlen, qlen;\n        nlen=IO::rd();\n        qlen=IO::rd();\n        for (int i = 1; i <= nlen; i++)\n        {\n            num[i] = IO::rd();\n            a[num[i]] = i;\n        }\n        build(root, 1, nlen);\n        int lastans = 0;\n        while (qlen--)\n        {\n            int opt=IO::rd();\n            if (opt == 1)\n            {\n                int pos=IO::rd();\n                pos ^= lastans;\n                if(num[pos]==0 || num[pos]>nlen)continue;\n                modify(0x3f3f3f3f, num[pos], num[pos], 1, nlen, root);\n            }\n            else\n            {\n                int t2, t3;\n                t2=IO::rd();\n                t3=IO::rd();\n                //cin >> t2 >> t3;\n                int r = t2 ^ lastans, k = t3 ^ lastans;\n\n                int t=query(k,nlen,r,1,nlen,root);\n                cout<<(lastans=(~t?t:nlen+1))<<endl;\n            }\n        }\n    }\n    return 0;\n}\n```","tags":["çº¿æ®µæ ‘"],"categories":["coding"]},{"title":"OJçš„åç«¯","url":"%2F2019%2F08%2F22%2Fsandbox-reef%2F","content":"\nå†…å®¹æœ‰å¤åˆ¶å’Œå‚è€ƒã€‚\n\nè¿™ç¯‡æ–‡ç« ä¸»è¦ç”¨äºè®°å½•åœ¨æ¢ç´¢è¯„æµ‹ç³»ç»ŸReefæœŸé—´æˆ‘æ‰€å­¦çš„ä¸œè¥¿,ä»¥ä¾¿ä¹‹åæŸ¥é˜….\n\nReefé¢„è®¡ä¸»è¦æ”¯æŒè¿œç¨‹è¯„æµ‹\n\nåŠ ä¸€ç‚¹æœ¬åœ°è¯„æµ‹.....\n\n<!--more-->\n\nç»“æœä¸»è¦çš„ä¸œè¥¿éƒ½ç‰¹ä¹ˆæ˜¯æœ¬åœ°è¯„æµ‹çš„.\n\n## æ€»ä½“æ¶æ„\nReefé¢„è®¡å°†é‡‡ç”¨seccompä½œä¸ºç¬¬ä¸€é“å®‰å…¨å…³å¡,ä½¿ç”¨å¤šçº¿ç¨‹æ£€æµ‹ç¨‹åºè€—æ—¶/å†…å­˜ç­‰ä¿¡æ¯.\n\nåœ¨å¤–å±‚ä½¿ç”¨dockerå°è£…å¹¶å†æ¬¡é™åˆ¶èµ„æº,æ¥å…¥é˜Ÿåˆ—ä»¥èƒ½å¤Ÿæ–¹ä¾¿çš„æ¨ªå‘æ‰©å±•.\n\n## seccomp\nseccompä¸ºlinuxç³»ç»Ÿä¸Šæ‰æœ‰çš„å®‰å…¨æŠ€æœ¯,å› æ­¤å¿…é¡»ä½¿ç”¨linux.åœ¨å®‰è£…å¿…è¦çš„å®‰è£…åŒ…å\n\n```bash\n$ sudo apt install libseccomp2 libseccomp-dev seccomp\n```\n\nå³å¯ä½¿ç”¨.\n\nå½“ç„¶,åœ¨windowsä¸‹çš„Jobsä¼¼ä¹ä¹Ÿå¯ä»¥åˆ©ç”¨,ä½†æ˜¯æˆ‘ä¸å¤ªæ‡‚,å¾®è½¯æ–‡æ¡£å†™å¾—ä¹Ÿå¥‡æ€ª,è€Œä¸”è¿˜å¾—æ˜¯æœåŠ¡å™¨ç‰ˆæœ¬çš„windowsæ‰èƒ½ç”¨.\n\n### åŸºæœ¬ä½¿ç”¨\nseccompéœ€è¦ç”±ç¨‹åºä¸»åŠ¨åŠ è½½.å…¶ä½¿ç”¨æ–¹æ³•åŸºæœ¬ä¸ºä¸‹\n\n```cpp\n//g++ -g test.c -o o -lseccomp\n#include <unistd.h>\n#include <seccomp.h>\n#include <linux/seccomp.h>\n\nint main(void){\n\t//åˆå§‹åŒ–ç­›é€‰å™¨\n\tscmp_filter_ctx ctx;\n\tctx = seccomp_init(SCMP_ACT_ALLOW);//flagæŒ‡æ˜é»˜è®¤é€šè¿‡\n\t//æ·»åŠ æ‹¦æˆª,å¹¶æŒ‡æ˜ä¸€æ—¦æ‹¦æˆªå°±å°†ç¨‹åºkillæ‰.\n\tseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);\n\t//å°†è§„åˆ™åŠ è½½æ³¨å…¥.\n\tseccomp_load(ctx);\n\n\tchar * filename = \"/bin/sh\";\n\tchar * argv[] = {\"/bin/sh\",NULL};\n\tchar * envp[] = {NULL};\n\twrite(1,\"i will give you a shell\\n\",24);\n\t//ç¨‹åºå°†ä¼šåœ¨æ­¤è¡Œå´©æºƒ.\n\tsyscall(59,filename,argv,envp);//execve\n\treturn 0;\n}\n```\n\nseccomp_initæ˜¯åˆå§‹åŒ–çš„è¿‡æ»¤çŠ¶æ€,è¿™é‡Œç”¨çš„æ˜¯SCMP_ACT_ALLOW,è¡¨ç¤ºé»˜è®¤å…è®¸æ‰€æœ‰çš„syscacll.å¦‚æœåˆå§‹åŒ–çŠ¶æ€ä¸ºSCMP_ACT_KILL,åˆ™è¡¨ç¤ºé»˜è®¤ä¸å…è®¸æ‰€æœ‰çš„syscall.\n\n```cpp\n/**\n * Kill the process\n */\n#define SCMP_ACT_KILL\t\t0x00000000U\n/**\n * Throw a SIGSYS signal\n */\n#define SCMP_ACT_TRAP\t\t0x00030000U\n/**\n * Return the specified error code\n */\n#define SCMP_ACT_ERRNO(x)\t(0x00050000U | ((x) & 0x0000ffffU))\n/**\n * Notify a tracing process with the specified value\n */\n#define SCMP_ACT_TRACE(x)\t(0x7ff00000U | ((x) & 0x0000ffffU))\n/**\n * Allow the syscall to be executed after the action has been logged\n */\n#define SCMP_ACT_LOG\t\t0x7ffc0000U\n/**\n * Allow the syscall to be executed\n */\n#define SCMP_ACT_ALLOW\t\t0x7fff0000U\n```\n\nè§„åˆ™æ·»åŠ \n```cpp\n/**\n * Add a new rule to the filter\n * @param ctx the filter context\n * @param action the filter action\n * @param syscall the syscall number\n * @param arg_cnt the number of argument filters in the argument filter chain\n * @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended)\n *\n * This function adds a series of new argument/value checks to the seccomp\n * filter for the given syscall; multiple argument/value checks can be\n * specified and they will be chained together (AND'd together) in the filter.\n * If the specified rule needs to be adjusted due to architecture specifics it\n * will be adjusted without notification.  Returns zero on success, negative\n * values on failure.\n *\n */\nint seccomp_rule_add(scmp_filter_ctx ctx,\n\t\t     uint32_t action, int syscall, unsigned int arg_cnt, ...);\n```\n\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);,arg_cntä¸º0,è¡¨ç¤ºç›´æ¥é™åˆ¶execve,ä¸ç®¡ä»–ä»€ä¹ˆå‚æ•°.\n\nå¦‚æœarg_cntä¸ä¸º0,é‚£arg_cntè¡¨ç¤ºåé¢é™åˆ¶çš„å‚æ•°çš„ä¸ªæ•°,ä¹Ÿå°±æ˜¯åªæœ‰è°ƒç”¨execve,ä¸”å‚æ•°æ»¡è¶³è¦æ±‚æ—¶,æ‰ä¼šæ‹¦æˆªsyscall.\n\n```\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write),1,SCMP_A2(SCMP_CMP_EQ,0x10));//ç¬¬2(ä»0)ä¸ªå‚æ•°ç­‰äº0x10\n```\n\n```cpp\n/**\n * Specify an argument comparison struct for use in declaring rules\n * @param arg the argument number, starting at 0\n * @param op the comparison operator, e.g. SCMP_CMP_*\n * @param datum_a dependent on comparison\n * @param datum_b dependent on comparison, optional\n */\n#define SCMP_CMP(...)\t\t((struct scmp_arg_cmp){__VA_ARGS__})\n\n/**\n * Specify an argument comparison struct for argument 0\n */\n#define SCMP_A0(...)\t\tSCMP_CMP(0, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 1\n */\n#define SCMP_A1(...)\t\tSCMP_CMP(1, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 2\n */\n#define SCMP_A2(...)\t\tSCMP_CMP(2, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 3\n */\n#define SCMP_A3(...)\t\tSCMP_CMP(3, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 4\n */\n#define SCMP_A4(...)\t\tSCMP_CMP(4, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 5\n */\n#define SCMP_A5(...)\t\tSCMP_CMP(5, __VA_ARGS__)\n\n\n\n/**\n * Comparison operators\n */\nenum scmp_compare {\n\t_SCMP_CMP_MIN = 0,\n\tSCMP_CMP_NE = 1,\t\t/**< not equal */\n\tSCMP_CMP_LT = 2,\t\t/**< less than */\n\tSCMP_CMP_LE = 3,\t\t/**< less than or equal */\n\tSCMP_CMP_EQ = 4,\t\t/**< equal */\n\tSCMP_CMP_GE = 5,\t\t/**< greater than or equal */\n\tSCMP_CMP_GT = 6,\t\t/**< greater than */\n\tSCMP_CMP_MASKED_EQ = 7,\t\t/**< masked equality */\n\t_SCMP_CMP_MAX,\n};\n\n/**\n * Argument datum\n */\ntypedef uint64_t scmp_datum_t;\n\n/**\n * Argument / Value comparison definition\n */\nstruct scmp_arg_cmp {\n\tunsigned int arg;\t/**< argument number, starting at 0 */\n\tenum scmp_compare op;\t/**< the comparison op, e.g. SCMP_CMP_* */\n\tscmp_datum_t datum_a;\n\tscmp_datum_t datum_b;\n};\n```\n\nctxçš„å†…å®¹å¯ä»¥ä½¿ç”¨å‡½æ•°dumpå‡ºæ¥,ä¹‹åå¯ä»¥ç›´æ¥ä½¿ç”¨prctlå‘½ä»¤ç›¸å…³ç›´æ¥è½½å…¥,æ–¹ä¾¿ä½¿ç”¨?\n\n### seccompè°ƒè¯•\n\nä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å¯¼å‡ºæ‰€æœ‰å¯èƒ½çš„å‘½ä»¤\n```bash\nfile=syscall-names.h\necho \"static const char *syscall_names[] = {\" > $file\necho \"#include <sys/syscall.h>\" | cpp -dM | grep '^#define __NR_' | LC_ALL=C sed -r -n -e 's/^\\#define[ \\t]+__NR_([a-z0-9_]+)[ \\t]+([0-9]+)(.*)/ [\\2] = \"\\1\",/p' >> $file\necho \"};\" >> $file\n```\n\nä½¿ç”¨å¦‚ä¸‹ä»£ç å¯¼å‡ºä¸€æ®µä»£ç æ‰€éœ€è¦çš„æƒé™.éµå¾ªæœ€å°æƒé™åŸåˆ™,è¯•éªŒä»£ç è¿è¡Œæ‰€éœ€è¦çš„æœ€å°‘æƒé™.\n```cpp\n#define __USE_GNU 1\n#define _GNU_SOURCE 1\n#include <signal.h>\n#include <sys/prctl.h>\n#include <linux/types.h>\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n#include <seccomp.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"syscall-names.h\"\n#if defined(__i386__)\n#define REG_RESULT\tREG_EAX\n#define REG_SYSCALL\tREG_EAX\n#define REG_ARG0\tREG_EBX\n#define REG_ARG1\tREG_ECX\n#define REG_ARG2\tREG_EDX\n#define REG_ARG3\tREG_ESI\n#define REG_ARG4\tREG_EDI\n#define REG_ARG5\tREG_EBP\n#elif defined(__x86_64__)\n#define REG_RESULT\tREG_RAX\n#define REG_SYSCALL\tREG_RAX\n#define REG_ARG0\tREG_RDI\n#define REG_ARG1\tREG_RSI\n#define REG_ARG2\tREG_RDX\n#define REG_ARG3\tREG_R10\n#define REG_ARG4\tREG_R8\n#define REG_ARG5\tREG_R9\n#endif\n#ifndef SYS_SECCOMP\n#define SYS_SECCOMP 1\n#endif\n\nconst char *const msg=\"system call invalid: \";\n\nstatic void write_uint(char *buf, unsigned int val)\n{\n    int width = 0;\n    unsigned int tens;\n    if (val == 0) {\n        strcpy(buf, \"0\");\n        return;\n    }\n    for (tens = val; tens; tens /= 10)\n        ++ width;\n    buf[width] = '\\0';\n    for (tens = val; tens; tens /= 10)\n        buf[--width] = (char) ('0' + (tens % 10));\n}\nstatic void helper(int nr, siginfo_t *info, void *void_context) {\n    char buf[255];\n    ucontext_t *ctx = (ucontext_t *)(void_context);\n    unsigned int syscall;\n    if (info->si_code != SYS_SECCOMP)\n        return;\n    if (!ctx)\n        return;\n    syscall = (unsigned int) ctx->uc_mcontext.gregs[REG_SYSCALL];\n    strcpy(buf, msg);\n    if (syscall < sizeof(syscall_names)) {\n        strcat(buf, syscall_names[syscall]);\n        strcat(buf, \"(\");\n    }\n    write_uint(buf + strlen(buf), syscall);\n    if (syscall < sizeof(syscall_names))\n        strcat(buf, \")\");\n    strcat(buf, \"\\n\");\n    write(STDOUT_FILENO, buf, strlen(buf));\n    _exit(1);\n}\nstatic int install_helper() {\n    struct sigaction act;\n    sigset_t mask;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGSYS);\n    act.sa_sigaction = &helper;\n    act.sa_flags = SA_SIGINFO;\n    if (sigaction(SIGSYS, &act, NULL) < 0) {\n        perror(\"sigaction\");\n        return -1;\n    }\n    if (sigprocmask(SIG_UNBLOCK, &mask, NULL)) {\n        perror(\"sigprocmask\");\n        return -1;\n    }\n    return 0;\n}\n\n#include <stdio.h>\nint main(){\n\tif(install_helper()){\n\t\tprintf(\"install helper failed\");\n\t\treturn 1;\n\t}\n\n\tscmp_filter_ctx ctx = NULL;\n\tctx = seccomp_init(SCMP_ACT_ALLOW);\n\n\tseccomp_rule_add(ctx, SCMP_ACT_TRAP, SCMP_SYS(execve), 0);\n\tseccomp_load(ctx);\n\tseccomp_release(ctx);\n\tfprintf(stdout, \"something to stdout\\n\");\n\tchar * filename = \"/bin/sh\";\n\tchar * argv[] = {\"/bin/sh\",NULL};\n\tchar * envp[] = {NULL};\n\twrite(1,\"i will give you a shell\\n\",24);\n\tsyscall(59,filename,argv,envp);//execve\n\n\treturn 0;\n}\n```\n\n### æ³¨å…¥ç¨‹åº\nåˆšåˆšæåˆ°äº†seccompå¿…é¡»ç”±ç¨‹åºä¸»åŠ¨åŠ è½½,å› æ­¤éœ€è¦æœ‰ä¸€ä¸ªåŠæ³•å°†ä»£ç æ³¨å…¥åˆ°ç”¨æˆ·çš„ä»£ç ä¸­.\n\n> ç­‰å¾…å®Œæˆ\n\n### å…¶ä»–è¯­è¨€\nè¿™ç©æ„è²Œä¼¼è‡³å°‘èƒ½æ–¹ä¾¿çš„ç”¨åœ¨cç³»è¯­è¨€,javaå’Œpythonä¸Š.\n\n## Docker\nå‡†å¤‡ä½¿ç”¨Dockeré‡æ„æ•´ä¸ªOJ\n\n### å¤šé˜¶æ®µæ„å»º\nä½¿ç”¨Docker,å°†OJåˆ†è§£ä¸ºå¤šä¸ªé˜¶æ®µæ¥æ„å»º.\n\n1. å‰ç«¯æ„å»º\n2. åç«¯æ„å»º\n3. è¿è¡Œç¯å¢ƒæ„å»ºä¸ä»£ç æ•´åˆ\n4. nginxæ„å»º\n\n#### å‘½ä»¤\n```Dockerfile\n#...\n\n# ä½¿ç”¨phpä½œä¸ºåŸºç¡€,æŒ‡æ˜è¯¥æ„å»ºé˜¶æ®µä¸ºcodeisland\nFROM php:alpine as codeisland\n# åœ¨å®¹å™¨æ‰“åŒ…é˜¶æ®µå®‰è£…æ•°æ®åº“é©±åŠ¨\nRUN docker-php-ext-install pdo pdo_pgsql\n\nARG PATH=/app/laravel\n\n# ä»å…¶ä»–é˜¶æ®µå¤åˆ¶ä»£ç åˆ°æœ¬é˜¶æ®µ\nCOPY --from=DELETED /app/ ${PATH}\n\n# æ‰§è¡Œå…¶ä»–åˆå§‹åŒ–å‘½ä»¤\n# [DELETED]\n\n# æŒ‡æ˜å®¹å™¨çš„å·¥ä½œè·¯å¾„\nWORKDIR ${PATH}\n\n#...\n```\n\n### å®¹å™¨åè°ƒ\nä½¿ç”¨Docker-composeæ¥åè°ƒå„ä¸ªå®¹å™¨çš„å…³ç³».\n\n* æ•°æ®åº“å®¹å™¨\n* rediså®¹å™¨\n* ç½‘ç«™åç«¯å®¹å™¨\n* è¯„æµ‹å™¨å®¹å™¨\n* è¯„æµ‹ä»£ç†å®¹å™¨\n* nginxå®¹å™¨\n\né™åˆ¶è¯„æµ‹å™¨å®¹å™¨çš„èµ„æºæ¶ˆè€—çš„ä¾‹å­\n\n```yml\ndeploy:\n  resources:\n    limits:\n      cpus: '0.50'\n      memory: 1024M\n```\n\n### ç½‘ç»œ\n...å­¦æ ¡ç½‘å…³çš„ç™»å½•çŠ¶æ€æ ¹æœ¬æ²¡æ³•ç»´æŒ,å¡æ­».\n","tags":["code island"],"categories":["é—²æ‰¯"]},{"title":"[FZU 2204]Seven","url":"%2F2019%2F08%2F10%2Fproblem-seven%2F","content":"\nnä¸ªæœ‰æ ‡å·çš„çƒå›´æˆä¸€ä¸ªåœˆã€‚æ¯ä¸ªçƒæœ‰ä¸¤ç§é¢œè‰²å¯ä»¥é€‰æ‹©é»‘æˆ–ç™½æŸ“è‰²ã€‚é—®æœ‰å¤šå°‘ç§æ–¹æ¡ˆä½¿å¾—æ²¡æœ‰å‡ºç°è¿ç»­ç™½çƒ7ä¸ªæˆ–è¿ç»­é»‘çƒ7ä¸ªã€‚\n\nå¯¹æ–¹æ¡ˆæ•°mod 2015ï¼Œçƒæœ€å¤šæœ‰100000ä¸ªã€‚\n\n# åˆ†æ\nè€ƒè™‘å¯¹äºéç¯çŠ¶çƒçš„ç­”æ¡ˆè®¡ç®—ï¼Œå¯ä»¥è®¾$sum(i,k)$è¡¨ç¤ºç¬¬iä¸ªçƒä¸ºkè‰²æ—¶çš„æ–¹æ¡ˆæ•°ã€‚å…¶è®¡ç®—éå¸¸æ˜¾ç„¶\n\n$$\nsum(i,k)=\\sum_{1\\leq j \\leq 6}{sum(i-j,1-k)}\n$$\n\næ¥ä¸‹æ¥è€ƒè™‘æ”¶å°¾ç›¸æ¥åéœ€è¦æ’é™¤çš„æƒ…å†µï¼Œå³æ”¶å°¾åŒè‰²çƒé•¿åº¦ç›¸åŠ è¶…è¿‡6çš„æƒ…å†µï¼Œè¿™å¯ä»¥ç›´æ¥æšä¸¾ã€‚\n\né¦–å–iä¸ªæœ«å–jä¸ªåŒè‰²ï¼Œä»ç­”æ¡ˆä¸­åˆ é™¤æ­¤æ—¶å‰©ä¸‹çƒçš„æ–¹æ¡ˆæ•°ï¼Œæ³¨æ„å‰©ä¸‹çš„çƒçš„é¦–æœ«çƒé¢œè‰²**ä¸èƒ½**å’Œå·²ç»æšä¸¾çš„é¢œè‰²åŒè‰²ã€‚é‰´äºè¿™ç§è¦æ±‚ï¼Œæˆ‘ä»¬é€€å›åˆ°sumçš„é€’æ¨å…¬å¼å¤„ï¼Œå†³å®šsumçš„è¾¹ç•Œæ¡ä»¶ä¸ºé¦–ä¸ªçƒå›ºå®šä¸ºé»‘è‰²ï¼Œè¿™æ ·å°±èƒ½å¾ˆæ–¹ä¾¿çš„ç¡®å®šçƒçš„é¢œè‰²ï¼Œä¸”æ ¹æ®å¯¹ç§°æ€§ç­”æ¡ˆå¯ä»¥ç›´æ¥x2å¾—åˆ°ã€‚\n\né¢˜å°±åšå®Œäº†ã€‚\n\n# ä»£ç \n> æ·¦ï¼Œä¸ºä»€ä¹ˆå½“æ—¶æ²¡å†™ã€‚\n\n```cpp\n#include <iostream>\nusing namespace std;\nconst int MAXN=100010;\nconst int P=2015;\n\nint sum[MAXN][2];\nint main(){\n    int kase;cin>>kase;\n    sum[0][1]=1;\n    for(int i=1;i<=100000;i++){\n        for(int j=1;j<=min(i,6);j++){\n            (sum[i][1]+=sum[i-j][0])%=P;\n            (sum[i][0]+=sum[i-j][1])%=P;\n        }\n    }\n    sum[0][1]=0;\n    int cnt=0;\n    while(kase--){\n        int nlen;cin>>nlen;\n        int ans=(sum[nlen][0]+sum[nlen][1])%P;\n        if(nlen>=7)\n            for(int i=1;i<=6;i++)\n                for(int j=1;j<=6;j++)\n                    if(i+j>=7 && nlen-i-j>=0)\n                        ans=(ans-sum[nlen-i-j][0])%P;\n        cout<<\"Case #\"<<++cnt<<\": \"<<((ans*2)%P+2015)%P<<endl;\n    }\n    return 0;\n}\n```\n","tags":["è®¡æ•°"],"categories":["coding"]},{"title":"[HDU6638] Snowy Smile","url":"%2F2019%2F08%2F07%2Fproblem-snowy-smile%2F","content":"\nThere are n pirate chests buried in Byteland, labeled by 1,2,â€¦,n. The i-th chest's location is (xi,yi), and its value is wi, wi can be negative since the pirate can add some poisonous gases into the chest. When you open the i-th pirate chest, you will get wi value.\n\nYou want to make money from these pirate chests. You can select a rectangle, the sides of which are all paralleled to the axes, and then all the chests inside it or on its border will be opened. Note that you must open all the chests within that range regardless of their values are positive or negative. But you can choose a rectangle with nothing in it to get a zero sum.\n\nPlease write a program to find the best rectangle with maximum total value.\n\nThe first line of the input contains an integer T(1â‰¤Tâ‰¤100), denoting the number of test cases.\n\nIn each test case, there is one integer n(1â‰¤nâ‰¤2000) in the first line, denoting the number of pirate chests.\n\nFor the next n lines, each line contains three integers xi,yi,wi(âˆ’109â‰¤xi,yi,wiâ‰¤109), denoting each pirate chest.\n\nIt is guaranteed that âˆ‘nâ‰¤10000.\n\n\n## åˆ†æ\né¦–å…ˆï¼Œæˆ‘æ²¡åšå‡ºæ¥ã€‚\n\n<!--more-->\n\nè¿™é“é¢˜å®é™…ä¸Šå°±æ˜¯åœ¨è¦æ±‚ä½ ç”¨å°äº$O(N^3)$çš„å¤æ‚åº¦æ±‚å‡ºæœ€å¤§å’Œå­çŸ©é˜µã€‚æ³¨æ„åˆ°è¯¥é¢˜çš„ç‚¹**ç¨€ç–**ï¼Œæ‰€ä»¥ä»¥ç‚¹ä¸ºè€ƒè™‘å¯¹è±¡ã€‚\n\nä¸‰æ–¹çš„åšæ³•ï¼Œæšä¸¾çŸ©é˜µçš„ä¸Šè¾¹ç•Œå’Œä¸‹è¾¹ç•Œï¼Œç»´æŠ¤çºµå‘ä¸Šçš„å’Œï¼Œæ±‚æœ€å¤§å­—æ®µå’Œã€‚å½“ä»¥ç‚¹è€ƒè™‘æ—¶ï¼Œä¸Šä¸‹è¾¹ç•Œå°±å¯ä»¥ç›´æ¥ç”±**æ’åºå**çš„ç‚¹å†³å®šã€‚ä¹‹åï¼Œä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤æœ€å¤§å­æ®µå’Œã€‚\n\n## ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconstexpr int MAXN=400010;\n\nll d_sub[MAXN],d_pre[MAXN],d_suf[MAXN];\nll d_sum[MAXN];\nint lc[MAXN],rc[MAXN];\nint idx=0;\nvoid build(int &n,int l,int r){\n    if(!n)n=++idx;\n    d_sum[n]=d_sub[n]=d_pre[n]=d_suf[n]=0;\n    if(l==r){\n        return;\n    }\n    int mid=(l+r)/2;\n    build(lc[n],l,mid);\n    build(rc[n],mid+1,r);\n    //combine data\n}\nvoid collect(int node){\n    d_sum[node]=d_sum[lc[node]]+d_sum[rc[node]];\n\n    d_pre[node]=max(d_pre[lc[node]],d_sum[lc[node]]+d_pre[rc[node]]);\n    d_suf[node]=max(d_suf[rc[node]],d_sum[rc[node]]+d_suf[lc[node]]);\n\n    d_sub[node]=max(max(d_sub[lc[node]],d_sub[rc[node]]),d_suf[lc[node]]+d_pre[rc[node]]);\n}\n\nvoid modify(int x,int l,int r,int L,int R,int node){\n    if(l<=L && R<=r){\n        //only single point to modify\n        d_sub[node]=d_sub[node]+x;\n        d_pre[node]=d_pre[node]+x;\n        d_suf[node]=d_suf[node]+x;\n        d_sum[node]+=x;\n        return;\n    }\n    int mid=(L+R)/2;\n    if(l<=mid)modify(x,l,r,L,mid,lc[node]);\n    if(mid<r)modify(x,l,r,mid+1,R,rc[node]);\n\n    collect(node);\n}\nint root;\nll query_all(){\n    return d_sub[root];\n}\n\nstruct Chest{\n    int x,y,v;\n    bool operator<(const Chest &other)const{\n        if(x==other.x)return y<other.y;\n        return x<other.x;\n    }\n} chests[MAXN];\n\nvector<int> refy;\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    while(kase--){\n        int nlen;cin>>nlen;\n        refy.clear();\n        for(int i=0;i<nlen;i++){\n            Chest &chest=chests[i];\n            cin>>chest.x>>chest.y>>chest.v;\n            refy.push_back(chest.y);\n        }\n        sort(chests,chests+nlen);\n\n        sort(refy.begin(),refy.end());\n        auto refyend=unique(refy.begin(),refy.end());\n        int maxy=0;\n        for(int i=0;i<nlen;i++){\n            chests[i].y=lower_bound(refy.begin(),refyend,chests[i].y)-refy.begin()+1;\n            maxy=max(maxy,chests[i].y);\n        }\n\n        int lastx=0;\n        ll ans=0;\n\n        for(int i=0;i<nlen;i++){\n            if(lastx==chests[i].x)continue;\n            lastx=chests[i].x;\n            //cout<<\"start from \"<<lastx<<endl;\n\n            build(root,1,maxy);\n            int nextx=chests[i].x;\n            for(int j=i;j<nlen;j++){\n                if(chests[j].x!=nextx){\n                    nextx=chests[j].x;\n                    ans=max(ans,query_all());\n                }\n                modify(chests[j].v,chests[j].y,chests[j].y,1,maxy,root);\n            }\n            ans=max(ans,query_all());\n        }\n        cout<<max(0ll,ans)<<endl;\n    }\n\n    return 0;\n}\n```\n\n\n","tags":["çº¿æ®µæ ‘"],"categories":["coding"]},{"title":"mo-s-algorithm","url":"%2F2019%2F08%2F03%2Fmo-s-algorithm%2F","content":"\nå¯¹äºå¯ä»¥ç¦»çº¿çš„åŒºé—´è¯¢é—®é—®é¢˜ï¼Œè«é˜Ÿç®—æ³•æå‡ºäº†ä¸€ç§å¯ä»¥åœ¨$O(n\\sqrt n)$(æ— ä¿®æ”¹)ï¼Œ$n^{3/5}$(å¸¦ä¿®æ”¹)å†…å¾—å‡ºç­”æ¡ˆçš„æ–¹æ³•ã€‚\n\nä¸»è¦çš„æ€è·¯æ˜¯å¯¹è¯¢é—®ç¦»çº¿å¹¶åˆ†å—ï¼Œåˆ©ç”¨åœ¨2ä¸ªåŒºé—´é—´ç­”æ¡ˆçš„**å¿«é€Ÿè½¬ç§»**ï¼ˆå¦‚æœæ— æ³•æ‰¾åˆ°å¿«é€Ÿè½¬ç§»çš„æ–¹æ³•ï¼Œå°±æ²¡æ³•ç”¨äº†ï¼‰é™ä½å¤æ‚åº¦ã€‚\n\n<!--more-->\n\n## æ— ä¿®æ”¹è«é˜Ÿ\nä»¥$B=\\sqrt{n}$ï¼ŒæŒ‰ç…§$(l/B,r)$å¯¹è¯¢é—®æ’åºã€‚\n\nä¹‹åæšä¸¾æ¯ä¸€ä¸ªè¯¢é—®ï¼Œå°†ç­”æ¡ˆåœ¨ç›¸é‚»è¯¢é—®åŒºé—´é—´æš´åŠ›çš„+1-1è½¬ç§»ã€‚\n\n### Problem: å°Yçš„è¢œå­\næ²¡æœ‰åœ¨é’ˆå¯¹å“ªä¸ªäººã€‚\n\nä½œä¸ºä¸€ä¸ªç”Ÿæ´»æ•£æ¼«çš„äººï¼Œå°Zæ¯å¤©æ—©ä¸Šéƒ½è¦è€—è´¹å¾ˆä¹…ä»ä¸€å †äº”é¢œå…­è‰²çš„è¢œå­ä¸­æ‰¾å‡ºä¸€åŒæ¥ç©¿ã€‚ç»ˆäºæœ‰ä¸€å¤©ï¼Œå°Zå†ä¹Ÿæ— æ³•å¿å—è¿™æ¼äººçš„æ‰¾è¢œå­è¿‡ç¨‹ï¼Œäºæ˜¯ä»–å†³å®šå¬å¤©ç”±å‘½â€¦â€¦\n\nå…·ä½“æ¥è¯´ï¼Œå°ZæŠŠè¿™Nåªè¢œå­ä»1åˆ°Nç¼–å·ï¼Œç„¶åä»ç¼–å·Låˆ°R(L å°½ç®¡å°Zå¹¶ä¸åœ¨æ„ä¸¤åªè¢œå­æ˜¯ä¸æ˜¯å®Œæ•´çš„ä¸€åŒï¼Œç”šè‡³ä¸åœ¨æ„ä¸¤åªè¢œå­æ˜¯å¦ä¸€å·¦ä¸€å³ï¼Œä»–å´å¾ˆåœ¨æ„è¢œå­çš„é¢œè‰²ï¼Œæ¯•ç«Ÿç©¿ä¸¤åªä¸åŒè‰²çš„è¢œå­ä¼šå¾ˆå°´å°¬ã€‚\n\nä½ çš„ä»»åŠ¡ä¾¿æ˜¯å‘Šè¯‰å°Zï¼Œä»–æœ‰å¤šå¤§çš„æ¦‚ç‡æŠ½åˆ°ä¸¤åªé¢œè‰²ç›¸åŒçš„è¢œå­ã€‚å½“ç„¶ï¼Œå°Zå¸Œæœ›è¿™ä¸ªæ¦‚ç‡å°½é‡é«˜ï¼Œæ‰€ä»¥ä»–å¯èƒ½ä¼šè¯¢é—®å¤šä¸ª(L,R)ä»¥æ–¹ä¾¿è‡ªå·±é€‰æ‹©ã€‚\n\nè¢œå­çš„æ•°é‡æœ€å¤šä¸º50000ï¼ˆæ˜¯çœŸçš„ğŸ‚ğŸºï¼‰\n\n#### åˆ†æ\nè¿™ä¼¼ä¹æ˜¯è«é˜Ÿçš„ä¾‹é¢˜ï¼ˆ\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50010,MAXQ=50010;\n\nll gcd(ll a,ll b){\n    return !b?a:gcd(b,a%b);\n}\nll c2(ll n){\n    if(n<2)return 0;\n    return n*(n-1)/2;\n}\nint a[MAXN];\nint block=0;\nstruct Q{\n    int l,r;\n    int i;\n    ll ansu,ansd;\n    bool operator<(const Q &b)const{\n        if(l/block!=b.l/block)return l/block<b.l/block;\n        return r<b.r;\n    }\n}qs[MAXQ];\n\nint cnt[MAXN];\nll cup=0,cdown=0;\nvoid remove(int ptr){\n    cup-=c2(cnt[a[ptr]]);\n    cnt[a[ptr]]--;\n    cdown--;\n    cup+=c2(cnt[a[ptr]]);\n}\nvoid add(int ptr){\n    cup-=c2(cnt[a[ptr]]);\n    cnt[a[ptr]]++;\n    cdown++;\n    cup+=c2(cnt[a[ptr]]);\n}\nint main(){\n    int nlen,qlen;cin>>nlen>>qlen;\n    for(int i=1;i<=nlen;i++)cin>>a[i];\n    for(int i=0;i<qlen;i++)cin>>qs[i].l>>qs[i].r;\n    for(int i=0;i<qlen;i++)qs[i].i=i;\n    block=sqrt(nlen);\n    sort(qs,qs+qlen);\n    /*\n    cout<<\"current queries:\"<<endl;\n    for(auto q:qs){\n        cout<<q.l<<\" \"<<q.r<<endl;\n    }\n    cout<<\"=====\"<<endl;\n*/\n    int l=1,r=1;\n    add(1);\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        if(q.l==q.r){\n            q.ansu=0;q.ansd=1;\n            continue;\n        }\n        while(q.l<l)add(--l);\n        while(r<q.r)add(++r);\n        while(l<q.l)remove(l++);\n        while(q.r<r)remove(r--);\n\n        q.ansu=cup;\n        q.ansd=cdown;\n        //cout<<cup/c2(cdown)<<endl;\n    }\n    sort(qs,qs+qlen,[](const Q &a,const Q &b){\n            return a.i<b.i;\n            });\n    for(int i=0;i<qlen;i++){\n        if(qs[i].ansd<2){\n            cout<<\"0/1\"<<endl;\n            continue;\n        }\n        ll u=qs[i].ansu;\n        ll d=c2(qs[i].ansd);\n        ll g=gcd(u,d);\n        if(g!=0)u/=g,d/=g;\n        cout<<u<<\"/\"<<d<<endl;\n    }\n\n\n    return 0;\n}\n```\n\n## å¸¦ä¿®æ”¹è«é˜Ÿ\n> ä¸€åˆ‡éƒ½æ˜¯çŸ³xé—¨çš„é€‰æ‹©ï¼\n\nå°†ä¿®æ”¹æ“ä½œå¹³é“ºåœ¨æ—¶é—´çº¿ä¸Šï¼Œè®¡ç®—æ¯æ¬¡è¯¢é—®æ‰€å¤„çš„æ—¶é—´ç‚¹ï¼Œä»¥$B=\\sqrt{n}$ï¼ŒæŒ‰ç…§$(l/B,r/B,time)$å¯¹è¯¢é—®æ’åºã€‚\n\nä¹‹åæšä¸¾æ¯ä¸€ä¸ªè¯¢é—®ï¼Œå°†ç­”æ¡ˆåœ¨ä¸åŒæ—¶é—´çº¿é—´æš´åŠ›+1-1è·³è½¬ï¼Œå†æš´åŠ›åœ¨ç›¸é‚»è¯¢é—®çš„åŒºé—´é—´+1-1è½¬ç§»ã€‚\n\n~~å¬èµ·æ¥æœ‰ç‚¹ä¸­äºŒçš„æ„æ€ã€‚~~\n\n### Problem: Game\nAgain Alice and Bob is playing a game with stones. There are N piles of stones labelled from 1 to N, the i th pile has ai stones. \n\nFirst Alice will choose piles of stones with consecutive labels, whose leftmost is labelled with L and the rightmost one is R. After, Bob will choose another consecutive piles labelled from l to r (Lâ‰¤lâ‰¤râ‰¤R). Then they're going to play game within these piles.\n\nHere's the rules of the game: Alice takes first and the two will take turn to make a move: choose one pile with nonegetive stones and take at least one stone and at most all away. One who cant make a move will lose.\n\nBob thinks this game is not so intersting because Alice always take first. So they add a new rule, which is that Bob can swap the number of two adjacent piles' stones whenever he want before a new round. That is to say, if the i th and i+1 pile have ai and ai+1 stones respectively, after this swapping there will be ai+1 and ai.\n\nBefore today's game with Bob, Alice wants to know, if both they play game optimally when she choose the piles from L to R, there are how many pairs (l, r) chosed by Bob that will make Alice *win*.\n\n#### åˆ†æ\nnimæ¸¸æˆè¾“èµ¢å°±æ˜¯çœ‹å¼‚æˆ–å’Œï¼Œå¼‚æˆ–å’Œå¯ä»¥çœ‹å‰ç¼€å¼‚æˆ–å’Œå†…æœ‰å¤šå°‘ä¸ªå€¼ç›¸åŒçš„ç‚¹ã€‚æ‰€ä»¥å®ƒå°±æ˜¯åœ¨é—®ä¸€ä¸ªåŒºé—´é‡Œæœ‰å¤šå°‘ä¸ªç›¸åŒç‚¹å¯¹ã€‚\n\nå¸¦å•ç‚¹ä¿®æ”¹çš„åŒºé—´ç‚¹å¯¹è®¡æ•°ã€‚\n\n#### ä»£ç \n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=100010,MAXQ=100010;\nconst int MAXPOS=2e6+11;\n\nint nlen,qlen;\nint game[MAXN];\nint pre[MAXN];\nint modified[MAXQ],midx=0,belong[MAXN];\nint block=0;\nstruct Q{\n    int i;\n    int l,r;\n    int tick;\n\n    bool operator<(const Q &b)const{\n //       if(l/block!=b.l/block)return l/block<b.l/block;\n   //     if(r/block!=b.r/block)return r/block<b.r/block;\n        if(belong[l]!=belong[b.l])\n            return belong[l]<belong[b.l];\n        if(belong[r]!=belong[b.r])\n            return belong[r]<belong[b.r];\n        return  tick<b.tick;\n    }\n}q[MAXQ];\nint qidx=0;\nll cache=0;\nint cnt[MAXPOS];\n\ninline void add(int pos){\n    int &c=cnt[pre[pos]];\n    cache-=(ll)c*(c-1)/2;\n    c++;\n    cache+=(ll)c*(c-1)/2;\n}\ninline void rm(int pos){\n    int &c=cnt[pre[pos]];\n    cache-=(ll)c*(c-1)/2;\n    c--;\n    cache+=(ll)c*(c-1)/2;\n}\n\nint l=1,r=1,curt=0;\ninline void jumpup(int tim){\n    if(tim==0)return;\n    int pos=modified[tim];\n    int a=game[pos];\n    int b=game[pos+1];\n    swap(game[pos],game[pos+1]);\n    if(l<=pos && pos<=r){\n        rm(pos);\n    }\n    pre[pos]^=a;\n    pre[pos]^=b;\n    if(l<=pos && pos<=r){\n        add(pos);\n    }\n}\ninline void jumpdown(int tim){\n    jumpup(tim);\n}\n\nll qans[MAXQ];\n\nint main(){\n    //freopen(\"00.in\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&nlen,&qlen)){\n        block=pow(nlen,2.0/3);\n        for(int i=1;i<=nlen;i++){\n            scanf(\"%d\",&game[i]);\n            belong[i]=(i-1)/block;\n        }\n        pre[0]=0;\n        for(int i=1;i<=nlen;i++)pre[i]=pre[i-1]^game[i];\n\n        qidx=0,midx=0;\n        for(int i=1;i<=qlen;i++){\n            int opt;\n            scanf(\"%d\",&opt);\n            if(opt==1){\n                int l,r;\n                scanf(\"%d%d\",&l,&r);\n                q[qidx].i=qidx;\n                q[qidx].l=l;\n                q[qidx].l--;\n                q[qidx].r=r;\n                q[qidx].tick=midx;\n                qidx++;\n            }else if(opt==2){\n                scanf(\"%d\",&modified[++midx]);\n            }\n        }\n        sort(q,q+qidx);\n\n        memset(cnt,0,sizeof(cnt));\n        cache=0;\n        l=r=1;curt=0;\n        add(1);\n        for(int i=0;i<qidx;i++){\n            if(q[i].r-q[i].l+1<2){\n                qans[q[i].i]=0;\n                continue;\n            }\n            while(curt<q[i].tick)jumpup(++curt);\n            while(q[i].tick<curt)jumpdown(curt--);\n\n            while(q[i].l<l)add(--l);\n            while(r<q[i].r)add(++r);\n            while(l<q[i].l)rm(l++);\n            while(q[i].r<r)rm(r--);\n \n            //qans[q[i].i]=cache;\n            ll len=r-l+1;\n            qans[q[i].i]=len*(len-1)/2-cache;\n        }\n        for(int i=0;i<qidx;i++){\n            printf(\"%lld\\n\",qans[i]);\n        }\n    }\n    return 0;\n}\n```\n\n## æ³¨æ„\n* å…³äºè®°å½•å½“å‰é—®é¢˜çš„åŒºé—´çš„å¼€é—­é—®é¢˜ï¼Œéœ€è¦è°¨æ…å®‰æ’ã€‚\n* åœ¨ç¡®è®¤äº†åŒºé—´å¼€é—­åï¼Œå…³äºæœ€åˆå§‹çš„çŠ¶æ€ï¼Œéœ€è¦è°¨æ…å®‰æ’ã€‚","tags":["è«é˜Ÿ"],"categories":["study"]},{"title":"Distribution of Books","url":"%2F2019%2F08%2F01%2Fproblem-distribution-of-books%2F","content":"zz6d likes reading very much, so he bought a lot of books. One day, zz6d brought n books to a classroom in school. The books of zz6d is so popular that K students in the classroom want to borrow his books to read. Every book of zz6d has a number i (1<=i<=n). Every student in the classroom wants to get a continuous number books. Every book has a pleasure value, which can be 0 or even negative (causing discomfort). Now zz6d needs to distribute these books to K students. The pleasure value of each student is defined as the sum of the pleasure values of all the books he obtains.Zz6d didn't want his classmates to be too happy, so he wanted to minimize the maximum pleasure of the K classmates. zz6d can hide some last numbered books and not distribute them,which means he can just split the first x books into k parts and ignore the rest books, every part is consecutive and no two parts intersect with each other.However,every classmate must get at least one book.Now he wonders how small can the maximum pleasure of the K classmates be.\n\n1<=T<=10\n\n1<=n<=2*105 \n\n1<=k<=n \n\n-109<=ai<=109\n\n# åˆ†æ\næœ€å¤§å€¼æœ€å°ï¼Œè€ƒè™‘äºŒåˆ†ç­”æ¡ˆã€‚æ€è€ƒé¢˜ç›®æ˜¯å¦å…·æœ‰å•è°ƒæ€§ï¼šå½“æœ€å¤§å€¼æå¤§æ—¶ï¼Œä¹¦å¯ä»¥éšä¾¿åˆ†ï¼Œå½“æœ€å¤§å€¼æå°æ—¶ï¼Œå¯èƒ½ä¼šå‡ºç°æ— æ³•å‡‘é½çš„çŠ¶å†µï¼Œç›®æµ‹æ»¡è¶³ã€‚\n\né¢˜ç›®è¦æ±‚åˆ†ä¹¦æ—¶å¿…é¡»è¿ç»­åˆ†ï¼Œå¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥åšã€‚å‡è®¾äºŒåˆ†çš„ç­”æ¡ˆä¸ºlim\n\n$$f(i)=\\max \\{ f(j) | \\sum_{k=j+1}^i a_k \\leq lim  \\}+1$$\n\nå°†æ±‚å’Œæ”¹ä¸ºå‰ç¼€å’Œï¼Œ$pre(i)$ã€‚\n\n$$f(i)=\\max \\{ f(j) | pre(i)-pre(j-1) \\leq lim  \\}+1$$\n\nåŠ¨æ€è§„åˆ’çš„å¤æ‚åº¦ä¸º$O(n^2)$ï¼Œå¤ªæ…¢ï¼Œè€ƒè™‘ä¼˜åŒ–ã€‚\n\næ¯æ¬¡è½¬ç§»éƒ½ä»å…ˆå‰å·²ç»å‡ºç°çš„æ»¡è¶³è¦æ±‚çš„fä¸­è½¬ç§»ã€‚é™åˆ¶æ¡ä»¶è½¬ä¸€ä¸‹ï¼Œå°±æ˜¯\n\n$$pre(i)-lim \\leq pre(?)$$\n\n* å½“æœ‰2ä¸ªfå¯¹åº”çš„å‰ç¼€å’Œç›¸åŒï¼Œæˆ‘ä»¬é€‰æ‹©æ›´å¤§çš„é‚£ä¸ª\n\næ‰€ä»¥å¯ä»¥ç›´æ¥ç»´æŠ¤å·²ç»å‡ºç°çš„æ¯ç§å‰ç¼€å’Œæ‰€å¯¹åº”çš„æœ€å¤§fã€‚å¯ä»¥ç¦»æ•£åŒ–åä½¿ç”¨æƒå€¼çº¿æ®µæ ‘ã€‚å¤æ‚åº¦å˜ä¸º$O(n\\lg n)$\n\næ€»å¤æ‚åº¦ä¸º$O(n\\lg n \\lg n)$ã€‚\n\n# ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=900010;\n\nll dat[MAXN];\nint lc[MAXN],rc[MAXN];\nint idx=0;\nint build(int &n,int l,int r){\n    if(!n)n=++idx;\n    dat[n]=-0x3f3f3f3f;\n    if(l>=r)return dat[n];\n\n    int mid=(l+r)/2;\n    dat[n]=max(build(lc[n],l,mid),build(rc[n],mid+1,r));\n    return dat[n];\n}\nvoid collectchild(int node){\n    dat[node]=max(dat[lc[node]],dat[rc[node]]);\n}\n\nint query_n(int l,int r,int L,int R,int node){\n    if(l<=L && R<=r)return dat[node];\n    int mid=(L+R)/2;\n    int res=-0x3f3f3f3f;\n    if(l<=mid)res=max(res,query_n(l,r,L,mid,lc[node]));\n    if(mid<r)res=max(res,query_n(l,r,mid+1,R,rc[node]));\n    return res;\n}\n\nvoid modify(int l,int r,ll x,int L,int R,int node){\n    if(L>=R){\n        dat[node]=max(dat[node],x);\n        return;\n    }\n    int mid=(L+R)/2;\n    if(l<=mid)modify(l,r,x,L,mid,lc[node]);\n    if(mid<r)modify(l,r,x,mid+1,R,rc[node]);\n    collectchild(node);\n}\nll prefix[MAXN];\nll bprefix[MAXN];\nll num[MAXN];\n\nint nlen,sel;\nint rlen;\nint root;\nbool check(ll x){\n    build(root,0,rlen-1);\n\n    int zero=lower_bound(bprefix,bprefix+rlen,0)-bprefix;\n    modify(zero,zero,0,0,rlen-1,root);\n\n    for(int i=1;i<=nlen;i++){\n        int start=lower_bound(bprefix,bprefix+rlen,bprefix[prefix[i]]-x)-bprefix;\n        int dp=query_n(start,rlen-1,0,rlen-1,root)+1;\n        if(dp>=sel)return true;\n        modify(prefix[i],prefix[i],dp,0,rlen-1,root);\n    }\n    return false;\n}\n\n\nint main(){\n    //debug\n    /*\n    int opt;\n    build(root,0,10-1);\n    while(cin>>opt){\n        if(opt==1){\n            int pos,x;cin>>pos>>x;\n            modify(pos,pos,x,0,10-1,root);\n        }else{\n            int l,r;cin>>l>>r;\n            cout<<query_n(l,r,0,10-1,root)<<endl;\n        }\n    }\n    */\n\n    int kase;cin>>kase;\n    while(kase--){\n        cin>>nlen>>sel;\n        for(int i=1;i<=nlen;i++){\n            cin>>num[i];\n        }\n        bprefix[0]=prefix[0]=0;\n        for(int i=1;i<=nlen;i++)bprefix[i]=prefix[i]=prefix[i-1]+num[i];\n        //discrete\n        sort(bprefix,bprefix+nlen+1);\n        rlen=unique(bprefix,bprefix+nlen+1)-bprefix;\n        for(int i=0;i<=nlen;i++)prefix[i]=lower_bound(bprefix,bprefix+rlen,prefix[i])-bprefix;\n\n        \n\n\n        //binary\n        ll l=-1e15,r=1e15;\n        while(l+1<r){\n            ll mid=(l+r)/2;\n            if(check(mid)){\n                r=mid;\n            }else l=mid;\n        }\n        for(ll i=l;i<=r;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```\n\nå¤šç»„è¯¢é—®æ²¡æœ‰æ¸…ç†å¹²å‡€æ•°ç»„ï¼ŒWAäº†å¥½å‡ å‘ã€‚","tags":["ç¦»æ•£åŒ–"],"categories":["coding"]},{"title":"Fansblog","url":"%2F2019%2F08%2F01%2FFansblog%2F","content":"Farmer John keeps a website called â€˜FansBlogâ€™ .Everyday , there are many people visited this blog.One day, he find the visits has reached P , which is a prime number.He thinks it is a interesting fact.And he remembers that the visits had reached another prime number.He try to find out the largest prime number Q ( Q < P ) ,and get the answer of Q! Module P.But he is too busy to find out the answer. So he ask you for help. ( Q! is the product of all positive integers less than or equal to n: n! = n * (n-1) * (n-2) * (n-3) *â€¦ * 3 * 2 * 1 . For example, 4! = 4 * 3 * 2 * 1 = 24 )\n\n\nFirst line contains an number T(1<=T<=10) indicating the number of testcases.\nThen T line follows, each contains a positive prime number P (1e9â‰¤pâ‰¤1e14)\n\n<!--more-->\n\n\n# åˆ†æ\nè¿™é¢˜å¾—çŸ¥é“2ä¸ªç»“è®ºï¼Œç„¶è€Œæˆ‘éƒ½ä¸çŸ¥é“ã€‚\n\n## å¨å°”é€Šå®šç†\nå½“Pä¸ºè´¨æ•°æ—¶ï¼Œ$(P-1)! \\equiv -1 \\pmod P$.\n\næ³¨æ„è¿™é‡Œ$!$æ˜¯é˜¶ä¹˜ï¼Œä¸æ˜¯å–åçš„æ„æ€ã€‚\n\n## ç´ æ•°åˆ†å¸ƒ\nå½“èŒƒå›´å˜å¤§æ—¶ï¼Œç´ æ•°çš„å‡ºç°é¢‘ç‡å¢é«˜ï¼Œå¯»æ‰¾ä¸€ç´ æ•°çš„ç›¸é‚»ç´ æ•°å¤æ‚åº¦é€æ¸è¶‹è¿‘äºçº¿æ€§ã€‚\n\næ‰€ä»¥ï¼Œå¯»æ‰¾ç´ æ•°Pçš„å‰ä¸€ä¸ªç´ æ•°å¯ä»¥ç›´æ¥æš´åŠ›æ‰¾ã€‚æ‰¾åˆ°ä¹‹ååˆ©ç”¨$(P-1)! \\equiv -1 \\pmod P$å³å¯å¿«é€Ÿç”±$P-1$çš„é˜¶ä¹˜é€šè¿‡é€†å…ƒè½¬åˆ°$Q$çš„é˜¶ä¹˜ï¼Œè¿™é¢˜å°±åšå®Œäº†ã€‚\n\nå› ä¸ºåœ¨è®¡ç®—é€†å…ƒæ—¶ä¼šçˆ†llï¼Œä½¿ç”¨å¿«é€Ÿä¹˜æ³•æ¥é¿å…ï¼Œå¤æ‚åº¦ç¬¦åˆè¦æ±‚ã€‚\n\n# ä»£ç \n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\ninline ll qmul(ll x,ll y,ll q){\n    ll res=0;\n    for(;y;y>>=1,x=(x+x)%q){\n        if(y&1)res=(res+x)%q;\n    }\n    return res;\n}\n\n\ninline ll qpow(ll x,ll a,ll q){\n    ll res=1;\n    for(a;a;a>>=1,x=qmul(x,x,q)){\n        if(a&1)res=qmul(res,x,q);\n    }\n    return res;\n}\n\ninline ll get_rev(ll x,ll q){\n    return qpow(x,q-2,q);\n}\n\ninline bool is_prime(ll x){\n    for(ll i=2;i<=sqrt(x);i++){\n        if(x%i==0)return false;\n    }\n    return true;\n}\n\ninline ll factor(ll l,ll r,ll q){\n    ll res=1;\n    for(ll i=l;i<=r;i++)res=qmul(res,i,q);\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    while(kase--){\n        ll x;cin>>x;\n        ll prex=x-1;\n        while(!is_prime(prex))prex--;\n\n        ll ans=qmul(x-1,get_rev(factor(prex+1,x-1,x),x),x);\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n```","tags":["å¨å°”é€Šå®šç†"],"categories":["coding"]},{"title":"æ°´çš„åˆé›† 1","url":"%2F2019%2F07%2F22%2Fwaterful-summary-1%2F","content":"\n\n## é›†åˆæŒ‘é€‰\nä»ç»™å®šçš„Nä¸ªé›†åˆä¸­å„æŒ‘å‡ºä¸€ä¸ªæ•°å¹¶æ±‚å’Œï¼Œæ±‚å‡ºå‰$K$å¤§çš„$K$ä¸ªå’Œã€‚\n\nè€ƒè™‘å¦‚ä½•ä»2ä¸ªé›†åˆ$A$,$B$ä¸­é€‰å‡ºå‰$K$å¤§ã€‚é™åºæ’åºå$a_1$å’Œ$b_1$æ˜¾ç„¶æ˜¯æœ€å¤§ï¼Œç¬¬äºŒå¤§åˆ™æ˜¯$(a_1,b_2)$æˆ–è€…$(a_2,b_1)$ã€‚ä¸å¦¨ä»¥$(a_1,b_2)$æ¥è®²ï¼Œé‚£ä¹ˆç¬¬ä¸‰å¤§ç«äº‰è€…é™¤$(a_2,b_1)$è¿˜æœ‰$(a_1,b_3)$ï¼Œ$(a_2,b_3)$â€¦â€¦æ¯å¯¹ç»„åˆéƒ½èƒ½æ‰¾åˆ°ç›´æ¥å°äºå®ƒçš„2ä¸ªç»„åˆï¼Œè€Œè¿™ç§åç»§å…³ç³»æ˜¾ç„¶å–éäº†æ‰€æœ‰ç»„åˆã€‚ä»…éœ€è¦å‰Kå¤§çš„æˆ‘ä»¬æŒ‰éœ€æ‰©å±•è¿™ä¸€æ£µæ ‘å³å¯ã€‚2ä¸ªé›†åˆçš„å‰Kå¤§å¯ä¸ç¬¬3ä¸ªé›†åˆæ‰§è¡Œç›¸åŒçš„æ“ä½œï¼Œä»è€Œå¾—åˆ°æœ€ç»ˆç­”æ¡ˆã€‚å®é™…ç¼–å†™æ—¶ï¼ŒæŒ‰ç…§ä¸€å®šé¡ºåºé™åˆ¶æ‰©å±•æ–¹å‘æ¥ä¿è¯æ¯ä¸ªæ–¹æ¡ˆä»…è®¿é—®ä¸€æ¬¡ï¼Œä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤ï¼Œå¤æ‚åº¦ä¸º$O(\\sum^N{K\\log n_k}) \\leq O(KN)$\n\n## LISä¼˜åŒ–\n$$f(i)=max\\{f(j)| j < i, a(j) < a(i) \\}+1$$\n\nå¯ä»¥å‘ç°ï¼Œä¸€æ—¦æœ‰$a(k) < a(j), f(k) \\geq f(j)$ï¼Œjè¿™ä¸ªä½ç½®å°±æ²¡æœ‰ç”¨äº†ã€‚æŒ‰ç…§è¯¥è§„å¾‹ç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆè®°å½•ï¼Œä»¥é•¿åº¦å•è°ƒï¼ˆåˆ™æ•°å­—aç»“å°¾çš„LISè‡ªç„¶å•è°ƒï¼‰ã€‚æ­¤åè½¬ç§»\n","categories":["study"]},{"title":"å’¸é±¼æ•°è®º","url":"%2F2019%2F07%2F22%2Fnumeric-water%2F","content":"\n## ä¸€äº›ç»“è®º\n* $N!$çš„è´¨å› æ•°åˆ†è§£ä¸­æŸè´¨æ•°çš„æŒ‡æ•°ä¸º$\\sum_{r=1}^{\\inf} [ n/p^r ] $\n* çº¦æ•°ä¸ªæ•°ä¸ºè´¨å› æ•°æŒ‡æ•°+1çš„ä¹˜ç§¯ï¼Œå’Œä¸ºè´¨å› æ•°æšä¸¾æŒ‡æ•°æ¬¡å’Œçš„ä¹˜ç§¯ã€‚\n* è´¹é©¬å°å®šç†è¦æ±‚pæ˜¯è´¨æ•°\n\n## æ¬§æ‹‰å‡½æ•°\nå°äºxä¸”ä¸å…¶äº’è´¨çš„æ•°çš„ä¸ªæ•°\n$$\n\\phi(x)=x\\prod_{k=1}^n(1-\\frac{1}{p_k})\n$$\n\n* $phi(1)=1$\n* $phi(p)=p-1$,å½“pä¸ºè´¨æ•°\n* $phi(2n)=phi(n)$\n* $phi(phi(phi...))))=1$\n\nå¯¹äºä»»æ„ç§¯æ€§å‡½æ•°$f(xy)=f(x)f(y)$ï¼Œå¯ä»¥ç­›ã€‚æ¬§æ‹‰å‡½æ•°éå®Œå…¨ç§¯æ€§å‡½æ•°ã€‚\n\n* $phi(xy)=phi(x)(y-1)$,å½“xä¸yäº’è´¨\n* $phi(xy)=phi(x)y$,å½“xä¸yä¸äº’è´¨\n\n```cpp\nfor(int i=2;i<=n;i++){\n    if(!no[i]){\n        p[++cnt]=i;\n        phi[i]=i-1;\n    }\n    for(int j=1;j<=cnt&&p[j]*i<=n;j++){\n        no[p[j]*i]=1;\n        if(i%p[j]==0){\n            phi[p[j]*i]=phi[i]*p[j];\n            break;\n        }\n        phi[p[j]*i]=phi[i]*(p[j]-1);\n    }\n}\n```\n\n## æ‰©å±•æ¬§å‡ é‡Œå¾—\n* å­˜åœ¨xï¼Œyä½¿å¾—ax+by=gcdï¼ˆaï¼Œbï¼‰\n* æ±‚é€†å…ƒï¼Œè¦æ±‚xä¸æ¨¡æ•°äº’è´¨\n\n```cpp\nvoid exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){\n        x=1,y=0;\n    }else{\n        exgcd(b,a%b,y,x);\n        y-=(a/b)*x;\n    }\n}\n```\n\n## é€’æ¨é€†å…ƒ\ninv(i) = inv(mod % i) * (mod-mod/i) % mod;\n\n* é˜¶ä¹˜çš„é€†å…ƒï¼šinv(i)=inv(i+1)*(i+1)\n","tags":["æ•°è®º"],"categories":["study"]},{"title":"æ˜æ—¥æ–¹èˆŸå·¥å…·","url":"%2F2019%2F07%2F20%2Farknights-tools%2F","content":"\n{% asset_img img.jpg Penguin Logistics %}\n\nè™½ç„¶ç±»å‹å®Œå…¨ä¸ä¸€æ ·ï¼Œä½†æ˜æ—¥æ–¹èˆŸå¤§æ¦‚æ˜¯æˆ‘ç»§ç©çˆ†Minecraftä¹‹åå¦ä¸€ä¸ªå–œæ¬¢çš„æ¸¸æˆäº†ã€‚\n\n<!--more-->\n\ntaçš„è®¾å®šã€å‰§æƒ…ã€ç¾æœ¯ã€å¡”é˜²ç©æ³•éƒ½å¾ˆå¯¹æˆ‘å£å‘³ï¼Œåºå¤§çš„ä¸–ç•Œè§‚ä»¥åŠå¤æ‚çš„äººç‰©å…³ç³»ä¹Ÿå€¼å¾—ç§°èµã€‚è€Œä¸”æˆ‘è®¤ä¸ºè¿™ä¸ªæ¸¸æˆå¾ˆå‡ºä¼—çš„ä¸€ç‚¹æ˜¯taçš„æ•…äº‹ä¸ä»¥ç©å®¶ä¸ºä¸­å¿ƒï¼Œä¸€åˆ‡è‡ªæœ‰å…¶å‘å±•ã€‚\n\n## æ‰è½ç»Ÿè®¡\nå·²ç»æœ‰éå¸¸å®Œå–„çš„è½®å­äº†â€¦â€¦æ‰è½ç»Ÿè®¡æ”¹ä¸ºæ‰è½è¯†åˆ«ç»Ÿè®¡ï¼Œæ”¶å½’åˆ°è¾…åŠ©å·¥å…·å†…ã€‚\n\n## èµ„æºè§„åˆ’\nå·²ç»æœ‰éå¸¸å®Œå–„çš„è½®å­äº†â€¦â€¦\n\nåˆæ­¥è®¾æƒ³ä¸ºåŸºäºçº¿æ€§è§„åˆ’çš„å…³å¡è§„åˆ’å®‰æ’ã€‚æ­£åœ¨æ€è€ƒæ˜¯å¦æœ‰æ›´å¥½çš„æ–¹æ³•æˆ–è€…æ”¹è¿›ã€‚\n\n## è¾…åŠ©å·¥å…·\nè¿™ä¸ªè¾…åŠ©å·¥å…·ç»ä¸å¯ç ´åæ‰â€œæˆ‘è®¤ä¸ºâ€çš„æœ‰ä¹è¶£çš„éƒ¨åˆ†ï¼Œå®ƒçš„å¼€å‘ä¹Ÿä¼šä¸€ç›´åšæŒè¿™ä¸ªæƒ³æ³•ã€‚\n\nç‹¬æ–­è€Œå¸¦æœ‰åè§çš„æ€è€ƒåï¼Œå®ƒçš„åŠŸèƒ½ç›®å‰è§„åˆ’ä¸ºï¼š\n\n1. å•ä¸€å…³å¡çš„é‡å¤æ€§æˆ˜æ–—ä»£ç†\n2. æ‰è½ç‰©å“è‡ªåŠ¨ç»Ÿè®¡ä¸ä¸Šä¼ \n\n### ç‰©å“è¯†åˆ«\nå·¥å…·ç›®å‰å¯ä»¥åœ¨å…³å¡ç»“æŸæ—¶è‡ªåŠ¨è¯†åˆ«å±å†…çš„æ‰è½ç‰©å“å’Œæ‰è½æ•°é‡ï¼Œä½†ä¸ç¨³å®šã€‚\n\næ‰è½æ£€æµ‹ä»ç°åº¦åŒ¹é…æ”¹ä¸ºåŸºäºç‰¹å¾ç‚¹çš„åŒ¹é…ã€‚é¦–å…ˆèƒ½å¤Ÿè‡ªåŠ¨å°†æ‰è½ç‰©å“å›¾ç‰‡è¿›è¡Œçªå‡ºç‰¹å¾çš„å¤„ç†åæ‹†åˆ†ç”Ÿæˆç‰©å“ç‰¹å¾å›¾ï¼Œå¹¶ä½¿ç”¨SIFTä»ç‰¹å¾å›¾ä¸­å–å‡ºä¸å—å›¾åƒç¼©æ”¾ä¸è‰²å·®å½±å“çš„ç‰¹å¾ç‚¹ã€‚\n\næ­¤åå†æ¬¡ä½¿ç”¨æ—¶ï¼Œä¸é¢„è®¾ç‰¹å¾ç‚¹æ¯”è¾ƒä»è€Œæ‰¾åˆ°å¯¹åº”çš„æ‰è½ç‰©å“ç¼–ç ï¼Œä»æ•°æ®åº“ä¸­æå–å‡ºåç§°ã€‚\n\næ‰è½æ•°é‡æ˜¯å¯¹åˆ‡åˆ†å‡ºæ¥çš„æ•°å­—å›¾ç‰‡è°ƒç”¨`tesseract`è¿›è¡ŒOCRè¯†åˆ«ï¼Œç„¶è€Œè¿™ä¸ªå‡†ç¡®ç‡å®åœ¨å ªå¿§ã€‚å¯¹å›¾ç‰‡çš„é¢„å¤„ç†ä¼¼ä¹æ•ˆæœå¹¶ä¸æ€ä¹ˆå¥½ï¼Œä¹‹åï¼ˆä¹Ÿè®¸ï¼‰ä¼šæƒ³åŠæ³•å†æ”¹æ”¹ã€‚\n\nç‰©å“æ‰è½çš„ç»Ÿè®¡ä¿¡æ¯æœªæ¥ä¹Ÿè®¸èƒ½å¤Ÿå®ç°å‘å·²æœ‰çš„æ•°æ®åº“å¯¹æ¥ã€‚\n\n## å…³å¡å‹åŠ›åˆ†æ\nè¿›æ”»é‡æ”¾ä¸é˜²å®ˆå‹åŠ›çš„åˆ†æå·¥å…·ã€‚\n\n## ï¼Ÿ\néå¸¸è¿œæœŸçš„ç›®æ ‡ï¼š\n\n* ç ”ç©¶èƒ½å¤Ÿç ”ç©¶å…³å¡è¿‡æ³•çš„ç®—æ³•å¤§æ¦‚ç‡æœ‰ä¹è¶£","tags":["å°å·¥å…·"],"categories":["projects"]},{"title":"[BUPT WARMUP|CF] çç å¥¶èŒ¶","url":"%2F2019%2F07%2F20%2Fproblem-bupt-milk-tea%2F","content":"\n\nç»™å‡ºä¸€ä¸ª$N \\times N$çš„éè´Ÿæ•´æ•°çŸ©é˜µï¼Œè¦æ±‚æ‰¾åˆ°ä¸€æ¡ä»å·¦ä¸Šè§’æ•°å­—åˆ°å³ä¸‹è§’æ•°å­—çš„è·¯çº¿ï¼Œä¸”\n\n* åªèƒ½å‘å³æˆ–è€…ä¸‹èµ°ã€‚\n* å°†ç»è¿‡æ•°å­—ç›¸ä¹˜åå¾—åˆ°çš„ç»“æœï¼Œä½¿å…¶æœ«å°¾çš„â€œ0â€æœ€å°‘ã€‚\n\n$$\nN \\leq 1000\n$$\n\n<!--more-->\n\n## åˆ†æ\nå¤§æ¦‚æ˜¯å› ä¸ºæœ«å°¾çš„0é•¿å¾—åƒçç ã€‚\n\næ€è€ƒ0æ˜¯æ€ä¹ˆå‡ºç°çš„ï¼Œå¯ä»¥å‘ç°ç»“æœä¸­å› æ•°10çš„æŒ‡æ•°è¶Šå°è¶Šå¥½ï¼Œå³ï¼Œä½¿å¾—ç»è¿‡çš„è·¯ä¸Šå‡‘å‡ºçš„å› æ•°10æœ€å°‘å³å¯ã€‚10çš„è´¨å› æ•°åˆ†è§£ä¸º$2 \\times 5$ï¼Œä»¥çŸ©é˜µä¸­æ¯ä¸ªæ•°æ‰€å«å› æ•°2å’Œ5çš„æ•°ç›®åˆ†åˆ«DPä¸€éæ±‚è·¯å¾„ï¼Œå†åœ¨ä¸¤æ¬¡DPçš„ç»“æœä¸­å–å°ã€‚\n\nä¸€ä¸ªç‰¹æ®Šæƒ…å†µæ˜¯æ•°å­—é‡Œæœ‰0ï¼Œé‚£ä¹ˆç»è¿‡0çš„è·¯çš„æœ«å°¾0ä¸€å®šæ˜¯1ä¸ªâ€¦â€¦ä¸€å¼€å§‹è„‘è¢‹æŠ½äº†ä»¥ä¸ºæ˜¯0ä¸ªã€‚å¦‚æœå…¶ä»–æƒ…å†µçš„è·¯å¾„æœ«å°¾0éƒ½å¤šäº1ä¸ªçš„è¯ï¼Œå°±ç‰¹åˆ¤èµ°0ã€‚\n\n## ä»£ç  \n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconstexpr int MAXN=1010;\n\nint game[MAXN][MAXN];\nint num[2][MAXN][MAXN];\nint cal(int x,int fac){\n    if(x==0)return 0;\n    int res=0;\n    while(x%fac==0){\n        x/=fac;\n        res++;\n    }\n    return res;\n}\nint n;\nint dp[MAXN][MAXN];\nint from[MAXN][MAXN];\nvoid dodp(int fac){\n    for(int i=0;i<MAXN;i++){\n        for(int j=0;j<MAXN;j++){\n            dp[i][j]=0x3f3f3f3f;\n        }\n    }\n    dp[0][1]=dp[1][0]=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(dp[i-1][j]<dp[i][j-1]){\n                from[i][j]=2;\n                dp[i][j]=dp[i-1][j];\n            }else{\n                from[i][j]=1;\n                dp[i][j]=dp[i][j-1];\n            }\n            dp[i][j]+=num[fac][i][j];\n        }\n    }\n}\nstring genpath(){\n    string res=\"\";\n    int i=n,j=n;\n    for(int p=from[i][j];i!=1 || j!=1 ;p=from[i][j]){\n        if(p==2){\n            res+=\"D\";\n            i--;\n        }else{\n            res+=\"R\";\n            j--;\n        }\n    }\n    reverse(res.begin(),res.end());\n    return res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin>>n;\n    bool haszero=false;\n    int zeroi,zeroj;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cin>>game[i][j];\n            if(game[i][j]==0){\n                haszero=1;\n                zeroi=i,zeroj=j;\n            }\n        }\n    }\n    \n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            num[0][i][j]=cal(game[i][j],2);\n            num[1][i][j]=cal(game[i][j],5);\n        }\n    }\n    int ans=0x7f7f7f7f;\n    dodp(0);\n    string P;\n    if(ans>dp[n][n]){\n        ans=dp[n][n];\n        P=genpath();\n    }\n    dodp(1);\n    if(ans>dp[n][n]){\n        ans=dp[n][n];\n        P=genpath();\n    }\n\n    if(haszero && ans>1){\n        cout<<1<<endl;\n        for(int i=1;i<zeroi;i++)cout<<\"D\";\n        for(int j=1;j<zeroj;j++)cout<<\"R\";\n        for(int i=zeroi+1;i<=n;i++)cout<<\"D\";\n        for(int j=zeroj+1;j<=n;j++)cout<<\"R\";\n        cout<<endl;\n        return 0;\n    }\n\n    cout<<ans<<endl;\n    cout<<P<<endl;\n\n    return 0;\n}\n```\n","tags":["æ•°è®º"],"categories":["coding"]},{"title":"blogè¿ç§»","url":"%2F2019%2F07%2F13%2Fblog-upgrade%2F","content":"\n{% asset_img girl.jpg %}\n\nåˆå›åˆ°äº†é™æ€blogğŸ˜€.æœç„¶è¿™æ ·æ‰æ˜¯æœ€å¼çš„.\n\n## é™æ€blogç¼–è¯‘å™¨\nç°åœ¨æµè¡Œçš„é™æ€blogç¼–è¯‘å™¨å¤§æ¦‚æœ‰è¿™ä¹ˆå‡ ç§\n\n* `Node.js`çš„`Hexo`\n* `Python`çš„`Pelican`\n* `Ruby`çš„`Jekyll`\n* `Golang`çš„`Hugo`\n\n<!--more-->\n\n## ä½¿ç”¨Github pages\nGithubä¸ºç”¨æˆ·å‡†å¤‡äº†å…è´¹çš„pagesæœåŠ¡,èƒ½å¤Ÿå±•ç¤ºé™æ€é¡µé¢,æ»¡è¶³æˆ‘ä»¬çš„è¦æ±‚.\n\nä¸ºäº†ä½¿ç”¨Github pages,éœ€è¦æ–°å»ºé¡¹ç›®`<username>.github.io`,å°†æ–‡ä»¶pushä¸Šå»å,è®¿é—®ç›¸åº”çš„åŸŸå`https://<username>.github.io`å°±èƒ½çœ‹åˆ°.\n\nä½¿ç”¨githubæä¾›çš„åŸŸåä¹Ÿå¯ä»¥,ä¸€èˆ¬æ¥è¯´ä¸ºäº†~~è£…é€¼~~è¾¾åˆ°æ›´å¥½çš„å±•ç¤ºæ•ˆæœ,ä¼šå°†pageså†å’Œè‡ªå·±çš„åŸŸåç»‘å®š.\n\n### åŸŸåè§£æè¿‡ç¨‹\nå½“è®¿é—®ä¸€ä¸ªç½‘ç«™æ—¶,ç»è¿‡äº†è¿™ä¹ˆå‡ ä¸ªè¿‡ç¨‹.\n\n1. ç”¨æˆ·è®¿é—®åŸŸå`DOMAIN`\n2. ç³»ç»Ÿå‘DNSæœåŠ¡å™¨è¯¢é—®`DOMAIN`æ‰€å¯¹åº”çš„IP(æˆ–è€…å…¶ä»–åŸŸå)åœ°å€.\n3. æµè§ˆå™¨å‘è¯¥IPåœ°å€å‘é€è¯·æ±‚.\n4. æµè§ˆå™¨å°†è¯¥IPè¿”å›çš„æ•°æ®æ¸²æŸ“ä¸ºç½‘é¡µ.\n\nå› æ­¤ä¸ºäº†è®©è‡ªå·±çš„åŸŸåæŒ‡å‘pagesæœåŠ¡,éœ€è¦è¿™ä¹ˆå‡ æ­¥.\n\n#### åœ¨DNSæœåŠ¡å™¨é…ç½®è®°å½•\nå¯¹DNSæœåŠ¡å™¨è¯´æ˜åŸŸåæ‰€æŒ‡å‘çš„åœ°å€.åœ¨æ­¤,æˆ‘ä»¬å°†åŸŸåæŒ‡å‘pagesçš„åŸŸå`<username>.github.io`.è¯¥ç±»è®°å½•çš„ç±»å‹ä¸º`CNAME`,æŒ‰ç…§é¡µé¢ç›¸å…³æç¤ºå¡«å†™å³å¯.\n\n#### åœ¨Githubé…ç½®æ¥æ”¶æ¥æº\nä¹‹å,è¦å‘Šè¯‰githubå½“å…¶æ¥æ”¶åˆ°æ ‡æ³¨è‡ªæˆ‘ä»¬çš„åŸŸåçš„è¯·æ±‚æ—¶,è¦åšå‡ºå¯¹åº”çš„ç›¸åº”.\n\nåœ¨é¡¹ç›®ä¸­æ·»åŠ æ–‡ä»¶`CNAME`,å†…å†™ä¸€è¡Œ,ä¸ºæˆ‘ä»¬çš„åŸŸå.\n\n## å¯ç”¨SSL\nå¯ç”¨SSLæ²»ç–—å„ç§åŠ«æŒ.\n\nå› ä¸ºpagesä¸åŸç”Ÿæ”¯æŒSSL,å¯ä»¥ä½¿ç”¨cloudflareçš„æœåŠ¡æ¥å¯ç”¨SSL.\n\næ³¨å†Œcloudflareå,æŒ‰ç…§æŒ‡ç¤º,å°†åŸŸåçš„è§£ææœåŠ¡å™¨æ”¹ä¸ºcloudflare,ä¸€æ®µæ—¶é—´åè§£æç”Ÿæ•ˆå³å¯å¼€å¯SSL.\n\nä½ è¿˜å¯ä»¥åŠ ä¸€æ¡Rule,å¼ºåˆ¶æŠŠHTTPè½¬åˆ°HTTPS,æ²»ç–—ä¸€ä¸‹å‰¥ç¦»æ”»å‡»."},{"title":"Colorful Tree","url":"%2F2019%2F07%2F12%2Fcolorful-tree%2F","content":"\n\nThere is a tree having n nodes, the i-th node of which has a type of color, denoted by an integer $c_i$\n\nThe path between every two nodes is unique, of which we define the value is the number of distinct types of colors appearing on it.\n\nCalculate the sum of values of all possible paths, $\\frac{n(n-1)}{2}$ in total, between two different nodes on the tree.\n\n## è¾“å…¥èŒƒå›´\nå¤šç»„æ•°æ®,çº¦50;èŠ‚ç‚¹æ•°$2 \\times 10^5$.\n\n# åˆ†æ\næ²¡æƒ³å‡ºæ¥è¯¥æ€ä¹ˆåš.ç»Ÿè®¡è·¯å¾„é¢œè‰²çš„ç­”æ¡ˆæ²¡æœ‰ä»€ä¹ˆåˆå¹¶çš„å¥½æ–¹æ³•,åŒæ—¶ä¹Ÿä¸èƒ½æŒ‰ç…§æ¯ç§é¢œè‰²å•ç‹¬è€ƒè™‘.\n\nåæ¥ç»è¿‡dalaoç‚¹æ‹¨,è¯¥é¢˜ä¸­çš„\"ç»Ÿè®¡ä¸€æ¡è·¯å¾„ä¸Šé¢œè‰²ç§ç±»\"çš„è¦æ±‚å¯ä»¥è½¬åŒ–ä¸ºæ±‚å…¶**åé¢**\"æ²¡æœ‰æŸç§é¢œè‰²çš„è·¯å¾„æœ‰å¤šå°‘ç§\".\n\nå¦‚æ­¤,å¯¹äºæ¯ä¸€ç§é¢œè‰²å°±å¯ä»¥ä½¿ç”¨$n(n-1)/2-size$æ¥æ±‚å…¶å¯¹ç­”æ¡ˆçš„è´¡çŒ®äº†.So,æ¥è§£å†³è¿™ä¸ªé—®é¢˜.\n\nåŸå›¾æ˜¯ä¸€æ£µæ ‘,å¦‚æœæŸç‚¹$N$ä¸ºé¢œè‰²$c$,é‚£ä¹ˆç»è¿‡$N$çš„å­æ ‘ä»»æ„ç‚¹è·¨è¶Š$N$çš„è·¯å¾„éƒ½æœ‰è¯¥é¢œè‰².æ‰€æœ‰ä¸åŒ…æ‹¬è¯¥é¢œè‰²$c$çš„è·¯å¾„åª**èƒ½**å‡ºç°åœ¨ä»¥$N$ä¸ºåˆ‡ç‚¹çš„å…¶ä»–2éƒ¨åˆ†.è€ƒè™‘å…¶ä¸­ä¸€ä¸ªéƒ¨åˆ†,ä»»æ„é€‰ä¸­å…¶ä¸­2ä¸ªèŠ‚ç‚¹å³å¯æ„å»ºä¸€æ¡è·¯å¾„,ä½†è¿˜æ˜¯å¿…é¡»æ»¡è¶³åˆšåˆšçš„æ¡ä»¶(ä¸èƒ½è·¨è¶Šé¢œè‰²$c$çš„èŠ‚ç‚¹).ä»¥dfsé€’å½’è¿›å»å³å¯.\n\nè€ƒè™‘èƒ½å¦é€’å½’åˆå¹¶å·²æœ‰ç­”æ¡ˆ.èƒ½å¤Ÿå¾—åˆ°çš„æ•°æ®æœ‰*å­èŠ‚ç‚¹ä¸­2éƒ¨åˆ†çš„èŠ‚ç‚¹æ•°ç›®*,æ˜¾ç„¶èƒ½å¤Ÿåˆå¹¶å‡ºä»¥å½“å‰èŠ‚ç‚¹ä¸ºç•Œåˆ’åˆ†çš„2éƒ¨åˆ†ä¸­çš„ä¸€éƒ¨åˆ†,è‡ªç„¶å¯ä»¥åœ¨é€’å½’è¿”å›åæ¨å‡ºå¦ä¸€éƒ¨åˆ†.\n\n# ä»£ç \n```cpp\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXV=200010;\nvector<int> g[MAXV];\ninline void adde(int u,int v){\n    g[u].push_back(v);\n}\nint color[MAXV];\nll sz[MAXV];\nll gsz;\nll res=0;\nvoid dfs(int u,int fa){\n    gsz++;\n    for(auto v:g[u]){\n        if(v==fa)continue;\n        ll b_gsz=gsz;\n        ll b_sz=sz[color[u]];\n        dfs(v,u);\n\n        ll d=(gsz-b_gsz)-(sz[color[u]]-b_sz);\n        res+=d*(d-1)/2;\n        sz[color[u]]+=d;\n    }\n    sz[color[u]]++;\n}\nint flag[MAXV];\nint main(){\n    ios::sync_with_stdio(false);\n    int n;\n    int kase=0;\n    while(cin>>n){\n        for(int i=1;i<=n;i++)g[i].clear();\n        memset(sz,0,sizeof(sz));\n        gsz=0;\n        res=0;\n\n        vector<int> discol;\n        for(int i=1;i<=n;i++){\n            cin>>color[i];\n            flag[color[i]]=1;\n        }\n        for(int i=1;i<=n;i++){\n            if(flag[i])discol.push_back(i);\n        }\n        for(int i=0;i<n-1;i++){\n            int u,v;cin>>u>>v;\n            adde(u,v);\n            adde(v,u);\n        }\n\n        int disnum=discol.size();\n        dfs(1,0);\n        ll ans=(ll)disnum*n*(n-1)/2;\n        for(auto i:discol){\n            ll t=n-sz[i];\n            ans-=t*(t-1)/2;\n        }\n        cout<<\"Case #\"<<++kase<<\": \"<<ans-res<<endl;\n    }\n\n    return 0;\n}\n```","categories":["coding"]},{"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","url":"%2F2019%2F07%2F12%2Ffft%2F","content":"\n> å†™ä»£ç æ˜¯ä¸å¯èƒ½å†™ä»£ç çš„,ä»Šä¸‹åˆæ˜¯ä¸æƒ³å†™ä»£ç çš„.ä¸æƒ³å†™ä»£ç ,åˆä¸æƒ³å’¸é±¼,å°±åªèƒ½é å­¦ç‚¹æ–°ä¸œè¥¿æ¥å‡è£…è‡ªå·±åœ¨å·¥ä½œçš„æ ·å­,å¿ƒé‡Œæ‰èƒ½å¥½å—äº›.\n>\n> > çªƒæ ¼ç æ‹‰\n\næŠŠ2å¹´å‰å°±å¬è¿‡ä½†æ˜¯æ²¡å­¦çš„FFTè¿™æ¬¡çœ‹çœ‹å§.\n\nå‡ ä¹å¯ä»¥è‚¯å®š,ä¸‹é¢çš„å†…å®¹è‚¯å®šä¼šå‡ºé”….\n\n<!--more-->\n\n## å‚…é‡Œå¶å˜æ¢çš„å®é™…æ„ä¹‰\n### ä»ç”µå‹è¯´èµ·\nè¢«æ¨¡ç”µæŠ˜ç£¨çš„åŒå­¦éƒ½çŸ¥é“,æœ‰ç§ä¸œè¥¿å«åšå‚…é‡Œå¶çº§æ•°,å¯ä»¥å°†æˆå‘¨æœŸæ€§å˜åŒ–çš„ç”µå‹åˆ†è§£ä¸ºæ•°ä¸ªä¸‰è§’å‡½æ•°æ³¢çš„å åŠ .\n\nåœ¨è¿™é‡Œ,æˆ‘ä»¬æå‡ºå¦ä¸€ä¸ªé—®é¢˜,å¦‚æœä¸çŸ¥é“å‘¨æœŸ,è¯¥å¦‚ä½•å°†è¿™äº›å åŠ åœ¨ä¸€èµ·çš„ä¿¡å·æ‹†åˆ†ä¸ºå•çº¯çš„ä¸‰è§’æ³¢?\n\n> ä¸‰è§’æ³¢å åŠ å›¾è±¡å‘¨æœŸå¹¶ä¸é‚£ä¹ˆæ˜¾ç„¶,ä¹Ÿè®¸ä½ å¯ä»¥è¯•ä¸€è¯•.\n\n### ä¸€ç§ç¼ ç»•æœº\næœ‰ä¸€ç§å¥‡ç‰¹çš„æ–¹æ³•,æˆ‘ä»¬å°†ä¸€æ®µ`æ—¶åŸŸå›¾è±¡`åœ¨ç¬›å¡å°”åæ ‡ç³»ä¸Šä»¥åŸç‚¹ä¸ºåœ†å¿ƒ**ç»•**èµ·æ¥,ä¸€åœˆä¸€åœˆç¼ èµ·æ¥,ç„¶åè°ƒæ•´æºå›¾è±¡ç¼ ç»•çš„é€Ÿç‡(å‡ ç§’ä¸€åœˆ),è§‚å¯Ÿæ•´ä¸ªå›¾å½¢çš„**è´¨å¿ƒ**å˜åŒ–.\n\nè¿™ä¸ªè´¨å¿ƒä¼šéšç€å›¾è±¡ç¼ ç»•çš„é¢‘ç‡è€Œå‘ç”Ÿä½ç§».å–è´¨å¿ƒçš„xåæ ‡ä¸ºyè½´,ä»¥ç¼ ç»•çš„é¢‘ç‡ä¸ºæ¨ªè½´,ä½œå‡ºå›¾è±¡`B`.åœ¨è¿™ä¸ªå›¾è±¡ä¸Š,ä¼šè§‚æµ‹åˆ°ä¸€ä¸ªç°è±¡:(å‡è®¾æˆ‘ä»¬å·²çŸ¥åŸå›¾åƒçš„åˆ†è§£ä¸‰è§’æ³¢é¢‘ç‡)å½“ç¼ ç»•é¢‘ç‡æ¥è¿‘æŸä¸ªæºä¸‰è§’æ³¢çš„é¢‘ç‡æ—¶,ç¼ ç»•å›¾è±¡å‡ºç°**é‡åˆ**,è´¨å¿ƒç›¸å¯¹åŸç‚¹å‡ºç°è¾ƒå¤§ä½ç§»,å›¾è±¡å‡ºç°ä¸€ä¸ª**å³°å€¼**.\n\nç»§ç»­è°ƒæ•´ç¼ ç»•é¢‘ç‡,å³°å€¼æ¶ˆå¤±,å›¾è±¡å›å½’åˆ°å°èŒƒå›´æ³¢åŠ¨.\n\né€šè¿‡è§‚å¯Ÿå›¾è±¡`B`,å¯ä»¥è®¤ä¸º,å‡ºç°å³°å€¼çš„é¢‘ç‡å¯¹åº”ç€ä¸€ä¸ªé¢‘ç‡çš„æºä¸‰è§’æ³¢.å¦‚æ­¤,å°±å°†å åŠ å›¾è±¡è¿˜åŸäº†å›å».\n\n## å‚…é‡Œå¶å˜æ¢çš„æ•°å­¦å®ç°\nç°åœ¨,è€ƒè™‘å¦‚ä½•é€šè¿‡çš„æ•°å­¦çš„æ–¹æ³•æ¥å®ç°è¿™ä¸ªç¼ ç»•.\n\n### å¦‚ä½•ç¼ ç»•\nå°†$g(t)$çš„å›¾è±¡ç¼ ç»•åˆ°åœ†ä¸Šå¬èµ·æ¥æŒºå¥‡æ€ªçš„,æœ‰è¿™æ ·çš„æ•°å­¦æ–¹æ³•å—.\n\næœ‰ä¸€ä¸ªä¸œè¥¿,å«åš$y=e^{ix}$.å½“å…¶å›¾è±¡ç”»åœ¨å¤å¹³é¢æ—¶,å°±å‡ºç°äº†æœ‰è¶£çš„äº‹æƒ…:ä¸€ä¸ªåœ†.å¯¹è¿™ä¸ªå…¬å¼åšä¸€äº›åŠ å·¥.\n\n$$\ny=g(t)e^{-2\\pi i ft}\n$$\n\nå¦‚æ­¤,å°±èƒ½å¤Ÿå°†$g(t)$ä»¥$f$é¢‘ç‡ç¼ ç»•.\n\n### å…³äºè´¨å¿ƒ\nä¸Šæ–‡æˆ‘ä»¬å–è´¨å¿ƒçš„xåæ ‡ä½œå›¾,ç°åœ¨éœ€è¦ç¨å¾®ä¿®æ”¹ä¸€ä¸‹.\n\nå®é™…ä¸Š,æˆ‘ä»¬å…³å¿ƒçš„æ˜¯è´¨å¿ƒç›¸å¯¹äºåŸç‚¹çš„åç§»**è·ç¦»**.åŒæ ·,ä»¥å¤å¹³é¢çš„æ–¹å¼æ¥è¡¨ç¤ºè´¨å¿ƒä½ç½®å°±èƒ½å¤ŸåŒæ—¶ä¿ç•™xå’Œyåæ ‡ä¿¡æ¯.\n\nå…³äºå¦‚ä½•æ±‚å–è´¨å¿ƒ,å…¶å®ä¹Ÿå¾ˆç›´è§‚.é€‰å–ç¼ ç»•å›¾è±¡ä¸Šçš„æ•°ä¸ªç‚¹,å–å¹³å‡,å°±æ˜¯è´¨å¿ƒçš„å¤§çº¦ä½ç½®.å½“ç‚¹çš„æ•°ç›®è¾¾åˆ°æé™,æ±‚å’Œå…¬å¼åŒ–ä¸ºç§¯åˆ†,æ‰€æ±‚å³ä¸ºè´¨å¿ƒ.\n\n$$\n\\hat g(f)=\\frac{1}{t_2-t_1} \\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}}\n$$\n\n### ?\nç›®å‰ä¸ºæ­¢,è¿™å‡ ä¹å·²ç»æ˜¯å‚…é‡Œå¶å˜æ¢äº†.åœ¨æ•°å­¦åº”ç”¨æ—¶,å‚…é‡Œå¶å˜æ¢ä¼šå»æ‰å–å‡å€¼,å³\n\n$$\n\\hat g(f)=\\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}}\n$$\n\nä¹Ÿå°±æ˜¯è¯´,å–æ ·çš„æ—¶åŸŸä¿¡å·è¶Šé•¿,è¯¥è´¨å¿ƒçš„åç§»å€¾å‘è¶Šå¤§,è¿™å’Œæˆ‘ä»¬æƒ³è¦çš„æ•ˆæœä¸€è‡´.\n\nè¿™å°±æ˜¯å‚…é‡Œå¶å˜æ¢,å®ç°äº†`æ—¶åŸŸä¿¡å·`åˆ°`é¢‘åŸŸä¿¡å·`çš„è½¬æ¢.\n\næ­¤å¤–,è¿˜æœ‰æ–¹æ³•å°†é¢‘åŸŸä¿¡å·å†æ¬¡é€†å˜æ¢ä¸ºæ—¶åŸŸä¿¡å·çš„æ–¹æ³•.\n\n## åº”ç”¨\nå‚…é‡Œå¶å˜æ¢åœ¨å¾ˆå¤šé¢†åŸŸéƒ½æœ‰é‡è¦ä½œç”¨.åªè¦é—®é¢˜èƒ½è½¬æ¢ä¸ºæ—¶åŸŸé¢‘åŸŸä¹‹é—´çš„å˜åŒ–,å°±æœ‰å‚…é‡Œå¶å˜æ¢çš„ç”¨æ­¦ä¹‹å¤„.\n\næ¯”å¦‚,åœ¨éŸ³é¢‘å¤„ç†è½¯ä»¶ä¸­,å¸¸å¸¸æœ‰ä¸€ä¸ªåŠŸèƒ½å«åš`æ¶ˆé™¤äººå£°`.åŸºäºå‚…é‡Œå¶å˜æ¢æˆ‘ä»¬å¯ä»¥è®¾è®¡ä¸€ä¸ª(è‡³å°‘ç†è®ºä¸Šæœ‰ç”¨)çš„ç®—æ³•.\n\né¦–å…ˆ,ä»»ä½•å£°éŸ³éƒ½æ˜¯ç›¸åº”é¢‘ç‡çš„æ³¢å¯¹æ°”å‹å˜åŒ–å¼•èµ·çš„,ä¹Ÿå°±æ˜¯ä¸åŒ**é¢‘ç‡**çš„æ³¢åœ¨**æ—¶é—´**ä¸Šå åŠ åœ¨ä¸€èµ·,äº§ç”Ÿäº†å£°éŸ³.å°†æºæ³¢ä½¿ç”¨å‚…é‡Œå¶å˜æ¢æ‹†åˆ†åˆ°å¤šä¸ªä¸‰è§’æ³¢ä¸Šå».**åˆ é™¤äººå£°æ‰€åœ¨çš„é¢‘åŸŸ**,å†å°†é¢‘åŸŸä¿¡å·é€†å˜æ¢ä¸ºæ—¶åŸŸä¿¡å·.äººå£°ä¾¿æ¶ˆå¤±äº†.\n\n# ç¦»æ•£å‚…é‡Œå¶å˜æ¢\nè¿ç»­æ„ä¹‰ä¸‹çš„å‚…é‡Œå¶å˜æ¢å…ˆåˆ°æ­¤ä¸ºæ­¢.åœ¨è®¡ç®—æœºä¸­æ‰€å¤„ç†çš„æ•°æ®ä¸€èˆ¬éƒ½æ˜¯ç¦»æ•£çš„.æˆ‘ä»¬éœ€è¦çš„æ˜¯ç¦»æ•£å‚…é‡Œå¶å˜æ¢.\n\nç¦»æ•£æ„ä¹‰ä¸‹çš„æ—¶åŸŸä¿¡å·å’Œé¢‘åŸŸä¿¡å·å°±éƒ½å˜æˆäº†ç‚¹é›†.å½“ä»è¿ç»­å‘ç¦»æ•£è¿‡æ¸¡æ—¶,å¯ä»¥è¿™æ ·æ€è€ƒ:\n\n> åœ¨è¿ç»­çš„å›¾è±¡ä¸Šä»¥ä¸€å®šé—´éš”**å–æ ·**å¾—åˆ°ç¦»æ•£ç‚¹é›†.ä½¿ç”¨è¯¥ç‚¹é›†è¿›è¡Œå‚…é‡Œå¶å˜æ¢.\n\nè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ä¸€å¼€å§‹é‡‡å–çš„è´¨å¿ƒæ±‚è§£æ–¹æ³•,åªä¸è¿‡,è¿™æ¬¡æˆ‘ä»¬ä»ç¼ ç»•æ—¶å°±å–æ ·.(è´¨ç‚¹ä¾ç„¶æ˜¯çœŸæ­£çš„è´¨ç‚¹)\nå¯¹äºç‚¹é›†$g(0\\leq n < N)$,å®ƒçš„å‚…é‡Œå¶å˜åŒ–å°±æ˜¯\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\nç®€å•ç²—æš´.\n\n# å¿«é€Ÿå‚…é‡Œå¶å˜æ¢\nåœ¨äº†è§£äº†å…³äºå‚…é‡Œå¶å˜æ¢çš„ä¸€ç³»åˆ—èƒŒæ™¯ä¸ä¸€ä¸ªåº”ç”¨å,æˆ‘ä»¬å†å›æ¥è§£å†³ä¸€äº›é‡è¦çš„é—®é¢˜.\n\næ ¹æ®å‚…é‡Œå¶å˜æ¢çš„å…¬å¼å®šä¹‰\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\nå…¶æœ´ç´ ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(N^2)$ è¿™ä¸ªå¤æ‚åº¦è¿˜ä¸å¤Ÿä¼˜ç§€.ä¸€ç§å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ç®—æ³•åˆ©ç”¨$e^{ix}$çš„æ€§è´¨,å°†å¤æ‚åº¦é™ä½åˆ°äº†$O(N\\lg N)$.\n\n## å•ä½æ ¹\nç»™$e^{ix}$ä¸ªåå­—.\n\nåœ¨æ•°å­¦ä¸Š, $n$æ¬¡**å•ä½æ ¹**æ˜¯ $n$æ¬¡å¹‚ä¸º1çš„å¤æ•°.å®ƒä»¬ä½äºå¤å¹³é¢çš„å•ä½åœ†ä¸Š,æ„æˆæ­£nè¾¹å½¢çš„é¡¶ç‚¹,å…¶ä¸­ä¸€ä¸ªé¡¶ç‚¹æ˜¯1.\n\nè®°\n\n$$\n\\omega_{n,k}=-e^{i\\frac{2\\pi}{n}k}\n$$\n\nå…¶å‡ ä½•æ„ä¹‰ä¸ºå•ä½åœ†ä¸Šçš„nç­‰åˆ†ç‚¹çš„é¡ºæ—¶é’ˆç¬¬kä¸ª.\n\n> ä¸€èˆ¬æ¥è¯´,å•ä½æ ¹å–é€†æ—¶é’ˆ,ä¸è¿‡è¿™é‡Œä¸ºäº†æ–¹ä¾¿,å–é¡ºæ—¶é’ˆ.\n\nå¦‚åŒä¸‰è§’å‡½æ•°ä¸€æ ·,å•ä½æ ¹å­˜åœ¨ä¸€äº›æ˜¾ç„¶çš„å®šç†.\n\n**æŠ˜åŠ:**$\\omega_{2n,2k}=\\omega_{n,k}$\n\n**åŒ–ç®€:**$\\omega_{n,k+\\frac 2n}=-\\omega_{n,k}$\n\n### ä¿®æ”¹å…¬å¼\næ¥çœ‹åŸæœ¬çš„ç¦»æ•£å‚…é‡Œå¶å˜æ¢å…¬å¼\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\nä½¿ç”¨å•ä½æ ¹æ¥æ›¿æ¢ä¸€ä¸‹\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}\\omega_{N,nk} g(n)\n$$\n\næŒ‰ç…§~~ç¥~~åŒ–ç®€å…¬å¼çš„æŒ‡å¼•,å°†æ±‚å’Œå…¬å¼æŒ‰ç…§å•ä½æ ¹å¥‡å¶æ‹†åˆ†ä¸º2éƒ¨åˆ†.\n\nâ€‹                                                                                                              \n$$\n\\begin{aligned}\n\\hat g(k) &= \\sum_{n=0}^{N-1}\\omega_{N,nk} g(n) \\\\\n&= \\sum_{0 \\leq n < N}\\omega_{N,nk} g(n) \\\\\n&= \\sum_{0 \\leq 2n < N}\\omega_{N,2nk} g(2n) + \\sum_{0 \\leq 2n+1 < N}\\omega_{N,(2n+1)k} g(2n+1) \\\\\n&=\\sum_{0 \\leq 2n < N}\\omega_{N,2nk} g(2n) + \\sum_{0 \\leq 2n+1 < N}\\omega_{N,2nk+k} g(2n+1) \\\\\n&=\\sum_{0 \\leq 2n < N}\\omega_{\\frac N2,nk} g(2n) + \\omega_{N,k}\\sum_{0 \\leq 2n+1 < N}\\omega_{\\frac N2,nk} g(2n+1) \\\\\n&=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k)\n\\end{aligned}\n$$\n\næ³¨æ„åˆ°ä¸ç®¡æ˜¯$\\hat g_{even}(k)$è¿˜æ˜¯$\\hat g_{even}(k)$,å®ƒä»¬éƒ½ä»¥$N/2$ä¸ºå‘¨æœŸ.æ¥ä¸‹æ¥,åº”ç”¨åŒ–ç®€å®šç†\n\n$$\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\nå°†è¿™2ä¸ªå¼å­æ”¾åœ¨ä¸€èµ·\n\n$$\n\\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\nå½“kå–éåŸé—®é¢˜è§„æ¨¡çš„ä¸€åŠæ—¶,å¯ä»¥ç›´æ¥ç”±ç¬¬äºŒä¸ªå¼å­å¾—åˆ°å¦ä¸€åŠ.é—®é¢˜çš„è§„æ¨¡å‡åŠ.é€’å½’æ±‚è§£,æœ€ç»ˆçš„å¤æ‚åº¦å°±é™åˆ°äº†$O(N \\lg N)$.\n\nè¿™å°±æ˜¯`Cooley-Turkey`å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ç®—æ³•.\n\n# å¿«é€Ÿä¹˜æ³•\nå®šä¹‰å¤šé¡¹å¼$A(x)=\\sum_k a_kx^{k+1}$,$B(x)$åŒç†,æ±‚è§£$C(x)=A(x)B(x)$.\n\nå¾ˆå®¹æ˜“çœ‹å‡º,æœ´ç´ ç®—æ³•çš„å¤æ‚åº¦ä¸º$O(N^2)$.\n\nç°åœ¨,æ¥çœ‹å¦‚ä½•ä½¿ç”¨FFTå¿«é€Ÿè®¡ç®—.\n\n## ç‚¹å€¼è¡¨ç¤º\n> å¯¹äºä¸€ä¸ªæ¬¡æ•°ä¸º$n-1$çš„å¤šé¡¹å¼,å…¶å›¾è±¡ä¸Šäº’ä¸ç›¸åŒçš„$n$ä¸ªç‚¹å¯ä»¥å”¯ä¸€ç¡®å®šè¯¥å¤šé¡¹å¼.\n> ...\n> å¦‚åŒç¡®å®šæ··åˆåœ¨ä¸€èµ·çš„å‡ ä¸ªæ³¢ä¸€æ ·.\n\nè‡³äºä¸ºä»€ä¹ˆæ˜¯å¯¹çš„,å¤§å¯åœ¨Googleä¸Šæœç´¢ä¸€ç•ª.\n\nå–$x$ä¸ºæ•°ä¸ªå•ä½æ ¹,åœ¨$A(x)$å’Œ$B(x)$ä¸Šåˆ©ç”¨å•ä½æ ¹çš„æ€§è´¨å¾—åˆ°$A$å’Œ$B$çš„ç‚¹å€¼è¡¨ç¤º,å°†ç‚¹å€¼ç›¸ä¹˜å¾—åˆ°$C$çš„ç‚¹å€¼è¡¨ç¤º.ä¹‹å,å°†$C$çš„ç‚¹å€¼è¡¨ç¤ºå†è½¬æ¢ä¸ºç³»æ•°è¡¨ç¤º.\n\nå—¯?FFTåœ¨å“ª?\n\nå…¶å®åœ¨è¿™é‡Œ,\n\n$$\n\\hat g(\\omega)=A(\\omega)=\\sum_{n}\\omega A[x^{n+1}]\n$$\n\n## ç¦»æ•£å·ç§¯\næœ‰ä¸€ç§**æ•°å­¦è¿ç®—**,å«åš**å·ç§¯**.ç°åœ¨åªè®¨è®ºå®ƒçš„ç¦»æ•£æƒ…å†µ.\n\n$$\n(f * g)(n)=\\sum_{\\tau=-\\inf}^{inf}f(\\tau)g(n-\\tau)\n$$\n\nè¿™ç©æ„çš„æ„ä¹‰...å®åœ¨æ˜¯ä¸æ€ä¹ˆæ˜æ˜¾.ä¸è¿‡å¥½åœ¨æˆ‘ä»¬åªæ˜¯æƒ³ç®—ä¸ªå¤šé¡¹å¼ä¹˜æ³•,ä¹Ÿå°±æ˜¯æŠŠå¤šé¡¹å¼çš„**ç³»æ•°**ç®—æ¥ç®—å»:\n\n$C[x^n]$ è¡¨ç¤ºå¤šé¡¹å¼$C$ä¸­$x^n$é¡¹çš„ç³»æ•°.\n\n$$\nC[x^{n}]=\\sum_{\\tau=0}^{n}A[x^\\tau]B[x^{n-\\tau}]\n$$\n\nå—¯?\n\nå¦‚æœæˆ‘ä»¬è®¾å¤šé¡¹å¼ä¸­ä¸å­˜åœ¨çš„é¡¹çš„ç³»æ•°ä¸º0çš„è¯.\n\n$$\nC[x^{n}]=\\sum_{\\tau=-\\inf}^{\\inf}A[x^\\tau]B[x^{n-\\tau}]\n$$\n\nå“ˆ,\n\n$$\nC[x^n]=(A*B)[x^n]\n$$\n## å·ç§¯å®šç†\nå·ç§¯å®šç†æŒ‡å‡º:\n\n> ä¸€ä¸ªåŸŸä¸­çš„å·ç§¯å¯¹åº”äºå¦ä¸€ä¸ªåŸŸä¸­çš„ä¹˜ç§¯.\n\nè¿™æ„å‘³ç€,ä¸Šé¢è¿™ä¸ªè®¡ç®—(å·ç§¯)å¯¹åº”ç€å¦ä¸€ä¸ªåŸŸé‡Œçš„ä¹˜ç§¯.ä¹Ÿå°±æ˜¯\n\n$$\nF(C[x^n])=F(A[x^n]) \\cdot F(B[x^n])\n$$\n\nè¿™ä¾¿æ˜¯æ·±å±‚åŸç†.å¯¹Aå’ŒBçš„å–æ ·(é¢‘åŸŸ)ç§°ä¸ºAå’ŒBçš„ç‚¹å€¼è¡¨ç¤º,æœ€ç»ˆä»¥ä¹˜ç§¯çš„æ–¹å¼å¾—åˆ°äº†Cçš„ç‚¹å€¼è¡¨ç¤º(é¢‘åŸŸ).ç”¨FFTæ¥è®¡ç®—ä¹˜æ³•çš„è¯´æ³•æ˜¯å¯¹çš„.\n\n# å‚…é‡Œå¶é€†å˜æ¢\nå¦‚ä½•ä»ä¸€ä¸ªé¢‘åŸŸä¿¡å·å†å¾—åˆ°æ—¶åŸŸä¿¡å·?\n\n$$\ng(n)=\\frac 1N\\sum_{k=0}^{N-1}e^{i\\frac{2\\pi}{N}nk} \\hat g(k)\n$$\n\n> æ³¨æ„:æ­¤å¤„çš„1/Nä¸ä¸Šé¢çš„å˜æ¢æ˜¯ç›¸åŒ¹é…çš„.\n\nè¿™ä¸ªå¼å­å¯ä»¥ç†è§£æˆå¯¹å˜æ¢åçš„å¼å­å†å˜æ¢,æ„å‘³ç€å®ƒåŒæ ·å¯ä»¥ç”¨å˜æ¢æ—¶çš„æ€æƒ³æ¥åŠ é€Ÿ.\n\n# FFTçš„C++å®ç°\nä¸€ä¸ªå€¼å¾—æ³¨æ„çš„é—®é¢˜å°±æ˜¯,å¯¹äºå•ä½æ ¹çš„è¿ç®—æ¶‰åŠåˆ°äº†ç²¾åº¦çš„é—®é¢˜.ä½†ç›®å‰è¿˜ä¸éœ€è¦è®¨è®º.\n\n## ç¿»è½¬æ“ä½œ\nå¯ä»¥è§‚å¯Ÿåˆ°,æŒ‰ç…§ä¸Šé¢çš„ç®—æ³•å®ç°,æˆ‘ä»¬éœ€è¦åœ¨æ¯æ¬¡é€’å½’æŒ‰ç…§å¥‡å’Œå¶å°†å–æ ·åˆ†ç»„.ä¸”æ¯æ¬¡é€’å½’éƒ½ä¼šåˆ†ç»„.æ¯æ¬¡åˆ†ç»„éƒ½ä¼šæ¶‰åŠåˆ°æ•°ç»„çš„å¤åˆ¶,å¸¸æ•°è¾ƒå¤§.\n\nè§‚å¯Ÿåˆ†ç»„æ“ä½œä¸­ä¸‹æ ‡çš„å˜åŒ–.\n\n```\n(è¡¨ç¤ºä¸‹æ ‡)\n0 1 2 3 4 5 6 7\n0 2 4 6 | 1 3 5 7\n0 4 | 2 6 | 1 5 | 3 7\n```\n\nå°†å…¶è½¬æ¢ä¸ºäºŒè¿›åˆ¶\n```\n000 001 010 011 100 101 110 111\n000 100 010 110 001 101 011 111\n```\n\nå¯ä»¥å‘ç°,æœ€ç»ˆçš„åˆ†ç»„ç»“æœå°±æ˜¯å°†åŸä¸‹æ ‡äºŒè¿›åˆ¶ç¿»è½¬.æ‰€ä»¥å¯ä»¥ç›´æ¥ä¸€æ¬¡å®Œæˆåˆ†ç»„.\n\næ³¨æ„,**è¿™è¦æ±‚å–æ ·ä¸º2çš„å¹‚æ¬¡**.\n\n## ğŸ¦‹è´è¶æ“ä½œ\nè§£å†³äº†é€’å½’ä¸­ç”±é¡¶è‡³åº•çš„åˆ†ç»„å,æ¥ä¸‹æ¥ä¼˜åŒ–å­é—®é¢˜åˆå¹¶æ—¶çš„æ•°ç»„å¤åˆ¶.\n\nè§‚å¯ŸåŸæ¥çš„åˆå¹¶å¼å­\n\n$$\n\\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\næŒ‰ç…§ç®—æ³•ä¸­çš„å®ç°æ–¹æ³•,å…¶ä¸º\n\n$$\n\\hat g(k)=\\hat g(k)+\\omega_{N,k} \\hat g(k+\\frac N2) \\\\\n\\hat g(k+\\frac N2)=\\hat g(k)-\\omega_{N,k} \\hat g(k+\\frac N2)\n$$\n\næƒ³è¦çœç•¥æ•°ç»„å¤åˆ¶,è¿›è¡ŒåŸåœ°åˆå¹¶,é—®é¢˜å‡ºåœ¨æ–°æ•°å€¼å¤ªæ—©åœ°æ›¿æ¢æ‰äº†æˆ‘ä»¬éœ€è¦çš„æ•°å€¼.\n\nå–è¾…åŠ©å˜é‡,ä¿®æ”¹åŸå¼\n\n$$\nt=\\omega_{N,k} \\hat g(k+\\frac N2)\\\\\n\\hat g(k+\\frac N2)=\\hat g(k)-t\\\\\n\\hat g(k)=\\hat g(k)+t\n$$\n\nè¿™ä¸ªæ“ä½œè¢«ç§°ä¸º\"è´è¶æ“ä½œ\",åå­—å¾ˆæœ‰æ„æ€.\n\n## ä»£ç \nåœ¨è¿™æ®µä»£ç ä¸­åŒæ—¶å»æ‰äº†é€’å½’.\n\n```cpp\nconst double PI=acos(-1);\n\ninline complex<double> gomega(int n,int k,bool rev=false){\n    complex<double> res(cos(2*PI/n*k),sin(2*PI/n*k));\n    if(rev)return conj(res);\n    else return res;\n}\nconst int MAXN=10;\nstruct FFT{\n    complex<double> omega[MAXN],omegaI[MAXN];\n\n    FFT(int n){\n        for(int i=0;i<n;i++){\n            omega[i]=gomega(n,i);\n            omegaI[i]=gomega(n,i,1);\n        }\n    }\n    void transform(complex<double> *a,int n,const complex<double> *omega){\n        for(int i=0,j=0;i<n;i++){\n            if(i>j)swap(a[i],a[j]);\n            //äºŒè¿›åˆ¶æ¢ä½\n            for(int l=n/2;(j^=l)<l;l>>=1);\n        }\n        for(int l=2;l<=n;l<<=1){\n            int m=l/2;\n            for(complex<double> *p=a;p!=a+n;p+=l){\n                for(int i=0;i<m;i++){\n                //è´è¶æ“ä½œ\n                    complex<double> t=omega[n/l*i]*p[m+i];\n                    p[m+i]=p[i]-t;\n                    p[i]+=t;\n                }\n            }\n        }\n    }\n    void dft(complex<double> *a,int n){\n        transform(a,n,omega);\n    }\n    void idft(complex<double> *a,int n){\n        transform(a,n,omegaI);\n        for(int i=0;i<n;i++)a[i]/=n;\n    }\n};\n```\n\nå¦‚æœæƒ³è¦å®ç°å¿«é€Ÿä¹˜æ³•,åªè¦å°†2ä¸ªå¤šé¡¹å¼çš„ç³»æ•°å‡½æ•°ä¼ å…¥è¿›è¡Œå˜æ¢,å˜æ¢ç»“æœç›¸ä¹˜å¹¶é€†å˜æ¢å³å¯.\n\n### åº”ç”¨\n\n#### å¿«é€Ÿä¹˜æ³•\næŒ‡å¿«é€Ÿå¤§æ•°ä¹˜æ³•ã€‚\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN=300000;\nconst double PI=acos(-1);\n\ninline complex<double> gomega(int n,int k,bool rev=false){\n    complex<double> res(cos(2*PI/n*k),sin(2*PI/n*k));\n    if(rev)return conj(res);\n    else return res;\n}\nstruct FFT{\n    complex<double> omega[MAXN],omegaI[MAXN];\n\n    FFT(){\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            omega[i]=gomega(n,i);\n            omegaI[i]=gomega(n,i,1);\n        }\n    }\n\n    void transform(complex<double> *a,int n,const complex<double> *omega){\n        for(int i=0,j=0;i<n;i++){\n            if(i>j)swap(a[i],a[j]);\n            //äºŒè¿›åˆ¶æ¢ä½\n            for(int l=n/2;(j^=l)<l;l>>=1);\n        }\n        for(int l=2;l<=n;l<<=1){\n            int m=l/2;\n            for(complex<double> *p=a;p!=a+n;p+=l){\n                for(int i=0;i<m;i++){\n                    //è´è¶æ“ä½œ\n                    complex<double> t=omega[n/l*i]*p[m+i];\n                    p[m+i]=p[i]-t;\n                    p[i]+=t;\n                }\n            }\n        }\n    }\n    void dft(complex<double> *a,int n){\n        transform(a,n,omega);\n    }\n    void idft(complex<double> *a,int n){\n        transform(a,n,omegaI);\n        for(int i=0;i<n;i++)a[i]/=n;\n    }\n};\n\ncomplex<double> a[2][MAXN];\nint ans[MAXN];\nFFT fft;\nint main(){\n\n    int nlen;cin>>nlen;\n    int n=1;\n    //æ ¹æ®åŸç†ï¼Œ\b\bnå¿…é¡»å–å¤§äº2nlençš„æ•°ï¼Œæ‰èƒ½æ»¡è¶³å–æ ·è¦æ±‚å’Œåè½¬æ“ä½œè¦æ±‚\n    while(n<2*nlen)n*=2;\n    fft.init(n);\n\n\n    for(int i=0;i<2;i++){\n        string inp;cin>>inp;\n        for(int j=0,k=inp.size()-1;j<inp.size();j++,k--){\n            a[i][j]=complex<double>(inp[j]-'0',0);\n        }\n        fft.dft(a[i],n);\n    }\n    for(int i=0;i<n;i++)a[0][i]=a[0][i]*a[1][i];\n    fft.idft(a[0],n);\n    int reslen=nlen+nlen-1;\n    for(int i=reslen-1,k=0;i>=0;i--,k++)\n        ans[k]=(int)floor(a[0][i].real()+0.5);\n    /*\n    for(int i=0;i<reslen;i++)cout<<ans[i]<<\" \";\n    cout<<endl;\n    */\n    for(int i=0;i<MAXN;i++){\n        ans[i+1]+=ans[i]/10;\n        ans[i]%=10;\n    }\n    int ptr=MAXN-1;\n    while(ans[ptr]==0)ptr--;\n    for(;ptr>=0;ptr--)cout<<ans[ptr];\n    cout<<endl;\n\n    return 0;\n}\n```","categories":["study"]},{"title":"did-i-write-qsort-right","url":"%2F2019%2F07%2F12%2Fdid-i-write-qsort-right%2F","content":"ä¼—æ‰€å‘¨çŸ¥ï¼Œå¿«é€Ÿæ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n\\lg n)$çš„ã€‚ç„¶è€Œå› ä¸ºæˆ‘å¤ªèœï¼Œå†™å‡ºæ¥çš„å¿«é€Ÿæ’åºä¸€ä¸å°å¿ƒå°±æˆäº†$O(n^2)$...\n\n<!--more-->\n\n## è¿™ä¸ªè¾£é¸¡é—®é¢˜\nè¿™ä¸ªåº”è¯¥éƒ½çŸ¥é“ï¼Œå½“å¾…æ’åºæ•°ç»„å·²ç»æœ‰åºæ—¶ï¼Œå›ºå®šé€‰æ‹©æŸä¸€ä¸ªä½ç½®çš„æ•°å­—å½“å“¨å…µçš„å¿«æ’ä¼šå˜æˆ$O(n^2)$ã€‚ä¸€ä¸ªè§£å†³æ–¹æ³•å°±æ˜¯éšæœºé€‰æ‹©å“¨å…µï¼Œæˆ–è€…å¹²è„†å°†è¾“å…¥çš„æ•°ç»„æ‰“ä¹±åå†æ’åºã€‚\n\nç„¶è€Œï¼Œå¦‚æœè¾“å…¥çš„æ•°ç»„æ•°å­—å…¨éƒ¨ç›¸åŒå‘¢ï¼Ÿ\n\nå½“ç„¶è¿™åœ¨å®é™…ä¸­å¾ˆå°‘è§ï¼Œä½†æ˜¯åœ¨å®ç°çš„æ—¶å€™å°±è¦å°å¿ƒã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‰€å®ç°çš„å¿«æ’å¿…é¡»å¯¹äºç›¸åŒæ•°å­—ä¹Ÿäº¤æ¢ä½ç½®ï¼Œå¦åˆ™å°±ä¼šé€€åŒ–ä¸º$O(n^2)$ã€‚\n\næ¯”å¦‚è¯´ï¼Œè¿™ä¸ª\n```cpp\n    void quicksort(int left,int right)\n    {\n    int i,j,t,temp;\n    if(left>right)\n       return;\n\n    temp=a[left]; //tempä¸­å­˜çš„å°±æ˜¯åŸºå‡†æ•°\n    i=left;\n    j=right;\n    while(i!=j)\n    {\n       //é¡ºåºå¾ˆé‡è¦ï¼Œè¦å…ˆä»å³è¾¹å¼€å§‹æ‰¾\n       while(a[j]>=temp && i<j)\n    j--;\n       //å†æ‰¾å³è¾¹çš„\n       while(a[i]<=temp && i<j)\n    i++;\n       //äº¤æ¢ä¸¤ä¸ªæ•°åœ¨æ•°ç»„ä¸­çš„ä½ç½®\n       if(i<j)\n       {\n    t=a[i];\n    a[i]=a[j];\n    a[j]=t;\n       }\n    }\n    //æœ€ç»ˆå°†åŸºå‡†æ•°å½’ä½\n    a[left]=a[i];\n    a[i]=temp;\n\n    quicksort(left,i-1);//ç»§ç»­å¤„ç†å·¦è¾¹çš„ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹\n    quicksort(i+1,right);//ç»§ç»­å¤„ç†å³è¾¹çš„ ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹\n    }\n```\nè¿˜æœ‰è¿™ä¸ªï¼Œ\n```cpp\nvoid quick_sort(int s[], int l, int r)\n{\n    if (l < r)\n    {\n\t\t//Swap(s[l], s[(l + r) / 2]); //å°†ä¸­é—´çš„è¿™ä¸ªæ•°å’Œç¬¬ä¸€ä¸ªæ•°äº¤æ¢ å‚è§æ³¨1\n        int i = l, j = r, x = s[l];\n        while (i < j)\n        {\n            while(i < j && s[j] >= x) // ä»å³å‘å·¦æ‰¾ç¬¬ä¸€ä¸ªå°äºxçš„æ•°\n\t\t\t\tj--;  \n            if(i < j) \n\t\t\t\ts[i++] = s[j];\n\t\t\t\n            while(i < j && s[i] < x) // ä»å·¦å‘å³æ‰¾ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„æ•°\n\t\t\t\ti++;  \n            if(i < j) \n\t\t\t\ts[j--] = s[i];\n        }\n        s[i] = x;\n        quick_sort(s, l, i - 1); // é€’å½’è°ƒç”¨ \n        quick_sort(s, i + 1, r);\n    }\n}\n\n```\nå®ƒä»¬éƒ½ä¼šè·³è¿‡ç›¸åŒçš„æ•°å­—ï¼Œæ¯æ¬¡æ’åºåå“¨å…µæ€»ä¼šåœ¨è¾¹ç•Œä¸Šï¼Œå¯¼è‡´ç®—æ³•åŠ£åŒ–åˆ°$O(n^2)$ã€‚\n\nå¤§æ¦‚å°±æ˜¯è¿™å›äº‹ï¼Œæ²¡åˆ«çš„äº†ã€‚è¿™ç§æƒ…å†µå½“ç„¶æœ‰æ”¹è¿›çš„å¿«é€Ÿæ’åºå¯ä»¥ç›´æ¥é¿å…è¿™ç§ç½•è§çš„æƒ…å†µï¼Œåœ¨ä¸å¤§å¹…åº¦æ”¹åŠ¨ç®—æ³•çš„å‰æä¸‹ï¼Œå°±è¦å¯¹ç›¸åŒçš„å…ƒç´ ä¹Ÿè¿›è¡Œæ¢ä½æ‰å¯ä»¥ï¼Œå³ä½¿ä¼šå¢åŠ äº¤æ¢æ¬¡æ•°ã€‚","tags":["æ’åº"],"categories":["é—²æ‰¯"]},{"title":"åŸºäºPBDSçš„splay","url":"%2F2019%2F07%2F12%2Fimplment-of-splay-based-on-PBDS%2F","content":"\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntree<int,null_type,greater<int>,rb_tree_tag,tree_order_statistics_node_update> bbt;\nmap<int,string> ef;\nint main(){\n    int n;cin>>n;\n    while(n--){\n        int op;\n        cin>>op;\n        if(op==1){\n            string name;\n            int value;\n            cin>>name>>value;\n            ef[value]=name;\n            bbt.insert(value);\n        }else if(op==2){\n            int v;cin>>v;\n            if(!bbt.erase(v))cout<<\"NO\"<<endl;\n            else cout<<ef[v]<<endl;\n        }else if(op==3){\n            int v;cin>>v;\n            if(bbt.find(v)==bbt.end())cout<<\"NO\"<<endl;\n            else cout<<bbt.order_of_key(v)+1<<endl;\n        }else if(op==4){\n            int r;cin>>r;\n            r--;\n            auto it=bbt.find_by_order(r);\n            if(it!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }else if(op==5){\n            int v;cin>>v;\n            auto it=bbt.find(v);\n            if(it!=bbt.end() && (--it)!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }else if(op==6){\n            int v;cin>>v;\n            auto it=bbt.find(v);\n            if(it!=bbt.end() &&(++it)!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }\n    }\n    return 0;\n}\n\n```","tags":["splay"]}]