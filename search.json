[{"title":"HTTPæœåŠ¡å™¨ä¸Rust","url":"%2F2020%2F01%2F18%2Fhttp-server-in-rust%2F","content":"\nä»¥ä¸€ä¸ªhttpæœåŠ¡å™¨å…¥æ‰‹,è®°ç‚¹ä¸œè¥¿.\n\n<!--more-->\n\n```rust\nuse std::thread;\nuse std::sync::mpsc;\nuse std::sync::Arc;\nuse std::sync::Mutex;\npub struct ThreadPool{\n    workers:Vec<Worker>,\n    sender: mpsc::Sender<Message>,\n}\n\ntype Job=Box<dyn FnOnce()+Send+'static>;\n\nenum Message{\n    NewJob(Job),\n    Terminate,\n}\n\nimpl ThreadPool{\n    /// Create thread pool\n    /// \n    /// The number of threads in pool\n    /// \n    /// # Paincs\n    /// \n    /// `new` will panic when size is not great than 0.\n    pub fn new(size:usize)->ThreadPool{\n        assert!(size>0);\n\n        let (sender,receiver)=mpsc::channel();\n        let receiver=Arc::new(Mutex::new(receiver));\n\n        let mut workers=Vec::with_capacity(size);\n        for id in 0..size{\n            workers.push(Worker::new(id,receiver.clone()));\n        }\n\n        ThreadPool{\n            workers,\n            sender\n        }\n    }\n\n    pub fn execute<F>(&self,f:F)\n        where F:FnOnce()+Send+'static\n    {\n        let job=Box::new(f);\n        self.sender.send(Message::NewJob(job)).unwrap();\n\n    }\n}\n\nimpl Drop for ThreadPool{\n    fn drop(&mut self){\n        for _ in &mut self.workers{\n            self.sender.send(Message::Terminate).unwrap();\n        }\n        for worker in &mut self.workers{\n            println!(\"shutting down worker {}\",worker.id );\n\n            if let Some(thread)=worker.thread.take(){\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker{\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker{\n    fn new(id:usize,receiver: Arc<Mutex<mpsc::Receiver<Message>>>)->Worker{\n        let thread=thread::spawn(move|| {\n            loop{\n                let message=receiver.lock().unwrap().recv().unwrap();\n\n                match message{\n                    Message::NewJob(job)=>{\n                        println!(\"Worker {} got job.\",id );\n                        job();\n                    },\n                    Message::Terminate=>{\n                        println!(\"Worker {} is terminating.\",id);\n                        break;\n                    }\n                }\n                \n            }\n        });\n\n        Worker{\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n```\n```rust\nuse std::io::prelude::*;\nuse std::net::{TcpListener,TcpStream};\nuse std::fs;\nuse std::time::Duration;\nuse std::thread;\nuse automan::ThreadPool;\n\nfn main() {\n    let listener=TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(1);\n\n    for stream in listener.incoming(){\n        let stream=stream.unwrap();\n\n        pool.execute(|| {\n            handler(stream);\n        });\n    }\n}\n\nfn handler(mut stream: TcpStream){\n    let mut buffer = [0; 512];\n    stream.read(&mut buffer).unwrap();\n\n    let get = b\"GET / HTTP/1.1\\r\\n\";\n    let sleep = b\"GET /sleep HTTP/1.1\\r\\n\";\n\n    let (status_line, filename) = if buffer.starts_with(get) {\n        (\"HTTP/1.1 200 OK\\r\\n\\r\\n\", \"hello.html\")\n    } else if buffer.starts_with(sleep) {\n        thread::sleep(Duration::from_secs(5));\n        (\"HTTP/1.1 200 OK\\r\\n\\r\\n\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\\r\\n\\r\\n\", \"404.html\")\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n\n    let response = format!(\"{}{}\", status_line, contents);\n\n    stream.write(response.as_bytes()).unwrap();\n    stream.flush().unwrap();\n}\n```\n\n## æºç ç»„ç»‡\n\nè¿˜æ˜¯æºç çš„ç»„ç»‡å½¢å¼..åœ¨ä¸€ä¸ªåŒ…é‡Œ,å…è®¸æœ‰å¤šä¸ªcrate.å¦‚æœç¡¬è¦è¯´,ç±»ä¼¼äºvs studioé‡Œçš„è§£å†³æ–¹æ¡ˆå’Œé¡¹ç›®ä¹‹é—´çš„å…³ç³».ä½†æ˜¯,rustè¿˜æœ‰ä¸€äº›ä¸é‚£ä¹ˆæ˜¾ç„¶çš„é™åˆ¶\n\n* æœ€å¤šæœ‰ä¸€ä¸ªlib crate\n* å¯ä»¥æœ‰å¤šä¸ªbinary crate\n\nä¹Ÿå°±æ˜¯è¯´,ä¸Šé¢çš„ä¸¤ä¸ªä»£ç ä¸€ä¸ªä½œä¸ºlib,ä¸€ä¸ªåšä¸ºbin,æ˜¯æ»¡è¶³è¦æ±‚çš„.\n\nå…¶æ¬¡,æ–‡ä»¶å’Œç›®å½•ä¹Ÿå°†åŒæ—¶ä½œä¸ºæ¨¡å—è¢«çº³å…¥å¤„ç†.å½“éœ€è¦å¼•ç”¨æŸä¸ªæ–‡ä»¶å†…çš„ä»£ç æ—¶,éœ€è¦åœ¨libä¸­å†™å…¥\n\n```rust\nmod <name>;\n```\n\n## FnOnce\n\n```rust\ntype Job=Box<dyn FnOnce()+Send+'static>;\n```\n\nå¾—ç›Šäºrustçš„å†…å­˜æ¨¡å‹,è¯ç”Ÿå‡ºè¿™ä¸ªå¥‡è‘©ç©æ„.åæ­£è¿˜æ˜¯å’Œå˜é‡çš„æ‰€æœ‰æƒæœ‰å…³ç³».`FnOnce`çš„é—­åŒ…ä¼šè·å–å…¶æ•è·å˜é‡çš„æ‰€æœ‰æƒ.å¦å¤–`FnMut`çš„é—­åŒ…è·å¾—å…¶æ•è·å˜é‡çš„å¯å˜å€Ÿç”¨,`Fn`è·å¾—ä¸å¯å˜å€Ÿç”¨.\n\nè‡³äºåˆ°åº•ä»€ä¹ˆé—­åŒ…ä¼šå®ç°å“ªä¸€ä¸ª,æ˜¯ç”±ç¼–è¯‘å™¨æ ¹æ®å®é™…æƒ…å†µåˆ¤æ–­çš„.æƒ³è¦å¼ºåˆ¶å°†å˜é‡æŒªè¿›é—­åŒ…æ—¶,å¯ä»¥å‰ç¼€`move`,å°±åƒ`Worker`çš„`run`é‡Œçš„ä»£ç ä¸€æ ·.å› ä¸ºå½“`run`æ‰§è¡Œå®Œ,receiverå°†ä¼šè¢«ä¸¢å¼ƒ,ä»è€Œå½±å“åˆ°é—­åŒ…é‡Œçš„å¼•ç”¨.\n\nå…¶ä»–çš„å‡ ä¸ª`+`å·å’Œ`Send`,`'static`ä»€ä¹ˆçš„.`+`å°±æ˜¯`+`,è¦æ±‚è¯¥ç±»å‹å¿…é¡»åŒæ—¶å®ç°è¿™ä¸‰ç§`trait`.Sendæ˜¯ä¸ª`trait`(Types that can be transferred across thread boundaries).`'static`ç­‰æ—¶é—´å‘¨æœŸå®é™…ä¸Šä¹Ÿæ˜¯`trait`.\n\n## Boxå’Œdyn\n\n```rust\ntype Job=Box<dyn FnOnce()+Send+'static>;\n```\n\n......æ²¡å®Œ..å‰é¢é‚£ä¸ª`dyn`ç©æ„ä¹Ÿæ˜¯æŒºå¥‡æ€ª,éœ€è¦å’Œ`impl`å…³é”®å­—å¯¹æ¯”ç†è§£.\n\nRustçš„ä¸€å¤§ç‰¹ç‚¹å°±æ˜¯é›¶ä»£ä»·æŠ½è±¡.ä¾‹å¦‚å¯¹äºæ³›å‹,ä¸€ç§å®ç°0æŠ½è±¡çš„æ–¹æ³•å°±æ˜¯åœ¨ç¼–è¯‘é˜¶æ®µå•ä¾‹åŒ–.C++ä¹Ÿæ˜¯å¦‚æ­¤å¤„ç†.\n\nä¸è¿‡æœ‰ä¸€ç§æƒ…å†µç›®æµ‹C++æ— æ³•å®ç°é›¶æŠ½è±¡:åœ¨C++ä¸­,å¦‚æœå­˜åœ¨çˆ¶ç±»`A`æœ‰è™šæ–¹æ³•`f`,è€Œå­ç±»`B`é‡å†™äº†`f`,åˆæœ‰ä¸€ä¸ªå‡½æ•°`g(A a)`ä¼šè°ƒç”¨`f`.å½“æŠŠ`B`ä½œä¸ºå‚æ•°ä¼ ç»™`g`æ—¶,C++é€šè¿‡ä¸€ç§å«`è™šå‡½æ•°è¡¨`çš„æ–¹å¼å®ç°è°ƒç”¨`B`å†™çš„`f`.è¿™ç§è¡Œä¸ºæ˜¯å‘ç”Ÿåœ¨è¿è¡Œæ—¶çš„.\n\nå¯¹äºRustæ¥è®²,è™½ç„¶æ²¡æœ‰ç±»ä¸ç»§æ‰¿,è¿™ç§æ“ä½œå®é™…ç­‰ä»·äº`trait`.ä¸Šé¢çš„æƒ…å†µå¯¹ç­‰äºå­˜åœ¨`trait A`,å®ƒå®šä¹‰äº†ä¸€ä¸ª`f`,`B`å®ç°äº†`A`,`g`åŒä¸Š.Rust**èƒ½å¤Ÿåœ¨ç¼–è¯‘é˜¶æ®µ**å°±ç¡®å®šä¼ ç»™`g`çš„æ˜¯è°,å¹¶ä¸”ä¼˜åŒ–æ‰å®ƒ.ä¸è¿‡è¿™ç§ä¼˜åŒ–ä¹Ÿæ˜¯æœ‰é™åº¦çš„.å¦‚æœæŠŠä¸€å †å®ç°`A`çš„ç»“æ„çš„æŒ‡é’ˆå­˜åˆ°æ•°ç»„æˆ–è€…å…¶ä»–å†…å­˜ç»“æ„é‡Œ,é‚£Rustä¹Ÿæ˜¯æ— èƒ½ä¸ºåŠ›çš„,åªèƒ½åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ†å‘.\n\nå†å›æ¥çœ‹`impl`å’Œ`dyn`.å®ƒä»¬åˆ†åˆ«å¯¹åº”äº†èƒ½å¤Ÿä¼˜åŒ–(é™æ€åˆ†å‘)å’ŒåŠ¨æ€åˆ†å‘çš„æƒ…æ™¯.\n\nå¦å¤–,é‡‡ç”¨åŠ¨æ€åˆ†å‘çš„ç»“æ„ä¹Ÿä¸èƒ½åœ¨ç¼–è¯‘æ—¶ç¡®å®šå¤§å°,æ‰€ä»¥å¿…é¡»å¤–åŒ…`Box`.\n\n## Arcå’ŒMutex\n\n```rust\nfn new(id:usize,receiver: Arc<Mutex<mpsc::Receiver<Message>>>)->Worker;\n```\n\nè¯´çœŸçš„,çœ‹åˆ°`Worker`çš„è¿™ä¸ªå‡½æ•°ç­¾å,å½“æ—¶å°±åƒå.Rustè¿™ç©æ„,åŠ¨ä¸åŠ¨å°±ä¼šåµŒå¥—ä¸Šå¥½å‡ å±‚çš„`<>`.\n\né¦–å…ˆå…³äº`Arc`...å…ˆ`Rc`.ä¸€èˆ¬æƒ…å†µä¸‹,ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒæ˜¯å¯ä»¥åœ¨ç¼–è¯‘é˜¶æ®µå°±ç¡®å®šä¸‹æ¥çš„.ä½†æ˜¯æ€»ä¼šæœ‰ä¸å¦‚æ„çš„æ—¶å€™,å½“æœ‰å¤šä¸ªç»“æ„åŒæ—¶äº«æœ‰æŸä¸ªå˜é‡çš„æ‰€æœ‰æƒ(ä¾‹å¦‚ä¸€æ£µæ ‘),å°±ä¸å¤ªå¥½ç¡®å®šå…¶å®é™…çš„é”€æ¯æ—¶æœº,è€Œä¸”Rustä¹Ÿä¸ä¼šç»™ä½ æœºä¼šå…±äº«æ‰€æœ‰æƒ.`Rc`æ˜¯ä¸€ä¸ªå¼•ç”¨è®¡æ•°æŒ‡é’ˆ,å˜é‡æ‰€æœ‰æƒç”±å®ƒä¿ç®¡,è€Œå®ƒèƒ½å¤Ÿæä¾›å¤šä»½åªè¯»å€Ÿç”¨.\n\nç„¶è€Œ`Rc`çº¿ç¨‹ä¸å®‰å…¨,`Arc`çº¿ç¨‹å®‰å…¨.ä¸è¿‡`Arc`æ€§èƒ½å¼±äº`Rc`.\n\nå…¶æ¬¡æ˜¯`Mutex`...å°±æ˜¯ä¸ªé”...\n\nè‡³äºä¸ºå•¥ç”¨é”,å…ˆçœ‹`mpsc`,Multi-producer, single-consumer FIFO queue communication primitives.\n\nä¸€å¤´é›¾æ°´çš„ç¼©å†™...ç®€è€Œè¨€ä¹‹,è¿™ä¸ªä¸œè¥¿çš„è®¾å®šç±»ä¼¼äºgoé‡Œ`channel`,åŒæ—¶æ˜¯å¤šç”Ÿäº§è€…,**å•æ¶ˆè´¹è€…**æ¨¡å¼.æœ¬èº«ä½¿ç”¨æ²¡ä»€ä¹ˆç»•çš„åœ°æ–¹.ç»•çš„åœ°æ–¹åœ¨äºå¤šçº¿ç¨‹å…±äº«å’Œå•æ¶ˆè´¹è€…æ¨¡å¼çš„å†²çª,æ‰€ä»¥å¼•å…¥äº†é”,ä¿è¯åŒæ—¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿæ¶ˆè´¹æ¶ˆæ¯.\n\né¡ºä¾¿åæ§½ä¸€å¥è¿™ä»£ç å†™çš„...\n\n```rust\nlet message=receiver.lock().unwrap().recv().unwrap();\n```\n\n## è¿˜æœ‰\n\n`unwrap`,`unwrap`,`unwrap`,`unwrap`,`unwrap`,`unwrap`,`unwrap`,`unwrap`,`unwrap`,`unwrap`,`unwrap`,`unwrap`...\n\nå½“ç„¶å®ƒä»¬æœ¬æ¥ä¼šè¢«æ›¿ä»£æˆæ›´å¤æ‚çš„é”™è¯¯å¤„ç†.\n\n## å°ç»“\n\nç”¨Rustå†™çš„ç¨‹åº,å’Œè‡ªå·±è„‘è¢‹æ–—æ™ºæ–—å‹‡å‡ å›åˆ,å†å’Œç¼–è¯‘å™¨æ–—æ™ºæ–—å‹‡(å•æ–¹é¢æŒ¨æ)å‡ ç™¾å›åˆ,æœ€åæ˜¯çœŸçš„éš¾ä»¥å‡ºç°bug,æ¯•ç«Ÿä¸€åˆ‡éƒ½è¢«ç®¡çš„æ­»æ­»çš„.æˆ‘è¿˜çœ‹åˆ°Rusté‡Œä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„ç©æ„å«é”™è¯¯é©±åŠ¨,è¯´æ˜¯å…ˆæŠŠä»£ç å¤§æ¦‚æ¨¡æ ·çç³Šä¸Š,ç„¶åè®©ç¼–è¯‘å™¨checkä¸€é,å†ä¸€æ­¥æ­¥æ”¹æ‰ç¼–è¯‘å™¨çš„æŠ¥é”™~~é¡ºä¾¿å†™ä»£ç ~~,æœ€åå°±èƒ½åœ¨ç¼–è¯‘å™¨çš„åæ§½ä¸‹å®Œç¾å®ç°ç¨‹åº,å†åŠ ç‚¹æµ‹è¯•å°±é½å…¨äº†...\n\nè™½ç„¶æ•´ä¸ªè¯­æ³•çœ‹èµ·æ¥å¤æ‚å•°å—¦,ä¸è¿‡æ— æ³•å¦è®¤è¿™äº›è¯­å¥å¯¹äºå·¥ç¨‹æ¥è®²å®é™…ä¸Šéƒ½æ˜¯å¿…è¦çš„.æ‰€ä»¥è¿™ç©æ„çš„æ°”è´¨å†³å®šå®ƒä¸å¤ªé€‚åˆä½œä¸ºæ‰“æ¯”èµ›æ—¶ç”¨çš„è¯­è¨€.ç¿»äº†ç¿»CFå¥½å‡ åœºæ¯”èµ›,é›¶æ˜Ÿæœ‰å‡ ä¸ªRustçš„ä»£ç ä¹Ÿéƒ½æ²¡æœ‰æ¶‰åŠä»»ä½•æ•°æ®ç»“æ„,æœ¬æ¥è¿˜æƒ³ç»ä»°ä¸€ä¸‹ä»–ä»¬ä¼šæ€ä¹ˆå¤„ç†ç”Ÿå‘½å‘¨æœŸä¸€ç±»çš„é—®é¢˜.\n\nå¦‚æœæœ‰æœºä¼š,æ‹¿Rustå†™è¯¾è®¾åº”è¯¥å¯ä»¥ç©ä¸€ç©(å¤§æ¦‚ä¼šè¢«å¼ºè¡Œç”¨Cç³»è¯­è¨€).è‡³äºåŸæœ¬æƒ³æ‹¿Rustå†™ä¸ªæœ¬åœ°è¯„æµ‹å™¨,è¿˜æ˜¯ç®—äº†,æœ‰ç©ºå†è¯´å§.","tags":["rust"],"categories":["é—²æ‰¯"]},{"title":"Rust and OS","url":"%2F2020%2F01%2F17%2Fos-in-rust-2%2F","content":"\nrustæ˜¯ä¸€é—¨å¾ˆæœ‰æ„æ€çš„è¯­è¨€,å®ƒçš„å†…å­˜æ¨¡å‹å’Œ0ä»£ä»·æŠ½è±¡ç­‰éƒ½å¾ˆå¸å¼•äºº.å‡ å¤©é€Ÿæˆæƒ³æŠ˜è…¾å†™ç‚¹å¥½ç©çš„ä¸œè¥¿.\n\n> rustçš„0ä»£ä»·æŠ½è±¡æœ‰äº›è¿‡åˆ†.ä¸€å †é«˜é˜¶å‡½æ•°,awaitå’Œasyncä¹Ÿèƒ½åšåˆ°0ä»£ä»·,å’Œå†™æ±‡ç¼–æ€§èƒ½å·®ä¸äº†å¤šå°‘,æ˜¯æœ‰äº›æœæ°”.\n\nä¸¥æ ¼æ¥è¯´è¿™ç¯‡æ˜¯è¯»ä¹¦ç¬”è®°.\n\n<!--more-->\n\n## ä¸€ç‚¹å°æ’æ›²: å¦‚ä½•åœ¨windowsä¸Šçš„rustä½¿ç”¨gnuå·¥å…·é“¾\n\nä¼—æ‰€å‘¨çŸ¥windowså¯¹ç¼–ç¨‹çš„ä½“éªŒä¸å¦‚*nixå’Œosx,rustç”šè‡³åœ¨Windowsä¸Šçš„é…ç½®éƒ½éº»çƒ¦ä¸€ç‚¹.æ¯”å¦‚è¯´,ä¸ºäº†è£…ä¸ªrust,å¯èƒ½éœ€è¦å¦å¤–å‡†å¤‡vs2019.è¿™ä¸¤ä¸ªä¸œè¥¿çš„ç©ºé—´å ç”¨å·®äº†ä¸æ­¢ä¸€ç‚¹åŠç‚¹.\n\næŠ˜è…¾äº†ä¸€å¤©.å¦‚æœèƒ½ä»”ç»†é˜…è¯»å®˜æ–¹çš„rustupæ–‡æ¡£çš„è¯,è¯´ä¸å®šå°±ä¸ç”¨è¿™ä¹ˆå¤´ç§ƒäº†.\n\nä¸»è¦çš„é€‰é¡¹åœ¨äºé€‰å¥½hostå’Œversion.åœ¨rustupæ‰§è¡Œå®‰è£…æ—¶,ä¿®æ”¹ä¸º\n\n```bash\nx86_64-pc-windows-gnu\nstable-gnu\n```\n\nè¿™æ ·å®‰è£…çš„ç‰ˆæœ¬æ‰ä¼šä½¿ç”¨gnuå·¥å…·é“¾.ä½†æ˜¯å¦‚æ­¤åšçš„åæœ,æˆ‘è¿˜ä¸å¤ªæ¸…æ¥š.\n\n## ä»¥Cå¯¹æ’Rust\nè‡ªå·±ä¸»è¦è¿˜æ˜¯Cç³»è¯­è¨€ç”¨æˆ·,æ‰€ä»¥å®é™…å­¦ä¹ æ—¶,æ€»æ˜¯ä¼šç›¸æ¯”è¾ƒç€è¿›è¡Œ.\n\n### å˜é‡å£°æ˜\n\n```rust\nlet x:i32=10;\n```\né¦–å…ˆ,rustä¹Ÿä½¿ç”¨åˆ†å·.æ¯ä¸ªå˜é‡çš„å£°æ˜å¼€å¤´ä½¿ç”¨let,å¹¶ä¸”å°†å˜é‡ç±»å‹è·Ÿéšåç§°åé¢.\n\néšç€æ—¶é—´å‘å±•,ç°ä»£è¯­è¨€å‡ ä¹éƒ½æŠ›å¼ƒäº†å˜é‡ç±»å‹åœ¨å·¦ä¾§çš„å£°æ˜æ–¹å¼.è¿™å¤§æ¦‚æ˜¯ä¸€ä¸ªå®è·µä¸Šçš„ç»éªŒ.å·¦ä¾§çš„ç±»å‹å£°æ˜ä¼šåœ¨å¤æ‚çŠ¶å†µä¸‹é€ æˆæå¤§çš„ç†è§£éšœç¢.æ¯”å¦‚\n\n```cpp\nvoid (*signal(int, void (*fp)(int)))(int);\n```\n\né˜…è¯»æ­¤ç±»ä¸œè¥¿,æ€»ä¼šæ˜¯è®©äººå¤´ç–¼.ä½ ä¼šå‘ç°,ä¸ºäº†ç†è§£å®ƒåœ¨å¹²å˜›,è¿™ç§å£°æ˜æ–¹å¼ä½¿å¾—é˜…è¯»é¡ºåºå¿…é¡»æ˜¯é¡ºæ—¶é’ˆçš„èºæ—‹å¼,æ˜¾å¾—å¾ˆä¸è‡ªç„¶å’Œæ˜ç¡®.ä¸€æ—¦è°ƒæ•´ç±»å‹åˆ°å³ä¾§æ—¶,è¿™ä¸ªé—®é¢˜ä¼¼ä¹å°±ä¸å­˜åœ¨äº†.\n\næ‰€ä»¥ä¸ä½†å˜é‡çš„å£°æ˜ç±»å‹ä½äºåç§°å·¦ä¾§,åŒ…æ‹¬å‡½æ•°å‚æ•°ç±»å‹ è¿”å›å€¼ä¹Ÿéƒ½æ˜¯ä½äºå³ä¾§.\n\nå¦å¤–.\n\n| Type     | Refer     |\n| :------- | :--------:|\n| i8,i32,i64,i128 | short,int,long long  |\n| u8,u32,u64,u128 | unsigned  |\n| f32,f64    | float,double    |\n| bool     | bool     |\n| char     | char     |\n\nå½“ç„¶,rustä¹Ÿç¼ºä¸äº†å…ƒç»„.\n\nå¦å¤–å€¼å¾—æ³¨æ„çš„æ˜¯rustçš„charä¸stræ˜¯utf8çš„,è€Œä¸æ˜¯ascii.æ‰€ä»¥åœ¨éå†æ—¶ä¹Ÿä¸èƒ½æŒ‰ç…§cä¸­çš„æ–¹å¼å¤„ç†.\n\nrustä¸­çš„å˜é‡**é»˜è®¤ä¸ºä¸å¯æ›´æ”¹**.å¿…é¡»æ·»åŠ `mut`å…³é”®å­—æ‰ä½œä¸ºä¸€èˆ¬æ„ä¹‰ä¸Šçš„å˜é‡è€ƒè™‘.\n\n```rust\nlet mut x=9;\nx=6;\n\nlet y=9;\ny=8; // this is not allowed.\n```\n\n### æ§åˆ¶æµ\n\nrusté‡Œçš„ifä¸€ç±»,æ²¡æœ‰å°æ‹¬å·.(æ˜¯ä¸æ˜¯æœ‰äº›åƒGo)\n\n```rust\nif <expr> {\n    //do something\n}else if <expr>{\n    //do what\n}else{\n    //yeah?\n}\n```\n\nå¾ªç¯ä¹Ÿæœ‰äº›ä¸ä¸€æ ·\n\n```rust\nloop{\n}\n\nwhile <expr>{\n}\n\nfor i in 1..9{\n}\n//è¿™ä¸ªæ˜¯å³é—­åŒºé—´\nfor i in 1..=9{\n}\n```\n\næœ€ä¸»è¦çš„æ˜¯,å¤šå‡ºäº†ä¸€ä¸ª`loop`æ­»å¾ªç¯,forå¾ªç¯ä»¥è¿­ä»£æ–¹å¼å®Œæˆ.ä¸è¿‡,å…¶å®è¿˜æœ‰ä¸€ä¸ªé‡è¦çš„ä¿¡æ¯,å®ƒä»¬éƒ½æ˜¯è¡¨è¾¾å¼,èƒ½å¤Ÿè¿”å›å€¼.\n\nå¾—ç›Šäºrustçš„é›¶ä»£ä»·æŠ½è±¡,è¿­ä»£çš„ä½¿ç”¨ç›¸æ¯”ç›´æ¥çš„`for(int i=1;i<=9;i++)`å‡ ä¹æ²¡æœ‰åŒºåˆ«.\n\n```rust\nlet flag=if a>0{\n    1\n}else{\n    -1\n};\n```\n\næœ€åä¸€è¡Œä¸å¸¦å¼•å·,åˆ™ä½œä¸ºè¿”å›å€¼è¿”å›.è¿™æ ·ç”¨ifæ˜¯å…è®¸çš„.(æ‰€ä»¥æˆ‘ä»¬ä¹Ÿæ²¡æœ‰ä¸‰å…ƒè¿ç®—ç¬¦å¯ç”¨äº†)\n\n### å‡½æ•°å£°æ˜\n\n```rust\nfn func(a:i32,b:i32) -> i32{\n    a+b\n}\n```\n\nrustå†…çš„æ‰€æœ‰å…³é”®å­—éƒ½çœç•¥åˆ°äº†æç®€,ä¹Ÿç®—æ˜¯ä¸€ç§é£æ ¼.\n\n## åŒ…ç®¡ç†\n\nrustå‘å±•å¤ªå¿«äº†,å„ç§æ–‡ç« å„è¯´å„è¯.è¿™é‡Œä¸»è¦æ˜¯ä¸€ä¸ª`crate`(ä¸€ä¸ªåŒ…)å†…çš„ç»“æ„.\n\nrustä½¿ç”¨`mod`æ¥æ˜ç¡®çš„æ ‡æ³¨ä¸€ä¸ªæ¨¡å—.å…³é”®å­—é»˜è®¤ä¸ºç§æœ‰,ä½¿ç”¨`pub`æ¥æ ‡æ³¨ä¸€ä¸ªå¯¹å¤–å…¬å¼€çš„å…³é”®å­—.åœ¨2018æ ‡å‡†,æ–‡ä»¶ä¹Ÿä¼šä½œä¸ºä¸€ä¸ªæ¨¡å—,æ–‡ä»¶åä½œä¸ºæ¨¡å—å,æ–‡ä»¶å†…å…³é”®å­—åŒæ ·é»˜è®¤ç§æœ‰.ä½¿ç”¨`use`å…³é”®å­—æ¥æ˜¾å¼çš„å¼•å…¥æŸä¸ªæ¨¡å—.\n\nå¯¹äºç¬¬ä¸‰æ–¹æ¨¡å—,2018ä¸å†éœ€è¦æ˜¾å¼æ ‡æ³¨å¼•å…¥`crate`.(ä½†æ˜¯ä»ç„¶éœ€è¦`use`)\n\n## ä¸€ä¸ªç‹¬ç«‹çš„rust\n\nè¿›è¡Œç³»ç»Ÿç¼–ç¨‹ä¸åŒäºåº”ç”¨çº§ç¼–ç¨‹.ä¸€èˆ¬æƒ…å†µæˆ‘ä»¬å¹¶ä¸ä¼šåœ¨æ„ç¼–ç¨‹ä¸­çš„è¯­è¨€ç‰¹æ€§å’Œç³»ç»Ÿç‰¹æ€§çš„æ˜ç¡®ç•Œé™,ä½†æ˜¯è¿™é‡Œ,å¿…é¡»å°†å®ƒä»¬å‰¥ç¦»å¼€,å»æ‰ç³»ç»Ÿç‰¹æ€§.æ¯•ç«Ÿæˆ‘ä»¬è¦ç¼–å†™OS.\n\n* å–æ¶ˆæ ‡å‡†åº“\n\næ•´ä¸ªç¨‹åºçš„å¯åŠ¨æµç¨‹å¤§æ¦‚å®é™…ä¸Š:ç”±ç³»ç»Ÿè£…è½½Cè¿è¡Œæ—¶å¯åŠ¨,Cè¿è¡Œæ—¶è°ƒèµ·rustè¿è¡Œæ—¶.rustè¿è¡Œæ—¶æ‰§è¡Œå®Œæˆæœ‰å…³æ ˆæº¢å‡ºä¿æŠ¤ å¼‚å¸¸å¤„ç†æœºåˆ¶ç­‰æ“ä½œåå°†æ§åˆ¶æƒäº¤ç»™`fn main`.æ‰€ä»¥ä¸€æ—¦å–æ¶ˆäº†æ ‡å‡†åº“,æˆ‘ä»¬å°±è¦è‡ªè¡Œè§£å†³è¿™äº›é—®é¢˜.\n\nå½“å–æ¶ˆäº†æ ‡å‡†åº“æ—¶,æˆ‘ä»¬å°±è¦è¢«è¿«å¤„ç†ä»¥ä¸‹çš„ä¸œè¥¿.\n\n* è‡ªå®šå¼‚å¸¸å¤„ç†å‡½æ•°\n* å–æ¶ˆå¼‚å¸¸é€€æ ˆæ“ä½œ\n* è‡ªå®šç¨‹åºå…¥å£\n* å–æ¶ˆCè¿è¡Œæ—¶ä¾èµ–\n\n```rust\n#![no_std] //ä¸ä½¿ç”¨rustæ ‡å‡†åº“\n#![no_main] //å–æ¶ˆrustå±‚ä¸Šçš„å…¥å£\n\nuse core::panic::PanicInfo;\n\n#[no_mangle] //ä¸è®©rustç¼–è¯‘å™¨é‡æ•´å…¥å£å‡½æ•°çš„åç§°.è¿™å°†ä¼šåœ¨ä¹‹åè¢«ä½¿ç”¨åˆ°\npub extern \"C\" fn _start() -> ! {\n    //ç¨‹åºå°†ä¼šä»æ­¤å¼€å§‹\n    loop {}\n}\n\n//å½“ç¨‹åºå‘ç”Ÿå¼‚å¸¸æ—¶,å°±ä¼šè°ƒç”¨è¯¥å‡½æ•°å¤„ç†.\n//æ­£å¸¸æƒ…å†µä¸‹è¯¥å‡½æ•°ç”±æ ‡å‡†åº“å®ç°,æ ‡å‡†åº“æ‰“å°å¼‚å¸¸ä¿¡æ¯å,å°†ä¼šåœ¨ç¨‹åºé€€å‡ºå‰é€€æ ˆè¿”è¿˜ç¨‹åºå ç”¨çš„å†…å­˜.\n#[panic_handler]\nfn panic(_info: &PanicInfo) -> ! {\n    loop {}\n}\n```\n\né™¤äº†ä»£ç ä¸­å¤šäº†è®¸å¤šä¸€èˆ¬æ¥è§¦ä¸åˆ°çš„ç»†èŠ‚,åœ¨cargoçš„é…ç½®ä¸­ä¹Ÿæœ‰ä¸€äº›ä¸œè¥¿.\n\n```toml\n[package]\nname = \"kaos\"\nversion = \"0.1.0\"\nauthors = [\"Author Name <author@example.com>\"]\n\n\n[profile.dev]\npanic = \"abort\"\n\n[profile.release]\npanic = \"abort\"\n```\n\nä»£ç å°†panicç½®ä¸ºäº†abortä¸»è¦æ˜¯å› ä¸ºé€€æ ˆçš„æ“ä½œ.åœ¨æ™®é€šç¼–ç¨‹ä¸­,abortå°†ä¼šè®©ç¨‹åºç›´æ¥å´©æºƒé€€å‡º,å†…å­˜äº¤ç”±ç³»ç»Ÿé‡Šæ”¾;panicåˆ™æ˜¯ç”±ç¨‹åºå®Œæˆå†…å­˜é‡Šæ”¾.é€€æ ˆæ˜¯ä¸€ä¸ªç³»ç»Ÿç›¸å…³çš„æœºåˆ¶,æ— æ³•åœ¨OSå±‚ä¸Šå®Œæˆ,æ­¤å¤„ä½¿ç”¨ä¸å¸¦é€€æ ˆçš„abort.\n\nç¼–è¯‘æŒ‡ä»¤\n\n```bash\n$ cargo build --target thumbv7em-none-eabihf\n```\n\n\n## CPUå¼‚å¸¸\n\nCPUå¼‚å¸¸å¾ˆå¸¸è§,æ¯”å¦‚\n\n* é™¤0é”™è¯¯.\"æŠŠ0ä¸ªé¥¼å¹²åˆ†ç»™0ä¸ªæœ‹å‹,æ¯ä¸ªæœ‹å‹æœ‰å¤šå°‘ä¸ªé¥¼å¹²,è¿™ç§é—®é¢˜å¾ˆæ²¡æœ‰æ„æ€,æ—¢æ²¡æœ‰é¥¼å¹²ä¹Ÿæ²¡æœ‰æœ‹å‹.\" --æŸäººå·¥æ™ºéšœåŠ©æ‰‹S`DELETE`i\n* å†…å­˜é¡µé”™è¯¯.è®¿é—®äº†éæ³•å†…å­˜.\n* éæ³•æ“ä½œç¬¦.ç¨‹åºæ‰§è¡Œäº†ä¸€ä¸ªcpuä¸è®¤è¯†çš„æœºå™¨ç .\n* ä¸€èˆ¬ä¿æŠ¤æ€§é”™è¯¯.\n* äºŒæ¬¡é”™è¯¯.æŒ‡ç¬¬ä¸€æ¬¡é”™è¯¯çš„æ¢å¤è¿‡ç¨‹ä¸­åˆå‘ç”Ÿçš„é”™è¯¯\n* ä¸‰æ¬¡é”™è¯¯.æŒ‡ç¬¬äºŒæ¬¡é”™è¯¯çš„æ¢å¤è¿‡ç¨‹ä¸­åˆå‘ç”Ÿçš„é”™è¯¯\n* ~~å››æ¬¡é”™è¯¯~~æ²¡æœ‰å¥—å¨ƒäº†.ä¸‰æ¬¡é”™è¯¯å°†ä¼šç›´æ¥å¼•èµ·CPUé‡å¯.\n\nä¸€ä¸ªéœ€è¦å¼ºè°ƒçš„ç‚¹æ˜¯è¿™äº›é”™è¯¯ç±»å‹éƒ½æ˜¯**äº‹å…ˆçº¦å®š**çš„,å½“å¼‚å¸¸å‘ç”Ÿæ—¶,CPUä¿è¯ä¼šä»å†…å­˜çš„æŒ‡å®šä½ç½®è¯»å–ä¸­æ–­è¡¨,å°†ä¸é”™è¯¯ç›¸å…³çš„ä¿¡æ¯å‹å…¥æ ˆå†…,å°†ç¨‹åºè¿è¡Œè½¬åˆ°ä¸­æ–­è¡¨çš„å¤„ç†å‡½æ•°ä»£ç ä½ç½®,ä»æ­¤å¤„å¼€å§‹æ‰§è¡Œ.åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­æ¶‰åŠçš„çº¦å®šæœ‰\n\n* ä¸­æ–­è¡¨æ ¼å¼\n* ä¸­æ–­å¤„ç†å‡½æ•°æ ¼å¼\n* CPUè°ƒç”¨è¯¥å‡½æ•°çš„æ–¹å¼\n\nä¸­æ–­å¤„ç†å‡½æ•°å’Œä¸€èˆ¬å‡½æ•°ä¸ä¸€æ ·.\n\n## å¯„å­˜å™¨ä¸æ ˆ\nå¯„å­˜å™¨æœ‰ç”±è°ƒç”¨è€…ä¿å­˜å’Œè¢«è°ƒç”¨è€…ä¿å­˜ä¸¤ç§,ä½œä¸ºå‡½æ•°å‚æ•°ä¼ é€’æ•°æ®çš„å¯„å­˜å™¨ä¹Ÿæœ‰å›ºå®šçš„ä½¿ç”¨(rdi,rsi,rdx,rcx...),è¿”å›å€¼é»˜è®¤ç”¨raxä¿å­˜ç­‰ç­‰.å®é™…ä¸Šè¿™ç§è¡Œä¸ºæ˜¯å®Œå…¨è¯­è¨€å±‚é¢çš„,è¿›ä¸€æ­¥çš„,CSAPPä¸­ä»‹ç»çš„è§„èŒƒæ˜¯Cè¯­è¨€é‡‡ç”¨çš„.æ›´è¯¦ç»†çš„ä¿¡æ¯éœ€è¦å‚è§`System V ABI`(ABI: Application Binary Interface).\n\nä¸çŸ¥é“æ˜¯ä¸æ˜¯æˆ‘ä¹¦çœ‹å¾—å¤ªè‰,æ„Ÿè§‰ä¹¦é‡Œæ²¡è¯´?ç°åœ¨å¦‚æœæœ‰ä¸€é—¨è¯­è¨€ä¸éµå®ˆè¿™ç§è§„èŒƒ,é‚£ä¹ˆä¸€æ—¦ä¸¤é—¨è¯­è¨€è¦é“¾æ¥åœ¨ä¸€èµ·ç›¸äº’è°ƒç”¨,å°±ä¼šäº§ç”Ÿä¸å¯é¢„æµ‹çš„ç»“æœ.è¿™ä¹Ÿæ˜¯åœ¨C++ä¸­ä½¿ç”¨`extern \"C\"`çš„åŸå› ,è¿™ä¸ªæ ‡è¯†ä¼šå‘ŠçŸ¥ç¼–è¯‘å™¨ä½¿ç”¨Cçš„è§„èŒƒç”Ÿæˆç»“æœ.ä¸å·§çš„æ˜¯,CPUä¸­æ–­çš„å¤„ç†å‡½æ•°ä¸éµå®ˆCè§„èŒƒ(.\n\né¡ºä¾¿,Rustç›®å‰æ²¡æœ‰å±äºè‡ªå·±çš„è§„èŒƒ.å¦å¤–,å…¶å®C++ä¹Ÿæ²¡æœ‰,ä½†æ˜¯å…¶ç¼–è¯‘å™¨çš„å®ç°æœ‰.\n\næ ˆç»“æ„ä¹Ÿæ˜¯è¿™æ ·.ä¸åŒç¼–è¯‘å™¨å¯èƒ½ä¼šç»™å‡ºæœ‰äº›ä¸ä¸€æ ·çš„ä½¿ç”¨ç­–ç•¥.\n\nä¸ºäº†ç”Ÿæˆç¬¦åˆä¸­æ–­å¤„ç†å‡½æ•°è§„èŒƒçš„ç»“æœ,éœ€è¦æ³¨æ˜`extern \"x86-interrupt\"`,å®ƒå®ç°äº†è¿™ä¸ªè§„èŒƒ,ä¸è¿‡åŒæ—¶ä¹Ÿæ©ç›–äº†å¾ˆå¤šç»†èŠ‚.éœ€è¦å¼ºè°ƒ,ä¸é€šè¿‡å®ƒ,ä»…é å¾’æ‰‹ä¹Ÿæ˜¯å¯ä»¥å®Œæˆçš„.","tags":["Rust"],"categories":["é—²æ‰¯"]},{"title":"Seen Another Thing","url":"%2F2020%2F01%2F17%2Fi-see-another-thing%2F","content":"***thanks for supervision.***","categories":["æ¢¦è¯"]},{"title":"Codeforces Round #612 (Div. 2)","url":"%2F2020%2F01%2F14%2Fcf1287%2F","content":"\n## C\næ— è„‘DP.è®¾çŠ¶æ€$f(i,j,0/1)$è¡¨ç¤ºå·²ç»è®¾ç½®äº†$i$ä½,ç”¨äº†$j$ä¸ªå¶æ•°,ç¬¬$i$ä½æ˜¯å¶æ•°/å¥‡æ•°.ç„¶å\n\n$$\n\\begin{aligned}\nf(i,j,0)&=\\min\\{f(i-1,j-1,0),f(i-1,j-1,1)+1\\} \\\\\nf(i,j,1)&=\\min\\{f(i-1,j,0)+1,f(i-1,j,1)\\}\n\\end{aligned}\n$$\n\nä»¥$i=1$ä½œä¸ºå¼€å§‹,å› ä¸ºç¬¬1ä½ä¸èƒ½ç®—ä»£ä»·.\n\n```cpp\n// missing?\n```\n\n## D\nä¸€ä¸ªäº‹å®æ˜¯,ä¸¤æ£µå­ğŸŒ³çš„é—´å¤§å°å…³ç³»ä¸ä¼šå½±å“å…¶å†…éƒ¨èŠ‚ç‚¹çš„æ—¢å®šå…³ç³».\n\nä»¥æ­¤,ç›´æ¥dfs,ä»åº•å±‚å‘ä¸Šæ„é€ ç›¸å¯¹å¤§å°é¡ºåº.åˆå¹¶æ—¶å­æ ‘é—´çš„ç›¸å¯¹å¤§å°æ²¡æœ‰å½±å“,æ‰€ä»¥ç›´æ¥å‰åæ¥åœ¨ä¸€èµ·å°±å¥½,å†æŠŠå½“å‰èŠ‚ç‚¹æ’åˆ°åˆé€‚çš„ä½ç½®ä½¿å…¶æ»¡è¶³cçš„æ¡ä»¶.\nå…¨éƒ¨å®Œæˆåå†å¯¹èŠ‚ç‚¹ç»Ÿä¸€æ ‡å·.\n\næœ€å¼€å§‹å…ˆæ ‡äº†å·,ç„¶åè¶Šå†™è¶Šéº»çƒ¦,ç”Ÿæ°”.\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int MAXN=2010;\nconst int MAXV=2010,MAXE=4020;\nint tick=0;\n \nstruct Edge{\n    int v,n;\n}edges[MAXE];\nint head[MAXV];\nint idx=0;\nint sz[MAXV];\nvoid adde(int u,int v){\n    edges[++idx].v=v;\n    edges[idx].n=head[u];\n    head[u]=idx;\n}\nint name[MAXV];\nint cur[MAXV][MAXV];\nint dfs0(int u,int fa){\n    sz[u]=1;\n    for(int ei=head[u];ei;ei=edges[ei].n){\n        Edge &e=edges[ei];\n        if(e.v==fa)continue;\n        sz[u]+=dfs0(e.v,u);\n    }\n    if(sz[u]==1){\n        name[u]=tick;\n        cur[u][tick]++;\n        tick+=2000;\n    }\n    return sz[u];\n}\nint target[MAXV];\nbool ok=1;\nvector<int> dfs(int u,int fa){\n    vector<int> res;\n    for(int ei=head[u];ei;ei=edges[ei].n){\n        Edge &e=edges[ei];\n        if(e.v==fa)continue;\n        vector<int> cur=dfs(e.v,u);\n        for(auto it=cur.begin();it!=cur.end();it++){\n            res.push_back(*it);\n        }\n    }\n    if(target[u]>res.size())ok=0;\n    else res.insert(res.begin()+target[u],u);\n    return res;\n}\nint main(){\n    int vlen;cin>>vlen;\n    int root;\n    for(int i=1;i<=vlen;i++){\n        int fa;\n        cin>>fa>>target[i];\n        if(fa!=0){\n            adde(fa,i);\n        }else root=i;\n    }\n \n    vector<int> res=dfs(root,0);\n    if(ok){\n        cout<<\"YES\"<<endl;\n        for(int i=0;i<res.size();i++){\n            name[res[i]]=i;\n        }\n        for(int i=1;i<=vlen;i++){\n            cout<<name[i]+1<<\" \";\n        }\n        cout<<endl;\n    }else{\n        cout<<\"NO\"<<endl;\n    }\n \n    return 0;\n}\n```","categories":["coding"]},{"title":"I Realized Something","url":"%2F2020%2F01%2F13%2Fi-see-something%2F","content":"\næ— è¯å¯è¯´.","categories":["æ¢¦è¯"]},{"title":"CF1285D Dr.Evil Underscores","url":"%2F2020%2F01%2F13%2Fproblem-dr-evil-underscores%2F","content":"\nToday, as a friendship gift, Bakry gave Badawy n integers a1,a2,â€¦,an and challenged him to choose an integer X such that the value max1â‰¤iâ‰¤n(aiâŠ•X) is minimum possible, where âŠ• denotes the bitwise XOR operation.\n\nAs always, Badawy is too lazy, so you decided to help him and find the minimum possible value of max1â‰¤iâ‰¤n(aiâŠ•X).\n\n<!--more-->\n\n## åˆ†æ\n\nå°†è¾“å…¥æŒ‰ç…§äºŒè¿›åˆ¶ä½ä»é«˜ä½å¼€å§‹å»ºæ ‘,å°±èƒ½çœ‹å‡ºæ¥,ä¸€æ—¦ç¡®å®šäº†é«˜ä½$i$å¡«1è¿˜æ˜¯0å,åªä¼šæœ‰ä¸€æ£µå­æ ‘å½±å“ç­”æ¡ˆ.å¦ä¸€æ£µå­æ ‘çš„æ‰€æœ‰æ•°å­—éƒ½å› ä¸º$i$ä½ä¸Šçš„å¼‚æˆ–ç»“æœä¸º0è€Œå®šå°äºå¦ä¸€ä¸ªå­æ ‘.\n\næ ‘ä¸ç”¨çœŸçš„å»ºå‡ºæ¥,è¿™æ ·å°±å¯ä»¥åšäº†.\n\n## ä»£ç \n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <limits>\n#include <vector>\nusing namespace std;\nusing ll=long long;\nconst ll LMAX=numeric_limits<ll>::max();\nconst int MAXN=100010;\n \n//int nlen;\n//int num[MAXN];\nvector<int> num;\n \nint dfs(int ptr,const vector<int> &vec){\n    if(ptr<0)return 0;\n    vector<int> one,zero;\n    for(auto i:vec){\n        if((i>>ptr)&1==1)one.push_back(i);\n        else zero.push_back(i);\n    }\n    /*\n    cout<<\"====vec====\"<<endl;\n    for(auto i:one)cout<<i<<\",\";\n    cout<<endl;\n    for(auto i:zero)cout<<i<<\",\";\n    cout<<endl;\n    cout<<\"===========\"<<endl;\n    */\n    if(one.size()==0) return dfs(ptr-1,zero);\n    if(zero.size()==0) return dfs(ptr-1,one);\n    //cout<<\"add\"<<(1<<ptr)<<endl;\n \n    return (1<<ptr)+min(dfs(ptr-1,zero),dfs(ptr-1,one));\n}\n \n \nint main(){\n    ios::sync_with_stdio(false);\n \n    int nlen;cin>>nlen;\n    for(int i=0;i<nlen;i++){\n        int x;cin>>x;\n        num.push_back(x);\n    }\n \n    cout<<dfs(30,num)<<endl;\n \n    return 0;\n}\n```","categories":["coding"]},{"title":"æ–°æ•™åŠ¡è§£æ","url":"%2F2019%2F12%2F27%2Fthe-new-jwgl%2F","content":"\nå­¦æ ¡æ¢æ•™åŠ¡äº†?çªå¦‚å…¶æ¥çš„æƒŠå–œ,ç»“æœç¬¬ä¸€å¤©æ•™åŠ¡å‡ºäº†ä¸ªé”….\n\næ‰’æ‰’ä»£ç çœ‹çœ‹å¼€å‘è¿™ä¸ªæ•™åŠ¡çš„å…¬å¸æ°´å¹³,å½»åº•å¤±æœ›.\n\nè¿™ä¸ªæ•™åŠ¡ç³»ç»Ÿçš„é—®é¢˜è¿œä¸æ­¢æ—¶åŒº,æœ€å¤§çš„é—®é¢˜æ˜¯å®ƒè¡¨é¢ä¸Šç›¸æ¯”å…ˆå‰çš„ç³»ç»Ÿ...ä¼¼ä¹...æ²¡å•¥...é•¿è¿›?\n\n## é¦–é¡µ\n### ç¼–ç æ–¹å¼\né¦–å…ˆ,æ¥çœ‹è¿™æ•™åŠ¡å¦‚ä½•å¤„ç†ç™»å½•ä¿¡æ¯.\n\n<!--more-->\n\n```js\nfunction submitForm1() {\n    try {\n        var xh = document.getElementById(\"userAccount\").value;\n        var pwd = document.getElementById(\"userPassword\").value;\n        if (xh == \"\") {\n            alert(\"ç”¨æˆ·åä¸èƒ½ä¸ºç©ºï¼\");\n            return false;\n        }\n        if (pwd == \"\") {\n            alert(\"å¯†ç ä¸èƒ½ä¸ºç©ºï¼\");\n            return false;\n        }\n        var account = encodeInp(xh);\n        var passwd = encodeInp(pwd);\n        var encoded = account + \"%%%\" + passwd;\n        document.getElementById(\"encoded\").value = encoded;\n        var jzmmid = document.getElementById(\"Form1\").jzmmid;\n        document.getElementById(\"userPassword\").value = \"\";\n        return true;\n    } catch (e) {\n        alert(e);\n        return false;\n    }\n}\n```\n\nè¿™æ®µä»£ç ç”¨äº†ä¸€ç§éå¸¸è§„çš„ç™»å½•æ–¹å¼.å°†è´¦å·å’Œå¯†ç ç¼–ç åç”¨`%%%`è¿æ¥,ä½œä¸ºçœŸæ­£çš„ç™»å½•è¯·æ±‚å‘åˆ°æœåŠ¡å™¨\n\n%%%(???)æ¥çœ‹çœ‹è¿™`encodeInp`æ˜¯å•¥ç©æ„.\n\n```js\neval(function(p,a,c,k,e,d){e=function(c){return(c<a?\"\":e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;}('b 9=\"o+/=\";p q(a){b e=\"\";b 8,5,7=\"\";b f,g,c,1=\"\";b i=0;m{8=a.h(i++);5=a.h(i++);7=a.h(i++);f=8>>2;g=((8&3)<<4)|(5>>4);c=((5&s)<<2)|(7>>6);1=7&t;k(j(5)){c=1=l}v k(j(7)){1=l}e=e+9.d(f)+9.d(g)+9.d(c)+9.d(1);8=5=7=\"\";f=g=c=1=\"\"}u(i<a.n);r e}',32,32,'|enc4||||chr2||chr3|chr1|keyStr|input|var|enc3|charAt|output|enc1|enc2|charCodeAt||isNaN|if|64|do|length|ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789|function|encodeInp|return|15|63|while|else'.split('|'),0,{}))\n```\n\nè¿™æ®µä»£ç æ˜¯æ··æ·†è¿‡çš„base64ç®—æ³•.**è¿™å…¬å¸å¼€å‘çš„æ•™åŠ¡ç³»ç»Ÿçš„ç™»å½•ä¿¡æ¯å±…ç„¶ç”¨å¯é€†ç¼–ç ,è„‘å­å‘¢?**\n\n\n### å‰ç«¯è´Ÿè½½å¹³è¡¡\n\n```js\nfunction selectServer(uName) {\n    var enableServers = true;//æ˜¯å¦å¯ç”¨å¤šæœåŠ¡å™¨ true/false\n    var serversArray = new Array();//æœåŠ¡å™¨åˆ—è¡¨\n\n\n    serversArray[0] = \"http://[DELETED].10:8080/jsxsd1/\";\n\n    serversArray[1] = \"http://[DELETED].11:8080/jsxsd/\";\n\n    serversArray[2] = \"http://[DELETED].12:8080/jsxsd/\";\n\n    serversArray[3] = \"http://[DELETED].13:8080/jsxsd/\";\n\n    serversArray[4] = \"http://[DELETED].14:8080/jsxsd/\";\n\n    serversArray[5] = \"http://[DELETED].15:8080/jsxsd/\";\n\n    serversArray[6] = \"http://[DELETED].16:8080/jsxsd/\";\n\n    serversArray[7] = \"http://[DELETED].17:8080/jsxsd/\";\n\n\n    var loginUrl = \"xk/LoginToXk\";\n    if (enableServers == true) {\n        if (!/[^\\d]/.test(uName)) {//å¿…é¡»ä¸ºæ•°å­—\n            var modVal = eval(uName % serversArray.length);\n            loginUrl = serversArray[modVal] + loginUrl;\n        } else {\n            loginUrl = serversArray[0] + loginUrl;\n        }\n    } else {\n        loginUrl = \"/jsxsd\" + loginUrl;\n    }\n    return loginUrl;\n}\n```\n\n**æ•™åŠ¡åœ¨å‰ç«¯ä½œè´Ÿè½½å¹³è¡¡**\n\nè¿™æ®µä»£ç æ˜¯å®Œå…¨é¢å‘éœ€æ±‚ç¼–å†™çš„.\n\n1. éœ€è¦è´Ÿè½½åªåœ¨é€‰è¯¾æ—¶,å­¦ç”Ÿå­¦å·åˆ†å¸ƒå‡åŒ€.\n2. å¤§å®¶éƒ½æ˜¯æ­£å¸¸ä½¿ç”¨ç³»ç»Ÿ,ä¸ä¼šæœ‰äººæ¥ææˆ‘.\n\nå¦‚æœæœ‰ä»»ä½•ä¸€æ¡ä¸æ»¡è¶³,å°±ç™½çäº†.\n\nä¸è¿‡è¿™ä¸ª`else`æ˜¯ä»€ä¹ˆ?\n```js\nif (!/[^\\d]/.test(uName)) {//å¿…é¡»ä¸ºæ•°å­—\n    var modVal = eval(uName % serversArray.length);\n    loginUrl = serversArray[modVal] + loginUrl;\n} else {\n    loginUrl = serversArray[0] + loginUrl;\n}\n```\n\n\n\n## åå°é¦–é¡µ\nåå°æ˜¯ä¸€ä¸ªæ¡†æ¶åµŒå¥—çš„æ¨¡å¼.å¦å¤–æ–°æ•™åŠ¡ç½‘é¡µå…ƒç´ çš„é•¿å®½æ˜¯å†™æ­»çš„.\n\n### å¤§é‡æ‹¼å†™é”™è¯¯\n\n{% asset_img loadkb.png è¯¾è¡¨è¯·æ±‚ %}\n\næ•™åŠ¡çš„ä¸­è‹±æ–‡æ··è¡€å‘½åæ³•`åŠ è½½è¯¾è¡¨`.\n\n{% asset_img panle.png æ‹¼å†™é”™è¯¯ %}\n\nçœ‹æ¥è¯¥å…¬å¸ç¡®å®é€‚åˆç”¨æ‹¼éŸ³,è¿™ä¸ªæ‹¼å†™é”™è¯¯å‡ºç°äº†æ— æ•°æ¬¡.\n\n### åå°å¯†ç åŠ å¯†\n\nå¥½å§,æˆ‘æ‰¿è®¤,å½“æˆ‘æ‰“å¼€ç™»å½•åçš„é¦–é¡µå,æˆ‘ç¡®å®çœ‹åˆ°äº†è¿™å®¶å…¬å¸çš„åŠªåŠ›.\n\n\n```js\nfunction opengld(){\n    //...\n\t//å–å¾—userid\n\tvar userid = '[DELETED]';\n\tvar userpsw = '[DELETED]';\n\t//å–å¾—userid\n\tdocument.getElementById(\"ticket\").value = userid+\"#\"+userpsw;\n}\n```\n\nåç«¯ä½¿ç”¨çš„åŠ å¯†æ–¹å¼ä¸º**æ²¡æœ‰ä»»ä½•åŠ ç›çš„MD5æ‘˜è¦**.\n\n**è¿™ä¸ªæ˜¯æå…¶å¹¼ç¨šä¸”ä¸¥é‡çš„å®‰å…¨éšæ‚£**.\n\nå¦å¤–,è¿˜èƒ½çœ‹å‡ºæ¥è¿™å¥—ç³»ç»Ÿåœ¨å¼€å‘æ—¶æ²¡æœ‰ä»»ä½•çº¦å®š,éšæ€§å†™.å‰é¢ç™»å½•ç”¨`%%%`,è¿™é‡Œç”¨`#`.\n\n### æ•°æ®æäº¤æ–¹å¼\næ•´ä¸ªåå°æäº¤æ•°æ®çš„æ–¹å¼,å…¨æ˜¯éšè—è¡¨å•+jsèµ‹å€¼æäº¤.\n\n## å“åº”æ•°æ®\n\n### æ—¶é—´\n\nå…¶HTTPæœåŠ¡ä»ç„¶æ˜¯å®Œç¾çš„æ ¼æ—å°¼æ²»æ—¶é—´,åˆ°æ–‡ç« å‘å¸ƒæ—¶ä¹Ÿæ²¡æ”¹.æˆ‘ä¸çŸ¥é“æ”¹ä¸‹æ—¶é—´å¯¹äºè¯¥å…¬å¸è¿ç»´æ¥è¯´éš¾åº¦æœ‰å¤šå¤§.\n\n### Cookie\n\nå¯ä»¥å‘ç°CookieåŒæ ·æ˜¯MD5åŠ å¯†äº†ä»€ä¹ˆç©æ„ä¸œè¥¿.\n\n> æœªå®Œå¾…ç»­\n\n## æ–°æ•™åŠ¡ æ—§æ€ç»´\n\nç»“è®º,**è¿™ä¸è¯¥æ˜¯ä¸€ä¸ªç°ä»£æ•™åŠ¡è¯¥æœ‰çš„æ°´å¹³**,ä»å¤´åˆ°å°¾éƒ½é€æ¼ç€ä¸ä¸“ä¸šçš„è¡¨ç°,éšä¾¿æŠ“å‡ ä¸ªæœ¬ç§‘ç”Ÿå¤šå­¦ç‚¹htmlå’Œjqueryå’Œjavaçš„æ°´å¹³.è¿csså’Œè‹±è¯­éƒ½ä¸ç”¨å­¦,æ¯•ç«Ÿè¿™csså’Œå‘½åå†™çš„éƒ½æ˜¯ä»€ä¹ˆåƒåœ¾.\n\næ— æ³•å®Œå…¨æ¥è§¦åˆ°åç«¯,å› æ­¤ä¸çŸ¥é“åç«¯çš„æŠ€æœ¯æ¶æ„å¦‚ä½•,ä¸è¿‡çœ‹å‰ç«¯éƒ½å†™ä¸å¥½,å¤§å¯çŒœæµ‹åç«¯æ¶æ„ä¹Ÿä¸ä¼šæ€æ ·.å•å‡­å‰ç«¯éƒ½æ˜¯æ— è®ºå¦‚ä½•éƒ½æ˜¯è¯´ä¸è¿‡å»çš„.é¦–å…ˆæ˜¯ç¡¬ä¼¤:\n\n* **å®‰å…¨æ„è¯†æ·¡è–„**.è¿™æ˜¯æœ€ä¸¥é‡çš„é—®é¢˜.å‰ç«¯base64,åç«¯md5è¿ç›éƒ½ä¸åŠ ,ç­‰æ’åº“?\n* å‘½ååƒåœ¾.å¼€å‘äººå‘˜è‹±è¯­éƒ½æ²¡å­¦å¥½.\n* æ— å¼€å‘çº¦å®š.å‘½åæ‹¼éŸ³è‹±è¯­æ··åˆä¸€æŠŠæ¢­,å‰åç«¯äº¤äº’æ•°æ®æ ¼å¼èƒ¡ä¹±æ‹¼æ¥ä¸€æŠŠæ¢­.\n* æ— ç§»åŠ¨ç«¯é€‚é….\n* åç«¯è¿ç»´çº¦ç­‰äºæ— .æ—¶é—´åˆ°ç°åœ¨éƒ½æ²¡è°ƒæ•´.\n\nå…¶æ¬¡æ˜¯æ„å»ºæ–¹å¼å®Œå…¨æ˜¯äº’è”ç½‘åˆšåˆšå…´èµ·æ—¶çš„æ–¹æ³•:\n\n* htmlæ‹¼æ¥.\n* ä»£ç vanillaä¸€æŠŠæ¢­.\n* ç¡¬ç¼–ç .å•è¯´urlæ‹¼æ¥,éƒ½æ˜¯ç›´æ¥å†™æ­»çš„.\n* å“­ç¬‘ä¸å¾—çš„è´Ÿè½½å¹³è¡¡.å°±å¥½åƒè¿™å…¬å¸è¿˜æ´»åœ¨ä¸Šä¸ªä¸–çºª.\n\næ•´å¥—ç³»ç»Ÿæ¥çœ‹,ä¹Ÿè®¸æœ€å¤§çš„å‡çº§æ˜¯å¤šäº†å¥½å‡ å°æ˜é¢ä¸Šçš„\"æœåŠ¡å™¨\".çœ‹å…¬å¸å®˜ç½‘è¿˜ç”¨åˆ°äº†ä¸€å †æ¡†æ¶,ä½†æ˜¯Talk is cheap.åœ¨å‡ å¹´è¿‡å,è¿™äº›ç¼ºç‚¹éƒ½ä¼šè®©è¿™å¥—ç³»ç»Ÿæˆä¸ºä¸€ä¸ªæ³¥æ½­.\n\nåœ¨å®é™…é€‰è¯¾æ—¶,æ–°æ•™åŠ¡ä»ç„¶æ— æ³•æ‰¿å—å‹åŠ›,æš‚æ—¶ä¸èƒ½æ’é™¤æ˜¯å¸¦å®½çš„é”…,æ€»ä¹‹æ˜¯æ²¡æœ‰å®Œå…¨è§£å†³é—®é¢˜.\n\nå¦‚æœä»Šåå‘ç°å¥½ç©çš„ç©æ„,æˆ‘è¿˜ä¼šç»§ç»­è¡¥å…….\n\n## ä¸€ç‚¹å¥½ç©çš„\n\nä¸ç”¨\"æ€€ç–‘\"äº†,è¿™ä¸ªå…¬å¸é£è¯„ä¸é”™å•Šçœ‹æ¥.\n\n[æ¥çœ‹çœ‹çŸ¥ä¹ä¸Šçš„è¯„ä»·](https://www.zhihu.com/question/294293977)","categories":["æ¢¦è¯"]},{"title":"Largest Common Submatrix","url":"%2F2019%2F12%2F02%2Fproblem-largest-common-submatrix%2F","content":"\nç»™å‡º2ä¸ª$n \\times m$å¤§å°çš„çŸ©é˜µï¼Œæ±‚å‡ºä¸¤çŸ©é˜µä¸­æœ€å¤§çš„ç›¸åŒå­çŸ©é˜µã€‚\n\n$n,m \\leq 1000$\n\n## åˆ†æ\né¦–å…ˆä¸ºäº†æ–¹ä¾¿æ¥ä¸‹æ¥çš„è®¡ç®—ï¼Œå°†ç¬¬ä¸€ä¸ªçŸ©é˜µ\"æ­£è§„åŒ–\"ï¼ˆä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³1-nmï¼‰ï¼Œä»¥çŸ©é˜µ1å¯¹çŸ©é˜µ2æ‰§è¡Œæ˜ å°„ã€‚è¿™æ ·äºŒè€…çš„æœ€å¤§å­çŸ©é˜µå¯ä»¥ä»…é€šè¿‡çŸ©é˜µ2å¾—åˆ°ã€‚\n\nå¤„ç†æ¯ä¸ªå…ƒç´ èƒ½å¤Ÿå¾€ä¸‹â€œæ‹‰â€çš„é•¿åº¦ã€‚å†ä»¥æ¯è¡Œ","categories":["coding"]},{"title":"8å¹´äº†ï¼Œæ˜¥ç‰©ç»ˆäºè¿æ¥äº†ç»“å±€","url":"%2F2019%2F11%2F19%2Fi-love-yuki%2F","content":"\næˆ‘è§‰å¾—è¿™ä»¶éœ€è¦å‘ä¸€ç¯‡æ¥åº†ç¥ä¸€ä¸‹ã€‚è™½ç„¶ä»å¤´åˆ°å°¾æˆ‘å°±æ²¡æ€€ç–‘è¿‡æœ€ç»ˆä¼šæ˜¯é›ªä¹ƒï¼Œï¼ˆé›ªä¹ƒ!ï¼‰ä½†æ˜¯ç»“å±€ä¸€å‡ºï¼Œè¿˜æ˜¯éå¸¸æ¬£æ…°ã€‚\n\nçœŸå¥½å•Š.jpgã€‚\n\næ˜¯æ—¶å€™å†ä¹°ä¸€å¥—æ¥æ”¶è—äº†ã€‚\n","categories":["é—²æ‰¯"]},{"title":"æ•°ä½DP","url":"%2F2019%2F11%2F06%2Fdigit-dp-1%2F","content":"\n## ä¾‹é¢˜-4 HDU2089 ä¸è¦62\nç»Ÿè®¡æ•°ä½ä¸­æ²¡æœ‰å‡ºç°4å’Œ62çš„æ•°å­—ä¸ªæ•°ã€‚\n\n### åˆ†æ\nä¸è¦4ï¼Œå¯ä»¥åœ¨4æ—¶ç›´æ¥ä¸è½¬ç§»ã€‚å¯¹äº62ï¼Œå¯ä»¥ç»´æŠ¤ä¸€ä¸ªä¸Šä¸€ä¸ªæ•°å­—å¡«äº†å•¥ï¼Œå°±å¯ä»¥åƒ4ä¸€æ ·åˆ¤æ–­äº†ã€‚\n\n<!--more-->\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconstexpr int MAXN=20;\nll cache[MAXN][MAXN];\nint digits[20];\nll solve(int pos,int last,int lim){\n    if(pos==0)return 1;\n    if(!lim && ~cache[pos][last])return cache[pos][last];\n\n    int maxd=9;\n    if(lim)maxd=digits[pos];\n    ll res=0;\n    for(int i=0;i<=maxd;i++){\n        if(last*10+i==62 || i==4)continue;\n        res+=solve(pos-1,i,lim && i==maxd);\n    }\n    if(!lim)cache[pos][last]=res;\n    return res;\n}\n\nll SOLVE(ll x){\n    int ptr=0;\n    while(x){\n        digits[++ptr]=x%10;\n        x/=10;\n    }\n\n    return solve(ptr,0,true);\n}\n\n\n\nint main(){\n    ll l,r;\n    memset(cache,-1,sizeof(cache));\n    while(cin>>l>>r){\n        if(l==0 && r==0)break;\n        cout<<SOLVE(r)-SOLVE(l-1)<<endl;\n    }\n    return 0;\n}\n```\n\n## ä¾‹é¢˜-3 HDU3555\nç»Ÿè®¡æ‰€æœ‰å‡ºç°è¿‡49çš„æ•°å­—çš„ä¸ªæ•°ã€‚\n\n### åˆ†æ\nç»Ÿè®¡æ‰€æœ‰æ²¡å‡ºç°è¿‡49çš„æ•°å­—ï¼Œå°±å’Œä¸Šä¸€é“ä¸€æ ·äº†ã€‚\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50;\n\nint digits[MAXN];\nll f[MAXN][MAXN];\n\nll solve(int pos,int last,int lim){\n    if(pos==0)return 1;\n    if(!lim && ~f[pos][last])return f[pos][last];\n\n    int maxd=9;\n    if(lim)maxd=digits[pos];\n    ll res=0;\n    for(int i=0;i<=maxd;i++){\n        if(last*10+i==49)continue;\n        res+=solve(pos-1,i,lim && i==maxd);\n    }\n\n    if(!lim)f[pos][last]=res;\n    return res;\n}\n\ninline ll SOLVE(ll x){\n    int ptr=0;\n    while(x){\n        digits[++ptr]=x%10;\n        x/=10;\n    }\n\n    return solve(ptr,0,true);\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    memset(f,-1,sizeof(f));\n    while(kase--){\n        ll r;cin>>r;\n        cout<<r-SOLVE(r)+1<<endl;\n    }\n    return 0;\n}\n```\n\n## ä¾‹é¢˜-2 POJ3252\nThe cows, as you know, have no fingers or thumbs and thus are unable to play Scissors, Paper, Stone' (also known as 'Rock, Paper, Scissors', 'Ro, Sham, Bo', and a host of other names) in order to make arbitrary decisions such as who gets to be milked first. They can't even flip a coin because it's so hard to toss using hooves.\n\nThey have thus resorted to \"round number\" matching. The first cow picks an integer less than two billion. The second cow does the same. If the numbers are both \"round numbers\", the first cow wins,\notherwise the second cow wins.\n\nA positive integer N is said to be a \"round number\" if the binary representation of N has as many or more zeroes than it has ones. For example, the integer 9, when written in binary form, is 1001. 1001 has two zeroes and two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since it has two zeroes and three ones, it is not a round number.\n\nObviously, it takes cows a while to convert numbers to binary, so the winner takes a while to determine. Bessie wants to cheat and thinks she can do that if she knows how many \"round numbers\" are in a given range.\n\nHelp her by writing a program that tells how many round numbers appear in the inclusive range given by the input (1 â‰¤ Start < Finish â‰¤ 2,000,000,000).\n\n### åˆ†æ\n\nè¿™é“é¢˜ç›®å°†ä¸Šç•Œæ‹†è§£ä¸ºäºŒè¿›åˆ¶æ•°ä½ã€‚\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=50;\n\nint digits[MAXN];\nll f[MAXN][MAXN][MAXN];\nint len=0;\n\nll solve(int pos,int one,int first, int lim){\n    if(pos==0){\n        //cout<<first<<\" \"<<one<<endl;\n        if(first==0)return 0;\n        if(first-one>=one)return 1;\n        return 0;\n    }\n    if(!lim && ~f[pos][one][first])return f[pos][one][first];\n\n    int maxd=1;\n    if(lim)maxd=digits[pos];\n    ll res=0;\n    for(int i=0;i<=maxd;i++){\n        res+=solve(pos-1,one+(i==1),(i==1 && !first? pos : first),lim && i==maxd);\n    }\n\n    if(!lim)f[pos][one][first]=res;\n    return res;\n}\n\ninline ll SOLVE(ll x){\n    int ptr=0;\n    while(x){\n        digits[++ptr]=x%2;\n        x/=2;\n    }\n\n    return solve(ptr,0,0,true);\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    memset(f,-1,sizeof(f));\n    ll l,r;cin>>l>>r;\n    cout<<SOLVE(r)-SOLVE(l-1)<<endl;\n\n    return 0;\n}\n```\n\n## ä¾‹é¢˜-1 HDU3652\nA wqb-number, or B-number for short, is a non-negative integer whose decimal form contains the sub- string \"13\" and can be divided by 13. For example, 130 and 2613 are wqb-numbers, but 143 and 2639 are not. Your task is to calculate how many wqb-numbers from 1 to n for a given integer n.\n\n### åˆ†æ\n\nç»´æŠ¤é¢å¤–2ä¸ªçŠ¶æ€ï¼Œä¸€ä¸ªçŠ¶æ€è®°å½•æ¨¡13çš„ä½™æ•°ï¼Œå¦ä¸€ä¸ªè¿›è¡Œç¼–ç ï¼š1ä¸ºä¸Šä¸€ä½ä¸º1ï¼Œ3ä¸ºå·²ç»å‡ºç°è¿‡13ï¼Œ0ä¸ºå…¶ä»–ã€‚ä¹‹åå°†è½¬ç§»æ¡ä»¶æè¿°æ¸…æ¥šå°±å¯ä»¥äº†ã€‚\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=20;\n\nint num[MAXN];\nll f[MAXN][5][20];\nll dfs(int ptr,int last,int mod,bool lim){\n\t//cout<<\"arrive\"<<ptr<<\" \"<<last<<\" \"<<mod<<\" \"<<lim<<endl;\n\tif(ptr<=0){\n\t\tif(last==3 && mod==0)return 1;\n\t\telse return 0;\n\t}\n\tif(!lim && ~f[ptr][last][mod])return f[ptr][last][mod];\n\n\tint maxx=lim?num[ptr]:9;\n\tll res=0;\n\tfor(int i=0;i<=maxx;i++){\n\t\tif(last==3)res+=dfs(ptr-1,3,(mod*10+i)%13,lim && i==maxx);\n\t\telse if(last==1 && i==3)res+=dfs(ptr-1,3,(mod*10+i)%13,lim && i==maxx);\n\t\telse if(i==1)res+=dfs(ptr-1,1,(mod*10+i)%13,lim&&i==maxx);\n\t\telse res+=dfs(ptr-1,0,(mod*10+i)%13,lim&&i==maxx);\n\t}\n\tif(!lim)f[ptr][last][mod]=res;\n\treturn res;\n}\nll solve(ll r){\n\tint ptr=0;\n\twhile(r){\n\t\tnum[++ptr]=r%10;\n\t\tr/=10;\n\t}\n\treturn dfs(ptr,0,0,1);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tmemset(f,-1,sizeof(f));\n\tll r;\n\twhile(cin>>r){\n\t\tcout<<solve(r)<<endl;\n\t}\n\n\treturn 0;\n}\n```\n\n\n## ä¾‹é¢˜0 HDU3709\nA balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 4*2 + 1*1 = 9 and 9*1 = 9, for left part and right part, respectively. It's your job to calculate the number of balanced numbers in a given range [x, y].\n\n### åˆ†æ\nè¿™é¢˜æœ‰ç‚¹éº»çƒ¦â€¦â€¦\n\nå°†æ æ†åœ¨å“ªä¸é¢˜ç›®åˆ†ç¦»å‡ºæ¥ï¼Œæšä¸¾æ æ†å®šåœ¨ä½•å¤„ã€‚å†ç»´æŠ¤æ˜¯å¦å¹³è¡¡ã€‚å¹³è¡¡ä¸å¦è¿˜æ˜¯æŒºå¥½è€ƒè™‘çš„ï¼Œä»¥æ æ†ä¸º0ï¼Œå·¦å³å„èµ‹å€¼æ­£ä¸è´Ÿçš„æƒå€¼ï¼Œå½“åˆ°è¾¾è¾¹æ¥åå…¨æ†é‡é‡ä¸º0æ—¶å³ä¸ºå¹³è¡¡ã€‚\n\n> æœ‰ä¸€ä¸ªå°å‘ï¼Œå°±æ˜¯0ã€‚å¦‚æœè¿™ä¸ªæ•°å­—å…¨tmå¡«0çš„æ—¶å€™ï¼Œä¸ç®¡æ æ†å®šåœ¨å“ªï¼Œå®ƒéƒ½å¹³è¡¡â€¦â€¦ä½ å½“ç„¶å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå‰å¯¼é›¶æ ‡å¿—ï¼Œå°†æ‰€æœ‰0éƒ½å»æ‰æœ€åå†åŠ ä¸Šã€‚è¿˜æœ‰ä¸€ç§åŠæ³•å°±æ˜¯æœ€åå†å°†é‡å¤çš„0å‡å»ï¼Œç›¸æ¯”èµ·æ¥æ›´åŠ ç®€å•ã€‚\n\n### ä»£ç \n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\n\nint num[20];\nll f[20][20][2010];\n\nll dfs(int ptr,bool lim,int piv,int l){\n\tif(ptr<=0)return l==0;\n\tif(l<0)return 0;\n\tif(!lim && ~f[ptr][piv][l])return f[ptr][piv][l];\n\n\tint maxx=lim?num[ptr]:9;\n\n\tll res=0;\n\tfor(int i=0;i<=maxx;i++){\n\t\tres+=dfs(ptr-1,lim && i==maxx,piv,l+i*(ptr-piv));\n\t}\n\n\tif(!lim)f[ptr][piv][l]=res;\n\treturn res;\n}\n\nll solve(ll r){\n\tint ptr=0;\n\twhile(r){\n\t\tnum[++ptr]=r%10;\n\t\tr/=10;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=ptr;i++){\n\t\tans+=dfs(ptr,1,i,0);\n\t}\n\treturn ans-ptr+1;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\tint kase;cin>>kase;\n\twhile(kase--){\n\t\tmemset(f,-1,sizeof(f));\n\t\tll l,r;cin>>l>>r;\n\t\tcout<<solve(r)+(l?-solve(l-1):0)<<'\\n';\n\t}\n\n\treturn 0;\n}\n```\n\n## ä¾‹é¢˜1 CF55D\nVolodya is an odd boy and his taste is strange as well. It seems to him that a positive integer number is beautiful if and only if it is divisible by each of its nonzero digits. We will not argue with this and just count the quantity of beautiful numbers in given ranges.\n\n### åˆ†æ\nç»´æŠ¤æ•°å­—å¯¹0-9æ¯ä¸ªæ•°å­—çš„æ¨¡ï¼Œä½†æ˜¯è¿™æ ·è¿˜éœ€è¦ç»´æŠ¤æŸäº›æ•°å­—æ˜¯å¦å‡ºç°ï¼Œç»§ç»­è€ƒè™‘ã€‚å½“æ•°å­—èƒ½åŒæ—¶è¢«$a$å’Œ$b$æ•´é™¤ï¼Œç­‰ä»·ä¸ºå…¶èƒ½å¤Ÿè¢«å®ƒä¿©çš„æœ€å°å…¬å€æ•°æ•´é™¤ã€‚\n\né‚£ä¹ˆæˆ‘ä»¬çš„é—®é¢˜å¯ä»¥ç¨å¾®ç®€åŒ–ä¸€ä¸‹äº†ã€‚ç»´æŠ¤å·²ç»å¡«å†™çš„æ•°ä½çš„æœ€å°å…¬å€æ•°ï¼Œå¹¶ç»´æŠ¤æ•°å­—å’Œã€‚åˆ°è¾¾è¾¹ç•Œæ—¶ï¼Œåªæœ‰æ»¡è¶³æ¡ä»¶æ‰è®¡æ•°ã€‚\n\n> è¿™é“é¢˜è¿˜æœ‰ä¸€ç‚¹éº»çƒ¦ï¼Œå°±æ˜¯å†…å­˜å®ƒä¸å¤Ÿç”¨ã€‚æŒ‰ç…§åˆ†æï¼Œè‡³å°‘éœ€è¦å¼€$2520\\times 2520$ï¼Œè¿˜è¦å†åŠ ä¸Šä¸ªæ•°ä½é•¿åº¦ã€‚å†…å­˜å°±ç‚¸äº†ã€‚å®é™…ä¸Šï¼Œæœ€å°å…¬å€æ•°ä»…æœ‰äº†äº†å‡ ä¸ªï¼Œå¯ä»¥äº‹å…ˆæ±‚å‡ºå¹¶å…ˆç¼–ç ï¼Œå°±èƒ½é™ä½ä¸€ç»´çŠ¶æ€ã€‚\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\nusing namespace std;\nusing ll = long long;\nconst int MAXN = 2620;\nconst int MAX_LCM = 2520;\n//posä½æ•°ä½™restæ¨¡Â·10Â·çš„æ–¹æ¡ˆ\nll cache[20][MAXN][50];\nint digits[20];\n\nint idx = 0;\nint lcmref[MAXN];\n\nll gcd(ll a, ll b)\n{\n    return !b ? a : gcd(b, a % b);\n}\nll lcm(ll a, ll b)\n{\n    return a / gcd(a, b) * b;\n}\nvoid init_lcm()\n{\n    for (int i = 0; i < (1 << 10); i++)\n    {\n        int temp = 1;\n        for (int j = 1; j < 10; j++)\n        {\n            if ((i >> j) & 1)\n            {\n                temp = lcm(temp, j);\n            }\n        }\n        if (!lcmref[temp])\n        {\n            //cout << temp << endl;\n            lcmref[temp]=++idx;\n        }\n    }\n}\nll solve(int pos, int rest, int l, bool lim)\n{\n    if (pos == 0)\n    {\n        if (rest % l == 0)\n            return 1;\n        return 0;\n    }\n    if (!lim && ~cache[pos][rest][lcmref[l]])\n        return cache[pos][rest][lcmref[l]];\n\n    ll res = 0;\n    int maxd = 9;\n    if (lim)\n        maxd = digits[pos];\n    for (int i = 0; i <= maxd; i++)\n    {\n        res += solve(pos - 1, (rest * 10 + i) % MAX_LCM, i == 0 ? l : lcm(l, i), lim && (i == maxd));\n    }\n    if (!lim)\n        cache[pos][rest][lcmref[l]] = res;\n    return res;\n}\n\nll SOLVE(ll x)\n{\n    int ptr = 0;\n    while (x)\n    {\n        digits[++ptr] = x % 10;\n        x /= 10;\n    }\n    return solve(ptr, 0, 1, true);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    init_lcm();\n    int kase;\n    cin >> kase;\n    memset(cache, -1, sizeof(cache));\n    while (kase--)\n    {\n        ll l, r;\n        cin >> l >> r;\n        cout << SOLVE(r) - SOLVE(l - 1) << endl;\n    }\n\n    return 0;\n}\n```\n\n## ä¾‹é¢˜2 \næ±‚$[l,r]$åŒºé—´å†…çš„æ‰€æœ‰æ»¡è¶³ä»¥ä¸‹è¦æ±‚çš„æ•°çš„å¹³æ–¹å’Œã€‚\n\n1. æ•°ä½ä¸Šæ²¡æœ‰$7$\n2. ä¸æ˜¯$7$çš„å€æ•°\n3. æ•°ä½å’Œä¸æ˜¯$7$çš„å€æ•°\n\nåŒºé—´ä¸º$10^{18}$çº§åˆ«ï¼Œè¯·å¯¹ç­”æ¡ˆå–æ¨¡$10^{9}+7$ã€‚\n\n### åˆ†æ\nè¿™é¢˜æŒºç‹ çš„â€¦â€¦é¦–å…ˆçœ‹å¦‚ä½•åˆ¤æ–­ä¸Šé¢çš„3ä¸ªæ¡ä»¶ã€‚\n\n* æ•°ä½ä¸Šæ²¡æœ‰$7$ï¼Œå¯ä»¥ç›´æ¥åœ¨æšä¸¾å¡«æ•°æ—¶è·³è¿‡$7$ã€‚\n* é * çš„å€æ•°ï¼Œå¯ä»¥ç»´æŠ¤å·²å¡«æ•°å­—çš„å–æ¨¡ã€‚å–æ¨¡ä¸º$0$åˆ™ä¸ºå€æ•°ã€‚\n* æ•°ä½å’Œï¼Œä»ç„¶å¯ä»¥ç›´æ¥ç»´æŠ¤ã€‚\n\nè¿™æ ·å°±å¯ä»¥æ­£ç¡®çš„åˆ¤æ–­æŸä¸ªæ•°æ˜¯ä¸æ˜¯æ»¡è¶³æ¡ä»¶ã€‚æ¥ä¸‹æ¥æ˜¯å¹³æ–¹å’Œã€‚\n\nå½“ä»¥æ•°ä½æ¥è€ƒè™‘å¹³æ–¹å’Œæ—¶ï¼Œé—®é¢˜å°±ç¨å¾®å˜å¾—å¤æ‚äº†ã€‚å‡è®¾æˆ‘ä»¬å·²ç»çŸ¥é“äº†ä¸‹ä¸€ä¸ªçŠ¶æ€çš„å¹³æ–¹å’Œä¸º$x_n$ï¼Œå¦‚ä½•å¾—åˆ°å½“å‰ä½$x$çš„å¹³æ–¹å’Œã€‚\n\nå‡è®¾å½“å‰ä½$ptr$å¡«äº†$i$ã€‚å…¶æ•°ä½æ‰€è¡¨è¾¾çš„æ„ä¹‰æ˜¯$10^{p}i$ï¼Œé‚£ä¹ˆä»¥è¯¥ä½ä¸ä¸‹ä¸€çŠ¶æ€çš„å¹³æ–¹å’Œï¼Œéœ€è¦ä¸‹ä¸€çŠ¶æ€çš„**å’Œ**ï¼Œå®šä¸º$s_n$ã€‚å¯ä»¥å¾—åˆ°\n\n$$\n(10^p i+s_n)^2=10^{2p}i^2+2 \\cdot 10^pis_n+s_n^2\n$$\n\nå¦å¤–ï¼Œå½“å‰ä½çš„å‡ºç°æ¬¡æ•°åœ¨å®é™…è®¡ç®—æ—¶éœ€è¦è€ƒè™‘è¿›å»ã€‚é‚£ä¹ˆï¼Œè¿˜éœ€è¦ç»´æŠ¤ä¸‹ä¸€çŠ¶æ€çš„**ä¸ªæ•°**ï¼Œè®°$cnt$ã€‚é‚£ä¹ˆï¼Œä¸Šå¼éœ€è¦ä¿®æ”¹\n\n$$\n10^{2p}i^2 \\cdot cnt_n+2 \\cdot 10^pis_n+s_n^2\n$$\n\nåä¸¤é¡¹ä¸ä¹˜ä»¥$cnt$æ˜¯å› ä¸ºå®ƒä»¬æœ¬èº«å°±å·²ç»æ˜¯åŒ…æ‹¬äº†ä¸‹ä¸€çŠ¶æ€çš„æ‰€æœ‰è®¡æ•°ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ä»¥æ•°ä½ä¸ºè§’åº¦çš„å¹³æ–¹å’Œç»´æŠ¤åŠæ³•ã€‚\n\n### ä»£ç \n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=22;\nconst ll MOD=1e9+7;\n\nstruct Status{\n\tll cnt;\n\tll sum,sqsum;\n\tStatus(ll cnt=-1,ll sum=0,ll sqsum=0):cnt(cnt),sum(sum),sqsum(sqsum){}\n} f[MAXN][9*20][10];\nint num[MAXN];\n\nll qpow(ll a,ll b){\n\tll res=1;\n\tfor(;b;b>>=1,a=a*a%MOD){\n\t\tif(b&1)res=res*a%MOD;\n\t}\n\treturn res;\n}\n\nStatus dfs(int ptr,int sum,int mod,bool lim){\n\tif(ptr<=0){\n\t\treturn Status(sum%7!=0 && mod!=0);\n\t}\n\n\tif(!lim && ~f[ptr][sum][mod].cnt)return f[ptr][sum][mod];\n\n\tint maxx=lim?num[ptr]:9;\n\tStatus res(0);\n\tfor(int i=0;i<=maxx;i++){\n\t\tif(i==7)continue;\n\t\tStatus nex=dfs(ptr-1,sum+i,(mod*10+i)%7,lim&&i==maxx);\n\t\tres.cnt+=nex.cnt;\n\t\tres.cnt%=MOD;\n\t\tres.sum=(res.sum%MOD+qpow(10,ptr-1)*i%MOD*nex.cnt%MOD)%MOD;\n\t\tres.sum=(res.sum+nex.sum)%MOD;\n\t\tres.sqsum=(res.sqsum+nex.cnt%MOD*qpow(10,2*(ptr-1))%MOD*i%MOD*i%MOD)%MOD;\n\t\tres.sqsum=((res.sqsum+nex.sqsum)%MOD+2*qpow(10,ptr-1)%MOD*i%MOD*nex.sum%MOD)%MOD;\n\t}\n\tif(!lim)f[ptr][sum][mod]=res;\n\treturn res;\n}\n\n\nll solve(ll n){\n\tint ptr=0;\n\twhile(n){\n\t\tnum[++ptr]=n%10;\n\t\tn/=10;\n\t}\n\treturn dfs(ptr,0,0,1).sqsum%MOD;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint kase;cin>>kase;\n\twhile(kase--){\n\t\tll l,r;cin>>l>>r;\n\t\tcout<<((solve(r)-(l?solve(l-1):0))%MOD+MOD)%MOD<<endl;\n\t}\n\treturn 0;\n}\n```\n\n## æ•°ä½DP\nä¸Šé¢è¿™é“é¢˜ç›®å¤§æ¦‚ç®—æ˜¯æš´éœ²äº†æ•°ä½DPä¸­éœ€è¦è€ƒè™‘çš„äº‹æƒ…ã€‚æ•°ä½DPèƒ½å¤Ÿä¸»è¦èƒ½å¤Ÿç»Ÿè®¡æŸ2ä¸ªæ•°å­—åŒºé—´å†…æ»¡è¶³æŸäº›æ¡ä»¶çš„æ•°å­—çš„ä¿¡æ¯ï¼Œæ¯”å¦‚ä¸ªæ•°ã€å’Œã€å¹³æ–¹å’Œâ€¦â€¦\n\né¦–å…ˆæ•°ä½DPä¸æ˜¯å•ç‹¬è€ƒè™‘æ¯ä¸€ä¸ªæ•°å­—ï¼Œè€Œæ˜¯ä»¥æ•°ä½ä¸ºå•ä½çš„è€ƒè™‘ã€‚è¿™æ ·åœ¨è€ƒè™‘æ¡ä»¶æ»¡è¶³å’Œå„ç±»ä¿¡æ¯çš„ç»´æŠ¤æ—¶ï¼Œå°±éœ€è¦è½¬ä¸€è½¬ã€‚\n\nå…ˆæ¥çœ‹è®°å¿†åŒ–æœç´¢ã€‚æ¯”è¾ƒç›´è§‚ï¼ˆ\n\n### è®¡æ•°åŸºç¡€\nåˆå§‹åŒ–çš„å€¼ä»ä½•è€Œæ¥ã€‚å½“æ•°ä½DPåˆ°è¾¾äº†è¾¹ç•Œï¼Œå°±æ˜¯è¦è€ƒè™‘åˆå§‹åŒ–çš„ä½ç½®ã€‚ä¸€èˆ¬ä¸ºæ»¡è¶³æ¡ä»¶ç½®$1$ã€‚\n\n### æ»¡è¶³æ¡ä»¶\nè¿™æ˜¯æˆ‘ä»¬éœ€è¦è€ƒè™‘çš„çŠ¶æ€ã€‚ä¾‹å¦‚ä¸Šé¢æåˆ°çš„ã€‚\n\n* æ•°ä½æ²¡æœ‰æŸæ•°ï¼šç›´æ¥ä¸è½¬ç§»ã€‚\n* æ•°ä½å’Œï¼šç›´æ¥ç»´æŠ¤ä¸€ç»´æ•°ä½å’Œã€‚\n* å€æ•°å…³ç³»ï¼šä»¥é€’æ¨æ–¹å¼ç»´æŠ¤å–æ¨¡ã€‚\n* æ•°å­—å‡ºç°æ¬¡æ•°ï¼šä½¿ç”¨çŠ¶å‹æ¥å¯¹æ¬¡æ•°ç¼–ç ã€‚ä¾‹å¦‚ï¼Œå¯¹æ¯ä¸€ç§æ•°å­—ç»´æŠ¤ç©ºé—´ä¸º3çš„çŠ¶æ€ï¼ˆ0ï¼Œå¥‡æ•°ï¼Œå¶æ•°ï¼‰ã€‚\n\nå…¶å®è¿˜å¯èƒ½æœ‰å¾ˆå¤šï¼Œä¸»è¦è€ƒè™‘çš„é—®é¢˜æ˜¯è¯¥çŠ¶æ€ç»è¿‡ç¼–ç åèƒ½ä¸èƒ½ä¿å­˜ä¸‹æ¥ï¼Œä¸¤ä¸ªçŠ¶æ€ä¹‹é—´èƒ½ä¸èƒ½é€’æ¨è¿‡å»ã€‚\n\n### è®¡æ•°\nå¿…é¡»è€ƒè™‘$n-1$åˆ°$n$**ä½**ä¹‹é—´çš„è½¬ç§»å…³ç³»ã€‚é¦–å…ˆä¸€å®šä¼šç»´æŠ¤æ»¡è¶³æ€§è´¨çš„æ•°å­—ä¸ªæ•°ï¼Œä¹‹åæ¯ä¸€ä¸ªä½çš„è®¡ç®—éƒ½éœ€è¦è€ƒè™‘ä¸‹ä¸€çŠ¶æ€çš„ä¸ªæ•°ã€‚","tags":["åŠ¨æ€è§„åˆ’"],"categories":["coding"]},{"title":"Liaoning Shipâ€™s Voyage","url":"%2F2019%2F10%2F27%2Fproblem-liaoning-ships-voyage%2F","content":"Liaoning ship, which named after a province of China, is the first aircraft carrier commissioned into the People's Liberation Army Navy. It was bought from Ukraine as a stripped hulk and was rebuilt by China as an important part of Chinaâ€™s blue water Navy plan. Liaoning ship has sailed far into the Pacific Ocean for serval times, which shows the power and resolve of China to defend her integrity of territory.\n\nNow Liaoning ship is on a new voyage to the Atlantic Ocean for a maneuver! The vast maneuver region on the ocean can be seen as an nÃ—n grid which has nÃ—n crosspoints. Each crosspoint stands for a check point of the maneuver region. Liaoning starts from the bottom-left check point whose coordinate is (0,0), and its destination is the upper-right checkpoint whose coordinate is (n-1,n-1). The positive side of the x axis points to the right, and the positive side of the y axis points up. All check pointsâ€™ coordinates are integral. During each move, Liaoning can go from one check point to its adjacent 8 check points along a straight line, and each move takes Liaoning one day. Some check points are not available to go due to the bad weather. And, as you know, on the Atlantic Ocean, there is a Bermuda Triangle in which many ships and planes were missing. Liaoning canâ€™t take risk to go into that triangle. Of course, Liaoning canâ€™t go outside the maneuver region. Please figure out a route for Liaoning to reach its destination as soon as possible.\n\n## åˆ†æ\n\nå®é™…ä¸Šæœ¬ä½“æ˜¯ä¸ªDijkstraï¼Œä½†æ˜¯ä¸¤ç‚¹æ˜¯å¦ç›¸è¿éœ€è¦ä½¿ç”¨åˆ°è®¡ç®—å‡ ä½•çš„ä¸œè¥¿ã€‚é‡ç‚¹å°±åœ¨äºå¦‚ä½•åˆ¤æ–­è¡Œè¿›è¿‡ç¨‹æ˜¯å¦ç©¿è¿‡äº†ç™¾æ…•å¤§ä¸‰è§’ã€‚\n\n<!--more-->\n\nç„¶åå°±WAäº†8å‘ã€‚\n\nå®é™…åˆ¤æ–­æ—¶ä¼šæœ‰å¾ˆå¤šé—®é¢˜ã€‚ä¾‹å¦‚ä»è¾¹ä¸Šç»è¿‡ï¼Œä»å¤–ç•Œåˆ°è¾¹ï¼Œä»è¾¹åˆ°è¾¹ï¼Œä»è¾¹åˆ°å¤–ç•Œï¼Œä»å¤–ç•Œåˆ°ç‚¹ï¼Œä»ç‚¹åˆ°å¤–ç•Œï¼Œä»è¾¹ç©¿è¿‡ç‚¹â€¦â€¦å¦‚æœä¸€å¼€å§‹é€‰æ‹©çš„åˆ¤æ–­æ–¹æ³•æœ‰é”…çš„è¯ï¼Œä¹‹åå°±æ”¹ä¸å‡ºæ¥äº†ï¼Œåªèƒ½WAâ€¦â€¦\n\næœ€ç»ˆæƒ³å‡ºæ¥çš„è§£å†³åŠæ³•æ˜¯æ‹¿åˆ°è¡Œè¿›çº¿æ®µä¸ä¸‰è§’å½¢ä¸‰è¾¹çš„äº¤ç‚¹ï¼Œè¿æ¥äº¤ç‚¹æ„é€ æ–°çº¿æ®µåï¼Œåˆ¤æ–­çº¿æ®µä¸­ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ï¼›å¹¶åŒæ—¶åˆ¤æ–­èµ·ç‚¹ç»ˆç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…ã€‚è¿™æ ·å°±èƒ½é¿å…æ‰å¤æ‚çš„è®¨è®ºã€‚\n\nå…¶æ¬¡ï¼Œé¡ºä¾¿æŠŠå·²ç»åœ¨ä¸‰è§’å½¢å†…çš„æ•´ç‚¹å…¨éƒ¨æ ‡è®°äº†ä¸èƒ½è®¿é—®ã€‚\n\nè¿™æ ·å°±è¿‡äº†ã€‚\n\n## ä»£ç \n\næ¿å­åˆ¤ç‚¹åœ¨çº¿æ®µéƒ¨åˆ†æœ‰é—®é¢˜ï¼Œè¦æ”¹ã€‚\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\nconst int MAXN=30;\n\n\nbool fuck=false;\nconst double EPS=1e-7;\nconst double PI=acos(-1);\nint sgn(double x){\n    return (x>-EPS)-(x<EPS);\n}\nstruct Vec{\n    double x,y;//never change it yourself unless you dont need polar angle.\n    double _polar;// make cache to accumulate speed as atan is too slow.\n\n    Vec(){\n        x=y=0;\n    }\n    Vec(double x,double y):x(x),y(y){\n        _polar=atan2(y,x);\n    }\n    double dot(const Vec &b)const{\n        return x*b.x+y*b.y;\n    }\n    double cross(const Vec &b)const{\n        return x*b.y-b.x*y;\n    }\n    double len(){\n        return sqrt(sqlen());\n    }\n    double sqlen(){\n        return x*x+y*y;\n    }\n    Vec normalize(){\n        double l=len();\n        return Vec(x/l,y/l);\n    }\n    Vec rotate(double angle){\n        return Vec(x*cos(angle)-y*sin(angle),x*sin(angle)+y*cos(angle));\n    }\n    Vec operator * (double factor)const{\n        return Vec(x*factor,y*factor);\n    }\n    double operator * (const Vec &b)const{\n        return cross(b);\n    }\n    Vec operator - (const Vec &b)const{\n        return Vec(x-b.x,y-b.y);\n    }\n    Vec operator +(const Vec &b)const{\n        return Vec(x+b.x,y+b.y);\n    }\n    double polar()const{\n        return _polar;\n    }\n    bool leftby(const Vec &b)const{\n        return sgn(b.cross(*this))>0;\n    }\n    bool samed(const Vec &b)const{\n        return sgn(this->cross(b))==0 && sgn(this->dot(b))>0;\n    }\n    bool operator<(const Vec &b)const{\n        return this->polar()<b.polar();\n    }\n    \n    bool operator==(const Vec &b)const{\n\t\treturn sgn(b.x-this->x)==0 &&sgn(b.y-this->y)==0;\n\t}\n};\nostream& operator<<(ostream& out,const Vec &b){\n    out<<\"(\"<<b.x<<\",\"<<b.y<<\")\";\n    return out;\n}\ntypedef Vec Point;\nstruct Line{\n    Point pos;\n    Vec dirc;\n    Line(Point pos=Point(0,0),Vec dirc=Vec(0,0)):pos(pos),dirc(dirc){}\n    static Line fromPoints(Point a,Point b){\n        return Line(a,b-a);\n    }\n    double getarea(const Line &b)const{\n        return abs(dirc.cross(b.dirc));\n    }\n    // è·å¾—å‚çº¿\n    Line getppd(){\n        return Line(pos+dirc*0.5,dirc.rotate(PI/2));\n    }\n\n    //TODO: what will happen if they have no intersection,-nan\n    Point getintersection(const Line &b)const{\n        Vec down=this->pos-b.pos;\n        double aa=b.dirc.cross(down);\n        double bb=this->dirc.cross(b.dirc);\n        return this->pos+this->dirc*(aa/bb);\n    }\n\n    bool point_on_line(Point point){\n        if(!dirc.samed(point-pos))\n            return false;\n        if(sgn((point-pos).sqlen()-dirc.sqlen())>0)\n            return false;\n        return true;\n    }\n\n    bool on_ver(Point point){\n        if(sgn(point.x-pos.x)==0 && sgn(point.y-pos.y)==0)return true;\n        if(sgn(point.x-(pos.x+dirc.x))==0 && sgn(point.y-(pos.y+dirc.y))==0)return true;\n        return false;\n    }\n\n    double get_distance(Point point){\n        Line ppd=getppd();\n        ppd.pos=point;\n\n        Point intersection=getintersection(ppd);\n\n        ppd.dirc=intersection-point;\n        Vec v=intersection-pos;\n\n        return abs(v.cross(point-pos)/v.len());\n    }\n\n    double get_distance(Line line){\n        return get_distance(line.pos);\n    }\n};\n\nPoint points[3];\nLine triangle[3];\n\nchar game[MAXN][MAXN];\n\ndouble get_area(vector<Point> &points){\n    if(points.size()<3){\n        return -1;\n    }\n    sort(points.begin(),points.end(),[](const Point &a,const Point &b){\n        return a.polar()<b.polar();\n    });\n    Point base(0,0);\n    Point last=points[0];\n    double res=0;\n    for(int i=1;i<points.size();i++){\n        Vec a=last-base,b=points[i]-base;\n        res+=a.cross(b)/2;\n\n        last=points[i];\n    }\n    //add the last point(also the first point)\n    Vec a=last-base,b=points[0]-base;\n    res+=a.cross(b)/2;\n\n    return fabs(res);\n}\n\nbool in_triangle(Point p){\n    if(fuck)return false;\n\n    for(int i=0;i<3;i++){\n        if(Line::fromPoints(points[i%3],points[(i+1)%3]).point_on_line(p))return false;\n    }\n\n    double areas=0;\n    for(int i=0;i<3;i++){\n        vector<Point> ps;\n        ps.push_back(points[i%3]);\n        ps.push_back(points[(i+1)%3]);\n        ps.push_back(p);\n        areas+=get_area(ps);\n    }\n\n    vector<Point> ps;\n    for(int i=0;i<3;i++)ps.push_back(points[i]);\n    return sgn(areas-get_area(ps))==0;\n}\n\nbool has_intersetct(Line line){\n    if(fuck)return false;\n    int cnt=0; \n    Point p[3];\n    bool flg[3]={0,0,0};\n    for(int i=0;i<3;i++){\n        if(sgn(line.dirc.cross(triangle[i].dirc))==0)continue;\n        p[i]=line.getintersection(triangle[i]);\n        if(line.point_on_line(p[i])||p[i]==line.pos) flg[i]=1;\n    }\n    if(in_triangle(line.pos)) return true;\n    if(in_triangle(line.pos+line.dirc)) return true;\n    Line l;\n    if(flg[0]&&flg[1])\n    {\n\t\tl=Line::fromPoints(p[0],p[1]);\n\t    if(in_triangle(l.pos+l.dirc*0.5)) return true;\n    }\n    if(flg[2]&&flg[1])\n    {\n\t\tl=Line::fromPoints(p[2],p[1]);\n\t    if(in_triangle(l.pos+l.dirc*0.5)) return true;\n    }\n    if(flg[0]&&flg[2])\n    {\n\t\tl=Line::fromPoints(p[0],p[2]);\n\t    if(in_triangle(l.pos+l.dirc*0.5)) return true;\n    }\n    return false;\n}\n\nstruct v4q{\n    int i,j,step;\n    v4q(int i,int j,int step):i(i),j(j),step(step){}\n\n    bool operator<(const v4q &other)const{\n        return step>other.step;\n    }\n};\nint nlen;\nint dist[MAXN][MAXN];\nbool vis[MAXN][MAXN];\nint solve(){\n    priority_queue<v4q> pq;\n    pq.push(v4q(1,1,0));\n    memset(dist,0x3f,sizeof(dist));\n    memset(vis,0,sizeof(vis));\n    dist[1][1]=0;\n    while(!pq.empty()){\n        v4q cur=pq.top();pq.pop();\n\n        if(vis[cur.i][cur.j])continue;\n        vis[cur.i][cur.j]=1;\n\t\t//printf(\"now:%d %d\\n\",cur.i,cur.j);\n        for(int i=max(1,cur.i-1);i<=min(nlen,cur.i+1);i++){\n            for(int j=max(1,cur.j-1);j<=min(nlen,cur.j+1);j++){\n                if(i==cur.i && j==cur.j)continue;\n                if(game[i][j]=='#')continue;\n                if(has_intersetct(Line::fromPoints(Point(j-1,i-1),Point(cur.j-1,cur.i-1))))continue;\n               //cout<<\"arrive \"<<i<<\",\"<<j;\n                if(dist[i][j]>dist[cur.i][cur.j]+1){\n                    dist[i][j]=dist[cur.i][cur.j]+1;\n                    //cout<<\" and update it to \"<<dist[i][j];\n                    pq.push(v4q(i,j,dist[i][j]));\n                }\n                //cout<<endl;\n            }\n        }\n    }\n    return dist[nlen][nlen];\n}\n\n\nint main(){\n//\tfreopen(\"in.txt\",\"r\",stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n    while(cin>>nlen){\n    \tfuck=0;\n        for(int i=0;i<3;i++){\n            Point &p=points[i];\n            cin>>p.x>>p.y;\n        }\n\n        for(int i=0;i<3;i++){\n            triangle[i]=Line::fromPoints(points[i%3],points[(i+1)%3]);\n        }\n\n        for(int i=0;i<3;i++){\n            if(sgn(triangle[i%3].dirc.cross(triangle[(i+1)%3].dirc))==0){\n                fuck=1;\n            }\n        }\n\n        for(int i=nlen;i>=1;i--){\n            for(int j=1;j<=nlen;j++){\n                cin>>game[i][j];\n            }\n        }\n\n        //solve triangle\n        \n        for(int i=1;i<=nlen;i++){\n            for(int j=1;j<=nlen;j++){\n                if(in_triangle(Point(j-1,i-1)))game[i][j]='#';\n            }\n        }\n        \n        /*\n        for(int i=nlen;i>=1;i--){\n            for(int j=1;j<=nlen;j++){\n                cout<<game[i][j];\n            }\n            cout<<endl;\n        }\n        */\n        \n        \n\n        int ans=solve();\n        if(ans!=0x3f3f3f3f)cout<<ans<<\"\\n\";\n        else cout<<\"-1\\n\";\n    }\n\n    return 0;\n}\n```\n","tags":["è®¡ç®—å‡ ä½•"],"categories":["coding"]},{"title":"[CCPC2017æ­å·] Heathrock","url":"%2F2019%2F10%2F23%2Fproblem-hearthrock%2F","content":"è¿™é¢˜æ„å¤ªé•¿äº†ï¼Œæˆ‘æ‡’å¾—å¤åˆ¶ã€‚\n\n## åˆ†æ\n\né¢â€¦â€¦å…¶å®å°±æ˜¯çˆ†æœæ¨¡æ‹Ÿã€‚ä½†æ˜¯çŠ¶æ€æ¯”è¾ƒå¤šï¼Œéœ€è¦è®°åŒæ–¹ç”Ÿå‘½å€¼ï¼Œ3ä¸ªéšä»çš„ç”Ÿå‘½ï¼Œå½“å‰åœºæ•°ï¼Œé­”åŠ›ï¼Œä½“åŠ›ï¼Œä»¥åŠä¸€äº›ç„å­¦ä¼˜åŒ–ã€‚\n\n* è‡ªé€‰ç›®æ ‡çš„ç‰Œä¸€å®šä¼šæ”¾åœ¨å›åˆçš„è¾ƒåå‡ºï¼Œå› ä¸ºå…¶ä¸ä¼šç´¯åŠ é­”åŠ›ã€‚\n* å¦‚æœå‰©ä¸‹çš„ç‰Œå…¨è¸¢è„¸ä¹Ÿè¸¢ä¸æ­»ï¼Œç›´æ¥è¿”å›ã€‚\n\nä¹‹åå°±èƒ½è·‘å¾—é£å¿«ã€‚\n\n<!--more-->\n\n{% asset_img \"1.png\" %}\n\n\n## ä»£ç \n\nä¸€å¼€å§‹è¾“å‡ºäº†\"YES\"ï¼Œæ·¦ã€‚\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\nusing namespace std;\nconst int MAXN=10;\nstruct Card{\n    int type;\n    int damage;\n    int cost;\n    int power;\n\n    Card(){}\n    Card(int type,int damage,int cost,int power):type(type),damage(damage),cost(cost),power(power){}\n} cards[MAXN];\nbool used[MAXN];\nint nlen;\nint md1,md2,md3;\nint mx1,mx2,mx3;\n\nstack<int> ans_cards,ans_target;\nbool dfs(int stone,int power,int bl_me,int bl_en,int m1,int m2,int m3,int depth,bool nearend=false){\n    if(stone<0)return false;\n    if(depth>=3)return false;\n    if(bl_en<=0)return true;\n\n    if(depth>=1 && stone==10){\n        if(m1>0)bl_me-=md1;\n        if(m2>0)bl_me-=md2;\n        if(m3>0)bl_me-=md3;\n\n        if(m1<=0)m1=mx1;\n        if(m2<=0)m2=mx2;\n        if(m3<=0)m3=mx3;\n    }\n    if(bl_me<=0)return false;\n\n    //full attacking to owner cannot kill it.\n    int fullattack=0;\n    int fakepower=power;\n    int unusd_lian=0;\n    for(int i=0;i<nlen;i++){\n        if(used[i])continue;\n        fakepower+=cards[i].power;\n        if(cards[i].type==1)continue;\n        unusd_lian++;\n        fullattack+=cards[i].damage;\n    }\n    if(fullattack+fakepower*(unusd_lian)<bl_en)return false;\n    \n\n    for(int i=0;i<nlen;i++){\n        if(used[i])continue;\n        const Card &card=cards[i];\n        int reald=card.damage+power;\n\n        if(card.cost>stone)continue;\n\n        used[i]=1;\n        if(!nearend && card.type==1){\n            if(stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1-reald,m2-reald,m3-reald,depth)){\n                ans_cards.push(i+1);\n                ans_target.push(-1);\n                return true;\n            }\n        }\n        if(!nearend && card.type==2){\n            if(stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en-reald,m1,m2,m3,depth)){\n                ans_cards.push(i+1);\n                ans_target.push(-1);\n                return true;\n            }\n        }\n        if(card.type==3){\n            if(stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en-reald,m1,m2,m3,depth,1)){\n                ans_cards.push(i+1);\n                ans_target.push(0);\n                return true;\n            }\n\n            if(m1>0 && stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1-reald,m2,m3,depth,1)){\n                ans_cards.push(i+1);\n                ans_target.push(1);\n                return true;\n            }\n\n            if(m2>0 && stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1,m2-reald,m3,depth,1)){\n                ans_cards.push(i+1);\n                ans_target.push(2);\n                return true;\n            }\n\n            if(m3>0 && stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1,m2,m3-reald,depth,1)){\n                ans_cards.push(i+1);\n                ans_target.push(3);\n                return true;\n            }\n        }\n        used[i]=0;\n    }\n\n    if(dfs(10,0,bl_me,bl_en,m1,m2,m3,depth+1)){\n        ans_cards.push(-1);\n        ans_target.push(-1);\n        return true;\n    }\n\n    return false;\n}\nint mc1,mc2,mc3;\nint bl_me,bl_en;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);cout.tie(0);\n    int kase;cin>>kase;\n    while(kase--){\n        memset(used,0,sizeof(used));\n        while(!ans_cards.empty())ans_cards.pop();\n        while(!ans_target.empty())ans_target.pop();\n\n        cin>>nlen;\n        cin>>bl_me>>bl_en;\n\n        cin>>md1>>mc1>>mx1;\n        cin>>md2>>mc2>>mx2;\n        cin>>md3>>mc3>>mx3;\n        for(int i=0;i<nlen;i++){\n            cards[i].cost=cards[i].damage=cards[i].power=cards[i].type=0;\n            int type;cin>>type;\n            if(type==1 || type==2){\n                int cost,x,y;\n                cin>>cost>>x>>y;\n                cards[i].type=type;\n                cards[i].cost=cost;\n                cards[i].damage=x;\n                cards[i].power=y;\n            }else{\n                int cost,x;\n                cin>>cost>>x;\n                cards[i].type=type;\n                cards[i].cost=cost;\n                cards[i].damage=x;\n            }\n        }\n        ans_cards.push(-1);\n        ans_target.push(-1);\n        if(dfs(10,0,bl_me,bl_en,mc1,mc2,mc3,0)){\n            cout<<\"Yes\\n\";\n        }else{\n            cout<<\"No\\n\";\n            continue;\n        }\n        \n        int block=0;\n        while(!ans_cards.empty()){\n            queue<int> pack_ans,pack_target;\n            while(!ans_cards.empty() && ans_cards.top()!=-1){\n                pack_ans.push(ans_cards.top());\n                ans_cards.pop();\n                pack_target.push(ans_target.top());\n                ans_target.pop();\n            }\n\n            if(!ans_cards.empty()){\n                ans_cards.pop();\n                ans_target.pop();\n            }\n\n            if(pack_ans.empty())continue;\n\n            cout<<pack_ans.size()<<\"\\n\";\n            while(!pack_ans.empty()){\n                cout<<pack_ans.front()<<\" \";\n                pack_ans.pop();\n            }\n            cout<<\"\\n\";\n            while(!pack_target.empty()){\n                cout<<pack_target.front()<<\" \";\n                pack_target.pop();\n            }\n            cout<<\"\\n\";\n            block++;            \n        }\n        while(block<3){\n            cout<<\"0\\n\";\n            block++;\n        }\n    }\n\n    return 0;\n}\n```","tags":["æ¨¡æ‹Ÿ"],"categories":["coding"]},{"title":"[CCPC 2017] Master of Sequence","url":"%2F2019%2F10%2F21%2Fproblem-master-of-sequence%2F","content":"ç»™å‡º2ä¸ªæ•°åˆ—ï¼Œ$\\{a_i\\},\\{b_i\\}$.è¦æ±‚æ”¯æŒä»¥ä¸‹æ“ä½œ\n\n1. ä¿®æ”¹æ•°åˆ—açš„ç¬¬iä¸ªä¸ºx\n2. ä¿®æ”¹æ•°åˆ—bçš„ç¬¬iä¸ªä¸ºx\n3. ç»™å‡ºkï¼Œæ±‚æœ€å°çš„tï¼Œæ»¡è¶³$\\sum \\lfloor \\frac {t-b_i}{a_i} \\rfloor \\ge k$\n\næ“ä½œæ•°ä¸å¤šäº100000ï¼Œæ“ä½œ3ä¸å¤šäº1000ï¼›æ•°åˆ—é•¿åº¦ä¸å¤šäº10000ï¼Œ**açš„å€¼åŸŸä¸å¤§äº1000**ã€‚\n\n## åˆ†æ\nå°†$\\lfloor \\frac {t-b_i}{a_i} \\rfloor$æ‹†å¼€ï¼Œè§‚å¯Ÿå‰åå¯èƒ½å‡ºç°çš„å·®ã€‚\n\n$$\n\\lfloor \\frac {t}{a_i} \\rfloor - \\lfloor \\frac {b_i}{a_i} \\rfloor\n$$\n\nè®¾$t=k_1a_i+c_1,b_i=k_2a_i+c_2$ï¼Œä»£å…¥è§‚å¯Ÿã€‚\n\n$$\n\\begin{aligned}\n\\lfloor \\frac {t-b_i}{a_i} \\rfloor&=\\lfloor \\frac {(k_1-k_2)a_i+c_1-c_2}{a_i} \\rfloor \\\\\n\\end{aligned}\n$$\n\nå¯ä»¥å‘ç°ï¼Œå½“æŠŠå¼å­æ‹†å¼€æ—¶ï¼Œæœ‰2ç§æƒ…å†µã€‚\n\n* $c_1 > c_2$ï¼Œå•¥äº‹æ²¡æœ‰ã€‚\n* $c_1 < c_2$ï¼Œæ‹†å¼€åä¼šå¤šç»Ÿè®¡ä¸€ä¸ª1ã€‚\n\näº‹å…ˆç»Ÿè®¡$\\{b_i\\}$æ¨¡$a$çš„ä½™æ•°ï¼Œé‚£ä¹ˆæœ‰$t$åå°±èƒ½å¿«é€Ÿæ•°å‡ºç¬¬2ç§æƒ…å†µçš„æ•°é‡ã€‚\n\n## ä»£ç \n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXA=1010,MAXB=100010;\n\nint nlen,mlen;\nint a[MAXB],acnt[MAXA];\nint b[MAXB];\n\nint fts[MAXA][MAXA];\nint pre[MAXA][MAXA];\n\nvoid force(int i){\n\tpre[i][0]=fts[i][0];\n\tfor(int j=1;j<MAXA;j++){\n\t\tpre[i][j]=pre[i][j-1]+fts[i][j];\n\t}\n}\n\nll base=0;\n\nbool check(ll k,ll t){\n\tll res=-base;\n\tfor(int i=1;i<=1000;i++){\n\t\tres+=(t/i)*acnt[i];\n\t\tint c=t%i;\n\t\tll offset=pre[i][1000]-pre[i][c];\n\t\tres-=offset;\n\t}\n\treturn res>=k;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\tint kase;cin>>kase;\n\twhile(kase--){\n\t\tmemset(acnt,0,sizeof(acnt));\n\t\tmemset(a,0,sizeof(a));\n\t\tbase=0;\n\t\tmemset(fts,0,sizeof(fts));\n\t\t\n\t\tcin>>nlen>>mlen;\n\t\tfor(int i=1;i<=nlen;i++){\n\t\t\tcin>>a[i];\n\t\t\tacnt[a[i]]+=1;\n\t\t}\n\t\tfor(int i=1;i<=nlen;i++){\n\t\t\tcin>>b[i];\n\t\t\tfts[a[i]][b[i]%a[i]]++;\n\t\t\tbase+=b[i]/a[i];\n\t\t}\n\t\tfor(int i=1;i<=1000;i++){\n\t\t\tforce(i);\n\t\t}\n\n\t\tfor(int i=1;i<=mlen;i++){\n\t\t\tint opt;\n\t\t\tcin>>opt;\n\t\t\tif(opt==1){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\n\t\t\t\tacnt[a[x]]--;\n\t\t\t\tfts[a[x]][b[x]%a[x]]--;\n\t\t\t\tbase-=b[x]/a[x];\n\t\t\t\tforce(a[x]);\n\n\t\t\t\ta[x]=y;\n\t\t\t\tfts[a[x]][b[x]%a[x]]++;\n\t\t\t\tacnt[a[x]]++;\n\t\t\t\tbase+=b[x]/a[x];\n\t\t\t\tforce(a[x]);\n\n\t\t\t\t\n\t\t\t}else if(opt==2){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\n\t\t\t\tfts[a[x]][b[x]%a[x]]--;\n\t\t\t\tbase-=b[x]/a[x];\n\t\t\t\tforce(a[x]);\n\n\t\t\t\tb[x]=y;\n\n\t\t\t\tfts[a[x]][b[x]%a[x]]++;\n\t\t\t\tforce(a[x]);\n\t\t\t\tbase+=b[x]/a[x];\n\t\t\t}else if(opt==3){\n\t\t\t\tint qk;cin>>qk;\n\t\t\t\tll l=0,r=1e13;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tll mid=(l+r)/2;\n\t\t\t\t\tif(check(qk,mid)){\n\t\t\t\t\t\tr=mid;\n\t\t\t\t\t}else l=mid+1;\n\t\t\t\t}\n\t\t\t\tfor(ll i=l;i<=r;i++){\n\t\t\t\t\tif(check(qk,i)){\n\t\t\t\t\t\tcout<<i<<\"\\n\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```","categories":["coding"]},{"title":"ç©ä¸€ç©ç½‘ç»œå°åŒ…","url":"%2F2019%2F10%2F14%2Fdo-something-with-network-packets%2F","content":"è¿™ç¯‡æ–‡ç« æ˜¯ä¸ºäº†åœ¨è‹±è¯­è¯¾presentationä¸Šå£èƒ¡httpså‡†å¤‡çš„ã€‚æ‰“ç®—åœ¨ç°åœºæ¼”ç¤ºä¸€æ¬¡ç®€æ˜“çš„ç½‘ç»œæ”»å‡»ï¼Œé¡ºä¾¿æŠŠæ—¶é—´æ°´ä¸€æ°´ã€‚æ‰€ä»¥åœ¨è¿™æ—¶æ¥å…ˆç®€å•äº†è§£ä¸€ä¸‹ç½‘ç»œå°åŒ…çš„æ ·å­ã€‚\n\n## OSIæ¨¡å‹\n\næ ‡å‡†åŒ–çš„è®¡ç®—æœºé€šä¿¡æ¨¡å‹ï¼Œè¯•å›¾ä½¿å„ç§è®¡ç®—æœºåœ¨ä¸–ç•ŒèŒƒå›´å†…äº’è¿ä¸ºç½‘ç»œçš„æ ‡å‡†æ¡†æ¶ã€‚\n\nç®€å•çš„æ¥è¯´ï¼Œå°±æ˜¯å°†ä¸€æ¬¡ç½‘ç»œé€šä¿¡åœ¨ä¸åŒå±‚çº§ä¸Šçš„æŠ½è±¡ï¼Œå¹¶åœ¨ä¸åŒå±‚ä¸Šå®ç°åŠŸèƒ½ï¼Œå®Œæˆæ•´ä¸ªé€šä¿¡ç³»ç»Ÿçš„æ„å»ºã€‚è™½ç„¶çœ‹èµ·æ¥è™šå¹»é£˜æ¸ºï¼Œæˆ‘ç”šè‡³è¿˜æ²¡å­¦ï¼Œä½†æ¥ä¸‹æ¥çš„æ”»å‡»æ˜¯å¿…é¡»è¦å¼„æ¸…å…¶æ˜¯åœ¨å“ªä¸€å±‚é¢ä¸Šçš„ï¼Œè¦ä¸ç„¶æ— ä»ä¸‹æ‰‹ã€‚\n\n> å¾…è¡¥å……\n\n## ARP æ±¡æŸ“\n\nè¿™æ˜¯è¿™æ¬¡ä¸»è¦å¼€åˆ€çš„å¯¹è±¡ï¼Œå®ç°è¾ƒä¸ºæ–¹ä¾¿ï¼Œæ¼”ç¤ºæ•ˆæœä¹Ÿä¸é”™ã€‚\n\nåœ¨ä»¥å¤ªç½‘åè®®ä¸­è§„å®šï¼ŒåŒä¸€å±€åŸŸç½‘ä¸­çš„ä¸€å°ä¸»æœºè¦å’Œå¦ä¸€å°ä¸»æœºè¿›è¡Œç›´æ¥é€šä¿¡ï¼Œå¿…é¡»è¦çŸ¥é“ç›®æ ‡ä¸»æœºçš„MACåœ°å€ã€‚ç„¶è€ŒIPåè®®å¹¶ä¸å…³å¿ƒMACåœ°å€ï¼Œæ‰€ä»¥æœ‰å¿…é¡»å†æœ‰ä¸€ä¸ªåº•å±‚çš„åè®®å»å°†IPå’ŒMAC bindèµ·æ¥ã€‚ARPåè®®å°±æ˜¯ç”¨æ¥åšè¿™ä¸ªçš„ã€‚\n\nå½“ä¸¤ä¸ªèŠ‚ç‚¹ä¸åœ¨ç›¸åŒå±€åŸŸç½‘æ—¶ï¼Œåˆ™éœ€è¦æœ‰ç½‘å…³ä¸­è½¬ï¼Œæ­¤æ—¶bindçš„MACåœ°å€ä¸ºç½‘å…³MACã€‚ARPæ”»å‡»çš„åŸç†å°±æ˜¯å°†è‡ªå·±ä¼ªè£…æˆç½‘å…³ï¼Œä»è€ŒåŠ«æŒæ•´ä¸ªå±€åŸŸç½‘å†…çš„æµé‡ã€‚è€Œä¸€æ—¦æ‹¿åˆ°æ˜æ–‡æµé‡åï¼Œæˆªå–æ¶ˆæ¯ã€è·å–å¯†ç ã€ä¿®æ”¹è¿”å›æ•°æ®ï¼Œéƒ½æ˜¯å¯ä»¥çš„ã€‚\n\n## BetterCap\n\næ–°ä¸€ä»£çš„â€œEtterCapâ€ã€‚æœ¬æ¥æˆ‘æœ‰ç‚¹æƒ³é‚£scapyæ¥è‡ªå·±å†™ä¸€ä¸ªå·¥å…·æ¥ç€ï¼Œä½†æ˜¯æˆ‘çš„é‡ç‚¹å¹¶ä¸åœ¨è¿™ï¼Œç›¸å¯¹ç°åœ¨æ¥è¯´æœ‰äº›è€½è¯¯æ—¶é—´ã€‚\n\nç¬¬2ä¸ªå¤§ç‰ˆæœ¬çš„BetterCapä¸ºæ¨¡å—åŒ–è®¾è®¡ï¼Œä¸ºäº†å®ç°æˆ‘ä»¬çš„ç›®æ ‡ï¼Œéœ€è¦å¼€å¯arpï¼Œnetä¸proxyæ¨¡å—ã€‚arpè´Ÿè´£è¿›è¡ŒæŠ•æ¯’ï¼Œnetè´Ÿè´£å—…æ¢å°åŒ…ï¼Œæˆ‘ä»¬ä½¿ç”¨proxyæ¥è·å–ä¿®æ”¹å°åŒ…çš„hookã€‚æ­é…è‡ªå·±çš„jsè„šæœ¬å°±èƒ½å¿«é€Ÿè¾¾åˆ°ç›®çš„ã€‚\n\n","categories":["é—²æ‰¯"]},{"title":"[CFEDU74 E] Keyboard Purchase","url":"%2F2019%2F10%2F09%2Fproblem-keyboard-purchase%2F","content":"å½“åœ¨ä½¿ç”¨ä¸€æŒ‡ç¦…é”®å…¥ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ—¶å€™ï¼Œä½ éœ€è¦ä¸åœçš„ç§»åŠ¨æ‰‹æŒ‡ã€‚æ¯”å¦‚è¯´è¾“å…¥â€œafâ€ï¼Œæ‰‹æŒ‡éœ€è¦è·¨è¿‡3ä¸ªé”®ï¼ˆåŒ…æ‹¬ç»ˆç‚¹ï¼‰è¾“å…¥â€œaâ€å’Œâ€œfâ€ã€‚\n\né’ˆå¯¹ä¸€ä¸ªç»å¸¸è¾“å…¥çš„å­—ç¬¦ä¸²ï¼Œä½ å¯ä»¥å®šåˆ¶ä¸€ä¸ªé•¿æ¡é”®ç›˜ï¼Œä½¿å¾—åœ¨è¿™ä¸ªé”®ç›˜ä¸Šè¾“å…¥å­—ç¬¦ä¸²éœ€è¦ç§»åŠ¨çš„è·ç¦»æœ€çŸ­ã€‚\n\nç»™å‡ºå­—ç¬¦ä¸²é•¿åº¦$n$ä¸å­—å…¸å¤§å°$k$ï¼ˆå°å†™å­—æ¯çš„å‰$k$ä¸ªï¼‰ï¼Œç»™å‡ºæœ€ä¼˜æƒ…å†µä¸‹æ‰‹æŒ‡éœ€è¦ç§»åŠ¨çš„è·ç¦»ã€‚\n\n## åˆ†æ\n\nè¿™é“é¢˜å’Œä¹‹å‰é‚£é“marbleså¾ˆåƒâ€¦â€¦æˆ–è€…è¯´çŠ¶å‹éƒ½æŒºåƒçš„ã€‚\n\n<!--more-->\n\né¢˜ç›®å³ä¾æ¬¡å†³å®šé”®ç›˜çš„ä¸‹ä¸€ä¸ªæŒ‰é”®è£…å•¥ï¼Œå¹¶åœ¨åŸå­—ç¬¦ä¸²é‡Œè®¡ç®—éœ€è¦ç§»åŠ¨çš„æ¬¡æ•°ã€‚è®¾$f(S)$è¡¨ç¤ºå·²ç»è€ƒè™‘äº†é›†åˆ$S$é‡Œæ‰€æœ‰çš„æŒ‰é”®ã€‚ä¸è¿‡ä»”ç»†æ€è€ƒä¸€ä¸‹å‘ç°è¿™ä¸ªä»£ä»·éœ€è¦çŸ¥é“å…ˆå‰å®‰è£…çš„æŒ‰é”®çš„é¡ºåºï¼Œè€Œè¿™ä¸ªé¡ºåºæ˜¾ç„¶ä¸èƒ½åŠ å…¥åˆ°çŠ¶æ€é‡Œï¼Œè¿™æ˜¯æ— æ³•æ¥å—çš„ã€‚å¿…é¡»è¦é€šè¿‡åˆ«çš„æ–¹å¼æ¥è®¡ç®—ã€‚\n\nç„¶åæˆ‘åˆå¡äº†ã€‚\n\nè¿™æ˜¯æ²¡è§è¿‡çš„è½¬ç§»æ–¹å¼â€¦â€¦è€ƒè™‘æœ¬è½®æ²¡æœ‰æ’å…¥é”®Aï¼Œé‚£ä¹ˆä¸€å®šå°±**æ’å…¥äº†åˆ«çš„é”®B**ï¼Œé‚£ä¹ˆï¼Œè¿™æ¬¡å¯¹äºäº‹ä»¶â€œæ’Aâ€çš„**ä¸€æ¬¡delay**ä¼šå¯¼è‡´åŸä¸²é‡ŒAå’Œç›¸é‚»**åœ¨é”®ç›˜ä¸Šå·²ç¡®å®šä½ç½®çš„**å­—æ¯é—´çš„è½¬ç§»å¤š**ä¸€ä¸ª**ä»£ä»·ã€‚\n\næœ‰ç§æ¨¡ç³Šçš„æ„Ÿè§‰ã€‚ä¹‹å‰é‚£ä¸ªé¢˜ç›®æ˜¯è®¡ç®—å½“å‰å…ƒç´ å’Œå·²æœ‰å…ƒç´ ä¹‹é—´çš„ä»£ä»·ï¼›è¿™ä¸ªæ˜¯è®¡ç®—å·²æœ‰å…ƒç´ å’Œæœªæœ‰å…ƒç´ ä¹‹é—´çš„ç´¯è¿›å¼ä»£ä»·ã€‚æä¸å¤ªæ¸…æ¥šè¿™ä¸ª$f(S)$ç°åœ¨ä»£è¡¨çš„æ˜¯ä»€ä¹ˆäº†â€¦ä¸çŸ¥å¯å¦æœ‰äººæŒ‡å¯¼ã€‚\n\n## ä»£ç \n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\nusing namespace std;\nusing ll=long long;\nconst int MAXK=21;\nint nlen,klen;\nstring inp;\n \nint cost[MAXK][MAXK];\nll dp[1<<20];\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin>>nlen>>klen;\n    cin>>inp;\n \n    for(int i=1;i<nlen;i++){\n        cost[inp[i-1]-'a'][inp[i]-'a']++;\n        cost[inp[i]-'a'][inp[i-1]-'a']++;\n    }\n \n \n    memset(dp,0x3f,sizeof(dp));\n    dp[0]=0;\n \n    for(int i=0;i<(1<<klen);i++){\n        ll scost=0;\n        for(int j=0;j<klen;j++){\n            if(!((i>>j)&1))continue;\n            for(int k=0;k<klen;k++){\n                if((i>>k)&1)continue;\n                scost+=cost[j][k];\n            }\n        }\n        for(int j=0;j<klen;j++){\n            if((i>>j)&1)continue;\n            dp[i|(1<<j)]=min(dp[i|(1<<j)],dp[i]+scost);\n        }\n    }\n \n    cout<<dp[(1<<klen)-1]<<endl;\n \n    \n \n    return 0;\n}\n```\n\n","tags":["åŠ¨æ€è§„åˆ’"],"categories":["coding"]},{"title":"[CF EDU72D] Coloring Edges","url":"%2F2019%2F10%2F06%2Fproblem-coloring-edges%2F","content":"You are given a directed graph with n vertices and m directed edges without self-loops or multiple edges.\n\nLet's denote the k-coloring of a digraph as following: you color each edge in one of k colors. The k-coloring is good if and only if there no cycle formed by edges of same color.\n\nFind a good k-coloring of given digraph with minimum possible k.\n\n## åˆ†æ\n\nå¯¹æˆ‘è¿™ä¸ªèœé¸¡æ¥è¯´ï¼Œå»æŸ“è‰²è¿”ç¥–è¾¹çš„æ“ä½œå¹¶ä¸æ€ä¹ˆæ˜¾ç„¶â€¦â€¦ç®—äº†â€¦â€¦\n\næ²¡èƒ½åšæŒåªæœ‰2ç§é¢œè‰²çš„çŒœæƒ³ã€‚æŒ‚åŸå¢™ã€‚\n\næ²¡å¿…è¦æŒ‚ä»£ç ã€‚","tags":["çåš"],"categories":["coding"]},{"title":"[CF585E] Marbles","url":"%2F2019%2F10%2F05%2Fproblem-marbles%2F","content":"Monocarp has arranged n colored marbles in a row. The color of the i-th marble is ai. Monocarp likes ordered things, so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment (and there is only one such segment for each color).\n\nIn other words, Monocarp wants to rearrange marbles so that, for every color j, if the leftmost marble of color j is l-th in the row, and the rightmost marble of this color has position r in the row, then every marble from l to r has color j.\n\nTo achieve his goal, Monocarp can do the following operation any number of times: choose two neighbouring marbles, and swap them.\n\nYou have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles. Note that the order of segments of marbles having equal color does not matter, it is only required that, for every color, all the marbles of this color form exactly one contiguous segment.\n\n## åˆ†æ\n\nè¿™é“é¢˜çš„ç¿»è¯‘å°±æ˜¯â€œé‡æ–°ç¡®å®šæ¯ä¸ªé¢œè‰²çš„æƒå€¼ï¼Œä½¿å¾—é€†åºå¯¹æœ€å°‘â€ã€‚\n\nç„¶åæˆ‘å°±å¡äº†ï¼Œç°åœ¨æˆ‘ä¹Ÿä¸æ˜¯ç‰¹åˆ«æ¸…æ¥šä¸ºå•¥å¯ä»¥dpï¼Œåªæ˜¯çŸ¥é“èƒ½dpã€‚\n\né€‰æ‹©çŠ¶æ€$f(S)$è¡¨ç¤ºé›†åˆ$S$å·²ç»å…¨éƒ¨åˆ†é…æƒå€¼æ—¶äº§ç”Ÿçš„æœ€å°‘é€†åºå¯¹ã€‚æšä¸¾ä¸‹ä¸€ä¸ªé¢œè‰²ï¼Œç»™äºˆä¸‹ä¸€ä¸ªï¼ˆè¾ƒå°ï¼‰æƒå€¼ï¼Œå¹¶è®¡ç®—ä»£ä»·ã€‚\n\n$$\nf(S+\\{i\\})=min\\{f(S)+w\\}\n$$\n\næ¥ä¸‹æ¥æ˜¯wçš„å¤„ç†ã€‚æˆ‘ä»¬éœ€è¦çš„æ˜¯åœ¨å½“å‰é¢œè‰²çš„æ‰€æœ‰ç‚¹å‰çš„**å·²ç»æ‹¥æœ‰æ–°æƒå€¼**çš„ç‚¹æ•°ç›®ï¼Œè¿™å¯ä»¥äº‹å…ˆé¢„å¤„ç†ã€‚é¢„å¤„ç†é¢œè‰²iå‰é¢œè‰²jçš„pairæ•°å³å¯ã€‚\n\n## ä»£ç \nä¸å°å¿ƒæŠŠptræ‰”åˆ°äº†é‡Œå±‚å¾ªç¯é‡ŒTäº†å‘â€¦\n\næ˜æ˜ç¬¬ä¸€æ­¥å®Œäº‹éƒ½å¾ˆç›´ç™½äº†ï¼Œå°±æ˜¯éå¾—è¢«å¡ä¸€ä¸‹ã€‚\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <stack>\n#include <cstring>\n#include <string>\nusing namespace std;\nusing ll=long long;\nconst int MAXN = 400010;\nconst int MAXC=21;\n \nint nlen;\nint num[MAXN];\nvector<int> pos[MAXC];\nll cnt[MAXC][MAXC];\nint tick=0;\nint newColor[MAXN];\n \nll dp[1<<MAXC];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n \n    cin>>nlen;\n    for(int i=0;i<nlen;i++){\n        cin>>num[i];\n    }\n    memset(newColor,-1,sizeof(newColor));\n    for(int i=0;i<nlen;i++){\n        if(newColor[num[i]]==-1)newColor[num[i]]=tick++;\n        pos[newColor[num[i]]].push_back(i);\n    }\n \n    for(int i=0;i<tick;i++){\n        for(int j=0;j<tick;j++){\n            if(i==j)continue;\n            int ptr=0;\n            for(int k=0;k<pos[i].size();k++){\n                if(ptr<0)ptr=0;\n                while(ptr<pos[j].size() && pos[j][ptr]<pos[i][k])ptr++;\n                ptr--;\n                if(ptr>=0 && pos[j][ptr]<pos[i][k]){\n                    cnt[i][j]+=ptr+1;\n                }\n            }\n        }\n    }\n \n \n    memset(dp,0x3f,sizeof(dp));\n    dp[0]=0;\n    for(int i=0;i<(1<<tick);i++){\n        for(int j=0;j<tick;j++){\n            if((i>>j)&1)continue;\n            ll diff=0;\n            for(int k=0;k<tick;k++){\n                if((i>>k)&1)diff+=cnt[j][k];\n            }\n            dp[i|(1<<j)]=min(dp[i|(1<<j)],dp[i]+diff);\n        }\n    }\n \n    cout<<dp[(1<<tick)-1]<<endl;\n \n    return 0;\n}\n```","tags":["åŠ¨æ€è§„åˆ’"],"categories":["coding"]},{"title":"[CF585D] Ticket Game","url":"%2F2019%2F10%2F05%2Fproblem-ticket-game%2F","content":"Monocarp and Bicarp live in Berland, where every bus ticket consists of n digits (n is an even number). During the evening walk Monocarp and Bicarp found a ticket where some of the digits have been erased. The number of digits that have been erased is even.\n\nMonocarp and Bicarp have decided to play a game with this ticket. Monocarp hates happy tickets, while Bicarp collects them. A ticket is considered happy if the sum of the first $\\frac n2$ digits of this ticket is equal to the sum of the last $\\frac n2$ digits.\n\nMonocarp and Bicarp take turns (and Monocarp performs the first of them). During each turn, the current player must replace any erased digit with any digit from 0 to 9. The game ends when there are no erased digits in the ticket.\n\nIf the ticket is happy after all erased digits are replaced with decimal digits, then Bicarp wins. Otherwise, Monocarp wins. You have to determine who will win if both players play optimally.\n\n## åˆ†æ\n\nåœ¨åšè¿™é“é¢˜çš„æ—¶å€™ï¼Œæˆ‘å‘ç°äº†å®é™…ä¸Šå½±å“ç­”æ¡ˆçš„åªå’Œä¸¤è¾¹çš„ å·²çŸ¥æ•°çš„å’Œ ä»¥åŠæœªçŸ¥ä½çš„æ•°ç›®æœ‰å…³ï¼Œå‘ç°äº†è·èƒœçš„æ ¹æœ¬æ˜¯å‰åä¸¤éƒ¨åˆ†å’Œçš„å·®å€¼å¤§å°ï¼Œå‘ç°äº†å…ˆæ‰‹çš„ç›®çš„æ˜¯**æ‰©å¤§å·®å€¼**ä½¿å¾—åæ‰‹æ— æ³•é€šè¿‡æŸç§æ–¹å¼è¿½èµ¶ã€‚\n\nä½†æ˜¯åˆ°è¿™æˆ‘å°±å¡ä½äº†ã€‚æ·¦ï¼Œä¸ºä»€ä¹ˆæˆ‘è¿™ä¹ˆèœã€‚\n\næ¥ä¸‹æ¥è¦è€ƒè™‘çš„æ˜¯**ä¼˜åŠ¿**ï¼Œåœ¨è¿™é“é¢˜é‡Œä¼˜åŠ¿å°±æ˜¯å·®å€¼ã€‚å…ˆæ‰‹çš„ç›®çš„æ˜¯æ‰©å¤§ä¼˜åŠ¿ï¼Œåœ¨å¤§çš„ä¸€è¾¹å¢å¤§ä¼šåŠ å¤§ä¼˜åŠ¿ï¼Œè€Œåœ¨å°çš„ä¸€è¾¹ç½®0ä¸ä¼šæ‰©å¤§ä¼˜åŠ¿ï¼›åæ‰‹è¦**å‡å°ä¼˜åŠ¿**ï¼ŒåŒæ ·çš„åŠæ³•å°±æ˜¯åœ¨å°çš„ä¸€ä¾§ç½®æ•°æ¥è¿½èµ¶å¦ä¸€ä¾§ï¼Œåœ¨å¤§çš„ä¸€ä¾§ç½®0ä¸ä¼šæ›´å¥½ã€‚\n\né‚£ä¹ˆï¼Œåˆå¯ä»¥å¾—å‡ºå…ˆæ‰‹æ‰©å¤§ä¼˜åŠ¿æœ€å¥½çš„åŠæ³•æ˜¯ç½®9ï¼ˆæœ€å¤§ï¼‰ã€‚é‚£ä¹ˆæ¸¸æˆæœ€å¼€å§‹çš„å‡ æ­¥ï¼Œå°±æ˜¯åŒæ–¹åœ¨ä¸¤ä¾§å¡«å†™9ã€‚ç›´åˆ°æŸä¾§ä¸å†æœ‰ç©ºä½ã€‚\n\næ­¤æ—¶ï¼Œå¦‚æœç©ºä½åœ¨å¤§çš„ä¸€ä¾§ï¼Œå…ˆæ‰‹å¿…èµ¢ã€‚å¦‚æœç©ºä½åœ¨å°çš„ä¸€ä¾§ï¼Œç»§ç»­è®¨è®ºå¦‚ä¸‹\n\n$$\nx_1+x_2+\\cdots+x_n=C\n$$\n\né¦–å…ˆ$2|n$æ˜¾ç„¶ã€‚\n\nå½“Cä¸æ˜¯9çš„å€æ•°æ—¶ï¼Œå…ˆæ‰‹æ€»æœ‰åŠæ³•è®©æœ€ç»ˆç»“æœåç¦»ã€‚å› æ­¤è¯¥æƒ…å†µåªæœ‰å½“$\\frac n2 \\times 9 = n$æ—¶åæ‰‹æ‰èƒ½è·èƒœã€‚\n\n## ä»£ç \n\nå«–äº†é˜Ÿå‹çš„â€¦æˆ‘çxxæçš„ç»“è®ºWA23äº†â€¦\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nchar s[200005];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tint cnt=0;\n\tint sum=0;\n\tfor(int i=1;i<=n/2;i++)\n\t{\n\t\tif(s[i]=='?') cnt++;\n\t\telse sum+=s[i]-'0';\n\t}\n\tfor(int i=n/2+1;i<=n;i++)\n\t{\n\t\tif(s[i]=='?') cnt--;\n\t\telse sum-=s[i]-'0';\n\t}\n\t//cout<<cnt<<\" \"<<sum<<endl;\n\tif(sum*2==-cnt*9) puts(\"Bicarp\");\n\telse puts(\"Monocarp\");\n}\n```","tags":["åšå¼ˆ"],"categories":["coding"]},{"title":"åç¼€è‡ªåŠ¨æœº","url":"%2F2019%2F10%2F04%2Fsuffix-automation%2F","content":"å¦‚ä½ æ‰€è§ï¼Œåç¼€è‡ªåŠ¨æœºã€‚\n\n> ç„¶è€Œå°±nmçœ‹ä¸æ‡‚ï¼Œå…ˆçœ‹ä¸æ‡‚å®ƒçš„å›¾æ˜¯å•¥ï¼Œåˆçœ‹ä¸æ‡‚å®ƒçš„è¾¹æ˜¯å•¥ï¼Œç°åœ¨è¿˜æ˜¯çœ‹ä¸æ‡‚å®ƒçš„è¾¹æ˜¯å’‹æ‰¾å‡ºæ¥çš„ã€‚å¯æ˜¯å’±ä¸æƒ³æä¸æ¸…æ¥šå®ƒæ˜¯å¹²å˜›çš„å°±ç›´æ¥ç”¨å•Šé ã€‚\n\nåç¼€è‡ªåŠ¨æœºé¦–å…ˆæ˜¯è‡ªåŠ¨æœºã€‚ä¸€ä¸ªå­—ç¬¦ä¸²Sçš„åç¼€è‡ªåŠ¨æœºèƒ½æ¥å—Sçš„æ‰€æœ‰åç¼€ã€‚åŸºäºå®ƒçš„è¿™ä¸ªæ€§è´¨ï¼Œå®ƒèƒ½å¤Ÿåšåˆ°ï¼š\n\n* æŸ¥è¯¢å­ä¸²æ˜¯å¦å‡ºç°ï¼šè¿™æ˜¾ç„¶è·‘ä¸€æ¬¡ï¼Œèƒ½åœ¨è‡ªåŠ¨æœºä¸Šè·‘å®Œå°±æ˜¯å‡ºç°è¿‡ã€‚\n* ç»Ÿè®¡ä¸åŒå­ä¸²çš„æ•°é‡ï¼šè‡ªåŠ¨æœºä¸Šæ¯æ¡ä¸åŒçš„è·¯å¾„å¯¹åº”ä¸€ä¸ªä¸åŒçš„å­ä¸²ã€‚å®šä¹‰$d(x)$ä¸ºä»¥xä¸ºèµ·ç‚¹çš„è·¯å¾„æ•°ç›®ï¼Œé€’æ¨å³å¯ã€‚\n* è®¡ç®—æ‰€æœ‰ä¸åŒå­ä¸²çš„é•¿åº¦æ€»å’Œï¼šå¾—åˆ°ä¸Šé¢çš„$d$ã€‚ä»¥xä¸ºèµ·ç‚¹ï¼Œæ¯æ¡è·¯å¾„éƒ½ä¼šè®©å­ä¸²**æ€»**é•¿åº¦å¢åŠ **è·¯å¾„ä¸ª**ã€‚ä¾ç„¶æ˜¯é€’æ¨ã€‚\n* å­—å…¸åºç¬¬kå°å­ä¸²ï¼šå½“ä½ æœ‰è·¯å¾„æ•°äº†ï¼Œåªéœ€è¦æŒ‰ç…§å­—å…¸åºå¯¹èŠ‚ç‚¹æ’åºï¼Œç„¶ååƒç¼–ç ä¸€æ ·æ‰¾ã€‚\n* æœ€å°å¾ªç¯ç§»ä½ï¼šæŒ‡å°†åŸå­—ç¬¦ä¸²é¦–å°¾ç›¸æ¥ç§»ä½ï¼Œæ‰¾åˆ°å­—å…¸åºæœ€å°çš„ä¸€ä¸ªã€‚å°†å­—ç¬¦ä¸²$S$æ–­ç¯æˆé“¾$SS$ï¼Œç„¶åå»ºç«‹SAMï¼Œè´ªå¿ƒæ‰¾æœ€å°ç›´åˆ°é•¿åº¦è¾¾åˆ°$|S|$å³å¯ã€‚\n* å¤šç»„å­ä¸²å‡ºç°æ¬¡æ•°ï¼šdfsé¢„å¤„ç†æ¯ä¸ªèŠ‚ç‚¹çš„ç»ˆç‚¹é›†åˆå¤§å°ã€‚åœ¨è‡ªåŠ¨æœºä¸ŠæŸ¥æ‰¾ä¸²$P$å¯¹åº”çš„èŠ‚ç‚¹,å­˜åœ¨åˆ™ç­”æ¡ˆä¸ºè¯¥èŠ‚ç‚¹çš„ç»ˆç‚¹é›†åˆå¤§å°ï¼›ä¸å­˜åœ¨ç­”æ¡ˆä¸º$0$.\n* æ‰€æœ‰å‡ºç°ä½ç½®ï¼šéå†æ ‘ï¼Œä¸€æ—¦å‘ç°ç»ˆç‚¹ç›´æ¥è¾“å‡ºã€‚\n\n## å»ºç«‹\n\næœ€æš´åŠ›çš„æ–¹å¼æ˜¯å»ºç«‹ä¸€ä¸ªO(n^2)çº§åˆ«çš„è‡ªåŠ¨æœºï¼Œä¸è¿‡é‚£ä¸ªå¤æ‚åº¦å°±æ²¡ä»€ä¹ˆæ„ä¹‰äº†ã€‚åç¼€è‡ªåŠ¨æœºéœ€è¦æ»¡è¶³çŠ¶æ€æ•°æœ€å°‘ï¼Œä¸ºçº¿æ€§çº§åˆ«ï¼Œä¸”è½¬ç§»ï¼ˆè¾¹ï¼‰ä¹Ÿä¸ºçº¿æ€§çº§åˆ«ã€‚\n\nç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹æŠ˜è…¾äº†ã€‚\n\nå®šä¹‰ä¸²Sçš„$endpos(x)$ä¸ºä¸€ä¸ªé›†åˆï¼Œå…ƒç´ ä¸ºxåœ¨å…¶å†…å‡ºç°çš„æ‰€æœ‰ä½ç½®çš„ç»“å°¾ä¸‹æ ‡ã€‚\n\n## èµ„æ–™\n\n* [å‚è€ƒèµ„æ–™](https://saisumit.wordpress.com/2016/01/26/suffix-automaton/)\n* 2015å¹´å›½å®¶é›†è®­é˜Ÿè®ºæ–‡\n\n### å­ä¸²ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®\nå¯¹SAMä¸­æ‰€æœ‰çŠ¶æ€é¢„å¤„ç†firstposï¼ˆç¬¬ä¸€æ¬¡å‡ºç°è¯¥çŠ¶æ€çš„æœ«ç«¯ä½ç½®ï¼Œä¹Ÿå°±æ˜¯endposé›†åˆçš„æœ€å°å…ƒç´ ï¼‰ã€‚\n\næ‰©å±•æºå‡½æ•°ä¸º`sam_extend()`ã€‚åˆ›å»ºæ–°çŠ¶æ€`cur`æ—¶ï¼Œä»¤\n\n$$\nfirstpos(cur)=len(cur)-1\n$$\n\nå½“`q`å¤åˆ¶åˆ°`clone`æ—¶ï¼Œä»¤\n\n$$\nfirstpos(clone)=firstpos(q)\n$$\n\néœ€è¦çš„ç­”æ¡ˆå°±æ˜¯$firstpos(t)-|P|+1$ï¼Œ$t$ä¸ºå­—ç¬¦ä¸²$P$çš„çŠ¶æ€ã€‚æ¯æ¬¡æŸ¥è¯¢éœ€è¦$O(|P|)$\n\n### æœ€çŸ­æœªå‡ºç°å­—ç¬¦ä¸²\nåŠ¨æ€è§„åˆ’ã€‚\n\nè®©$d_v$ä¸ºèŠ‚ç‚¹$v$çš„ç­”æ¡ˆã€‚å¦‚æœä¸å­˜åœ¨ä½¿ç”¨å­—ç¬¦é›†ä¸­è‡³å°‘ä¸€ä¸ªå­—ç¬¦çš„è½¬ç§»ï¼Œé‚£ä¹ˆ$d_v=1$ï¼Œå¦åˆ™\n\n$$\nd_v=1+\\min_{w:(v,w,c) \\in SAM} d_w\n$$\n\nå­—ç¬¦ä¸²å¯ä»¥ç”±è½¬ç§»æ¨å›å»ã€‚\n\n","tags":["åç¼€è‡ªåŠ¨æœº"],"categories":["study"]},{"title":"[CF589C] primes and multiplication","url":"%2F2019%2F09%2F30%2Fproblem-primes-and-multiplication%2F","content":"\nè®¾$primes(x)$ä¸ºxçš„è´¨å› æ•°çš„é›†åˆã€‚\n\nè®¾$g(x,p)$è¡¨ç¤ºå¯ä»¥æ•´é™¤xçš„æœ€å¤§çš„$p^k$ã€‚\n\nè®¾$f(x,y)$è¡¨ç¤ºå°†xä½œåˆ†è§£åå¯¹æ¯ä¸ªè´¨å› å­ä½œç”¨åˆ°1åˆ°yä¸Šæ±‚$g$çš„ä¹˜ç§¯ã€‚\n\næ±‚$f(x,n)$\n\n## åˆ†æ\n\nâ€¦â€¦æœ€åä½ ä¼šå‘ç°ï¼Œè¿™é¢˜å°±æ˜¯æ±‚é˜¶ä¹˜è´¨å› å­çš„ä¹˜ç§¯ã€‚\n\n## ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst int MAXN=1010;\nusing ll=long long;\nconst ll P=1e9+7;\n \nvector<ll> primes;\n \nvoid unpack(ll x){\n    ll b=x;\n    for(int i=2;i<=sqrt(b)+1;i++){\n        if(x%i==0)primes.push_back(i);\n        while(x%i==0)x/=i;\n    }\n    if(x!=1)primes.push_back(x);\n}\nll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(;b;b>>=1,a=a*a%p){\n        if(b&1)res=res*a%p;\n    }\n    return res;\n}\nll get(ll n,ll num){\n    ll res=0;\n    while(n){\n        res=(res+n/num)%(P-1);\n        n/=num;\n    }\n    return res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    ll x,n;cin>>x>>n;\n    unpack(x);\n \n    ll ans=1;\n    for(ll item:primes){\n        ans=ans*qpow(item,get(n,item),P)%P;\n    }\n    cout<<ans%P<<endl;\n \n    return 0;\n}\n```","tags":["æ•°è®º"],"categories":["coding"]},{"title":"[CCPC2019 ç§¦çš‡å²›] Angel Beats","url":"%2F2019%2F09%2F29%2Fproblem-angel-beats%2F","content":"\nç»™å‡ºä¸€äº›ç‚¹ï¼Œè¯¢é—®å¯¹äºç‚¹$(x,y)$ï¼Œæ±‚å…¶èƒ½å’Œå·²çŸ¥ç‚¹å½¢æˆå¤šå°‘ä¸ªç›´è§’ä¸‰è§’å½¢ã€‚\n\n## åˆ†æ\n\né¦–å…ˆï¼Œå¯¹äºè¯¢é—®çš„ç‚¹ï¼Œç›´æ¥åŠ å…¥é›†åˆç¦»çº¿æ“ä½œå°±å¯ä»¥ã€‚è¿™é“é¢˜å°±å˜æˆäº†å•çº¯çš„æ±‚ä¸‰è§’å½¢ã€‚ä¸€å¼€å§‹æˆ‘è·Ÿæ±‚é”è§’ä¸‰è§’å½¢é‚£é“é¢˜ä¸€æ ·åšï¼Œç„¶åå†™å¾—åˆæ¶å¿ƒåˆä¸çŸ¥é“å“ªé‡Œå‡ºäº†bugæ”¹ä¸å‡ºæ¥ã€‚\n\nåæ¥ï¼Œå®é™…ä¸Šå¯ä»¥äº‹å…ˆç›´æ¥æšä¸¾2ç‚¹æŒ‰ç…§æ–œç‡ç»Ÿè®¡è¾¹æ•°ï¼Œå¯¹æ¯ä¸ªæŸ¥è¯¢$lg(n^2)$æŸ¥è¯¢ï¼Œä¼šçœå¾ˆå¤šäº‹ã€‚\n\nä¹‹åçš„å°±æ˜¯å¾ˆæ˜¾ç„¶çš„ï¼šæŸ¥è¯¢ç‚¹ä½œä¸ºç›´è§’æ‰«ä¸€éï¼ŒæŸ¥è¯¢ç‚¹ä½œä¸ºéç›´è§’æ‰«ä¸€éã€‚\n\n## ä»£ç \n\næ·¦ã€‚\n\n```cpp\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\nconst int MAXN = 2010;\n\nstruct Point\n{\n    ll x, y;\n    Point(ll x, ll y) : x(x), y(y){};\n    Point(){}\n\n    Point normalize() const\n    {\n        if (x < 0 || (x == 0 && y < 0))\n            return Point(-x, -y);\n        return *this;\n    }\n\n    Point operator-(const Point &other) const\n    {\n        return Point(x - other.x, y - other.y);\n    }\n    bool operator<(const Point &other) const\n    {\n        //å°†çº¿æŒ‰ç…§æ–œç‡æ’åºï¼Œä»¥åœ¨mapä¸­ç»Ÿè®¡åˆ°ä¸€èµ·ã€‚\n        Point a = normalize(), b = other.normalize();\n        return a.y * b.x < b.y * a.x;\n    }\n};\nusing Vec = Point;\n\nPoint origin[MAXN],queries[MAXN];\nint ans[MAXN];\nmap<Vec,int> mp;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int nlen, qlen;\n    while (cin >> nlen >> qlen)\n    {\n        memset(ans,0,sizeof(ans));\n        for (int i = 0; i < nlen; i++)\n        {\n            cin>>origin[i].x>>origin[i].y;\n        }\n        for (int i = 0; i < qlen; i++)\n        {\n            cin>>queries[i].x>>queries[i].y;\n        }\n\n        for (int i = 0; i < nlen; i++)\n        {\n            mp.clear();\n            for (int j = 0; j < nlen; j++)\n            {\n                if (i == j)\n                    continue;\n                Vec temp = origin[j] - origin[i];\n                mp[temp]++;\n            }\n            for (int j = 0; j < qlen; j++)\n            {\n                Vec temp = queries[j] - origin[i];\n                ans[j] += mp[Vec(-temp.y, temp.x)];\n            }\n        }\n        /*\n        cout<<\"====not====\"<<endl;\n        for(int i=0;i<qlen;i++){\n            cout<<ans[i]<<\"\\t\";\n        }\n        cout<<endl<<\"====not====\"<<endl;\n        */\n\n        for (int i = 0; i < qlen; i++)\n        {\n            mp.clear();\n            for (int j = 0; j < nlen; j++)\n            {\n                Vec temp = origin[j] - queries[i];\n                ans[i] += mp[Vec(-temp.y, temp.x)];\n                mp[temp]++;\n            }\n        }\n\n        for (int i = 0; i < qlen; i++)\n        {\n            cout << ans[i] << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n```\n","tags":["è®¡ç®—å‡ ä½•"],"categories":["coding"]},{"title":"éŸ³ä¹ç›’æµ‹è¯•","url":"%2F2019%2F09%2F27%2Ftest-music-player%2F","content":"\næˆ‘è¿˜æ²¡ææ˜ç™½ä¸ºä»€ä¹ˆåœ¨é¦–é¡µä¸Šæ²¡æ³•åŠ è½½ï¼Œçœ‹èµ·æ¥æ˜¯æ’ä»¶å†…éƒ¨æœ‰bugã€‚\n\nå°±æ‹¿ä¸œæ–¹çš„åŒäººBGMæ¥åšä¸ªæµ‹è¯•å§ã€‚\n\n{% aplayer \"ä¸‡å¹´ç½®ãå‚˜ã«ã”æ³¨æ„ã‚’\" \"k-waves LAB\" \"k-waves.m4a\" \"music.jpg\" %}","categories":["é—²æ‰¯"]},{"title":"Rustå­¦ä¹ è®°å½•","url":"%2F2019%2F09%2F24%2Flearning-rust%2F","content":"\nåŸºäºå¯¹Rustçš„æµ…è–„ç†è§£ï¼Œå®ƒä¸€å®šæ˜¯æœªæ¥ä¸€é—¨é‡è¦çš„è¯­è¨€ã€‚å› æ­¤ï¼Œä¸ºäº†è¿›ä¸€æ­¥äº†è§£è¿™å“¥ä»¬ï¼Œå¯¹Rustçš„å­¦ä¹ å°†é€æ­¥å±•å¼€ã€‚\n\n## å‚è€ƒèµ„æ–™\n\n1. [Rust The Bookå­¦ä¹ å¿ƒå¾—](https://rustlang-cn.org/users/book-exp/)\n2. [Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/index.html)\n3. Rustç¼–ç¨‹ä¹‹é“ï¼ˆå®ä½“ä¹¦ï¼‰\n\nç¬¬ä¸€ä¸ªèµ„æºæ¥è‡ªå›½å†…ä¸€dalaoï¼Œåè¯»ä¹¦ç¬”è®°ï¼›ç¬¬äºŒä¸ªåˆ™æœ‰äº›æœ‰è¶£ï¼Œå®ƒåœ¨ä½¿ç”¨rustå®Œæˆä¸€ç³»ç±»åˆ—è¡¨çš„è¿‡ç¨‹ä¸­è¿›è¡Œrustçš„æ•™å­¦ã€‚\n\n*ç›®å‰è¿›åº¦ï¼šæ…¢é€Ÿé˜…è¯»ç¬¬äºŒé¡¹ä¸­*\n\n## å†…å­˜æ¨¡å‹\n\næ¢³ç†ä¸€ä¸‹ç°å­˜çš„å†…å­˜ç®¡ç†æ¨¡å‹ã€‚å¤§è‡´ä¸Šåˆ†ä¸ºä¸¤ç§ï¼š\n\n1. GCï¼Œä¾‹å¦‚Javaä¸C#\n2. è‡ªè¡Œç®¡ç†ï¼Œä¾‹å¦‚c++\n\nè¿™ä¸¤ç§æŠ€æœ¯å„æœ‰åˆ©å¼Šã€‚Rustæä¾›äº†ä¸€ç§ä¸åŒäºä»¥ä¸Šä¸¤ç§åŠæ³•çš„å†…å­˜æ¨¡å‹ï¼Œæ‰€å±æƒæ¨¡å‹ã€‚ä¸€ä¸ªå†…å­˜æœ‰å®ƒçš„å½’å±ï¼Œå¯¹æŸä¸ªå˜é‡çš„è¯»å†™éœ€è¦æ¶‰åŠâ€œå€Ÿå‡ºâ€â€œè¿˜å›â€ï¼Œåˆç”±æ­¤è¯ç”Ÿâ€œç”Ÿå‘½å‘¨æœŸâ€çš„æ¦‚å¿µã€‚é€šè¿‡è¿™å¥—ç³»ç»Ÿï¼ŒRustå®ç°äº†**å®‰å…¨ä¸”æ— ä»£ä»·çš„å†…å­˜ç®¡ç†åŠæ³•**ã€‚\n\n### æ‰€æœ‰æƒ\n\n* Rustä¸­å˜é‡é»˜è®¤ä¸å¯å˜ã€‚\n\nå˜é‡åœ¨rustä¸­ï¼Œè¿˜æœ‰ç€æ‰€æœ‰æƒçš„æ¦‚å¿µã€‚\n\n* å½“å˜é‡ä»¥ä¼ å€¼æ–¹å¼ä¼ æ’­ï¼Œé‚£ä¹ˆåŸæœ‰çš„æ‰€æœ‰æƒå°†ä¼š**ç§»åŠ¨**ç»™æ–°çš„å˜é‡åï¼ŒåŸæœ‰å˜é‡åä½œåºŸã€‚\n* å˜é‡å¯ä»¥åˆ›å»ºåªè¯»å¼•ç”¨ï¼Œå¹¶ç”¨äºä¼ é€’ã€‚åªè¯»å¼•ç”¨å¯ä»¥æœ‰å¤šä¸ªã€‚\n* å˜é‡å¯ä»¥åˆ›å»ºè¯»å†™å¼•ç”¨ã€‚åªèƒ½æœ‰ä¸€ä¸ªã€‚\n* åªè¯»ä¸è¯»å†™å¼•ç”¨ä¸å¯åŒæ—¶å­˜åœ¨ã€‚\n\nè¿™æ ·å°±ä»æ ¹æºä¸Šè§£å†³äº†ä¸€äº›é—®é¢˜ï¼Œä¾‹å¦‚å¤šçº¿ç¨‹è¯»å†™å¯èƒ½å‡ºç°çš„å„ç§é—®é¢˜ã€‚ä¸è¿‡è¿˜æ˜¯ä¸æ˜¯å¾ˆæ¸…æ¥šè¿™ç§æƒ…å†µä¸‹è¦å¦‚ä½•å®ç°åŸæœ¬çš„åŠŸèƒ½ã€‚\n\n### ç”Ÿå‘½å‘¨æœŸ\n\næƒ³è±¡è¿™æ ·ä¸€ç§æƒ…å†µï¼Œâ€œåˆ›å»ºä¸€ä¸ªé“¾è¡¨çš„è¿­ä»£å™¨â€ã€‚ä¸€ä¸ªå¿…è¦çš„é—®é¢˜æ˜¯ç¡®ä¿ä½¿ç”¨è¿­ä»£å™¨æ—¶**å…¶æ‰€æŒ‡å‘çš„é“¾è¡¨æ²¡æœ‰å‡ºç°é—®é¢˜**ï¼ˆä¾‹å¦‚è¢«é”€æ¯ï¼‰ã€‚\n\nåœ¨functionçš„å±‚çº§ä¸­ï¼Œrustcèƒ½å¤Ÿè‡ªåŠ¨æ¨å¯¼å‡ºå˜é‡çš„ä¼ é€’å…³ç³»ä¸å…¶*æœ€å°*ç”Ÿå‘½å‘¨æœŸã€‚è€Œç¨‹åºä¸Šå‡åˆ°ç»“æ„ã€æ¶æ„ã€APIä¸Šåï¼Œç»§ç»­æ¨å¯¼ç”Ÿå‘½å‘¨æœŸå°±ä¸æ˜¯å¾ˆå¥½åšåˆ°ï¼Œå¯èƒ½ä¼šè€—è´¹å¤§é‡ç¼–è¯‘æ—¶é—´ä¸èµ„æºã€‚æ­¤æ—¶ï¼Œè®©ä½¿ç”¨è€…ä¸»åŠ¨æ ‡è®°ç”Ÿå‘½å‘¨æœŸä¼šæ›´æœ‰æ•ˆç‡ã€‚å°½ç®¡æ­¤æ—¶å¯èƒ½æ— æ³•è¾¾åˆ°*æœ€å°*çš„ç›®æ ‡ã€‚\n","tags":["rust"],"categories":["study"]},{"title":"[CF1221F] Choose a Sequence","url":"%2F2019%2F09%2F23%2Fproblem-choose-a-sequence%2F","content":"\nPetya recently found a game \"Choose a Square\". In this game, there areÂ nnÂ points numbered fromÂ 11Â toÂ nnÂ on an infinite field. TheÂ ii-th point has coordinatesÂ (xi,yi)Â and costÂ ci.\n\nYou have to choose a square such that its sides are parallel to coordinate axes, the lower left and upper right corners belong to the lineÂ y=x, and all corners have integer coordinates.\n\nThe score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square. Note that the length of the side can be zero.\n\nPetya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square.\n\n{% asset_img a.png %}\n\n## åˆ†æ\n\nè¿™é“é¢˜å…¶å®å’Œå¤šæ ¡çš„Snowy Smileï¼ˆé¢˜æ–‡æ— å…³ï¼‰æŒºåƒçš„ã€‚\n\n<!--more-->\n\néœ€è¦è½¬åŒ–æ¡ä»¶ã€‚æ­£æ–¹å½¢å…¨éƒ¨ä½äºåæ ‡ç³»ç¬¬ä¸€è±¡é™çš„å¹³åˆ†çº¿ä¸Šï¼Œå¯ä»¥è¡¨ç¤ºä¸º$(l,r)$è¿™ç§å½¢å¼ã€‚ä¸€ä¸ªåœ¨æ­£æ–¹å½¢å†…çš„ç‚¹$(x,y)$(å‡è®¾$x < y$,ç”±äºè¿™ä¸ªé¢˜ç›®çš„ç‰¹æ€§ï¼Œä¸æ»¡è¶³æ—¶å¯ä»¥ç›´æ¥è°ƒæ¢)æ»¡è¶³çš„æ¡ä»¶ä¸º\n\n$$l \\leq x \\leq y \\leq r$$\n\nç”±æ­¤ï¼Œè¿™é“é¢˜å°±å˜æˆäº†äºŒç»´ååºã€‚æœ¬æ¥çš„æœ¬æ¥ï¼Œä¸Šä¸ªé•¿å¾—åƒæ ‘çŠ¶æ•°ç»„ä¸€ç±»çš„ä¸œè¥¿å°±è§£å†³äº†ã€‚\n\nå°†ç‚¹æŒ‰ç…§ç¬¬ä¸€ç»´æ’åºï¼Œä»å¤§åˆ°å°æšä¸¾ï¼Œåœ¨æ•°æ®ç»“æ„ä¸­ç»´æŠ¤ç»“å°¾åˆ°rçš„å‰ç¼€å’Œæœ€å¤§å€¼ï¼Œå¹¶æŸ¥è¯¢ï¼Œæ›´æ–°å…¨å±€ç­”æ¡ˆã€‚ä¸è¿‡è¿™ä¸ªé¢˜ç›®è¿˜è¦æ±‚æƒå€¼è¦å‡å»æ­£æ–¹å½¢è¾¹é•¿wã€‚\n\n$$f(r)-(r-l)=l+[f(r)-r]$$\n\nç»´æŠ¤æœ€å¤§å€¼ï¼Œyåˆ†å¼€ï¼Œåªåœ¨pushupæ—¶åˆåœ¨ä¸€èµ·ã€‚\n\nç„¶åè¿˜è¦ç¦»æ•£åŒ–â€¦â€¦\n\n## ä»£ç \n\nè¿™é¢˜ç»™æˆ‘æ•´è‡ªé—­äº†ï¼Œæˆ‘æƒ³ç”¨çº¿æ®µæ ‘å•ç‚¹ä¿®æ”¹æ¥é­”å¹»ç»´æŠ¤æˆ‘éœ€è¦çš„æ•°æ®ï¼ŒåŠ åŠ å‡å‡ã€‚ç»“æœå‘ç°2ç§ç»´æŠ¤æ–¹å¼éƒ½æœ‰æ— æ³•è§£å†³çš„é—®é¢˜ã€‚æœ€ååªèƒ½æ‰“tagã€‚\n\nçº¿æ®µæ ‘ç»´æŠ¤$f(n)$ä¸ºåˆ°$n$ä¸ºæ­¢çš„å‰ç¼€å’Œã€‚æ¯æ¬¡åŠ ç‚¹ä»¥$x$ä¸ºç»„ï¼Œå¯¹å·²æœ‰ç‚¹å‡å»æ–°å¢çº¿æ®µçš„é•¿åº¦ï¼Œå†åŠ ä¸Šæ–°ç‚¹çš„å½±å“ã€‚é‚£ä¹ˆåœ¨çº¿æ®µæ ‘ä¸Šç»´æŠ¤çš„å°±æ˜¯ç­”æ¡ˆã€‚å–å‡ºæœ€å¤§å€¼å³å¯ã€‚\n\nä»£ç å†™å¾—åˆé•¿åˆä¸‘ï¼Œä¸è¿‡è¿‡äº†ã€‚\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=500010*4;\n\nll tag[MAXN];\nll dMax[MAXN];\nint dy[MAXN];\nint lc[MAXN],rc[MAXN],idx=0;\nvoid build(int &n,int l,int r){\n    if(!n)n=++idx;\n    dy[n]=r;\n    if(l>=r){\n        tag[n]=0;\n        return;\n    }\n\n    int mid=(l+r)/2;\n    build(lc[n],l,mid);\n    build(rc[n],mid+1,r);\n}\nvoid pushdown(int n,int l,int r){\n    if(!tag[n])return;\n    tag[lc[n]]+=tag[n];\n    tag[rc[n]]+=tag[n];\n    dMax[lc[n]]+=tag[n];\n    dMax[rc[n]]+=tag[n];\n\n    tag[n]=0;\n}\nvoid collect(int n){\n    if(dMax[lc[n]]>dMax[rc[n]]){\n        dMax[n]=dMax[lc[n]];\n        dy[n]=dy[lc[n]];\n    }else{\n        dMax[n]=dMax[rc[n]];\n        dy[n]=dy[rc[n]];\n    }\n}\nvoid modify(int l,int r,int x,int L,int R,int n){\n    if(l<=L && R<=r){\n        tag[n]+=x;\n        dMax[n]+=x;\n        return;\n    }\n    pushdown(n,L,R);\n\n    int mid=(L+R)/2;\n    if(l<=mid)modify(l,r,x,L,mid,lc[n]);\n    if(mid<r)modify(l,r,x,mid+1,R,rc[n]);\n    collect(n);\n}\n\nbool operator<(const pair<ll,int> &a,const pair<ll,int> &b){\n    return a.first<b.first;\n}\n\npair<ll,int> query(int l,int r,int L,int R,int n){\n    if(l<=L && R<=r){\n        return make_pair(dMax[n],dy[n]);\n    }\n    pushdown(n,L,R);\n    \n    int mid=(L+R)/2;\n    pair<ll,int> res=make_pair(-0x3f3f3f3f,0);\n    if(l<=mid)res=max(res,query(l,r,L,mid,lc[n]));\n    if(mid<r)res=max(res,query(l,r,mid+1,R,rc[n]));\n\n    return res;\n}\nstruct Point{\n    int x,y,w;\n} points[MAXN];\nvector<int> nums;\nint root=0;\nint main(){\n    /*\n    build(root,1,10);\n    int opt;\n    while(cin>>opt){\n        if(opt==1){\n            int l,r,x;cin>>l>>r>>x;\n            modify(l,r,x,1,10,root);\n        }\n        if(opt==2){\n            int l,r;cin>>l>>r;\n            cout<<query(l,r,1,10,root).first<<\" \"<<query(l,r,1,10,root).second<<endl;\n        }\n    }\n    */\n    \n\n    int nlen;cin>>nlen;\n\n    for(int i=1;i<=nlen;i++){\n        Point &p=points[i];\n        cin>>p.x>>p.y>>p.w;\n        if(p.x>p.y)swap(p.x,p.y);\n        nums.push_back(p.y);\n        nums.push_back(p.x);\n    }\n    sort(nums.begin(),nums.end());\n    auto rit=unique(nums.begin(),nums.end());\n    for(int i=1;i<=nlen;i++){\n        points[i].x=lower_bound(nums.begin(),rit,points[i].x)-nums.begin();\n        points[i].y=lower_bound(nums.begin(),rit,points[i].y)-nums.begin();\n    }\n\n    sort(points+1,points+1+nlen,[](const Point &a,const Point &b){\n        if(a.x!=b.x)return a.x>b.x;\n        return a.y<b.y;\n    });\n\n    int len=rit-nums.begin()-1;\n    build(root,0,len);\n    vector<int>::iterator lastit=rit-1;\n    pair<ll,int> ans=make_pair(-0x3f3f3f3f,0);\n    int pairl=-0x3f3f3f3f;\n    for(int i=1;i<=nlen;i++){\n        int thisx=points[i].x;\n        //auto it=lower_bound(nums.begin(),rit,points[i].x);\n        auto it=nums.begin()+thisx;\n        for(;lastit!=it;lastit--){\n            modify(lastit-nums.begin(),len,*(lastit-1)-*lastit,0,len,root);\n            //cout<<\"cost \"<<*(lastit-1)-*lastit<<\" from \"<<lastit-nums.begin()<<\" to \"<<len<<endl;\n        }\n        /*\n        for(int j=0;j<=len;j++){\n            cout<<query(j,j,0,len,root).first<<\"\\t\";\n        }\n        cout<<endl;\n        */\n        while(i<=nlen && points[i].x==thisx){\n            const Point &p=points[i];\n            modify(p.y,len,p.w,0,len,root);\n            //cout<<\"add \"<<p.w<<\" from \"<<p.y<<\" to \"<<len<<endl;\n            i++;\n        }\n        i--;\n        /*\n        for(int j=0;j<=len;j++){\n            auto temp2=query(j,j,0,len,root);\n            cout<<temp2.first<<\",\"<<temp2.second<<\"\\t\";\n        }\n        cout<<endl;\n        */\n\n        pair<ll,int> temp=query(0,len,0,len,root);\n        if(ans<=temp){\n            ans=temp;\n            pairl=nums[thisx];\n        }\n    }\n\n    if(ans.first>0){\n        cout<<ans.first<<endl;\n        cout<<pairl<<\" \"<<pairl<<\" \"<<nums[ans.second]<<\" \"<<nums[ans.second]<<endl;\n    }else{\n        cout<<0<<endl;\n        cout<<*nums.rbegin()+1<<\" \"<<*nums.rbegin()+1<<\" \"<<*nums.rbegin()+1<<\" \"<<*nums.rbegin()+1<<endl;\n    }\n    return 0;\n}\n```","tags":["çº¿æ®µæ ‘"],"categories":["coding"]},{"title":"æ¥åº·åº·Gatsby.js","url":"%2F2019%2F09%2F21%2Fstarting-gatsbyjs%2F","content":"\næ˜¨å¤©å‘ç°notionç”¨å­¦ç”Ÿé‚®ç®±å¯ä»¥å…è´¹é¢†personal planï¼Œæ‰€ä»¥éå¸¸å¼€å¿ƒçš„ç©äº†ä¸€ä¼šã€‚ä¸œè¥¿ç¡®å®æŒºä¸é”™çš„ã€‚\n\n* å®Œå–„çš„é™„ä»¶ç®¡ç†ï¼ŒåŒ…æ‹¬å›¾ç‰‡ï¼Œpdfï¼Œexcelç­‰\n* å¹¶ä¸å¤ªå–œæ¬¢çš„blockç¼–è¾‘æ–¹å¼ï¼Œè¿˜æ˜¯æ›´å–œæ¬¢markdown\n* ä¸é”™çš„é£æ ¼\n* å¼ºå¤§çš„database\n* ä¸é”™çš„å†…å®¹é“¾æ¥\n* å„ç§embed\n* åƒåœ¾æ•°å­¦å…¬å¼ç¼–è¾‘ï¼Œä¸ºå•¥ç¼–è¾‘æ¡†ä¸èƒ½æ¢è¡Œ\n\næ—¢ç„¶æ’ç‰ˆæ•ˆæœå¾ˆå¥½â€¦â€¦è¿™ç©æ„ï¼Œèƒ½ä¸èƒ½åšæˆä¸ªäººåšå®¢ã€‚\n\nå»githubä¸Šæœäº†ä¸€å‘ï¼Œå±…ç„¶çœŸçš„æœ‰ï¼Œåå­—å«gine-blogã€‚\n\n## å·²æœ‰é¡¹ç›®åˆæ¢\nç ”ç©¶äº†è¿™ä¸ªå°å·§çš„é¡¹ç›®ä¹‹åï¼Œæœ‰äº›æ¿€åŠ¨ã€‚å®ƒä½¿ç”¨äº†ç›®å‰å¾ˆæ–°çš„å‡ ä¸ªæŠ€æœ¯ï¼ˆç›¸æ¯”Hexoç­‰ä¼ ç»Ÿç”Ÿæˆå™¨ï¼‰ã€‚\n\n* webpack\n* react\n* graphql\n\nå®é™…ä¸Šï¼Œè¿™äº›ä¸»è¦éƒ½æ¥è‡ªå¦ä¸€ä¸ªé¡¹ç›®`Gatsby.js`ï¼Œæ„åœ¨ä½¿ç”¨æ–°æŠ€æœ¯å¿«é€Ÿæ„å»ºç½‘ç«™ã€‚å®ƒèƒ½å¤Ÿæ±‡æ€»æ•°æ®ï¼Œä½¿ç”¨graphqlä¸ºreactæä¾›å†…å®¹ï¼Œå¹¶å°†å†…å®¹å›ºåŒ–ï¼Œäº§ç”Ÿèƒ½å¤Ÿç¦»å¼€åç«¯è¿è¡Œçš„çº¯ç½‘é¡µã€‚\n\néå¸¸é€‚åˆä½œä¸ºä¸ªäººåšå®¢ç”Ÿæˆä½¿ç”¨ã€‚\n\nä¹‹åæˆ‘ä¾¿å¿˜äº†æœ€å¼€å§‹çš„ç›®çš„ã€‚\n\n## å¥½åƒå°‘äº†äº›ä»€ä¹ˆ\nç”Ÿæˆçš„æ–¹å¼ä¼¼ä¹æ²¡æœ‰ä»€ä¹ˆé—®é¢˜äº†ï¼Œä¸è¿‡å¥½åƒå°‘äº†äº›ä»€ä¹ˆã€‚\n\ngine-blogé¡¹ç›®ä»notionæ‹‰å–è„æ•°æ®ç»è¿‡å¤æ‚å¤„ç†å¡«å……åˆ°reactä¸­â€¦â€¦ä½œè€…å®ç°äº†ä¸€ä¸ªçˆ¬è™«å»ä»notionçš„ç½‘é¡µä¸Šçˆ¬å–æºç â€¦\n\n\n\næˆ‘éƒ¨ç½²è¯•äº†ä¸€ä¸‹è¿™ä¸ªblogï¼Œæ•ˆæœè¿˜å¯ä»¥ï¼Œä¹Ÿæœ‰äº›bugã€‚æ¯”å¦‚bookmarkä¸¢å¤±urlï¼Œä½œè€…çš„æ–‡æ¡£æ–°æ—§æœ‰äº›åˆ†ä¸æ¸…æ¥šã€‚è¿˜æ˜¯ç»§ç»­åšæŒhexoã€‚\n\n~~ä¸è¿‡ï¼Œè¿™ä¸ª`gatsby.js`æœ‰ä¸€äº›æ„æ€ï¼Œå¯ä»¥ç ”ç©¶ä¸€ä¸‹ã€‚~~\n\n## å…³äºblog\n\nä»”ç»†æ€è€ƒäº†ä¸€ä¸‹ï¼Œç›¸æ¯”äºé€‰æ‹©ä»€ä¹ˆä¸»é¢˜ï¼Œé€‰æ‹©ä»€ä¹ˆæ¨¡æ¿ï¼Œé€‰æ‹©ä»€ä¹ˆæŠ€æœ¯ï¼Œè¿™äº›éƒ½æ˜¯æ¬¡è¦çš„äº‹æƒ…ã€‚æœ€é‡è¦çš„æ˜¯å¡«å……åœ¨é‡Œé¢çš„å†…å®¹ã€‚æ‰€ä»¥è¿™ä¸ªäº‹æƒ…å°±å…ˆè¿™ä¹ˆæ”¾ä¸‹äº†ï¼Œå¦‚æœè¦å¼€å§‹çš„è¯ï¼Œæœ‰ä¸€ç³»åˆ—çš„ä¸œè¥¿éƒ½éœ€è¦å­¦ä¹ ï¼Œå’Œæˆ‘ç°åœ¨è¦å¹²çš„äº‹æƒ…æœ‰äº›å†²çªã€‚\n\nå¬è¯´å­¦é•¿ä»¬åœ¨ææ–°çš„ojï¼Œç»™æˆ‘çš„é”…å®é™…ä¸Šå¾ˆå°ï¼Œä¸éœ€è¦è´Ÿå¤šå¤§è´£ä»»ã€‚é‚£ä¹ˆojä¹Ÿå¯ä»¥æš‚æ—¶æ”¾ä¸€æ”¾äº†ã€‚\n\nblogç»§ç»­ç»´æŒä½¿ç”¨hexoã€‚\n\nä¹Ÿè®¸æœªæ¥çš„å“ªå¤©ï¼Œä¼šå›æ¥å°è¯•ä¸€ä¸‹ä½¿ç”¨rust+é‚£æ—¶å€™çš„å‰ç«¯æŠ€æœ¯æ¥æ„é€ ä¸€ä¸ªä¸çŸ¥é“æ˜¯ä»€ä¹ˆçš„é¡¹ç›®ã€‚","tags":["gatsby"],"categories":["é—²æ‰¯"]},{"title":"ä½¿ç”¨Mathematicaç»˜åˆ¶è‚¡ç¥¨ç›¸å…³æ›²çº¿","url":"%2F2019%2F09%2F20%2Fstock-with-mathematica%2F","content":"\nMathematicaæ˜¯ä¸ªå¥½ä¸œè¥¿ã€‚è™½ç„¶æ—©æœ‰è€³é—»åŠŸèƒ½å¼ºå¤§ï¼Œä½†æ˜¯æ²¡æƒ³åˆ°å¼ºå¤§åˆ°è¿™ç§åœ°æ­¥ã€‚\n\nåŸæœ¬å› ä¸ºè¯¾ç¨‹åŸå› ï¼Œç ”ç©¶äº†ä¸€ä¸‹å¦‚ä½•åœ¨Mathematicaé‡Œç»˜åˆ¶è‚¡ç¥¨æ•°æ®ã€‚ä¸è¿‡ç°åœ¨**åœæ­¢**ï¼Œåªå®Œæˆäº†ä¸€å°éƒ¨åˆ†ã€‚å‰©ä¸‹çš„â€¦â€¦æƒ³æŠ˜è…¾çš„è¯ï¼ŒæŒ‰ç…§å·²ç»æœ‰çš„ä»£ç ï¼Œèƒ½å®¹æ˜“æ”¹å‡ºæ¥å…¶ä»–åŠŸèƒ½ã€‚\n\n## æ•°æ®æ¥æº\n\né¦–å…ˆè¦è¯´çš„æ˜¯ï¼ŒMathematicaä¸­**è‡ªè¡Œæä¾›**äº†éæƒå¨çš„é‡‘èæ•°æ®ã€‚è¿™å¯¹æˆ‘ä»¬å¾ˆæ–¹ä¾¿ã€‚\n\nä½¿ç”¨å‘½ä»¤`FinancialData`,å°±å¯ä»¥è·å–å¤§é‡éœ€è¦çš„æ•°æ®ã€‚å…·ä½“å¯ä»¥æŸ¥çœ‹æ–‡æ¡£ã€‚ä¸è¿‡é—®é¢˜æ˜¯ï¼Œä¸çŸ¥ä½•ç§åŸå› ï¼Œè¯¥å‡½æ•°å¯¹æ·±æ²ªè‚¡ç¥¨æ”¯æŒå¾ˆå·®ï¼Œæ‰€ä»¥åœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œå¹¶ä¸èƒ½ç›´æ¥ä½¿ç”¨è¯¥å‡½æ•°ï¼Œæ¯”è¾ƒå¯æƒœâ€¦â€¦\n\næˆ‘ä»¬éœ€è¦å®ç°è‡ªå·±çš„æ•°æ®å¤„ç†ã€‚\n\nç»è¿‡ä¸€ç•ªå¯»æ‰¾åï¼Œæˆ‘å‘ç°äº†ä¸€ä¸ªåŸºäºPythonçš„è¯åˆ¸æ•°æ®å¹³å°`baostock`ã€‚ç»è¿‡ç®€å•çš„å°è£…åï¼ŒMathematicaå°±å¯ä»¥ä½¿ç”¨Pythonä»å¹³å°ä¸Šæ‹‰å–æ•°æ®äº†ã€‚\n\nè¿™ä¸ªä¾‹å­åªèƒ½æ‹‰å–æ—¥Kã€‚\n\n```mathematica\n\nBeginPackage[\"StockLink`\"]\n\nStockLink::usage=\"StockLink\";\nCloseLink::usage=\"CloseLink\";\n\nDailyKLine::usage=\"Get KLine data\";\n\nCandlestickData::usage=\"adjust KLine data to fit Candlestick Chart\";\nTradingChartData::usage=\"adjust KLine data to fit Trading Chart\";\n\nBegin[\"`Private`\"]\n\nStockLink[]:=Module[{conn},\nconn=StartExternalSession[\"Python\"];\nExternalEvaluate[conn,\"\nimport baostock as bs\nlg=bs.login()\n\"];\nconn\n];\n\nCloseLink[conn_]:=Module[{},\nExternalEvaluate[conn,\"\nbs.logout()\n\"];\nDeleteObject[conn];\n];\n\nMMAListToPythonList[list_]:=StringReplace[ToString[list,InputForm],{\"\\\" \"->\"'\",\"{\"->\"[\",\"}\"->\"]\"}];\nDateObjectToStr[date_]:=DateString[date,\"ISODate\"];\n\nDailyKLine[conn_,code_,startDate_,endDate_]:=Module[{},\nraw=ExternalEvaluate[conn,\nStringTemplate[\"\nrs = bs.query_history_k_data_plus('``',\n    'date,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,isST',\n    start_date='``', end_date='``',\n    frequency='d', adjustflag='3')\ndata_list = {}\nwhile (rs.error_code == '0') & rs.next():\n    temp=rs.get_row_data()\n    data_list[temp[0]]=temp[1:];\ndata_list\"][code,DateObjectToStr[startDate],DateObjectToStr[endDate]]];\nToExpression[#]& /@ raw\n];\n\nCandlestickData[raw_]:=Table[{DateObject[key],raw[key][[1;;4]]},{key,Keys[raw]}];\nTradingChartData[raw_]:=Table[{DateObject[key],raw[key][[1;;5]]},{key,Keys[raw]}];\n\nEnd[]\n\nEndPackage[]\n```\n\n## å›¾è¡¨ç»˜åˆ¶\n\nåœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œé¦–å…ˆéœ€è¦å¯¼å…¥è¯¥åº“ï¼Œå¹¶ä¸”åˆå§‹åŒ–é“¾æ¥åï¼Œçµæ´»ç»„åˆå„éƒ¨åˆ†åŠŸèƒ½å³å¯ã€‚\n\n```mathematica\n<< (NotebookDirectory[] <> \"StockLink.wl\");\nconn = StockLink[];\n\n(:ä¾‹å¦‚è·å–æŸä¸ªæ—¥æœŸåŒºé—´å†…çš„æ•°æ®å¹¶è½¬åŒ–ï¼Œç»˜åˆ¶äº¤äº’å›¾æ ‡:)\nDailyKLine[conn, \"ss.000001\", Today, Today] // TradingChartData // InteractiveTradingChart\n```\n\nè¾“å…¥æ—¥æœŸæ—¶ï¼Œå¯ä»¥ç›´æ¥æŒ‰`ctrl+=`ï¼Œåœ¨æ¡†ä¸­æè¿°æ—¶é—´ï¼Œæ¯”è¾ƒæ–¹ä¾¿ã€‚\n\n## å¯èƒ½é‡åˆ°çš„é—®é¢˜\n\nå¦‚æœpythoné…ç½®ä¸å¯¹çš„è¯ï¼Œå¯èƒ½ä¼šå‡ºç°Mathematicaæ‰¾ä¸åˆ°pythonã€‚é—®é¢˜çš„è§£å†³æ–¹æ³•åœ¨å®˜æ–¹æ–‡æ¡£ä¸Šéå¸¸æ¸…æ™°ã€‚\n\nä¸è¿‡æˆ‘ä¸æŠ˜è…¾è‚¡ç¥¨ï¼Œå°±è¿™æ ·äº†ã€‚","tags":["mathematica"],"categories":["é—²æ‰¯"]},{"title":"ä¸€äº›ç­›æ³•çš„é¢˜","url":"%2F2019%2F09%2F05%2Fsome-sieves%2F","content":"\n\n## æŠ€å·§\n\n### è‡ªç„¶æº¢å‡º\n\n* è‡ªç„¶æº¢å‡ºä¸ä¼šå½±å“ä½ä½æ•°æ®,æ‰€ä»¥æœ‰çš„æ—¶å€™ä½ ä¸éœ€è¦å–æ¨¡,è€Œæ˜¯ä¸€ä¸ªunsigned.\n\n### é™¤æ³•å–æ¨¡\nå¯¹äºå¼å­\n\n$$\n\\frac {a \\times b}{c} \\mod p \\equiv \\frac{a \\times b \\mod cp}{c}\n$$\n\n\n\n## ç»†èŠ‚\n* æ³¨æ„æ•°æ®ç±»å‹,ä¾‹å¦‚`6*(ll)(1<<30)`æ˜¯è¦å‡ºé—®é¢˜çš„\n* æ³¨æ„å‡½æ•°åœ¨$f(1)$ä½ç½®çš„å–å€¼,ä¸è¦å¿˜è®°åˆå§‹åŒ–\n\n## Divisor\n\nGiven $n$ and $m$ ($1 \\leq n,m \\leq 5 \\times 10^4$),  please calculate\n\n<!--more-->\n\n### åˆ†æ\nä¸‹é¢æ‰€æœ‰çš„é™¤æ³•éƒ½æ˜¯èˆå»å°æ•°çš„æ•´é™¤.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) &= \\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}[p \\perp q] \\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d|(p,q)}\\mu(d) \\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d}\\mu(d)[d|p][d|q] \\\\\n&=\\sum_d \\mu(d)\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{pd} \\sum_{qd}[pd|i][qd|j] \\\\\n&=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd}\\sum_{i=1}^{n/pd}\\sum_{j=1}^{m/qd} \\\\\n&=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd} \\frac n {pd}\\frac m {qd} \\\\\n&=\\sum_d \\mu(d) \\sum_p^{n/d} \\frac n {pd} \\sum_q^{m/d} \\frac m {qd} \\\\\n\\end{aligned}\n$$\n\nè®¾$S(n)=\\sum_{1\\leq i \\leq n} \\frac n i$\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) &=\\sum_d \\mu(d)S(n/d)S(m/d)\n\\end{aligned}\n$$\n\n$n/d$çš„å–å€¼åœ¨ä¸€ä¸ªåŒºé—´ä¸­æ˜¯ç›¸åŒçš„,å› æ­¤å¯ä»¥æŠŠè¿™ä¸ªæ±‚å’Œå…¬å¼åˆ†å—è®¡ç®—.(åœ¨åˆ†å—å,éœ€è¦è·çŸ¥è¯¥æ®µåŒºåŸŸå†…$\\mu$çš„å’Œ,æ‰€ä»¥éœ€è¦æ±‚å‰ç¼€å’Œ)ç”±äº$n/d$çš„å–å€¼ä¸º$O(\\sqrt n)$çš„çº§åˆ«,å› æ­¤åœ¨çŸ¥é“$S$çš„å€¼çš„æƒ…å†µä¸‹,æ¯ä¸ªè¯¢é—®å¯ä»¥è¿™ä¸ªå¤æ‚åº¦ä¸­è®¡ç®—å‡ºæ¥.\n\nå¯¹äº$\\mu$,ä½¿ç”¨ç­›æ³•,å¹¶æ±‚å‡ºå…¶å‰ç¼€å’Œ.\n\nå¯¹äº$S$,ç›´æ¥æš´åŠ›è®¡ç®—.\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50010;\n\nbool isn_p[MAXN];\nvector<int> primes;\nint mu[MAXN];\nint premu[MAXN];\nvoid init_prime(int len){\n    isn_p[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=len;i++){\n        if(!isn_p[i]){\n            primes.push_back(i);\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=len;j++){\n            isn_p[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n    premu[0]=0;\n    for(int i=1;i<=len;i++)premu[i]=premu[i-1]+mu[i];\n}\n\n\nll S[MAXN];\nvoid init_S(int len){\n    for(int i=1;i<=len;i++){\n        for(int l=1,r;l<=i;l=r+1){\n\t        //remember this line\n            r=i/(i/l);\n            S[i]+=(ll)(r-l+1)*(i/l);\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    init_prime(50000);\n    init_S(50000);\n    int kase;cin>>kase;\n    while(kase--){\n        int n,m;cin>>n>>m;\n        ll ans=0;\n        // the minimum one will fastly approach to 0, leading the extra parts of bigger one do nothing to the answer.\n        int minn=min(n,m);\n        for(int l=1,r;l<=minn;l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ans+=S[n/l]*S[m/l]*(premu[r]-premu[l-1]);\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n```\n\n## table\nç»™å‡ºå¤šç»„$n,m,a$,æ±‚\n\n$$\n\\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j))[\\sigma_1((i,j)) \\geq a]\n$$\n\n### åˆ†æ\n> è¿™é“é¢˜è®©è°éƒ½èƒ½çœ‹å‡ºæ¥é‡ç‚¹æ˜¯å¦‚ä½•å¤„ç†æ¡ä»¶\n>\n> $$[\\sigma_1((i,j)) \\geq a]$$\n\nå¯æ˜¯è¿™æˆ‘æ˜¾ç„¶ä¸çŸ¥é“è¯¥æ€ä¹ˆåš.\n\nå¯¹è¯¢é—®ä½œä»¥$a$ä»å°åˆ°å¤§ç¦»çº¿å¤„ç†,è¯¢é—®å‰å…ˆå¤„ç†æ–°å¢$a$çš„å½±å“.\n\nåœ¨å·²ç»æ»¡è¶³æ¡ä»¶çš„å‰æä¸‹å¯¹å…¬å¼ä½œåŒ–ç®€.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j)) &= \\sum_d \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1(d)[(i,j)=d] \\\\\n&=\\sum_d \\sum_{i\\leq \\frac nd}\\sum_{j\\leq \\frac md}\\sigma_1(d)[(i,j)=1] \\\\\n&=\\sum_d \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}}\\sigma_1(d) \\sum_t \\mu(t) \\\\\n&=\\sum_d \\sum_t \\mu(t) \\sigma_1(d)  \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}} 1 \\\\\n&=\\sum_T \\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor \\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)\n\\end{aligned}\n$$\n\nå¯ä»¥çœ‹åˆ°è¿˜æ˜¯å¥—è·¯,å¼•å…¥d,å¼•å…¥$\\mu$,ä¹‹åèƒ¡ä¹±åŒ–ç®€.\n\næŒ‰ç…§è¿™ä¸ªå¼å­,éœ€è¦è®¡ç®—çš„å°±æ˜¯$g(x)=\\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)$çš„å‰ç¼€å’Œ.\n\næ¥ä¸‹æ¥æ˜¯å¦‚ä½•å¤„ç†æ¡ä»¶...\n\nå½“$a$æ¯æ‰©å¤§ä¸€ç‚¹,å°±æœ‰ä¸€éƒ¨åˆ†$\\mu(t)\\sigma_1(\\frac Td)$è¢«åŠ å…¥åˆ°å‡½æ•°$g$çš„å„ä¸ªéƒ¨åˆ†.ä½¿ç”¨ä¸€ç§æ•°æ®ç»“æ„æ¥ç»´æŠ¤$g$çš„å‰ç¼€å’Œ,ä¾‹å¦‚æ ‘çŠ¶æ•°ç»„.$a$æœ€å¤§åˆ°,æ¯æ¬¡å—åˆ°å½±å“çš„å°±æ˜¯$d$çš„å€æ•°,ä»¥æ­¤å¯ä»¥è®¡ç®—å‡ºæ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º\n\n$$\nWTF\n$$\n\nè‡³æ­¤,é—®é¢˜å°±è§£å†³äº†.\n\n### ä»£ç \nåˆä¸‘åˆé•¿.\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cassert>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=100010;\nconst int MAXQ=100010;\nconst int MAXFT=400010;\nconst ll P=(ll)1<<31;\n\n\nll FT[MAXFT];\nll lowbit(int x){\n    return x&-x;\n}\nvoid ftadd(int pos,ll x){\n    for(int i=pos;i<MAXN;i+=lowbit(i)){\n        FT[i]=(FT[i]+x);\n    }\n}\nll ftget(int pos){\n    ll res=0;\n    for(int i=pos;i;i-=lowbit(i)){\n        res=(res+FT[i]);\n    }\n    return res;\n}\n\nll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(b;b;b>>=1,a=(a*a)%p){\n        if(b&1)res=(res*a)%p;\n    }\n    return res;\n}\nll qpow(ll a,ll b){\n    ll res=1;\n    for(b;b;b>>=1,a=(a*a)){\n        if(b&1)res=(res*a);\n    }\n    return res;\n}\n\nbool is_np[MAXN];\nll sigma[MAXN],mu[MAXN];\nint t[MAXN];\nvector<int> primes;\nstruct Sig{\n    ll sigma;\n    int x;\n    Sig(){}\n    Sig(int x,ll sigma):x(x),sigma(sigma){}\n};\nvector<Sig> sigma_vec;\n\nvoid init(int n){\n    is_np[1]=1;\n    sigma[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=n;i++){\n        if(!is_np[i]){\n            primes.push_back(i);\n            sigma[i]=i+1;\n            t[i]=1;\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            is_np[i*primes[j]]=1;\n            sigma[i*primes[j]]=sigma[i]*sigma[primes[j]];\n            t[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                t[i*primes[j]]=t[i]+1;\n                sigma[i*primes[j]]=sigma[i/qpow(primes[j],t[i])]*((ll)1-qpow(primes[j],(t[i]+1)+1))/(1-primes[j]);\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++){\n        sigma_vec.push_back(Sig(i,sigma[i]));\n    }\n}\n\nstruct Q{\n    int n,m,a;\n    int i;\n    ll ans;\n    bool operator<(const Q &b)const{\n        return a<b.a;\n    }\n} qs[MAXQ];\n\nll f(int n){\n    return ftget(n);\n}\n\nint curidx=0;\nvoid mergea(int newa){\n    for(;curidx<sigma_vec.size();curidx++){\n        Sig &sig=sigma_vec[curidx];\n        if(sig.sigma>newa)break;\n        for(int i=sig.x;i<MAXN;i+=sig.x){\n            ftadd(i,mu[i/sig.x]*sig.sigma%P);\n        }\n    }\n}\n\nint main(){\n    init(100000);\n    sort(sigma_vec.begin(),sigma_vec.end(),[](Sig &a,Sig &b){\n        return a.sigma<b.sigma;\n    });\n\n    int qlen;cin>>qlen;\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        scanf(\"%d%d%d\",&q.n,&q.m,&q.a);\n        q.i=i;\n    }\n    sort(qs,qs+qlen,[](Q &a,Q &b){\n        return a.a<b.a;\n    });\n\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        int n=q.n,m=q.m,a=q.a;\n        ll &ans=q.ans=0;\n        mergea(a);\n        for(int l=1,r;l<=min(n,m);l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ans=ans+(n/l)*(m/l)*(f(r)-f(l-1));\n        }\n        \n    }\n    sort(qs,qs+qlen,[](Q &a,Q &b){\n        return a.i<b.i;\n    });\n    for(int i=0;i<qlen;i++){\n        printf(\"%lld\\n\",qs[i].ans%P);\n    }\n    return 0;\n}\n```\n\n## product\nå®šä¹‰æ–æ³¢çº³å¦¾(?)(linuxè¿™è¾“å…¥æ³•å¤Ÿé­”æ€§)å‡½æ•°$f(x)$\n\næ±‚\n\n$$\n\\prod_{i=1}^n \\prod_{j=1}^m f((i,j))\n$$\n\n### åˆ†æ\né¦–å…ˆ,å…ˆå¼•ä¸ª$d$æ˜¯æ²¡é”™äº†.\n\nä½†æ˜¯\n\nè¿™é“é¢˜,æˆ‘åˆä¸ä¼š.æˆ‘ä¸çŸ¥é“è¯¥æ€ä¹ˆå¤„ç†$\\prod$...è”¡å°±å®Œäº‹äº†.\n\nç°åœ¨æ¥çœ‹,å½“å¼•å…¥ä¸€ä¸ª$d$å,åœ¨è¯¥æ±‚ç§¯å…¬å¼é‡Œå‡ºç°äº†ç›¸åŒé¡¹ç›¸ä¹˜.å°†è¯¥éƒ¨åˆ†çš„è®¡ç®—è°ƒæ•´ä¸ºå¹‚,å‰©ä¸‹çš„å°±åˆéƒ½ä¸€æ ·äº†.\n\n$$\n\\begin{aligned}\n\\prod_{i=1}^n \\prod_{j=1}^m f((i,j)) &= \\prod_d f(d)^{\\sum_{i\\leq n} \\sum_{j \\leq m} [(i,j)=d]} \\\\\n&=\\prod_d f(d)^{\\sum_{i\\leq \\frac nd} \\sum_{j \\leq \\frac md} [(i,j)=1]} \\\\\n&=\\prod_d f(d)^{\\sum_t \\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\\n&=\\prod_d \\prod_t f(d)^{\\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\\n&=\\prod_T (\\prod_{d|T}  f(d)^{\\mu(\\frac Tt)})^{\\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor }\n\\end{aligned}\n$$\n\nè®¾$g(x)=\\prod_{d|T}  f(d)^{\\mu(\\frac Tt)}$,æ±‚å‰ç¼€å’Œå°±å®Œäº‹äº†.\n\n> è¿™é“é¢˜éœ€è¦ä½¿ç”¨**æ¬§æ‹‰å®šç†**æ¥ä¼˜åŒ–æ±‚å¹‚çš„é€Ÿåº¦.\n\n### æ¬§æ‹‰å®šç†\nå½“$(a,p)=1$,æœ‰ä»¥ä¸‹å¼å­\n\n$$\na^b \\equiv a^{b \\mod \\phi(p)} \\pmod p\n$$\n\nå½“$(a,p)\\neq 1$,æœ‰æ‰©å±•æ¬§æ‹‰å®šç†\n\n$$\na^b \\equiv a^{b \\mod \\phi(p)+ \\phi(p)} \\pmod p\n$$\n\næ ¹æ®è¿™2ä¸ªå¼å­,å¯ä»¥åœ¨å¿«é€Ÿé™å¹‚,æ¥åŠ å¿«è¿ç®—.\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=1000010;\nconst ll P=1e9+7;\n\ninline ll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(;b;b>>=1,a=a*a%p){\n        if(b&1)res=res*a%p;\n    }\n    return res;\n}\n\ninline ll get_inv(ll a,ll p){\n    return qpow(a,p-2,p);\n}\n\nbool is_np[MAXN];\nvector<int> primes;\nll f[MAXN], g[MAXN];\nll inv_f[MAXN];\nll preg[MAXN],inv_pg[MAXN];\nll mu[MAXN];\nvoid init(int n){\n    is_np[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=n;i++){\n        if(!is_np[i]){\n            primes.push_back(i);\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            is_np[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n\n    f[1]=f[2]=1;\n    for(int i=3;i<=n;i++){\n        f[i]=(f[i-1]+f[i-2])%P;\n    }\n    for(int i=1;i<=n;i++){\n        inv_f[i]=get_inv(f[i],P);\n    }\n\n    for(int i=1;i<=n;i++)g[i]=1;\n    for(int i=1;i<=n;i++){\n        for(int j=i;j<=n;j+=i){\n            if(mu[j/i]==-1)g[j]=(g[j]*inv_f[i])%P;\n            else if(mu[j/i]==1)g[j]=(g[j]*f[i])%P;\n            //when mu==0,nothing happens\n        }\n    }\n    preg[0]=1;\n    for(int i=1;i<=n;i++)preg[i]=preg[i-1]*g[i]%P;\n    inv_pg[0]=1;\n    for(int i=1;i<=n;i++)inv_pg[i]=get_inv(preg[i],P)%P;\n}\n\nint main(){\n    init(1000000);\n    //cout<<\"done\"<<endl;\n    /*\n    \n    for(auto i:primes){\n        cout<<i<<\" \";\n    }\n    cout<<endl;\n    \n    for(int i=1;i<=20;i++){\n        cout<<g[i]<<\" \";\n    }\n    cout<<endl;\n    */\n    \n\n    int kase;\n    scanf(\"%d\",&kase);\n    while(kase--){\n        ll n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(n>m)swap(n,m);\n\n        ll ans=1;\n        for(ll l=1,r;l<=n;l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ll sum=preg[r]*inv_pg[l-1]%P;\n            ans=ans*qpow(sum,(n/l)*(m/l)%(P-1),P)%P;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n## phi3\nç»™å‡º$n$,æ±‚\n\n$$\n(\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n \\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)} \\phi((i,j,k))) \\mod 2^{30}\n$$\n\n### åˆ†æ\nè¿™é“é¢˜é‡ç‚¹åœ¨äº\n\n$$\\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)}$$\n\nè¿™å †ä¸œè¥¿çš„åŒ–ç®€.å¾ˆæ˜¾ç„¶,æˆ‘åˆä¸ä¼š.\n\nè§‚å¯Ÿ$\\phi(n)$çš„å…¬å¼\n\n$$\n\\phi(n)=n\\prod_i(1-\\frac 1{\\phi(i)})\n$$\n\nå¯ä»¥å¾—å‡ºä¸Šé¢é‚£ä¸€å †ç­‰äº$jk^2$.å‰©ä¸‹çš„å°±åˆéƒ½ä¸€æ ·äº†.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi((i,j,k)) &=\\sum_d\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi(d)[(i,j,k)=d] \\\\\n&=\\sum_d \\sum_{t} \\phi(d) \\mu(t) t^3d^3 \\sum_{i\\leq \\frac n{td}}\\sum_{j \\leq \\frac n{td}}\\sum_{k \\leq \\frac n{td}} jk^2 \\\\\n&=\\sum_T \\sum_{i\\leq \\frac nT}\\sum_{j \\leq \\frac nT} j\\sum_{k \\leq \\frac nT}k^2 (T^3 \\sum_{d|T} \\phi(d) \\mu(\\frac Td))\n\\end{aligned} \n$$\n\nè®¾$g(n)=\\sum_{d|T} \\phi(d) \\mu(\\frac Td)$,ç›´æ¥ç­›.æœ€åè®¡ç®—å‰ç¼€å’Œçš„æ—¶å€™å†ä¹˜ä¸Š$n^3$å°±å¯ä»¥äº†.\n\n> è¿™é“é¢˜çš„å–æ¨¡è¿˜æœ‰è¿™ç§å¤„ç†æ–¹æ³•: ç›´æ¥å–æ•°ç»„ä¸º`unsigned`å¹¶è‡ªç„¶æº¢å‡º.**äºŒè¿›åˆ¶å30ä½**ä¸ä¼šå—åˆ°å½±å“.\n\n### ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\nusing ull=unsigned long long;\nusing ll=long long;\nconst int MAXN=10000010;\nconst unsigned P=1<<30;\n\nbool isnp[MAXN];\nvector<int> primes;\nint t[MAXN],M[MAXN];\nunsigned Mt[MAXN];\nunsigned g[MAXN];\nll preg[MAXN];\n\nvoid init(int n){\n    isnp[1]=1;\n    g[1]=1;\n\n    for(int i=2;i<=n;i++){\n        if(!isnp[i]){\n            primes.push_back(i);\n            g[i]=i-1-1;\n\n            t[i]=1;\n            M[i]=Mt[i]=i;\n        }\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            int newone=i*primes[j];\n            isnp[newone]=1;\n            g[newone]=g[i]*g[primes[j]]%P;\n            t[newone]=1;\n            M[newone]=Mt[newone]=primes[j];\n            if(i%primes[j]==0){\n                t[newone]=t[i]+1;\n                Mt[newone]=Mt[i]*primes[j]%P;\n                \n                g[newone]=g[i/Mt[i]]*(Mt[newone]+Mt[i]/primes[j]-2*Mt[i])%P;\n                break;\n            }\n        }\n    }\n\n    for(int i=1;i<=n;i++){\n        preg[i]=preg[i-1]+(ll)i*i%P*i%P*g[i]%P;\n        preg[i]%=P;\n    }\n}\n\nint main(){\n    init(10000000);\n\n    int kase;\n    scanf(\"%d\",&kase);\n    while(kase--){\n        int n;\n        scanf(\"%d\",&n);\n        ll ans=0;\n        for(int l=1,r;l<=n;l=r+1){\n            r=n/(n/l);\n            ull lim=n/l;\n            ull sum1=lim*(lim+1)%(2*P)/2;\n            ull sum2=lim*(lim+1)%(6*P)*(2*lim+1)%(6*P)/6;\n            ans=ans+lim*sum1%P*sum2%P*(preg[r]-preg[l-1])%P;\n        }\n        printf(\"%lld\\n\",ans%P);\n    }\n    return 0;\n}\n```","tags":["ç­›æ³•"]},{"title":"[HDU 6704] Kth Occurrence","url":"%2F2019%2F08%2F25%2Fproblem-kth-occurrence%2F","content":"\n\nYou are given a string S consisting of only lowercase english letters and some queries.\n\nFor each query (l,r,k), please output the starting position of the k-th occurence of the substring SlSl+1...Sr in S.\n\n## åˆ†æ\nç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯å¿«é€Ÿæ‰¾å‡ºæ‰€æœ‰å‡ºç°çš„å­ä¸²çš„ä½ç½®,å¯ä»¥ä½¿ç”¨åç¼€æ•°ç»„.è¿™äº›å­—ä¸²å‡ºç°åœ¨saçš„ä¸€ä¸ªè¿ç»­çš„åŒºé—´ä¸­.\n\n<!--more-->\n\nç¬¬äºŒä¸ªé—®é¢˜æ˜¯æ‰¾å‡ºè¿™äº›å‡ºç°ä½ç½®ä¸­çš„ç¬¬kå¤§,å¯ä»¥ä½¿ç”¨ä¸»å¸­æ ‘,ä»¥saå»ºæ ‘.\n\n\n## ä»£ç \næ€è·¯æ¸…æ™°,ä½†è¿™ä»£ç å®ƒä¸å¥½å†™\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\nconst int MAXN=100060;\nusing ull=unsigned long long;\n\nint n;\nint sa[MAXN], x[MAXN], c[MAXN], y[MAXN];\nchar a[MAXN];\n\ninline void SA()\n{\n    int m = 128;\n    for (int i = 0; i <= m; i++)\n        c[i] = 0;\n    for (int i = 1; i <= n; i++)\n        c[x[i]]++;\n    for (int i = 1; i <= m; i++)\n        c[i] += c[i - 1];\n    for (int i = n; i; i--)\n        sa[c[x[i]]--] = i;\n\n    for (int k = 1, p; k <= n; k <<= 1)\n    {\n        p = 0;\n        for (int i = n; i > n - k; i--)\n            y[++p] = i;\n        for (int i = 1; i <= n; i++)\n            if (sa[i] > k)\n                y[++p] = sa[i] - k;\n\n        for (int i = 0; i <= m; i++)\n            c[i] = 0;\n        for (int i = 1; i <= n; i++)\n            c[x[i]]++;\n        for (int i = 1; i <= m; i++)\n            c[i] += c[i - 1];\n        for (int i = n; i; i--)\n            sa[c[x[y[i]]]--] = y[i];\n\n        p = y[sa[1]] = 1;\n        for (int i = 2, a, b; i <= n; i++)\n        {\n            a = sa[i] + k > n ? -1 : x[sa[i] + k];\n            b = sa[i - 1] + k > n ? -1 : x[sa[i - 1] + k];\n            y[sa[i]] = (x[sa[i]] == x[sa[i - 1]]) && (a == b) ? p : ++p;\n        }\n        swap(x, y);\n        m = p;\n    }\n}\n\nint tot;\nint sum[(MAXN << 5) + 10], rt[MAXN + 10], ls[(MAXN << 5) + 10],\n    rs[(MAXN << 5) + 10];\n\nint build(int l, int r) //å»ºæ ‘\n{\n    int root = ++tot;\n    if (l == r)\n        return root;\n    int mid = l + r >> 1;\n    ls[root] = build(l, mid);\n    rs[root] = build(mid + 1, r);\n    return root; //è¿”å›è¯¥å­æ ‘çš„æ ¹èŠ‚ç‚¹\n}\nint update(int k, int l, int r, int root) //æ’å…¥æ“ä½œ\n{\n    int dir = ++tot;\n    ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + 1;\n    if (l == r)\n        return dir;\n    int mid = l + r >> 1;\n    if (k <= mid)\n        ls[dir] = update(k, l, mid, ls[dir]);\n    else\n        rs[dir] = update(k, mid + 1, r, rs[dir]);\n    return dir;\n}\n//left root, right root, querying l,r, the k-th\nint query(int u, int v, int l, int r, int k) //æŸ¥è¯¢æ“ä½œ\n{\n    int mid = l + r >> 1,\n        x = sum[ls[v]] - sum[ls[u]]; //é€šè¿‡åŒºé—´å‡æ³•å¾—åˆ°å·¦å„¿å­çš„ä¿¡æ¯\n    if (l == r){\n        return l;\n    }\n    if (k <= x) //è¯´æ˜åœ¨å·¦å„¿å­ä¸­\n        return query(ls[u], ls[v], l, mid, k);\n    else //è¯´æ˜åœ¨å³å„¿å­ä¸­\n        return query(rs[u], rs[v], mid + 1, r, k - x);\n}\n\nint height[MAXN];\nint st[20][MAXN];\ninline void get_height() {\n    int k = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (x[i] == 1) continue;\n        if (k) --k;\n        int j = sa[x[i] - 1];\n        while (j + k <= n && i + k <= n && a[i + k] == a[j + k]) ++k;\n        height[x[i]] = k;\n    }\n}\nvoid build_st() {\n    for (int i = 1; i <= n; i++) st[0][i] = height[i];\n    for (int k = 1; k <= 19; k++) {\n        for (int i = 1; i + (1 << k) - 1 <= n; i++) {\n            st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 << k - 1)]);\n        }\n    }\n}\nint lcp(int ll, int rr) {\n    int l = x[ll], r = x[rr];\n    if (l > r) swap(l, r);\n    if (l == r) return n - sa[l]+1;\n    int t = log2(r - l);\n    return min(st[t][l + 1], st[t][r - (1 << t) + 1]);\n}\n\nint main(){\n    int kase;cin>>kase;\n    while(kase--){\n        int nlen,qlen;cin>>nlen>>qlen;\n        scanf(\"%s\",a+1);\n        for(int i=0;i<MAXN;i++)x[i]=a[i];\n        n=nlen;\n        SA();\n        n=nlen;\n\n        get_height();\n        build_st();\n        \n        /*\n        for(int i=1;i<=nlen;i++)cout<<sa[i]<<\" \";\n        cout<<endl;\n        for(int i=1;i<=nlen;i++)cout<<x[i]<<\" \";\n        cout<<endl;\n        */\n\n        tot=0;\n        memset(sum,0,sizeof(sum));\n        rt[0] = build(1, nlen);\n        for (int i = 1; i <= n; ++i)\n            rt[i] = update(sa[i], 1, nlen, rt[i - 1]);\n\n        while(qlen--){\n            int ql,qr,qk;\n            scanf(\"%d%d%d\",&ql,&qr,&qk);\n            int sublen=qr-ql+1;\n\n            int ex_l,ex_r;\n            //binary search\n            {\n                int l=1,r=x[ql];\n                while(r-l>1){\n                    int mid=(l+r)/2;\n                    if(lcp(sa[mid], ql) >= sublen){\n                        r=mid;\n                    }else l=mid+1;\n                }\n                for(l;l<=r;l++){\n                    if(lcp(sa[l], ql) >= sublen){\n                        ex_l=l;\n                        break;\n                    }\n                }\n            }\n            {\n                int l=x[ql],r=nlen;\n                while(r-l>1){\n                    int mid=(l+r)/2;\n                    if(lcp(sa[mid], ql) >= sublen){\n                        l=mid;\n                    }else r=mid-1;\n                }\n                for(r;r>=l;r--){\n                    if(lcp(sa[r], ql) >= sublen){\n                        ex_r=r;\n                        break;\n                    }\n                }\n            }\n            //cout<<ex_l<<\" \"<<ex_r<<endl;\n            if(ex_r-ex_l+1<qk){\n                cout<<-1<<endl;\n            } else cout<<query(rt[ex_l - 1], rt[ex_r], 1, nlen, qk)<<endl;\n        }\n    }\n\n    return 0;\n}\n```\n\n\n","tags":["RMQ"],"categories":["coding"]},{"title":"è®°ä¸€ä¸ªbug (HDU 6703)","url":"%2F2019%2F08%2F24%2Fa-wonderful-bug%2F","content":"\nYou are given an array a1,a2,...,an(âˆ€iâˆˆ[1,n],1â‰¤aiâ‰¤n). Initially, each element of the array is **unique**. \n\nMoreover, there are m instructions. \n\nEach instruction is in one of the following two formats: \n\n1. (1,pos),indicating to change the value of apos to apos+10,000,000; \n2. (2,r,k),indicating to ask the minimum value which is **not equal** to any ai ( 1â‰¤iâ‰¤r ) and **not less ** than k. \n\nPlease print all results of the instructions in format 2. \n\n## åˆ†æ\nè¿™é¢˜å¼ºåˆ¶åœ¨çº¿.é¦–å…ˆ1æ“ä½œç›¸å½“äºåˆ é™¤äº†è¿™ä¸ªæ•°.\n\ndalaoè‡ªé—­äº†ä¸€ä¼šgetåˆ°äº†å®ƒçš„æ­£ç¡®åšæ³•,æˆ‘å°±ç›´æ¥æ‹¿æ¥ç”¨äº†.\n\nç»´æŠ¤ä¸€æƒå€¼çº¿æ®µæ ‘,ä½ç½®iå­˜å…¶åœ¨aä¸­å‡ºç°çš„ä½ç½®.é‚£ä¹ˆå½“1åˆ°råŒºé—´å†…å‡ºç°ä½ç½®çš„æœ€å¤§å€¼è¶…è¿‡äº†r,æ ¹æ®é¸½å·¢åŸç†,è‡³å°‘æœ‰ä¸€ä¸ªæ•°æœªè¢«é™åˆ¶.\n\nåŠ ä¸Šä¸å°äºkçš„æ¡ä»¶,å°±æ˜¯kåˆ°rä¸­,æ‰¾åˆ°æœ€å°çš„ä¸€ä¸ªr,ä½¿å¾—å®ƒæ»¡è¶³ä¸Šé¢çš„æ¡ä»¶,è¾“å‡ºè¿™ä¸ªr.\n\n## ä»£ç \nä¸€ä¸ªå¥‡è‘©çš„bug...\n\nå½“ä½¿ç”¨äº†freadè¿™ç§å…ˆè¯»å®Œç¼“å†²åŒºå†å¤„ç†çš„å¿«é€Ÿè¯»å…¥è€Œåˆ æ¼äº†cinæ—¶...ä¼šæ˜¾è€Œæ˜“è§çš„é‡åˆ°bug.\n\nä½†æ˜¯,å› ä¸ºç¼“å†²åŒºçš„å­˜åœ¨,**å°èŒƒå›´æ•°æ®è¢«å¿«ä¹çš„è¯»å…¥äº†ç¼“å†²åŒº,cinå¹¶ä¸ä¼šå®é™…å½±å“ä»€ä¹ˆ**.ä¸€æ—¦é‡åˆ°å¤§èŒƒå›´æ•°æ®,cinæå‰è¯»å…¥äº†æ¥ä¸‹æ¥çš„æ•°æ®,å¯¼è‡´ç¬¬ä¸€ä¸ªç¼“å†²åŒºä¹‹å¤–çš„æ•°æ®å…¨éƒ¨å‡ºé”™...\n\nè‰¹.\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst int MAXN = 400000;\n\nnamespace IO\n{\nconst int MAXSIZE = 1 << 20;\nchar buf[MAXSIZE], *p1, *p2;\n#define gc()                                                                 \\\n    (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\\n         ? EOF                                                               \\\n         : *p1++)\ninline int rd()\n{\n    int x = 0, f = 1;\n    char c = gc();\n    while (!isdigit(c))\n    {\n        if (c == '-')\n            f = -1;\n        c = gc();\n    }\n    while (isdigit(c))\n        x = x * 10 + (c ^ 48), c = gc();\n    return x * f;\n}\nchar pbuf[1 << 20], *pp = pbuf;\ninline void push(const char &c)\n{\n    if (pp - pbuf == 1 << 20)\n        fwrite(pbuf, 1, 1 << 20, stdout), pp = pbuf;\n    *pp++ = c;\n}\ninline void write(int x)\n{\n    static int sta[35];\n    int top = 0;\n    do\n    {\n        sta[top++] = x % 10, x /= 10;\n    } while (x);\n    while (top)\n        push(sta[--top] + '0');\n}\n} // namespace IO\n///////////////////////////////////////////////////////////////////////////////////////\n\nint dat[MAXN];\nint a[MAXN];\nint lc[MAXN], rc[MAXN], idx = 0;\n\ninline int imax(int a,int b){\n    if(a>b)return a;\n    return b;\n}\nvoid collect(int n)\n{\n    dat[n] = max(dat[lc[n]], dat[rc[n]]);\n}\n\nint build(int &n, int l, int r)\n{\n    if (!n)\n        n = ++idx;\n    dat[n] = a[l];\n    if (l == r)\n        return dat[n];\n    int mid = (l + r) / 2;\n    return dat[n] = imax(build(lc[n], l, mid), build(rc[n], mid + 1, r));\n}\n\nvoid modify(int x, int l, int r, int L, int R, int n)\n{\n    if (l <= L && R <= r)\n    {\n        dat[n] = x;\n        return;\n    }\n    int mid = (L + R) / 2;\n    if (l <= mid)\n        modify(x, l, r, L, mid, lc[n]);\n    if (mid < r)\n        modify(x, l, r, mid + 1, R, rc[n]);\n\n    collect(n);\n}\n\nint query(int l, int r,int target, int L, int R, int n)\n{\n    if(L>r || R<l || dat[n]<=target)return -1;\n    if(L==R)return L;\n\n    int mid = (L + R) / 2;\n    int res=query(l,r,target,L,mid,lc[n]);\n    return ~res?res:query(l,r,target,mid+1,R,rc[n]);\n}\nint root;\nint num[MAXN];\nint main()\n{\n    int kase=IO::rd();\n    while (kase--)\n    {\n        int nlen, qlen;\n        nlen=IO::rd();\n        qlen=IO::rd();\n        for (int i = 1; i <= nlen; i++)\n        {\n            num[i] = IO::rd();\n            a[num[i]] = i;\n        }\n        build(root, 1, nlen);\n        int lastans = 0;\n        while (qlen--)\n        {\n            int opt=IO::rd();\n            if (opt == 1)\n            {\n                int pos=IO::rd();\n                pos ^= lastans;\n                if(num[pos]==0 || num[pos]>nlen)continue;\n                modify(0x3f3f3f3f, num[pos], num[pos], 1, nlen, root);\n            }\n            else\n            {\n                int t2, t3;\n                t2=IO::rd();\n                t3=IO::rd();\n                //cin >> t2 >> t3;\n                int r = t2 ^ lastans, k = t3 ^ lastans;\n\n                int t=query(k,nlen,r,1,nlen,root);\n                cout<<(lastans=(~t?t:nlen+1))<<endl;\n            }\n        }\n    }\n    return 0;\n}\n```","tags":["çº¿æ®µæ ‘"],"categories":["coding"]},{"title":"OJçš„åç«¯","url":"%2F2019%2F08%2F22%2Fsandbox-reef%2F","content":"\nå†…å®¹æœ‰å¤åˆ¶å’Œå‚è€ƒã€‚\n\nè¿™ç¯‡æ–‡ç« ä¸»è¦ç”¨äºè®°å½•åœ¨æ¢ç´¢è¯„æµ‹ç³»ç»ŸReefæœŸé—´æˆ‘æ‰€å­¦çš„ä¸œè¥¿,ä»¥ä¾¿ä¹‹åæŸ¥é˜….\n\nReefé¢„è®¡ä¸»è¦æ”¯æŒè¿œç¨‹è¯„æµ‹\n\nåŠ ä¸€ç‚¹æœ¬åœ°è¯„æµ‹.....\n\n<!--more-->\n\nç»“æœä¸»è¦çš„ä¸œè¥¿éƒ½ç‰¹ä¹ˆæ˜¯æœ¬åœ°è¯„æµ‹çš„.\n\n## æ€»ä½“æ¶æ„\nReefé¢„è®¡å°†é‡‡ç”¨seccompä½œä¸ºç¬¬ä¸€é“å®‰å…¨å…³å¡,ä½¿ç”¨å¤šçº¿ç¨‹æ£€æµ‹ç¨‹åºè€—æ—¶/å†…å­˜ç­‰ä¿¡æ¯.\n\nåœ¨å¤–å±‚ä½¿ç”¨dockerå°è£…å¹¶å†æ¬¡é™åˆ¶èµ„æº,æ¥å…¥é˜Ÿåˆ—ä»¥èƒ½å¤Ÿæ–¹ä¾¿çš„æ¨ªå‘æ‰©å±•.\n\n## seccomp\nseccompä¸ºlinuxç³»ç»Ÿä¸Šæ‰æœ‰çš„å®‰å…¨æŠ€æœ¯,å› æ­¤å¿…é¡»ä½¿ç”¨linux.åœ¨å®‰è£…å¿…è¦çš„å®‰è£…åŒ…å\n\n```bash\n$ sudo apt install libseccomp2 libseccomp-dev seccomp\n```\n\nå³å¯ä½¿ç”¨.\n\nå½“ç„¶,åœ¨windowsä¸‹çš„Jobsä¼¼ä¹ä¹Ÿå¯ä»¥åˆ©ç”¨,ä½†æ˜¯æˆ‘ä¸å¤ªæ‡‚,å¾®è½¯æ–‡æ¡£å†™å¾—ä¹Ÿå¥‡æ€ª,è€Œä¸”è¿˜å¾—æ˜¯æœåŠ¡å™¨ç‰ˆæœ¬çš„windowsæ‰èƒ½ç”¨.\n\n### åŸºæœ¬ä½¿ç”¨\nseccompéœ€è¦ç”±ç¨‹åºä¸»åŠ¨åŠ è½½.å…¶ä½¿ç”¨æ–¹æ³•åŸºæœ¬ä¸ºä¸‹\n\n```cpp\n//g++ -g test.c -o o -lseccomp\n#include <unistd.h>\n#include <seccomp.h>\n#include <linux/seccomp.h>\n\nint main(void){\n\t//åˆå§‹åŒ–ç­›é€‰å™¨\n\tscmp_filter_ctx ctx;\n\tctx = seccomp_init(SCMP_ACT_ALLOW);//flagæŒ‡æ˜é»˜è®¤é€šè¿‡\n\t//æ·»åŠ æ‹¦æˆª,å¹¶æŒ‡æ˜ä¸€æ—¦æ‹¦æˆªå°±å°†ç¨‹åºkillæ‰.\n\tseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);\n\t//å°†è§„åˆ™åŠ è½½æ³¨å…¥.\n\tseccomp_load(ctx);\n\n\tchar * filename = \"/bin/sh\";\n\tchar * argv[] = {\"/bin/sh\",NULL};\n\tchar * envp[] = {NULL};\n\twrite(1,\"i will give you a shell\\n\",24);\n\t//ç¨‹åºå°†ä¼šåœ¨æ­¤è¡Œå´©æºƒ.\n\tsyscall(59,filename,argv,envp);//execve\n\treturn 0;\n}\n```\n\nseccomp_initæ˜¯åˆå§‹åŒ–çš„è¿‡æ»¤çŠ¶æ€,è¿™é‡Œç”¨çš„æ˜¯SCMP_ACT_ALLOW,è¡¨ç¤ºé»˜è®¤å…è®¸æ‰€æœ‰çš„syscacll.å¦‚æœåˆå§‹åŒ–çŠ¶æ€ä¸ºSCMP_ACT_KILL,åˆ™è¡¨ç¤ºé»˜è®¤ä¸å…è®¸æ‰€æœ‰çš„syscall.\n\n```cpp\n/**\n * Kill the process\n */\n#define SCMP_ACT_KILL\t\t0x00000000U\n/**\n * Throw a SIGSYS signal\n */\n#define SCMP_ACT_TRAP\t\t0x00030000U\n/**\n * Return the specified error code\n */\n#define SCMP_ACT_ERRNO(x)\t(0x00050000U | ((x) & 0x0000ffffU))\n/**\n * Notify a tracing process with the specified value\n */\n#define SCMP_ACT_TRACE(x)\t(0x7ff00000U | ((x) & 0x0000ffffU))\n/**\n * Allow the syscall to be executed after the action has been logged\n */\n#define SCMP_ACT_LOG\t\t0x7ffc0000U\n/**\n * Allow the syscall to be executed\n */\n#define SCMP_ACT_ALLOW\t\t0x7fff0000U\n```\n\nè§„åˆ™æ·»åŠ \n```cpp\n/**\n * Add a new rule to the filter\n * @param ctx the filter context\n * @param action the filter action\n * @param syscall the syscall number\n * @param arg_cnt the number of argument filters in the argument filter chain\n * @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended)\n *\n * This function adds a series of new argument/value checks to the seccomp\n * filter for the given syscall; multiple argument/value checks can be\n * specified and they will be chained together (AND'd together) in the filter.\n * If the specified rule needs to be adjusted due to architecture specifics it\n * will be adjusted without notification.  Returns zero on success, negative\n * values on failure.\n *\n */\nint seccomp_rule_add(scmp_filter_ctx ctx,\n\t\t     uint32_t action, int syscall, unsigned int arg_cnt, ...);\n```\n\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);,arg_cntä¸º0,è¡¨ç¤ºç›´æ¥é™åˆ¶execve,ä¸ç®¡ä»–ä»€ä¹ˆå‚æ•°.\n\nå¦‚æœarg_cntä¸ä¸º0,é‚£arg_cntè¡¨ç¤ºåé¢é™åˆ¶çš„å‚æ•°çš„ä¸ªæ•°,ä¹Ÿå°±æ˜¯åªæœ‰è°ƒç”¨execve,ä¸”å‚æ•°æ»¡è¶³è¦æ±‚æ—¶,æ‰ä¼šæ‹¦æˆªsyscall.\n\n```\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write),1,SCMP_A2(SCMP_CMP_EQ,0x10));//ç¬¬2(ä»0)ä¸ªå‚æ•°ç­‰äº0x10\n```\n\n```cpp\n/**\n * Specify an argument comparison struct for use in declaring rules\n * @param arg the argument number, starting at 0\n * @param op the comparison operator, e.g. SCMP_CMP_*\n * @param datum_a dependent on comparison\n * @param datum_b dependent on comparison, optional\n */\n#define SCMP_CMP(...)\t\t((struct scmp_arg_cmp){__VA_ARGS__})\n\n/**\n * Specify an argument comparison struct for argument 0\n */\n#define SCMP_A0(...)\t\tSCMP_CMP(0, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 1\n */\n#define SCMP_A1(...)\t\tSCMP_CMP(1, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 2\n */\n#define SCMP_A2(...)\t\tSCMP_CMP(2, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 3\n */\n#define SCMP_A3(...)\t\tSCMP_CMP(3, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 4\n */\n#define SCMP_A4(...)\t\tSCMP_CMP(4, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 5\n */\n#define SCMP_A5(...)\t\tSCMP_CMP(5, __VA_ARGS__)\n\n\n\n/**\n * Comparison operators\n */\nenum scmp_compare {\n\t_SCMP_CMP_MIN = 0,\n\tSCMP_CMP_NE = 1,\t\t/**< not equal */\n\tSCMP_CMP_LT = 2,\t\t/**< less than */\n\tSCMP_CMP_LE = 3,\t\t/**< less than or equal */\n\tSCMP_CMP_EQ = 4,\t\t/**< equal */\n\tSCMP_CMP_GE = 5,\t\t/**< greater than or equal */\n\tSCMP_CMP_GT = 6,\t\t/**< greater than */\n\tSCMP_CMP_MASKED_EQ = 7,\t\t/**< masked equality */\n\t_SCMP_CMP_MAX,\n};\n\n/**\n * Argument datum\n */\ntypedef uint64_t scmp_datum_t;\n\n/**\n * Argument / Value comparison definition\n */\nstruct scmp_arg_cmp {\n\tunsigned int arg;\t/**< argument number, starting at 0 */\n\tenum scmp_compare op;\t/**< the comparison op, e.g. SCMP_CMP_* */\n\tscmp_datum_t datum_a;\n\tscmp_datum_t datum_b;\n};\n```\n\nctxçš„å†…å®¹å¯ä»¥ä½¿ç”¨å‡½æ•°dumpå‡ºæ¥,ä¹‹åå¯ä»¥ç›´æ¥ä½¿ç”¨prctlå‘½ä»¤ç›¸å…³ç›´æ¥è½½å…¥,æ–¹ä¾¿ä½¿ç”¨?\n\n### seccompè°ƒè¯•\n\nä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å¯¼å‡ºæ‰€æœ‰å¯èƒ½çš„å‘½ä»¤\n```bash\nfile=syscall-names.h\necho \"static const char *syscall_names[] = {\" > $file\necho \"#include <sys/syscall.h>\" | cpp -dM | grep '^#define __NR_' | LC_ALL=C sed -r -n -e 's/^\\#define[ \\t]+__NR_([a-z0-9_]+)[ \\t]+([0-9]+)(.*)/ [\\2] = \"\\1\",/p' >> $file\necho \"};\" >> $file\n```\n\nä½¿ç”¨å¦‚ä¸‹ä»£ç å¯¼å‡ºä¸€æ®µä»£ç æ‰€éœ€è¦çš„æƒé™.éµå¾ªæœ€å°æƒé™åŸåˆ™,è¯•éªŒä»£ç è¿è¡Œæ‰€éœ€è¦çš„æœ€å°‘æƒé™.\n```cpp\n#define __USE_GNU 1\n#define _GNU_SOURCE 1\n#include <signal.h>\n#include <sys/prctl.h>\n#include <linux/types.h>\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n#include <seccomp.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"syscall-names.h\"\n#if defined(__i386__)\n#define REG_RESULT\tREG_EAX\n#define REG_SYSCALL\tREG_EAX\n#define REG_ARG0\tREG_EBX\n#define REG_ARG1\tREG_ECX\n#define REG_ARG2\tREG_EDX\n#define REG_ARG3\tREG_ESI\n#define REG_ARG4\tREG_EDI\n#define REG_ARG5\tREG_EBP\n#elif defined(__x86_64__)\n#define REG_RESULT\tREG_RAX\n#define REG_SYSCALL\tREG_RAX\n#define REG_ARG0\tREG_RDI\n#define REG_ARG1\tREG_RSI\n#define REG_ARG2\tREG_RDX\n#define REG_ARG3\tREG_R10\n#define REG_ARG4\tREG_R8\n#define REG_ARG5\tREG_R9\n#endif\n#ifndef SYS_SECCOMP\n#define SYS_SECCOMP 1\n#endif\n\nconst char *const msg=\"system call invalid: \";\n\nstatic void write_uint(char *buf, unsigned int val)\n{\n    int width = 0;\n    unsigned int tens;\n    if (val == 0) {\n        strcpy(buf, \"0\");\n        return;\n    }\n    for (tens = val; tens; tens /= 10)\n        ++ width;\n    buf[width] = '\\0';\n    for (tens = val; tens; tens /= 10)\n        buf[--width] = (char) ('0' + (tens % 10));\n}\nstatic void helper(int nr, siginfo_t *info, void *void_context) {\n    char buf[255];\n    ucontext_t *ctx = (ucontext_t *)(void_context);\n    unsigned int syscall;\n    if (info->si_code != SYS_SECCOMP)\n        return;\n    if (!ctx)\n        return;\n    syscall = (unsigned int) ctx->uc_mcontext.gregs[REG_SYSCALL];\n    strcpy(buf, msg);\n    if (syscall < sizeof(syscall_names)) {\n        strcat(buf, syscall_names[syscall]);\n        strcat(buf, \"(\");\n    }\n    write_uint(buf + strlen(buf), syscall);\n    if (syscall < sizeof(syscall_names))\n        strcat(buf, \")\");\n    strcat(buf, \"\\n\");\n    write(STDOUT_FILENO, buf, strlen(buf));\n    _exit(1);\n}\nstatic int install_helper() {\n    struct sigaction act;\n    sigset_t mask;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGSYS);\n    act.sa_sigaction = &helper;\n    act.sa_flags = SA_SIGINFO;\n    if (sigaction(SIGSYS, &act, NULL) < 0) {\n        perror(\"sigaction\");\n        return -1;\n    }\n    if (sigprocmask(SIG_UNBLOCK, &mask, NULL)) {\n        perror(\"sigprocmask\");\n        return -1;\n    }\n    return 0;\n}\n\n#include <stdio.h>\nint main(){\n\tif(install_helper()){\n\t\tprintf(\"install helper failed\");\n\t\treturn 1;\n\t}\n\n\tscmp_filter_ctx ctx = NULL;\n\tctx = seccomp_init(SCMP_ACT_ALLOW);\n\n\tseccomp_rule_add(ctx, SCMP_ACT_TRAP, SCMP_SYS(execve), 0);\n\tseccomp_load(ctx);\n\tseccomp_release(ctx);\n\tfprintf(stdout, \"something to stdout\\n\");\n\tchar * filename = \"/bin/sh\";\n\tchar * argv[] = {\"/bin/sh\",NULL};\n\tchar * envp[] = {NULL};\n\twrite(1,\"i will give you a shell\\n\",24);\n\tsyscall(59,filename,argv,envp);//execve\n\n\treturn 0;\n}\n```\n\n### æ³¨å…¥ç¨‹åº\nåˆšåˆšæåˆ°äº†seccompå¿…é¡»ç”±ç¨‹åºä¸»åŠ¨åŠ è½½,å› æ­¤éœ€è¦æœ‰ä¸€ä¸ªåŠæ³•å°†ä»£ç æ³¨å…¥åˆ°ç”¨æˆ·çš„ä»£ç ä¸­.\n\n> ç­‰å¾…å®Œæˆ\n\n### å…¶ä»–è¯­è¨€\nè¿™ç©æ„è²Œä¼¼è‡³å°‘èƒ½æ–¹ä¾¿çš„ç”¨åœ¨cç³»è¯­è¨€,javaå’Œpythonä¸Š.\n\n## Docker\nå‡†å¤‡ä½¿ç”¨Dockeré‡æ„æ•´ä¸ªOJ\n\n### å¤šé˜¶æ®µæ„å»º\nä½¿ç”¨Docker,å°†OJåˆ†è§£ä¸ºå¤šä¸ªé˜¶æ®µæ¥æ„å»º.\n\n1. å‰ç«¯æ„å»º\n2. åç«¯æ„å»º\n3. è¿è¡Œç¯å¢ƒæ„å»ºä¸ä»£ç æ•´åˆ\n4. nginxæ„å»º\n\n#### å‘½ä»¤\n```Dockerfile\n#...\n\n# ä½¿ç”¨phpä½œä¸ºåŸºç¡€,æŒ‡æ˜è¯¥æ„å»ºé˜¶æ®µä¸ºcodeisland\nFROM php:alpine as codeisland\n# åœ¨å®¹å™¨æ‰“åŒ…é˜¶æ®µå®‰è£…æ•°æ®åº“é©±åŠ¨\nRUN docker-php-ext-install pdo pdo_pgsql\n\nARG PATH=/app/laravel\n\n# ä»å…¶ä»–é˜¶æ®µå¤åˆ¶ä»£ç åˆ°æœ¬é˜¶æ®µ\nCOPY --from=DELETED /app/ ${PATH}\n\n# æ‰§è¡Œå…¶ä»–åˆå§‹åŒ–å‘½ä»¤\n# [DELETED]\n\n# æŒ‡æ˜å®¹å™¨çš„å·¥ä½œè·¯å¾„\nWORKDIR ${PATH}\n\n#...\n```\n\n### å®¹å™¨åè°ƒ\nä½¿ç”¨Docker-composeæ¥åè°ƒå„ä¸ªå®¹å™¨çš„å…³ç³».\n\n* æ•°æ®åº“å®¹å™¨\n* rediså®¹å™¨\n* ç½‘ç«™åç«¯å®¹å™¨\n* è¯„æµ‹å™¨å®¹å™¨\n* è¯„æµ‹ä»£ç†å®¹å™¨\n* nginxå®¹å™¨\n\né™åˆ¶è¯„æµ‹å™¨å®¹å™¨çš„èµ„æºæ¶ˆè€—çš„ä¾‹å­\n\n```yml\ndeploy:\n  resources:\n    limits:\n      cpus: '0.50'\n      memory: 1024M\n```\n\n### ç½‘ç»œ\n...å­¦æ ¡ç½‘å…³çš„ç™»å½•çŠ¶æ€æ ¹æœ¬æ²¡æ³•ç»´æŒ,å¡æ­».\n","tags":["code island"],"categories":["é—²æ‰¯"]},{"title":"[FZU 2204]Seven","url":"%2F2019%2F08%2F10%2Fproblem-seven%2F","content":"\nnä¸ªæœ‰æ ‡å·çš„çƒå›´æˆä¸€ä¸ªåœˆã€‚æ¯ä¸ªçƒæœ‰ä¸¤ç§é¢œè‰²å¯ä»¥é€‰æ‹©é»‘æˆ–ç™½æŸ“è‰²ã€‚é—®æœ‰å¤šå°‘ç§æ–¹æ¡ˆä½¿å¾—æ²¡æœ‰å‡ºç°è¿ç»­ç™½çƒ7ä¸ªæˆ–è¿ç»­é»‘çƒ7ä¸ªã€‚\n\nå¯¹æ–¹æ¡ˆæ•°mod 2015ï¼Œçƒæœ€å¤šæœ‰100000ä¸ªã€‚\n\n# åˆ†æ\nè€ƒè™‘å¯¹äºéç¯çŠ¶çƒçš„ç­”æ¡ˆè®¡ç®—ï¼Œå¯ä»¥è®¾$sum(i,k)$è¡¨ç¤ºç¬¬iä¸ªçƒä¸ºkè‰²æ—¶çš„æ–¹æ¡ˆæ•°ã€‚å…¶è®¡ç®—éå¸¸æ˜¾ç„¶\n\n$$\nsum(i,k)=\\sum_{1\\leq j \\leq 6}{sum(i-j,1-k)}\n$$\n\næ¥ä¸‹æ¥è€ƒè™‘æ”¶å°¾ç›¸æ¥åéœ€è¦æ’é™¤çš„æƒ…å†µï¼Œå³æ”¶å°¾åŒè‰²çƒé•¿åº¦ç›¸åŠ è¶…è¿‡6çš„æƒ…å†µï¼Œè¿™å¯ä»¥ç›´æ¥æšä¸¾ã€‚\n\né¦–å–iä¸ªæœ«å–jä¸ªåŒè‰²ï¼Œä»ç­”æ¡ˆä¸­åˆ é™¤æ­¤æ—¶å‰©ä¸‹çƒçš„æ–¹æ¡ˆæ•°ï¼Œæ³¨æ„å‰©ä¸‹çš„çƒçš„é¦–æœ«çƒé¢œè‰²**ä¸èƒ½**å’Œå·²ç»æšä¸¾çš„é¢œè‰²åŒè‰²ã€‚é‰´äºè¿™ç§è¦æ±‚ï¼Œæˆ‘ä»¬é€€å›åˆ°sumçš„é€’æ¨å…¬å¼å¤„ï¼Œå†³å®šsumçš„è¾¹ç•Œæ¡ä»¶ä¸ºé¦–ä¸ªçƒå›ºå®šä¸ºé»‘è‰²ï¼Œè¿™æ ·å°±èƒ½å¾ˆæ–¹ä¾¿çš„ç¡®å®šçƒçš„é¢œè‰²ï¼Œä¸”æ ¹æ®å¯¹ç§°æ€§ç­”æ¡ˆå¯ä»¥ç›´æ¥x2å¾—åˆ°ã€‚\n\né¢˜å°±åšå®Œäº†ã€‚\n\n# ä»£ç \n> æ·¦ï¼Œä¸ºä»€ä¹ˆå½“æ—¶æ²¡å†™ã€‚\n\n```cpp\n#include <iostream>\nusing namespace std;\nconst int MAXN=100010;\nconst int P=2015;\n\nint sum[MAXN][2];\nint main(){\n    int kase;cin>>kase;\n    sum[0][1]=1;\n    for(int i=1;i<=100000;i++){\n        for(int j=1;j<=min(i,6);j++){\n            (sum[i][1]+=sum[i-j][0])%=P;\n            (sum[i][0]+=sum[i-j][1])%=P;\n        }\n    }\n    sum[0][1]=0;\n    int cnt=0;\n    while(kase--){\n        int nlen;cin>>nlen;\n        int ans=(sum[nlen][0]+sum[nlen][1])%P;\n        if(nlen>=7)\n            for(int i=1;i<=6;i++)\n                for(int j=1;j<=6;j++)\n                    if(i+j>=7 && nlen-i-j>=0)\n                        ans=(ans-sum[nlen-i-j][0])%P;\n        cout<<\"Case #\"<<++cnt<<\": \"<<((ans*2)%P+2015)%P<<endl;\n    }\n    return 0;\n}\n```\n","tags":["è®¡æ•°"],"categories":["coding"]},{"title":"[HDU6638] Snowy Smile","url":"%2F2019%2F08%2F07%2Fproblem-snowy-smile%2F","content":"\nThere are n pirate chests buried in Byteland, labeled by 1,2,â€¦,n. The i-th chest's location is (xi,yi), and its value is wi, wi can be negative since the pirate can add some poisonous gases into the chest. When you open the i-th pirate chest, you will get wi value.\n\nYou want to make money from these pirate chests. You can select a rectangle, the sides of which are all paralleled to the axes, and then all the chests inside it or on its border will be opened. Note that you must open all the chests within that range regardless of their values are positive or negative. But you can choose a rectangle with nothing in it to get a zero sum.\n\nPlease write a program to find the best rectangle with maximum total value.\n\nThe first line of the input contains an integer T(1â‰¤Tâ‰¤100), denoting the number of test cases.\n\nIn each test case, there is one integer n(1â‰¤nâ‰¤2000) in the first line, denoting the number of pirate chests.\n\nFor the next n lines, each line contains three integers xi,yi,wi(âˆ’109â‰¤xi,yi,wiâ‰¤109), denoting each pirate chest.\n\nIt is guaranteed that âˆ‘nâ‰¤10000.\n\n\n## åˆ†æ\né¦–å…ˆï¼Œæˆ‘æ²¡åšå‡ºæ¥ã€‚\n\n<!--more-->\n\nè¿™é“é¢˜å®é™…ä¸Šå°±æ˜¯åœ¨è¦æ±‚ä½ ç”¨å°äº$O(N^3)$çš„å¤æ‚åº¦æ±‚å‡ºæœ€å¤§å’Œå­çŸ©é˜µã€‚æ³¨æ„åˆ°è¯¥é¢˜çš„ç‚¹**ç¨€ç–**ï¼Œæ‰€ä»¥ä»¥ç‚¹ä¸ºè€ƒè™‘å¯¹è±¡ã€‚\n\nä¸‰æ–¹çš„åšæ³•ï¼Œæšä¸¾çŸ©é˜µçš„ä¸Šè¾¹ç•Œå’Œä¸‹è¾¹ç•Œï¼Œç»´æŠ¤çºµå‘ä¸Šçš„å’Œï¼Œæ±‚æœ€å¤§å­—æ®µå’Œã€‚å½“ä»¥ç‚¹è€ƒè™‘æ—¶ï¼Œä¸Šä¸‹è¾¹ç•Œå°±å¯ä»¥ç›´æ¥ç”±**æ’åºå**çš„ç‚¹å†³å®šã€‚ä¹‹åï¼Œä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤æœ€å¤§å­æ®µå’Œã€‚\n\n## ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconstexpr int MAXN=400010;\n\nll d_sub[MAXN],d_pre[MAXN],d_suf[MAXN];\nll d_sum[MAXN];\nint lc[MAXN],rc[MAXN];\nint idx=0;\nvoid build(int &n,int l,int r){\n    if(!n)n=++idx;\n    d_sum[n]=d_sub[n]=d_pre[n]=d_suf[n]=0;\n    if(l==r){\n        return;\n    }\n    int mid=(l+r)/2;\n    build(lc[n],l,mid);\n    build(rc[n],mid+1,r);\n    //combine data\n}\nvoid collect(int node){\n    d_sum[node]=d_sum[lc[node]]+d_sum[rc[node]];\n\n    d_pre[node]=max(d_pre[lc[node]],d_sum[lc[node]]+d_pre[rc[node]]);\n    d_suf[node]=max(d_suf[rc[node]],d_sum[rc[node]]+d_suf[lc[node]]);\n\n    d_sub[node]=max(max(d_sub[lc[node]],d_sub[rc[node]]),d_suf[lc[node]]+d_pre[rc[node]]);\n}\n\nvoid modify(int x,int l,int r,int L,int R,int node){\n    if(l<=L && R<=r){\n        //only single point to modify\n        d_sub[node]=d_sub[node]+x;\n        d_pre[node]=d_pre[node]+x;\n        d_suf[node]=d_suf[node]+x;\n        d_sum[node]+=x;\n        return;\n    }\n    int mid=(L+R)/2;\n    if(l<=mid)modify(x,l,r,L,mid,lc[node]);\n    if(mid<r)modify(x,l,r,mid+1,R,rc[node]);\n\n    collect(node);\n}\nint root;\nll query_all(){\n    return d_sub[root];\n}\n\nstruct Chest{\n    int x,y,v;\n    bool operator<(const Chest &other)const{\n        if(x==other.x)return y<other.y;\n        return x<other.x;\n    }\n} chests[MAXN];\n\nvector<int> refy;\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    while(kase--){\n        int nlen;cin>>nlen;\n        refy.clear();\n        for(int i=0;i<nlen;i++){\n            Chest &chest=chests[i];\n            cin>>chest.x>>chest.y>>chest.v;\n            refy.push_back(chest.y);\n        }\n        sort(chests,chests+nlen);\n\n        sort(refy.begin(),refy.end());\n        auto refyend=unique(refy.begin(),refy.end());\n        int maxy=0;\n        for(int i=0;i<nlen;i++){\n            chests[i].y=lower_bound(refy.begin(),refyend,chests[i].y)-refy.begin()+1;\n            maxy=max(maxy,chests[i].y);\n        }\n\n        int lastx=0;\n        ll ans=0;\n\n        for(int i=0;i<nlen;i++){\n            if(lastx==chests[i].x)continue;\n            lastx=chests[i].x;\n            //cout<<\"start from \"<<lastx<<endl;\n\n            build(root,1,maxy);\n            int nextx=chests[i].x;\n            for(int j=i;j<nlen;j++){\n                if(chests[j].x!=nextx){\n                    nextx=chests[j].x;\n                    ans=max(ans,query_all());\n                }\n                modify(chests[j].v,chests[j].y,chests[j].y,1,maxy,root);\n            }\n            ans=max(ans,query_all());\n        }\n        cout<<max(0ll,ans)<<endl;\n    }\n\n    return 0;\n}\n```\n\n\n","tags":["çº¿æ®µæ ‘"],"categories":["coding"]},{"title":"è«é˜Ÿç®—æ³•","url":"%2F2019%2F08%2F03%2Fmo-s-algorithm%2F","content":"\nå¯¹äºå¯ä»¥ç¦»çº¿çš„åŒºé—´è¯¢é—®é—®é¢˜ï¼Œè«é˜Ÿç®—æ³•æå‡ºäº†ä¸€ç§å¯ä»¥åœ¨$O(n\\sqrt n)$(æ— ä¿®æ”¹)ï¼Œ$n^{3/5}$(å¸¦ä¿®æ”¹)å†…å¾—å‡ºç­”æ¡ˆçš„æ–¹æ³•ã€‚\n\nä¸»è¦çš„æ€è·¯æ˜¯å¯¹è¯¢é—®ç¦»çº¿å¹¶åˆ†å—ï¼Œåˆ©ç”¨åœ¨2ä¸ªåŒºé—´é—´ç­”æ¡ˆçš„**å¿«é€Ÿè½¬ç§»**ï¼ˆå¦‚æœæ— æ³•æ‰¾åˆ°å¿«é€Ÿè½¬ç§»çš„æ–¹æ³•ï¼Œå°±æ²¡æ³•ç”¨äº†ï¼‰é™ä½å¤æ‚åº¦ã€‚\n\n<!--more-->\n\n## æ— ä¿®æ”¹è«é˜Ÿ\nä»¥$B=\\sqrt{n}$ï¼ŒæŒ‰ç…§$(l/B,r)$å¯¹è¯¢é—®æ’åºã€‚\n\nä¹‹åæšä¸¾æ¯ä¸€ä¸ªè¯¢é—®ï¼Œå°†ç­”æ¡ˆåœ¨ç›¸é‚»è¯¢é—®åŒºé—´é—´æš´åŠ›çš„+1-1è½¬ç§»ã€‚\n\n### Problem: å°Yçš„è¢œå­\næ²¡æœ‰åœ¨é’ˆå¯¹å“ªä¸ªäººã€‚\n\nä½œä¸ºä¸€ä¸ªç”Ÿæ´»æ•£æ¼«çš„äººï¼Œå°Zæ¯å¤©æ—©ä¸Šéƒ½è¦è€—è´¹å¾ˆä¹…ä»ä¸€å †äº”é¢œå…­è‰²çš„è¢œå­ä¸­æ‰¾å‡ºä¸€åŒæ¥ç©¿ã€‚ç»ˆäºæœ‰ä¸€å¤©ï¼Œå°Zå†ä¹Ÿæ— æ³•å¿å—è¿™æ¼äººçš„æ‰¾è¢œå­è¿‡ç¨‹ï¼Œäºæ˜¯ä»–å†³å®šå¬å¤©ç”±å‘½â€¦â€¦\n\nå…·ä½“æ¥è¯´ï¼Œå°ZæŠŠè¿™Nåªè¢œå­ä»1åˆ°Nç¼–å·ï¼Œç„¶åä»ç¼–å·Låˆ°R(L å°½ç®¡å°Zå¹¶ä¸åœ¨æ„ä¸¤åªè¢œå­æ˜¯ä¸æ˜¯å®Œæ•´çš„ä¸€åŒï¼Œç”šè‡³ä¸åœ¨æ„ä¸¤åªè¢œå­æ˜¯å¦ä¸€å·¦ä¸€å³ï¼Œä»–å´å¾ˆåœ¨æ„è¢œå­çš„é¢œè‰²ï¼Œæ¯•ç«Ÿç©¿ä¸¤åªä¸åŒè‰²çš„è¢œå­ä¼šå¾ˆå°´å°¬ã€‚\n\nä½ çš„ä»»åŠ¡ä¾¿æ˜¯å‘Šè¯‰å°Zï¼Œä»–æœ‰å¤šå¤§çš„æ¦‚ç‡æŠ½åˆ°ä¸¤åªé¢œè‰²ç›¸åŒçš„è¢œå­ã€‚å½“ç„¶ï¼Œå°Zå¸Œæœ›è¿™ä¸ªæ¦‚ç‡å°½é‡é«˜ï¼Œæ‰€ä»¥ä»–å¯èƒ½ä¼šè¯¢é—®å¤šä¸ª(L,R)ä»¥æ–¹ä¾¿è‡ªå·±é€‰æ‹©ã€‚\n\nè¢œå­çš„æ•°é‡æœ€å¤šä¸º50000ï¼ˆæ˜¯çœŸçš„ğŸ‚ğŸºï¼‰\n\n#### åˆ†æ\nè¿™ä¼¼ä¹æ˜¯è«é˜Ÿçš„ä¾‹é¢˜ï¼ˆ\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50010,MAXQ=50010;\n\nll gcd(ll a,ll b){\n    return !b?a:gcd(b,a%b);\n}\nll c2(ll n){\n    if(n<2)return 0;\n    return n*(n-1)/2;\n}\nint a[MAXN];\nint block=0;\nstruct Q{\n    int l,r;\n    int i;\n    ll ansu,ansd;\n    bool operator<(const Q &b)const{\n        if(l/block!=b.l/block)return l/block<b.l/block;\n        return r<b.r;\n    }\n}qs[MAXQ];\n\nint cnt[MAXN];\nll cup=0,cdown=0;\nvoid remove(int ptr){\n    cup-=c2(cnt[a[ptr]]);\n    cnt[a[ptr]]--;\n    cdown--;\n    cup+=c2(cnt[a[ptr]]);\n}\nvoid add(int ptr){\n    cup-=c2(cnt[a[ptr]]);\n    cnt[a[ptr]]++;\n    cdown++;\n    cup+=c2(cnt[a[ptr]]);\n}\nint main(){\n    int nlen,qlen;cin>>nlen>>qlen;\n    for(int i=1;i<=nlen;i++)cin>>a[i];\n    for(int i=0;i<qlen;i++)cin>>qs[i].l>>qs[i].r;\n    for(int i=0;i<qlen;i++)qs[i].i=i;\n    block=sqrt(nlen);\n    sort(qs,qs+qlen);\n    /*\n    cout<<\"current queries:\"<<endl;\n    for(auto q:qs){\n        cout<<q.l<<\" \"<<q.r<<endl;\n    }\n    cout<<\"=====\"<<endl;\n*/\n    int l=1,r=1;\n    add(1);\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        if(q.l==q.r){\n            q.ansu=0;q.ansd=1;\n            continue;\n        }\n        while(q.l<l)add(--l);\n        while(r<q.r)add(++r);\n        while(l<q.l)remove(l++);\n        while(q.r<r)remove(r--);\n\n        q.ansu=cup;\n        q.ansd=cdown;\n        //cout<<cup/c2(cdown)<<endl;\n    }\n    sort(qs,qs+qlen,[](const Q &a,const Q &b){\n            return a.i<b.i;\n            });\n    for(int i=0;i<qlen;i++){\n        if(qs[i].ansd<2){\n            cout<<\"0/1\"<<endl;\n            continue;\n        }\n        ll u=qs[i].ansu;\n        ll d=c2(qs[i].ansd);\n        ll g=gcd(u,d);\n        if(g!=0)u/=g,d/=g;\n        cout<<u<<\"/\"<<d<<endl;\n    }\n\n\n    return 0;\n}\n```\n\n## å¸¦ä¿®æ”¹è«é˜Ÿ\n> ä¸€åˆ‡éƒ½æ˜¯çŸ³xé—¨çš„é€‰æ‹©ï¼\n\nå°†ä¿®æ”¹æ“ä½œå¹³é“ºåœ¨æ—¶é—´çº¿ä¸Šï¼Œè®¡ç®—æ¯æ¬¡è¯¢é—®æ‰€å¤„çš„æ—¶é—´ç‚¹ï¼Œä»¥$B=\\sqrt{n}$ï¼ŒæŒ‰ç…§$(l/B,r/B,time)$å¯¹è¯¢é—®æ’åºã€‚\n\nä¹‹åæšä¸¾æ¯ä¸€ä¸ªè¯¢é—®ï¼Œå°†ç­”æ¡ˆåœ¨ä¸åŒæ—¶é—´çº¿é—´æš´åŠ›+1-1è·³è½¬ï¼Œå†æš´åŠ›åœ¨ç›¸é‚»è¯¢é—®çš„åŒºé—´é—´+1-1è½¬ç§»ã€‚\n\n~~å¬èµ·æ¥æœ‰ç‚¹ä¸­äºŒçš„æ„æ€ã€‚~~\n\n### Problem: Game\nAgain Alice and Bob is playing a game with stones. There are N piles of stones labelled from 1 to N, the i th pile has ai stones. \n\nFirst Alice will choose piles of stones with consecutive labels, whose leftmost is labelled with L and the rightmost one is R. After, Bob will choose another consecutive piles labelled from l to r (Lâ‰¤lâ‰¤râ‰¤R). Then they're going to play game within these piles.\n\nHere's the rules of the game: Alice takes first and the two will take turn to make a move: choose one pile with nonegetive stones and take at least one stone and at most all away. One who cant make a move will lose.\n\nBob thinks this game is not so intersting because Alice always take first. So they add a new rule, which is that Bob can swap the number of two adjacent piles' stones whenever he want before a new round. That is to say, if the i th and i+1 pile have ai and ai+1 stones respectively, after this swapping there will be ai+1 and ai.\n\nBefore today's game with Bob, Alice wants to know, if both they play game optimally when she choose the piles from L to R, there are how many pairs (l, r) chosed by Bob that will make Alice *win*.\n\n#### åˆ†æ\nnimæ¸¸æˆè¾“èµ¢å°±æ˜¯çœ‹å¼‚æˆ–å’Œï¼Œå¼‚æˆ–å’Œå¯ä»¥çœ‹å‰ç¼€å¼‚æˆ–å’Œå†…æœ‰å¤šå°‘ä¸ªå€¼ç›¸åŒçš„ç‚¹ã€‚æ‰€ä»¥å®ƒå°±æ˜¯åœ¨é—®ä¸€ä¸ªåŒºé—´é‡Œæœ‰å¤šå°‘ä¸ªç›¸åŒç‚¹å¯¹ã€‚\n\nå¸¦å•ç‚¹ä¿®æ”¹çš„åŒºé—´ç‚¹å¯¹è®¡æ•°ã€‚\n\n#### ä»£ç \n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=100010,MAXQ=100010;\nconst int MAXPOS=2e6+11;\n\nint nlen,qlen;\nint game[MAXN];\nint pre[MAXN];\nint modified[MAXQ],midx=0,belong[MAXN];\nint block=0;\nstruct Q{\n    int i;\n    int l,r;\n    int tick;\n\n    bool operator<(const Q &b)const{\n //       if(l/block!=b.l/block)return l/block<b.l/block;\n   //     if(r/block!=b.r/block)return r/block<b.r/block;\n        if(belong[l]!=belong[b.l])\n            return belong[l]<belong[b.l];\n        if(belong[r]!=belong[b.r])\n            return belong[r]<belong[b.r];\n        return  tick<b.tick;\n    }\n}q[MAXQ];\nint qidx=0;\nll cache=0;\nint cnt[MAXPOS];\n\ninline void add(int pos){\n    int &c=cnt[pre[pos]];\n    cache-=(ll)c*(c-1)/2;\n    c++;\n    cache+=(ll)c*(c-1)/2;\n}\ninline void rm(int pos){\n    int &c=cnt[pre[pos]];\n    cache-=(ll)c*(c-1)/2;\n    c--;\n    cache+=(ll)c*(c-1)/2;\n}\n\nint l=1,r=1,curt=0;\ninline void jumpup(int tim){\n    if(tim==0)return;\n    int pos=modified[tim];\n    int a=game[pos];\n    int b=game[pos+1];\n    swap(game[pos],game[pos+1]);\n    if(l<=pos && pos<=r){\n        rm(pos);\n    }\n    pre[pos]^=a;\n    pre[pos]^=b;\n    if(l<=pos && pos<=r){\n        add(pos);\n    }\n}\ninline void jumpdown(int tim){\n    jumpup(tim);\n}\n\nll qans[MAXQ];\n\nint main(){\n    //freopen(\"00.in\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&nlen,&qlen)){\n        block=pow(nlen,2.0/3);\n        for(int i=1;i<=nlen;i++){\n            scanf(\"%d\",&game[i]);\n            belong[i]=(i-1)/block;\n        }\n        pre[0]=0;\n        for(int i=1;i<=nlen;i++)pre[i]=pre[i-1]^game[i];\n\n        qidx=0,midx=0;\n        for(int i=1;i<=qlen;i++){\n            int opt;\n            scanf(\"%d\",&opt);\n            if(opt==1){\n                int l,r;\n                scanf(\"%d%d\",&l,&r);\n                q[qidx].i=qidx;\n                q[qidx].l=l;\n                q[qidx].l--;\n                q[qidx].r=r;\n                q[qidx].tick=midx;\n                qidx++;\n            }else if(opt==2){\n                scanf(\"%d\",&modified[++midx]);\n            }\n        }\n        sort(q,q+qidx);\n\n        memset(cnt,0,sizeof(cnt));\n        cache=0;\n        l=r=1;curt=0;\n        add(1);\n        for(int i=0;i<qidx;i++){\n            if(q[i].r-q[i].l+1<2){\n                qans[q[i].i]=0;\n                continue;\n            }\n            while(curt<q[i].tick)jumpup(++curt);\n            while(q[i].tick<curt)jumpdown(curt--);\n\n            while(q[i].l<l)add(--l);\n            while(r<q[i].r)add(++r);\n            while(l<q[i].l)rm(l++);\n            while(q[i].r<r)rm(r--);\n \n            //qans[q[i].i]=cache;\n            ll len=r-l+1;\n            qans[q[i].i]=len*(len-1)/2-cache;\n        }\n        for(int i=0;i<qidx;i++){\n            printf(\"%lld\\n\",qans[i]);\n        }\n    }\n    return 0;\n}\n```\n\n## æ³¨æ„\n* å…³äºè®°å½•å½“å‰é—®é¢˜çš„åŒºé—´çš„å¼€é—­é—®é¢˜ï¼Œéœ€è¦è°¨æ…å®‰æ’ã€‚\n* åœ¨ç¡®è®¤äº†åŒºé—´å¼€é—­åï¼Œå…³äºæœ€åˆå§‹çš„çŠ¶æ€ï¼Œéœ€è¦è°¨æ…å®‰æ’ã€‚","tags":["è«é˜Ÿ"],"categories":["study"]},{"title":"Distribution of Books","url":"%2F2019%2F08%2F01%2Fproblem-distribution-of-books%2F","content":"zz6d likes reading very much, so he bought a lot of books. One day, zz6d brought n books to a classroom in school. The books of zz6d is so popular that K students in the classroom want to borrow his books to read. Every book of zz6d has a number i (1<=i<=n). Every student in the classroom wants to get a continuous number books. Every book has a pleasure value, which can be 0 or even negative (causing discomfort). Now zz6d needs to distribute these books to K students. The pleasure value of each student is defined as the sum of the pleasure values of all the books he obtains.Zz6d didn't want his classmates to be too happy, so he wanted to minimize the maximum pleasure of the K classmates. zz6d can hide some last numbered books and not distribute them,which means he can just split the first x books into k parts and ignore the rest books, every part is consecutive and no two parts intersect with each other.However,every classmate must get at least one book.Now he wonders how small can the maximum pleasure of the K classmates be.\n\n1<=T<=10\n\n1<=n<=2*105 \n\n1<=k<=n \n\n-109<=ai<=109\n\n# åˆ†æ\næœ€å¤§å€¼æœ€å°ï¼Œè€ƒè™‘äºŒåˆ†ç­”æ¡ˆã€‚æ€è€ƒé¢˜ç›®æ˜¯å¦å…·æœ‰å•è°ƒæ€§ï¼šå½“æœ€å¤§å€¼æå¤§æ—¶ï¼Œä¹¦å¯ä»¥éšä¾¿åˆ†ï¼Œå½“æœ€å¤§å€¼æå°æ—¶ï¼Œå¯èƒ½ä¼šå‡ºç°æ— æ³•å‡‘é½çš„çŠ¶å†µï¼Œç›®æµ‹æ»¡è¶³ã€‚\n\né¢˜ç›®è¦æ±‚åˆ†ä¹¦æ—¶å¿…é¡»è¿ç»­åˆ†ï¼Œå¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥åšã€‚å‡è®¾äºŒåˆ†çš„ç­”æ¡ˆä¸ºlim\n\n$$f(i)=\\max \\{ f(j) | \\sum_{k=j+1}^i a_k \\leq lim  \\}+1$$\n\nå°†æ±‚å’Œæ”¹ä¸ºå‰ç¼€å’Œï¼Œ$pre(i)$ã€‚\n\n$$f(i)=\\max \\{ f(j) | pre(i)-pre(j-1) \\leq lim  \\}+1$$\n\nåŠ¨æ€è§„åˆ’çš„å¤æ‚åº¦ä¸º$O(n^2)$ï¼Œå¤ªæ…¢ï¼Œè€ƒè™‘ä¼˜åŒ–ã€‚\n\næ¯æ¬¡è½¬ç§»éƒ½ä»å…ˆå‰å·²ç»å‡ºç°çš„æ»¡è¶³è¦æ±‚çš„fä¸­è½¬ç§»ã€‚é™åˆ¶æ¡ä»¶è½¬ä¸€ä¸‹ï¼Œå°±æ˜¯\n\n$$pre(i)-lim \\leq pre(?)$$\n\n* å½“æœ‰2ä¸ªfå¯¹åº”çš„å‰ç¼€å’Œç›¸åŒï¼Œæˆ‘ä»¬é€‰æ‹©æ›´å¤§çš„é‚£ä¸ª\n\næ‰€ä»¥å¯ä»¥ç›´æ¥ç»´æŠ¤å·²ç»å‡ºç°çš„æ¯ç§å‰ç¼€å’Œæ‰€å¯¹åº”çš„æœ€å¤§fã€‚å¯ä»¥ç¦»æ•£åŒ–åä½¿ç”¨æƒå€¼çº¿æ®µæ ‘ã€‚å¤æ‚åº¦å˜ä¸º$O(n\\lg n)$\n\næ€»å¤æ‚åº¦ä¸º$O(n\\lg n \\lg n)$ã€‚\n\n# ä»£ç \n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=900010;\n\nll dat[MAXN];\nint lc[MAXN],rc[MAXN];\nint idx=0;\nint build(int &n,int l,int r){\n    if(!n)n=++idx;\n    dat[n]=-0x3f3f3f3f;\n    if(l>=r)return dat[n];\n\n    int mid=(l+r)/2;\n    dat[n]=max(build(lc[n],l,mid),build(rc[n],mid+1,r));\n    return dat[n];\n}\nvoid collectchild(int node){\n    dat[node]=max(dat[lc[node]],dat[rc[node]]);\n}\n\nint query_n(int l,int r,int L,int R,int node){\n    if(l<=L && R<=r)return dat[node];\n    int mid=(L+R)/2;\n    int res=-0x3f3f3f3f;\n    if(l<=mid)res=max(res,query_n(l,r,L,mid,lc[node]));\n    if(mid<r)res=max(res,query_n(l,r,mid+1,R,rc[node]));\n    return res;\n}\n\nvoid modify(int l,int r,ll x,int L,int R,int node){\n    if(L>=R){\n        dat[node]=max(dat[node],x);\n        return;\n    }\n    int mid=(L+R)/2;\n    if(l<=mid)modify(l,r,x,L,mid,lc[node]);\n    if(mid<r)modify(l,r,x,mid+1,R,rc[node]);\n    collectchild(node);\n}\nll prefix[MAXN];\nll bprefix[MAXN];\nll num[MAXN];\n\nint nlen,sel;\nint rlen;\nint root;\nbool check(ll x){\n    build(root,0,rlen-1);\n\n    int zero=lower_bound(bprefix,bprefix+rlen,0)-bprefix;\n    modify(zero,zero,0,0,rlen-1,root);\n\n    for(int i=1;i<=nlen;i++){\n        int start=lower_bound(bprefix,bprefix+rlen,bprefix[prefix[i]]-x)-bprefix;\n        int dp=query_n(start,rlen-1,0,rlen-1,root)+1;\n        if(dp>=sel)return true;\n        modify(prefix[i],prefix[i],dp,0,rlen-1,root);\n    }\n    return false;\n}\n\n\nint main(){\n    //debug\n    /*\n    int opt;\n    build(root,0,10-1);\n    while(cin>>opt){\n        if(opt==1){\n            int pos,x;cin>>pos>>x;\n            modify(pos,pos,x,0,10-1,root);\n        }else{\n            int l,r;cin>>l>>r;\n            cout<<query_n(l,r,0,10-1,root)<<endl;\n        }\n    }\n    */\n\n    int kase;cin>>kase;\n    while(kase--){\n        cin>>nlen>>sel;\n        for(int i=1;i<=nlen;i++){\n            cin>>num[i];\n        }\n        bprefix[0]=prefix[0]=0;\n        for(int i=1;i<=nlen;i++)bprefix[i]=prefix[i]=prefix[i-1]+num[i];\n        //discrete\n        sort(bprefix,bprefix+nlen+1);\n        rlen=unique(bprefix,bprefix+nlen+1)-bprefix;\n        for(int i=0;i<=nlen;i++)prefix[i]=lower_bound(bprefix,bprefix+rlen,prefix[i])-bprefix;\n\n        \n\n\n        //binary\n        ll l=-1e15,r=1e15;\n        while(l+1<r){\n            ll mid=(l+r)/2;\n            if(check(mid)){\n                r=mid;\n            }else l=mid;\n        }\n        for(ll i=l;i<=r;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```\n\nå¤šç»„è¯¢é—®æ²¡æœ‰æ¸…ç†å¹²å‡€æ•°ç»„ï¼ŒWAäº†å¥½å‡ å‘ã€‚","tags":["ç¦»æ•£åŒ–"],"categories":["coding"]},{"title":"Fansblog","url":"%2F2019%2F08%2F01%2FFansblog%2F","content":"Farmer John keeps a website called â€˜FansBlogâ€™ .Everyday , there are many people visited this blog.One day, he find the visits has reached P , which is a prime number.He thinks it is a interesting fact.And he remembers that the visits had reached another prime number.He try to find out the largest prime number Q ( Q < P ) ,and get the answer of Q! Module P.But he is too busy to find out the answer. So he ask you for help. ( Q! is the product of all positive integers less than or equal to n: n! = n * (n-1) * (n-2) * (n-3) *â€¦ * 3 * 2 * 1 . For example, 4! = 4 * 3 * 2 * 1 = 24 )\n\n\nFirst line contains an number T(1<=T<=10) indicating the number of testcases.\nThen T line follows, each contains a positive prime number P (1e9â‰¤pâ‰¤1e14)\n\n<!--more-->\n\n\n# åˆ†æ\nè¿™é¢˜å¾—çŸ¥é“2ä¸ªç»“è®ºï¼Œç„¶è€Œæˆ‘éƒ½ä¸çŸ¥é“ã€‚\n\n## å¨å°”é€Šå®šç†\nå½“Pä¸ºè´¨æ•°æ—¶ï¼Œ$(P-1)! \\equiv -1 \\pmod P$.\n\næ³¨æ„è¿™é‡Œ$!$æ˜¯é˜¶ä¹˜ï¼Œä¸æ˜¯å–åçš„æ„æ€ã€‚\n\n## ç´ æ•°åˆ†å¸ƒ\nå½“èŒƒå›´å˜å¤§æ—¶ï¼Œç´ æ•°çš„å‡ºç°é¢‘ç‡å¢é«˜ï¼Œå¯»æ‰¾ä¸€ç´ æ•°çš„ç›¸é‚»ç´ æ•°å¤æ‚åº¦é€æ¸è¶‹è¿‘äºçº¿æ€§ã€‚\n\næ‰€ä»¥ï¼Œå¯»æ‰¾ç´ æ•°Pçš„å‰ä¸€ä¸ªç´ æ•°å¯ä»¥ç›´æ¥æš´åŠ›æ‰¾ã€‚æ‰¾åˆ°ä¹‹ååˆ©ç”¨$(P-1)! \\equiv -1 \\pmod P$å³å¯å¿«é€Ÿç”±$P-1$çš„é˜¶ä¹˜é€šè¿‡é€†å…ƒè½¬åˆ°$Q$çš„é˜¶ä¹˜ï¼Œè¿™é¢˜å°±åšå®Œäº†ã€‚\n\nå› ä¸ºåœ¨è®¡ç®—é€†å…ƒæ—¶ä¼šçˆ†llï¼Œä½¿ç”¨å¿«é€Ÿä¹˜æ³•æ¥é¿å…ï¼Œå¤æ‚åº¦ç¬¦åˆè¦æ±‚ã€‚\n\n# ä»£ç \n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\ninline ll qmul(ll x,ll y,ll q){\n    ll res=0;\n    for(;y;y>>=1,x=(x+x)%q){\n        if(y&1)res=(res+x)%q;\n    }\n    return res;\n}\n\n\ninline ll qpow(ll x,ll a,ll q){\n    ll res=1;\n    for(a;a;a>>=1,x=qmul(x,x,q)){\n        if(a&1)res=qmul(res,x,q);\n    }\n    return res;\n}\n\ninline ll get_rev(ll x,ll q){\n    return qpow(x,q-2,q);\n}\n\ninline bool is_prime(ll x){\n    for(ll i=2;i<=sqrt(x);i++){\n        if(x%i==0)return false;\n    }\n    return true;\n}\n\ninline ll factor(ll l,ll r,ll q){\n    ll res=1;\n    for(ll i=l;i<=r;i++)res=qmul(res,i,q);\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    while(kase--){\n        ll x;cin>>x;\n        ll prex=x-1;\n        while(!is_prime(prex))prex--;\n\n        ll ans=qmul(x-1,get_rev(factor(prex+1,x-1,x),x),x);\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n```","tags":["å¨å°”é€Šå®šç†"],"categories":["coding"]},{"title":"å’¸é±¼æ•°è®º","url":"%2F2019%2F07%2F22%2Fnumeric-water%2F","content":"\n## ä¸€äº›ç»“è®º\n* $N!$çš„è´¨å› æ•°åˆ†è§£ä¸­æŸè´¨æ•°çš„æŒ‡æ•°ä¸º$\\sum_{r=1}^{\\inf}n/p^r $\n* çº¦æ•°ä¸ªæ•°ä¸ºè´¨å› æ•°æŒ‡æ•°+1çš„ä¹˜ç§¯ï¼Œå’Œä¸ºè´¨å› æ•°æšä¸¾æŒ‡æ•°æ¬¡å’Œçš„ä¹˜ç§¯ã€‚\n* è´¹é©¬å°å®šç†è¦æ±‚pæ˜¯è´¨æ•°\n\n## æ¬§æ‹‰å‡½æ•°\nå°äºxä¸”ä¸å…¶äº’è´¨çš„æ•°çš„ä¸ªæ•°\n$$\n\\phi(x)=x\\prod_{k=1}^n(1-\\frac{1}{p_k})\n$$\n\n* $phi(1)=1$\n* $phi(p)=p-1$,å½“pä¸ºè´¨æ•°\n* $phi(2n)=phi(n)$\n* $phi(phi(phi...))))=1$\n\nå¯¹äºä»»æ„ç§¯æ€§å‡½æ•°$f(xy)=f(x)f(y)$ï¼Œå¯ä»¥ç­›ã€‚æ¬§æ‹‰å‡½æ•°éå®Œå…¨ç§¯æ€§å‡½æ•°ã€‚\n\n* $phi(xy)=phi(x)(y-1)$,å½“xä¸yäº’è´¨\n* $phi(xy)=phi(x)y$,å½“xä¸yä¸äº’è´¨\n\n```cpp\nfor(int i=2;i<=n;i++){\n    if(!no[i]){\n        p[++cnt]=i;\n        phi[i]=i-1;\n    }\n    for(int j=1;j<=cnt&&p[j]*i<=n;j++){\n        no[p[j]*i]=1;\n        if(i%p[j]==0){\n            phi[p[j]*i]=phi[i]*p[j];\n            break;\n        }\n        phi[p[j]*i]=phi[i]*(p[j]-1);\n    }\n}\n```\n\n## æ‰©å±•æ¬§å‡ é‡Œå¾—\n* å­˜åœ¨xï¼Œyä½¿å¾—ax+by=gcdï¼ˆaï¼Œbï¼‰\n* æ±‚é€†å…ƒï¼Œè¦æ±‚xä¸æ¨¡æ•°äº’è´¨\n\n```cpp\nvoid exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){\n        x=1,y=0;\n    }else{\n        exgcd(b,a%b,y,x);\n        y-=(a/b)*x;\n    }\n}\n```\n\n## é€’æ¨é€†å…ƒ\ninv(i) = inv(mod % i) * (mod-mod/i) % mod;\n\n* é˜¶ä¹˜çš„é€†å…ƒï¼šinv(i)=inv(i+1)*(i+1)\n","tags":["æ•°è®º"],"categories":["study"]},{"title":"æ°´çš„åˆé›† 1","url":"%2F2019%2F07%2F22%2Fwaterful-summary-1%2F","content":"\n\n## é›†åˆæŒ‘é€‰\nä»ç»™å®šçš„Nä¸ªé›†åˆä¸­å„æŒ‘å‡ºä¸€ä¸ªæ•°å¹¶æ±‚å’Œï¼Œæ±‚å‡ºå‰$K$å¤§çš„$K$ä¸ªå’Œã€‚\n\nè€ƒè™‘å¦‚ä½•ä»2ä¸ªé›†åˆ$A$,$B$ä¸­é€‰å‡ºå‰$K$å¤§ã€‚é™åºæ’åºå$a_1$å’Œ$b_1$æ˜¾ç„¶æ˜¯æœ€å¤§ï¼Œç¬¬äºŒå¤§åˆ™æ˜¯$(a_1,b_2)$æˆ–è€…$(a_2,b_1)$ã€‚ä¸å¦¨ä»¥$(a_1,b_2)$æ¥è®²ï¼Œé‚£ä¹ˆç¬¬ä¸‰å¤§ç«äº‰è€…é™¤$(a_2,b_1)$è¿˜æœ‰$(a_1,b_3)$ï¼Œ$(a_2,b_3)$â€¦â€¦æ¯å¯¹ç»„åˆéƒ½èƒ½æ‰¾åˆ°ç›´æ¥å°äºå®ƒçš„2ä¸ªç»„åˆï¼Œè€Œè¿™ç§åç»§å…³ç³»æ˜¾ç„¶å–éäº†æ‰€æœ‰ç»„åˆã€‚ä»…éœ€è¦å‰Kå¤§çš„æˆ‘ä»¬æŒ‰éœ€æ‰©å±•è¿™ä¸€æ£µæ ‘å³å¯ã€‚2ä¸ªé›†åˆçš„å‰Kå¤§å¯ä¸ç¬¬3ä¸ªé›†åˆæ‰§è¡Œç›¸åŒçš„æ“ä½œï¼Œä»è€Œå¾—åˆ°æœ€ç»ˆç­”æ¡ˆã€‚å®é™…ç¼–å†™æ—¶ï¼ŒæŒ‰ç…§ä¸€å®šé¡ºåºé™åˆ¶æ‰©å±•æ–¹å‘æ¥ä¿è¯æ¯ä¸ªæ–¹æ¡ˆä»…è®¿é—®ä¸€æ¬¡ï¼Œä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤ï¼Œå¤æ‚åº¦ä¸º$O(\\sum^N{K\\log n_k}) \\leq O(KN)$\n\n## LISä¼˜åŒ–\n$$f(i)=max\\{f(j)| j < i, a(j) < a(i) \\}+1$$\n\nå¯ä»¥å‘ç°ï¼Œä¸€æ—¦æœ‰$a(k) < a(j), f(k) \\geq f(j)$ï¼Œjè¿™ä¸ªä½ç½®å°±æ²¡æœ‰ç”¨äº†ã€‚æŒ‰ç…§è¯¥è§„å¾‹ç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆè®°å½•ï¼Œä»¥é•¿åº¦å•è°ƒï¼ˆåˆ™æ•°å­—aç»“å°¾çš„LISè‡ªç„¶å•è°ƒï¼‰ã€‚æ­¤åè½¬ç§»\n","categories":["study"]},{"title":"æ˜æ—¥æ–¹èˆŸå·¥å…·","url":"%2F2019%2F07%2F20%2Farknights-tools%2F","content":"\n{% asset_img img.jpg Penguin Logistics %}\n\nè™½ç„¶ç±»å‹å®Œå…¨ä¸ä¸€æ ·ï¼Œä½†æ˜æ—¥æ–¹èˆŸå¤§æ¦‚æ˜¯æˆ‘ç»§ç©çˆ†Minecraftä¹‹åå¦ä¸€ä¸ªå–œæ¬¢çš„æ¸¸æˆäº†ã€‚\n\n<!--more-->\n\ntaçš„è®¾å®šã€å‰§æƒ…ã€ç¾æœ¯ã€å¡”é˜²ç©æ³•éƒ½å¾ˆå¯¹æˆ‘å£å‘³ï¼Œåºå¤§çš„ä¸–ç•Œè§‚ä»¥åŠå¤æ‚çš„äººç‰©å…³ç³»ä¹Ÿå€¼å¾—ç§°èµã€‚è€Œä¸”æˆ‘è®¤ä¸ºè¿™ä¸ªæ¸¸æˆå¾ˆå‡ºä¼—çš„ä¸€ç‚¹æ˜¯taçš„æ•…äº‹ä¸ä»¥ç©å®¶ä¸ºä¸­å¿ƒï¼Œä¸€åˆ‡è‡ªæœ‰å…¶å‘å±•ã€‚\n\n## æ‰è½ç»Ÿè®¡\nå·²ç»æœ‰éå¸¸å®Œå–„çš„è½®å­äº†â€¦â€¦æ‰è½ç»Ÿè®¡æ”¹ä¸ºæ‰è½è¯†åˆ«ç»Ÿè®¡ï¼Œæ”¶å½’åˆ°è¾…åŠ©å·¥å…·å†…ã€‚\n\n## èµ„æºè§„åˆ’\nå·²ç»æœ‰éå¸¸å®Œå–„çš„è½®å­äº†â€¦â€¦\n\nåˆæ­¥è®¾æƒ³ä¸ºåŸºäºçº¿æ€§è§„åˆ’çš„å…³å¡è§„åˆ’å®‰æ’ã€‚æ­£åœ¨æ€è€ƒæ˜¯å¦æœ‰æ›´å¥½çš„æ–¹æ³•æˆ–è€…æ”¹è¿›ã€‚\n\n## è¾…åŠ©å·¥å…·\nè¿™ä¸ªè¾…åŠ©å·¥å…·ç»ä¸å¯ç ´åæ‰â€œæˆ‘è®¤ä¸ºâ€çš„æœ‰ä¹è¶£çš„éƒ¨åˆ†ï¼Œå®ƒçš„å¼€å‘ä¹Ÿä¼šä¸€ç›´åšæŒè¿™ä¸ªæƒ³æ³•ã€‚\n\nç‹¬æ–­è€Œå¸¦æœ‰åè§çš„æ€è€ƒåï¼Œå®ƒçš„åŠŸèƒ½ç›®å‰è§„åˆ’ä¸ºï¼š\n\n1. å•ä¸€å…³å¡çš„é‡å¤æ€§æˆ˜æ–—ä»£ç†\n2. æ‰è½ç‰©å“è‡ªåŠ¨ç»Ÿè®¡ä¸ä¸Šä¼ \n\n### ç‰©å“è¯†åˆ«\nå·¥å…·ç›®å‰å¯ä»¥åœ¨å…³å¡ç»“æŸæ—¶è‡ªåŠ¨è¯†åˆ«å±å†…çš„æ‰è½ç‰©å“å’Œæ‰è½æ•°é‡ï¼Œä½†ä¸ç¨³å®šã€‚\n\næ‰è½æ£€æµ‹ä»ç°åº¦åŒ¹é…æ”¹ä¸ºåŸºäºç‰¹å¾ç‚¹çš„åŒ¹é…ã€‚é¦–å…ˆèƒ½å¤Ÿè‡ªåŠ¨å°†æ‰è½ç‰©å“å›¾ç‰‡è¿›è¡Œçªå‡ºç‰¹å¾çš„å¤„ç†åæ‹†åˆ†ç”Ÿæˆç‰©å“ç‰¹å¾å›¾ï¼Œå¹¶ä½¿ç”¨SIFTä»ç‰¹å¾å›¾ä¸­å–å‡ºä¸å—å›¾åƒç¼©æ”¾ä¸è‰²å·®å½±å“çš„ç‰¹å¾ç‚¹ã€‚\n\næ­¤åå†æ¬¡ä½¿ç”¨æ—¶ï¼Œä¸é¢„è®¾ç‰¹å¾ç‚¹æ¯”è¾ƒä»è€Œæ‰¾åˆ°å¯¹åº”çš„æ‰è½ç‰©å“ç¼–ç ï¼Œä»æ•°æ®åº“ä¸­æå–å‡ºåç§°ã€‚\n\næ‰è½æ•°é‡æ˜¯å¯¹åˆ‡åˆ†å‡ºæ¥çš„æ•°å­—å›¾ç‰‡è°ƒç”¨`tesseract`è¿›è¡ŒOCRè¯†åˆ«ï¼Œç„¶è€Œè¿™ä¸ªå‡†ç¡®ç‡å®åœ¨å ªå¿§ã€‚å¯¹å›¾ç‰‡çš„é¢„å¤„ç†ä¼¼ä¹æ•ˆæœå¹¶ä¸æ€ä¹ˆå¥½ï¼Œä¹‹åï¼ˆä¹Ÿè®¸ï¼‰ä¼šæƒ³åŠæ³•å†æ”¹æ”¹ã€‚\n\nç‰©å“æ‰è½çš„ç»Ÿè®¡ä¿¡æ¯æœªæ¥ä¹Ÿè®¸èƒ½å¤Ÿå®ç°å‘å·²æœ‰çš„æ•°æ®åº“å¯¹æ¥ã€‚\n\n## å…³å¡å‹åŠ›åˆ†æ\nè¿›æ”»é‡æ”¾ä¸é˜²å®ˆå‹åŠ›çš„åˆ†æå·¥å…·ã€‚\n\n## ï¼Ÿ\néå¸¸è¿œæœŸçš„ç›®æ ‡ï¼š\n\n* ç ”ç©¶èƒ½å¤Ÿç ”ç©¶å…³å¡è¿‡æ³•çš„ç®—æ³•å¤§æ¦‚ç‡æœ‰ä¹è¶£","tags":["å°å·¥å…·"],"categories":["projects"]},{"title":"[BUPT WARMUP|CF] çç å¥¶èŒ¶","url":"%2F2019%2F07%2F20%2Fproblem-bupt-milk-tea%2F","content":"\n\nç»™å‡ºä¸€ä¸ª$N \\times N$çš„éè´Ÿæ•´æ•°çŸ©é˜µï¼Œè¦æ±‚æ‰¾åˆ°ä¸€æ¡ä»å·¦ä¸Šè§’æ•°å­—åˆ°å³ä¸‹è§’æ•°å­—çš„è·¯çº¿ï¼Œä¸”\n\n* åªèƒ½å‘å³æˆ–è€…ä¸‹èµ°ã€‚\n* å°†ç»è¿‡æ•°å­—ç›¸ä¹˜åå¾—åˆ°çš„ç»“æœï¼Œä½¿å…¶æœ«å°¾çš„â€œ0â€æœ€å°‘ã€‚\n\n$$\nN \\leq 1000\n$$\n\n<!--more-->\n\n## åˆ†æ\nå¤§æ¦‚æ˜¯å› ä¸ºæœ«å°¾çš„0é•¿å¾—åƒçç ã€‚\n\næ€è€ƒ0æ˜¯æ€ä¹ˆå‡ºç°çš„ï¼Œå¯ä»¥å‘ç°ç»“æœä¸­å› æ•°10çš„æŒ‡æ•°è¶Šå°è¶Šå¥½ï¼Œå³ï¼Œä½¿å¾—ç»è¿‡çš„è·¯ä¸Šå‡‘å‡ºçš„å› æ•°10æœ€å°‘å³å¯ã€‚10çš„è´¨å› æ•°åˆ†è§£ä¸º$2 \\times 5$ï¼Œä»¥çŸ©é˜µä¸­æ¯ä¸ªæ•°æ‰€å«å› æ•°2å’Œ5çš„æ•°ç›®åˆ†åˆ«DPä¸€éæ±‚è·¯å¾„ï¼Œå†åœ¨ä¸¤æ¬¡DPçš„ç»“æœä¸­å–å°ã€‚\n\nä¸€ä¸ªç‰¹æ®Šæƒ…å†µæ˜¯æ•°å­—é‡Œæœ‰0ï¼Œé‚£ä¹ˆç»è¿‡0çš„è·¯çš„æœ«å°¾0ä¸€å®šæ˜¯1ä¸ªâ€¦â€¦ä¸€å¼€å§‹è„‘è¢‹æŠ½äº†ä»¥ä¸ºæ˜¯0ä¸ªã€‚å¦‚æœå…¶ä»–æƒ…å†µçš„è·¯å¾„æœ«å°¾0éƒ½å¤šäº1ä¸ªçš„è¯ï¼Œå°±ç‰¹åˆ¤èµ°0ã€‚\n\n## ä»£ç  \n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconstexpr int MAXN=1010;\n\nint game[MAXN][MAXN];\nint num[2][MAXN][MAXN];\nint cal(int x,int fac){\n    if(x==0)return 0;\n    int res=0;\n    while(x%fac==0){\n        x/=fac;\n        res++;\n    }\n    return res;\n}\nint n;\nint dp[MAXN][MAXN];\nint from[MAXN][MAXN];\nvoid dodp(int fac){\n    for(int i=0;i<MAXN;i++){\n        for(int j=0;j<MAXN;j++){\n            dp[i][j]=0x3f3f3f3f;\n        }\n    }\n    dp[0][1]=dp[1][0]=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(dp[i-1][j]<dp[i][j-1]){\n                from[i][j]=2;\n                dp[i][j]=dp[i-1][j];\n            }else{\n                from[i][j]=1;\n                dp[i][j]=dp[i][j-1];\n            }\n            dp[i][j]+=num[fac][i][j];\n        }\n    }\n}\nstring genpath(){\n    string res=\"\";\n    int i=n,j=n;\n    for(int p=from[i][j];i!=1 || j!=1 ;p=from[i][j]){\n        if(p==2){\n            res+=\"D\";\n            i--;\n        }else{\n            res+=\"R\";\n            j--;\n        }\n    }\n    reverse(res.begin(),res.end());\n    return res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin>>n;\n    bool haszero=false;\n    int zeroi,zeroj;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cin>>game[i][j];\n            if(game[i][j]==0){\n                haszero=1;\n                zeroi=i,zeroj=j;\n            }\n        }\n    }\n    \n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            num[0][i][j]=cal(game[i][j],2);\n            num[1][i][j]=cal(game[i][j],5);\n        }\n    }\n    int ans=0x7f7f7f7f;\n    dodp(0);\n    string P;\n    if(ans>dp[n][n]){\n        ans=dp[n][n];\n        P=genpath();\n    }\n    dodp(1);\n    if(ans>dp[n][n]){\n        ans=dp[n][n];\n        P=genpath();\n    }\n\n    if(haszero && ans>1){\n        cout<<1<<endl;\n        for(int i=1;i<zeroi;i++)cout<<\"D\";\n        for(int j=1;j<zeroj;j++)cout<<\"R\";\n        for(int i=zeroi+1;i<=n;i++)cout<<\"D\";\n        for(int j=zeroj+1;j<=n;j++)cout<<\"R\";\n        cout<<endl;\n        return 0;\n    }\n\n    cout<<ans<<endl;\n    cout<<P<<endl;\n\n    return 0;\n}\n```\n","tags":["æ•°è®º"],"categories":["coding"]},{"title":"blogè¿ç§»","url":"%2F2019%2F07%2F13%2Fblog-upgrade%2F","content":"\n{% asset_img girl.jpg %}\n\nåˆå›åˆ°äº†é™æ€blogğŸ˜€.æœç„¶è¿™æ ·æ‰æ˜¯æœ€å¼çš„.\n\n## é™æ€blogç¼–è¯‘å™¨\nç°åœ¨æµè¡Œçš„é™æ€blogç¼–è¯‘å™¨å¤§æ¦‚æœ‰è¿™ä¹ˆå‡ ç§\n\n* `Node.js`çš„`Hexo`\n* `Python`çš„`Pelican`\n* `Ruby`çš„`Jekyll`\n* `Golang`çš„`Hugo`\n\n<!--more-->\n\n## ä½¿ç”¨Github pages\nGithubä¸ºç”¨æˆ·å‡†å¤‡äº†å…è´¹çš„pagesæœåŠ¡,èƒ½å¤Ÿå±•ç¤ºé™æ€é¡µé¢,æ»¡è¶³æˆ‘ä»¬çš„è¦æ±‚.\n\nä¸ºäº†ä½¿ç”¨Github pages,éœ€è¦æ–°å»ºé¡¹ç›®`<username>.github.io`,å°†æ–‡ä»¶pushä¸Šå»å,è®¿é—®ç›¸åº”çš„åŸŸå`https://<username>.github.io`å°±èƒ½çœ‹åˆ°.\n\nä½¿ç”¨githubæä¾›çš„åŸŸåä¹Ÿå¯ä»¥,ä¸€èˆ¬æ¥è¯´ä¸ºäº†~~è£…é€¼~~è¾¾åˆ°æ›´å¥½çš„å±•ç¤ºæ•ˆæœ,ä¼šå°†pageså†å’Œè‡ªå·±çš„åŸŸåç»‘å®š.\n\n### åŸŸåè§£æè¿‡ç¨‹\nå½“è®¿é—®ä¸€ä¸ªç½‘ç«™æ—¶,ç»è¿‡äº†è¿™ä¹ˆå‡ ä¸ªè¿‡ç¨‹.\n\n1. ç”¨æˆ·è®¿é—®åŸŸå`DOMAIN`\n2. ç³»ç»Ÿå‘DNSæœåŠ¡å™¨è¯¢é—®`DOMAIN`æ‰€å¯¹åº”çš„IP(æˆ–è€…å…¶ä»–åŸŸå)åœ°å€.\n3. æµè§ˆå™¨å‘è¯¥IPåœ°å€å‘é€è¯·æ±‚.\n4. æµè§ˆå™¨å°†è¯¥IPè¿”å›çš„æ•°æ®æ¸²æŸ“ä¸ºç½‘é¡µ.\n\nå› æ­¤ä¸ºäº†è®©è‡ªå·±çš„åŸŸåæŒ‡å‘pagesæœåŠ¡,éœ€è¦è¿™ä¹ˆå‡ æ­¥.\n\n#### åœ¨DNSæœåŠ¡å™¨é…ç½®è®°å½•\nå¯¹DNSæœåŠ¡å™¨è¯´æ˜åŸŸåæ‰€æŒ‡å‘çš„åœ°å€.åœ¨æ­¤,æˆ‘ä»¬å°†åŸŸåæŒ‡å‘pagesçš„åŸŸå`<username>.github.io`.è¯¥ç±»è®°å½•çš„ç±»å‹ä¸º`CNAME`,æŒ‰ç…§é¡µé¢ç›¸å…³æç¤ºå¡«å†™å³å¯.\n\n#### åœ¨Githubé…ç½®æ¥æ”¶æ¥æº\nä¹‹å,è¦å‘Šè¯‰githubå½“å…¶æ¥æ”¶åˆ°æ ‡æ³¨è‡ªæˆ‘ä»¬çš„åŸŸåçš„è¯·æ±‚æ—¶,è¦åšå‡ºå¯¹åº”çš„ç›¸åº”.\n\nåœ¨é¡¹ç›®ä¸­æ·»åŠ æ–‡ä»¶`CNAME`,å†…å†™ä¸€è¡Œ,ä¸ºæˆ‘ä»¬çš„åŸŸå.\n\n## å¯ç”¨SSL\nå¯ç”¨SSLæ²»ç–—å„ç§åŠ«æŒ.\n\nå› ä¸ºpagesä¸åŸç”Ÿæ”¯æŒSSL,å¯ä»¥ä½¿ç”¨cloudflareçš„æœåŠ¡æ¥å¯ç”¨SSL.\n\næ³¨å†Œcloudflareå,æŒ‰ç…§æŒ‡ç¤º,å°†åŸŸåçš„è§£ææœåŠ¡å™¨æ”¹ä¸ºcloudflare,ä¸€æ®µæ—¶é—´åè§£æç”Ÿæ•ˆå³å¯å¼€å¯SSL.\n\nä½ è¿˜å¯ä»¥åŠ ä¸€æ¡Rule,å¼ºåˆ¶æŠŠHTTPè½¬åˆ°HTTPS,æ²»ç–—ä¸€ä¸‹å‰¥ç¦»æ”»å‡»."},{"title":"Colorful Tree","url":"%2F2019%2F07%2F12%2Fcolorful-tree%2F","content":"\n\nThere is a tree having n nodes, the i-th node of which has a type of color, denoted by an integer $c_i$\n\nThe path between every two nodes is unique, of which we define the value is the number of distinct types of colors appearing on it.\n\nCalculate the sum of values of all possible paths, $\\frac{n(n-1)}{2}$ in total, between two different nodes on the tree.\n\n## è¾“å…¥èŒƒå›´\nå¤šç»„æ•°æ®,çº¦50;èŠ‚ç‚¹æ•°$2 \\times 10^5$.\n\n# åˆ†æ\næ²¡æƒ³å‡ºæ¥è¯¥æ€ä¹ˆåš.ç»Ÿè®¡è·¯å¾„é¢œè‰²çš„ç­”æ¡ˆæ²¡æœ‰ä»€ä¹ˆåˆå¹¶çš„å¥½æ–¹æ³•,åŒæ—¶ä¹Ÿä¸èƒ½æŒ‰ç…§æ¯ç§é¢œè‰²å•ç‹¬è€ƒè™‘.\n\nåæ¥ç»è¿‡dalaoç‚¹æ‹¨,è¯¥é¢˜ä¸­çš„\"ç»Ÿè®¡ä¸€æ¡è·¯å¾„ä¸Šé¢œè‰²ç§ç±»\"çš„è¦æ±‚å¯ä»¥è½¬åŒ–ä¸ºæ±‚å…¶**åé¢**\"æ²¡æœ‰æŸç§é¢œè‰²çš„è·¯å¾„æœ‰å¤šå°‘ç§\".\n\nå¦‚æ­¤,å¯¹äºæ¯ä¸€ç§é¢œè‰²å°±å¯ä»¥ä½¿ç”¨$n(n-1)/2-size$æ¥æ±‚å…¶å¯¹ç­”æ¡ˆçš„è´¡çŒ®äº†.So,æ¥è§£å†³è¿™ä¸ªé—®é¢˜.\n\nåŸå›¾æ˜¯ä¸€æ£µæ ‘,å¦‚æœæŸç‚¹$N$ä¸ºé¢œè‰²$c$,é‚£ä¹ˆç»è¿‡$N$çš„å­æ ‘ä»»æ„ç‚¹è·¨è¶Š$N$çš„è·¯å¾„éƒ½æœ‰è¯¥é¢œè‰².æ‰€æœ‰ä¸åŒ…æ‹¬è¯¥é¢œè‰²$c$çš„è·¯å¾„åª**èƒ½**å‡ºç°åœ¨ä»¥$N$ä¸ºåˆ‡ç‚¹çš„å…¶ä»–2éƒ¨åˆ†.è€ƒè™‘å…¶ä¸­ä¸€ä¸ªéƒ¨åˆ†,ä»»æ„é€‰ä¸­å…¶ä¸­2ä¸ªèŠ‚ç‚¹å³å¯æ„å»ºä¸€æ¡è·¯å¾„,ä½†è¿˜æ˜¯å¿…é¡»æ»¡è¶³åˆšåˆšçš„æ¡ä»¶(ä¸èƒ½è·¨è¶Šé¢œè‰²$c$çš„èŠ‚ç‚¹).ä»¥dfsé€’å½’è¿›å»å³å¯.\n\nè€ƒè™‘èƒ½å¦é€’å½’åˆå¹¶å·²æœ‰ç­”æ¡ˆ.èƒ½å¤Ÿå¾—åˆ°çš„æ•°æ®æœ‰*å­èŠ‚ç‚¹ä¸­2éƒ¨åˆ†çš„èŠ‚ç‚¹æ•°ç›®*,æ˜¾ç„¶èƒ½å¤Ÿåˆå¹¶å‡ºä»¥å½“å‰èŠ‚ç‚¹ä¸ºç•Œåˆ’åˆ†çš„2éƒ¨åˆ†ä¸­çš„ä¸€éƒ¨åˆ†,è‡ªç„¶å¯ä»¥åœ¨é€’å½’è¿”å›åæ¨å‡ºå¦ä¸€éƒ¨åˆ†.\n\n# ä»£ç \n```cpp\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXV=200010;\nvector<int> g[MAXV];\ninline void adde(int u,int v){\n    g[u].push_back(v);\n}\nint color[MAXV];\nll sz[MAXV];\nll gsz;\nll res=0;\nvoid dfs(int u,int fa){\n    gsz++;\n    for(auto v:g[u]){\n        if(v==fa)continue;\n        ll b_gsz=gsz;\n        ll b_sz=sz[color[u]];\n        dfs(v,u);\n\n        ll d=(gsz-b_gsz)-(sz[color[u]]-b_sz);\n        res+=d*(d-1)/2;\n        sz[color[u]]+=d;\n    }\n    sz[color[u]]++;\n}\nint flag[MAXV];\nint main(){\n    ios::sync_with_stdio(false);\n    int n;\n    int kase=0;\n    while(cin>>n){\n        for(int i=1;i<=n;i++)g[i].clear();\n        memset(sz,0,sizeof(sz));\n        gsz=0;\n        res=0;\n\n        vector<int> discol;\n        for(int i=1;i<=n;i++){\n            cin>>color[i];\n            flag[color[i]]=1;\n        }\n        for(int i=1;i<=n;i++){\n            if(flag[i])discol.push_back(i);\n        }\n        for(int i=0;i<n-1;i++){\n            int u,v;cin>>u>>v;\n            adde(u,v);\n            adde(v,u);\n        }\n\n        int disnum=discol.size();\n        dfs(1,0);\n        ll ans=(ll)disnum*n*(n-1)/2;\n        for(auto i:discol){\n            ll t=n-sz[i];\n            ans-=t*(t-1)/2;\n        }\n        cout<<\"Case #\"<<++kase<<\": \"<<ans-res<<endl;\n    }\n\n    return 0;\n}\n```","categories":["coding"]},{"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","url":"%2F2019%2F07%2F12%2Ffft%2F","content":"\n> å†™ä»£ç æ˜¯ä¸å¯èƒ½å†™ä»£ç çš„,ä»Šä¸‹åˆæ˜¯ä¸æƒ³å†™ä»£ç çš„.ä¸æƒ³å†™ä»£ç ,åˆä¸æƒ³å’¸é±¼,å°±åªèƒ½é å­¦ç‚¹æ–°ä¸œè¥¿æ¥å‡è£…è‡ªå·±åœ¨å·¥ä½œçš„æ ·å­,å¿ƒé‡Œæ‰èƒ½å¥½å—äº›.\n>\n> > çªƒæ ¼ç æ‹‰\n\næŠŠ2å¹´å‰å°±å¬è¿‡ä½†æ˜¯æ²¡å­¦çš„FFTè¿™æ¬¡çœ‹çœ‹å§.\n\nå‡ ä¹å¯ä»¥è‚¯å®š,ä¸‹é¢çš„å†…å®¹è‚¯å®šä¼šå‡ºé”….\n\n<!--more-->\n\n## å‚…é‡Œå¶å˜æ¢çš„å®é™…æ„ä¹‰\n### ä»ç”µå‹è¯´èµ·\nè¢«æ¨¡ç”µæŠ˜ç£¨çš„åŒå­¦éƒ½çŸ¥é“,æœ‰ç§ä¸œè¥¿å«åšå‚…é‡Œå¶çº§æ•°,å¯ä»¥å°†æˆå‘¨æœŸæ€§å˜åŒ–çš„ç”µå‹åˆ†è§£ä¸ºæ•°ä¸ªä¸‰è§’å‡½æ•°æ³¢çš„å åŠ .\n\nåœ¨è¿™é‡Œ,æˆ‘ä»¬æå‡ºå¦ä¸€ä¸ªé—®é¢˜,å¦‚æœä¸çŸ¥é“å‘¨æœŸ,è¯¥å¦‚ä½•å°†è¿™äº›å åŠ åœ¨ä¸€èµ·çš„ä¿¡å·æ‹†åˆ†ä¸ºå•çº¯çš„ä¸‰è§’æ³¢?\n\n> ä¸‰è§’æ³¢å åŠ å›¾è±¡å‘¨æœŸå¹¶ä¸é‚£ä¹ˆæ˜¾ç„¶,ä¹Ÿè®¸ä½ å¯ä»¥è¯•ä¸€è¯•.\n\n### ä¸€ç§ç¼ ç»•æœº\næœ‰ä¸€ç§å¥‡ç‰¹çš„æ–¹æ³•,æˆ‘ä»¬å°†ä¸€æ®µ`æ—¶åŸŸå›¾è±¡`åœ¨ç¬›å¡å°”åæ ‡ç³»ä¸Šä»¥åŸç‚¹ä¸ºåœ†å¿ƒ**ç»•**èµ·æ¥,ä¸€åœˆä¸€åœˆç¼ èµ·æ¥,ç„¶åè°ƒæ•´æºå›¾è±¡ç¼ ç»•çš„é€Ÿç‡(å‡ ç§’ä¸€åœˆ),è§‚å¯Ÿæ•´ä¸ªå›¾å½¢çš„**è´¨å¿ƒ**å˜åŒ–.\n\nè¿™ä¸ªè´¨å¿ƒä¼šéšç€å›¾è±¡ç¼ ç»•çš„é¢‘ç‡è€Œå‘ç”Ÿä½ç§».å–è´¨å¿ƒçš„xåæ ‡ä¸ºyè½´,ä»¥ç¼ ç»•çš„é¢‘ç‡ä¸ºæ¨ªè½´,ä½œå‡ºå›¾è±¡`B`.åœ¨è¿™ä¸ªå›¾è±¡ä¸Š,ä¼šè§‚æµ‹åˆ°ä¸€ä¸ªç°è±¡:(å‡è®¾æˆ‘ä»¬å·²çŸ¥åŸå›¾åƒçš„åˆ†è§£ä¸‰è§’æ³¢é¢‘ç‡)å½“ç¼ ç»•é¢‘ç‡æ¥è¿‘æŸä¸ªæºä¸‰è§’æ³¢çš„é¢‘ç‡æ—¶,ç¼ ç»•å›¾è±¡å‡ºç°**é‡åˆ**,è´¨å¿ƒç›¸å¯¹åŸç‚¹å‡ºç°è¾ƒå¤§ä½ç§»,å›¾è±¡å‡ºç°ä¸€ä¸ª**å³°å€¼**.\n\nç»§ç»­è°ƒæ•´ç¼ ç»•é¢‘ç‡,å³°å€¼æ¶ˆå¤±,å›¾è±¡å›å½’åˆ°å°èŒƒå›´æ³¢åŠ¨.\n\né€šè¿‡è§‚å¯Ÿå›¾è±¡`B`,å¯ä»¥è®¤ä¸º,å‡ºç°å³°å€¼çš„é¢‘ç‡å¯¹åº”ç€ä¸€ä¸ªé¢‘ç‡çš„æºä¸‰è§’æ³¢.å¦‚æ­¤,å°±å°†å åŠ å›¾è±¡è¿˜åŸäº†å›å».\n\n## å‚…é‡Œå¶å˜æ¢çš„æ•°å­¦å®ç°\nç°åœ¨,è€ƒè™‘å¦‚ä½•é€šè¿‡çš„æ•°å­¦çš„æ–¹æ³•æ¥å®ç°è¿™ä¸ªç¼ ç»•.\n\n### å¦‚ä½•ç¼ ç»•\nå°†$g(t)$çš„å›¾è±¡ç¼ ç»•åˆ°åœ†ä¸Šå¬èµ·æ¥æŒºå¥‡æ€ªçš„,æœ‰è¿™æ ·çš„æ•°å­¦æ–¹æ³•å—.\n\næœ‰ä¸€ä¸ªä¸œè¥¿,å«åš$y=e^{ix}$.å½“å…¶å›¾è±¡ç”»åœ¨å¤å¹³é¢æ—¶,å°±å‡ºç°äº†æœ‰è¶£çš„äº‹æƒ…:ä¸€ä¸ªåœ†.å¯¹è¿™ä¸ªå…¬å¼åšä¸€äº›åŠ å·¥.\n\n$$\ny=g(t)e^{-2\\pi i ft}\n$$\n\nå¦‚æ­¤,å°±èƒ½å¤Ÿå°†$g(t)$ä»¥$f$é¢‘ç‡ç¼ ç»•.\n\n### å…³äºè´¨å¿ƒ\nä¸Šæ–‡æˆ‘ä»¬å–è´¨å¿ƒçš„xåæ ‡ä½œå›¾,ç°åœ¨éœ€è¦ç¨å¾®ä¿®æ”¹ä¸€ä¸‹.\n\nå®é™…ä¸Š,æˆ‘ä»¬å…³å¿ƒçš„æ˜¯è´¨å¿ƒç›¸å¯¹äºåŸç‚¹çš„åç§»**è·ç¦»**.åŒæ ·,ä»¥å¤å¹³é¢çš„æ–¹å¼æ¥è¡¨ç¤ºè´¨å¿ƒä½ç½®å°±èƒ½å¤ŸåŒæ—¶ä¿ç•™xå’Œyåæ ‡ä¿¡æ¯.\n\nå…³äºå¦‚ä½•æ±‚å–è´¨å¿ƒ,å…¶å®ä¹Ÿå¾ˆç›´è§‚.é€‰å–ç¼ ç»•å›¾è±¡ä¸Šçš„æ•°ä¸ªç‚¹,å–å¹³å‡,å°±æ˜¯è´¨å¿ƒçš„å¤§çº¦ä½ç½®.å½“ç‚¹çš„æ•°ç›®è¾¾åˆ°æé™,æ±‚å’Œå…¬å¼åŒ–ä¸ºç§¯åˆ†,æ‰€æ±‚å³ä¸ºè´¨å¿ƒ.\n\n$$\n\\hat g(f)=\\frac{1}{t_2-t_1} \\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}}\n$$\n\n### ?\nç›®å‰ä¸ºæ­¢,è¿™å‡ ä¹å·²ç»æ˜¯å‚…é‡Œå¶å˜æ¢äº†.åœ¨æ•°å­¦åº”ç”¨æ—¶,å‚…é‡Œå¶å˜æ¢ä¼šå»æ‰å–å‡å€¼,å³\n\n$$\n\\hat g(f)=\\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}}\n$$\n\nä¹Ÿå°±æ˜¯è¯´,å–æ ·çš„æ—¶åŸŸä¿¡å·è¶Šé•¿,è¯¥è´¨å¿ƒçš„åç§»å€¾å‘è¶Šå¤§,è¿™å’Œæˆ‘ä»¬æƒ³è¦çš„æ•ˆæœä¸€è‡´.\n\nè¿™å°±æ˜¯å‚…é‡Œå¶å˜æ¢,å®ç°äº†`æ—¶åŸŸä¿¡å·`åˆ°`é¢‘åŸŸä¿¡å·`çš„è½¬æ¢.\n\næ­¤å¤–,è¿˜æœ‰æ–¹æ³•å°†é¢‘åŸŸä¿¡å·å†æ¬¡é€†å˜æ¢ä¸ºæ—¶åŸŸä¿¡å·çš„æ–¹æ³•.\n\n## åº”ç”¨\nå‚…é‡Œå¶å˜æ¢åœ¨å¾ˆå¤šé¢†åŸŸéƒ½æœ‰é‡è¦ä½œç”¨.åªè¦é—®é¢˜èƒ½è½¬æ¢ä¸ºæ—¶åŸŸé¢‘åŸŸä¹‹é—´çš„å˜åŒ–,å°±æœ‰å‚…é‡Œå¶å˜æ¢çš„ç”¨æ­¦ä¹‹å¤„.\n\næ¯”å¦‚,åœ¨éŸ³é¢‘å¤„ç†è½¯ä»¶ä¸­,å¸¸å¸¸æœ‰ä¸€ä¸ªåŠŸèƒ½å«åš`æ¶ˆé™¤äººå£°`.åŸºäºå‚…é‡Œå¶å˜æ¢æˆ‘ä»¬å¯ä»¥è®¾è®¡ä¸€ä¸ª(è‡³å°‘ç†è®ºä¸Šæœ‰ç”¨)çš„ç®—æ³•.\n\né¦–å…ˆ,ä»»ä½•å£°éŸ³éƒ½æ˜¯ç›¸åº”é¢‘ç‡çš„æ³¢å¯¹æ°”å‹å˜åŒ–å¼•èµ·çš„,ä¹Ÿå°±æ˜¯ä¸åŒ**é¢‘ç‡**çš„æ³¢åœ¨**æ—¶é—´**ä¸Šå åŠ åœ¨ä¸€èµ·,äº§ç”Ÿäº†å£°éŸ³.å°†æºæ³¢ä½¿ç”¨å‚…é‡Œå¶å˜æ¢æ‹†åˆ†åˆ°å¤šä¸ªä¸‰è§’æ³¢ä¸Šå».**åˆ é™¤äººå£°æ‰€åœ¨çš„é¢‘åŸŸ**,å†å°†é¢‘åŸŸä¿¡å·é€†å˜æ¢ä¸ºæ—¶åŸŸä¿¡å·.äººå£°ä¾¿æ¶ˆå¤±äº†.\n\n## ç¦»æ•£å‚…é‡Œå¶å˜æ¢\nè¿ç»­æ„ä¹‰ä¸‹çš„å‚…é‡Œå¶å˜æ¢å…ˆåˆ°æ­¤ä¸ºæ­¢.åœ¨è®¡ç®—æœºä¸­æ‰€å¤„ç†çš„æ•°æ®ä¸€èˆ¬éƒ½æ˜¯ç¦»æ•£çš„.æˆ‘ä»¬éœ€è¦çš„æ˜¯ç¦»æ•£å‚…é‡Œå¶å˜æ¢.\n\nç¦»æ•£æ„ä¹‰ä¸‹çš„æ—¶åŸŸä¿¡å·å’Œé¢‘åŸŸä¿¡å·å°±éƒ½å˜æˆäº†ç‚¹é›†.å½“ä»è¿ç»­å‘ç¦»æ•£è¿‡æ¸¡æ—¶,å¯ä»¥è¿™æ ·æ€è€ƒ:\n\n> åœ¨è¿ç»­çš„å›¾è±¡ä¸Šä»¥ä¸€å®šé—´éš”**å–æ ·**å¾—åˆ°ç¦»æ•£ç‚¹é›†.ä½¿ç”¨è¯¥ç‚¹é›†è¿›è¡Œå‚…é‡Œå¶å˜æ¢.\n\nè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ä¸€å¼€å§‹é‡‡å–çš„è´¨å¿ƒæ±‚è§£æ–¹æ³•,åªä¸è¿‡,è¿™æ¬¡æˆ‘ä»¬ä»ç¼ ç»•æ—¶å°±å–æ ·.(è´¨ç‚¹ä¾ç„¶æ˜¯çœŸæ­£çš„è´¨ç‚¹)\nå¯¹äºç‚¹é›†$g(0\\leq n < N)$,å®ƒçš„å‚…é‡Œå¶å˜åŒ–å°±æ˜¯\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\nç®€å•ç²—æš´.\n\n## å¿«é€Ÿå‚…é‡Œå¶å˜æ¢\nåœ¨äº†è§£äº†å…³äºå‚…é‡Œå¶å˜æ¢çš„ä¸€ç³»åˆ—èƒŒæ™¯ä¸ä¸€ä¸ªåº”ç”¨å,æˆ‘ä»¬å†å›æ¥è§£å†³ä¸€äº›é‡è¦çš„é—®é¢˜.\n\næ ¹æ®å‚…é‡Œå¶å˜æ¢çš„å…¬å¼å®šä¹‰\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\nå…¶æœ´ç´ ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(N^2)$ è¿™ä¸ªå¤æ‚åº¦è¿˜ä¸å¤Ÿä¼˜ç§€.ä¸€ç§å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ç®—æ³•åˆ©ç”¨$e^{ix}$çš„æ€§è´¨,å°†å¤æ‚åº¦é™ä½åˆ°äº†$O(N\\lg N)$.\n\n### å•ä½æ ¹\nç»™$e^{ix}$ä¸ªåå­—.\n\nåœ¨æ•°å­¦ä¸Š, $n$æ¬¡**å•ä½æ ¹**æ˜¯ $n$æ¬¡å¹‚ä¸º1çš„å¤æ•°.å®ƒä»¬ä½äºå¤å¹³é¢çš„å•ä½åœ†ä¸Š,æ„æˆæ­£nè¾¹å½¢çš„é¡¶ç‚¹,å…¶ä¸­ä¸€ä¸ªé¡¶ç‚¹æ˜¯1.\n\nè®°\n\n$$\n\\omega_{n,k}=-e^{i\\frac{2\\pi}{n}k}\n$$\n\nå…¶å‡ ä½•æ„ä¹‰ä¸ºå•ä½åœ†ä¸Šçš„nç­‰åˆ†ç‚¹çš„é¡ºæ—¶é’ˆç¬¬kä¸ª.\n\n> ä¸€èˆ¬æ¥è¯´,å•ä½æ ¹å–é€†æ—¶é’ˆ,ä¸è¿‡è¿™é‡Œä¸ºäº†æ–¹ä¾¿,å–é¡ºæ—¶é’ˆ.\n\nå¦‚åŒä¸‰è§’å‡½æ•°ä¸€æ ·,å•ä½æ ¹å­˜åœ¨ä¸€äº›æ˜¾ç„¶çš„å®šç†.\n\n**æŠ˜åŠ:**$\\omega_{2n,2k}=\\omega_{n,k}$\n\n**åŒ–ç®€:**$\\omega_{n,k+\\frac 2n}=-\\omega_{n,k}$\n\n#### ä¿®æ”¹å…¬å¼\næ¥çœ‹åŸæœ¬çš„ç¦»æ•£å‚…é‡Œå¶å˜æ¢å…¬å¼\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\nä½¿ç”¨å•ä½æ ¹æ¥æ›¿æ¢ä¸€ä¸‹\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}\\omega_{N,nk} g(n)\n$$\n\næŒ‰ç…§~~ç¥~~åŒ–ç®€å…¬å¼çš„æŒ‡å¼•,å°†æ±‚å’Œå…¬å¼æŒ‰ç…§å•ä½æ ¹å¥‡å¶æ‹†åˆ†ä¸º2éƒ¨åˆ†.\n\nâ€‹                                                                                                              \n$$\n\\begin{aligned}\n\\hat g(k) &= \\sum_{n=0}^{N-1}\\omega_{N,nk} g(n) \\\\\n&= \\sum_{0 \\leq n < N}\\omega_{N,nk} g(n) \\\\\n&= \\sum_{0 \\leq 2n < N}\\omega_{N,2nk} g(2n) + \\sum_{0 \\leq 2n+1 < N}\\omega_{N,(2n+1)k} g(2n+1) \\\\\n&=\\sum_{0 \\leq 2n < N}\\omega_{N,2nk} g(2n) + \\sum_{0 \\leq 2n+1 < N}\\omega_{N,2nk+k} g(2n+1) \\\\\n&=\\sum_{0 \\leq 2n < N}\\omega_{\\frac N2,nk} g(2n) + \\omega_{N,k}\\sum_{0 \\leq 2n+1 < N}\\omega_{\\frac N2,nk} g(2n+1) \\\\\n&=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k)\n\\end{aligned}\n$$\n\næ³¨æ„åˆ°ä¸ç®¡æ˜¯$\\hat g_{even}(k)$è¿˜æ˜¯$\\hat g_{even}(k)$,å®ƒä»¬éƒ½ä»¥$N/2$ä¸ºå‘¨æœŸ.æ¥ä¸‹æ¥,åº”ç”¨åŒ–ç®€å®šç†\n\n$$\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\nå°†è¿™2ä¸ªå¼å­æ”¾åœ¨ä¸€èµ·\n\n$$\n\\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\nå½“kå–éåŸé—®é¢˜è§„æ¨¡çš„ä¸€åŠæ—¶,å¯ä»¥ç›´æ¥ç”±ç¬¬äºŒä¸ªå¼å­å¾—åˆ°å¦ä¸€åŠ.é—®é¢˜çš„è§„æ¨¡å‡åŠ.é€’å½’æ±‚è§£,æœ€ç»ˆçš„å¤æ‚åº¦å°±é™åˆ°äº†$O(N \\lg N)$.\n\nè¿™å°±æ˜¯`Cooley-Turkey`å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ç®—æ³•.\n\n## å¿«é€Ÿä¹˜æ³•\nå®šä¹‰å¤šé¡¹å¼$A(x)=\\sum_k a_kx^{k+1}$,$B(x)$åŒç†,æ±‚è§£$C(x)=A(x)B(x)$.\n\nå¾ˆå®¹æ˜“çœ‹å‡º,æœ´ç´ ç®—æ³•çš„å¤æ‚åº¦ä¸º$O(N^2)$.\n\nç°åœ¨,æ¥çœ‹å¦‚ä½•ä½¿ç”¨FFTå¿«é€Ÿè®¡ç®—.\n\n### ç‚¹å€¼è¡¨ç¤º\n> å¯¹äºä¸€ä¸ªæ¬¡æ•°ä¸º$n-1$çš„å¤šé¡¹å¼,å…¶å›¾è±¡ä¸Šäº’ä¸ç›¸åŒçš„$n$ä¸ªç‚¹å¯ä»¥å”¯ä¸€ç¡®å®šè¯¥å¤šé¡¹å¼.\n> ...\n> å¦‚åŒç¡®å®šæ··åˆåœ¨ä¸€èµ·çš„å‡ ä¸ªæ³¢ä¸€æ ·.\n\nè‡³äºä¸ºä»€ä¹ˆæ˜¯å¯¹çš„,å¤§å¯åœ¨Googleä¸Šæœç´¢ä¸€ç•ª.\n\nå–$x$ä¸ºæ•°ä¸ªå•ä½æ ¹,åœ¨$A(x)$å’Œ$B(x)$ä¸Šåˆ©ç”¨å•ä½æ ¹çš„æ€§è´¨å¾—åˆ°$A$å’Œ$B$çš„ç‚¹å€¼è¡¨ç¤º,å°†ç‚¹å€¼ç›¸ä¹˜å¾—åˆ°$C$çš„ç‚¹å€¼è¡¨ç¤º.ä¹‹å,å°†$C$çš„ç‚¹å€¼è¡¨ç¤ºå†è½¬æ¢ä¸ºç³»æ•°è¡¨ç¤º.\n\nå—¯?FFTåœ¨å“ª?\n\nå…¶å®åœ¨è¿™é‡Œ,\n\n$$\n\\hat g(\\omega)=A(\\omega)=\\sum_{n}\\omega A[x^{n+1}]\n$$\n\n### ç¦»æ•£å·ç§¯\næœ‰ä¸€ç§**æ•°å­¦è¿ç®—**,å«åš**å·ç§¯**.ç°åœ¨åªè®¨è®ºå®ƒçš„ç¦»æ•£æƒ…å†µ.\n\n$$\n(f * g)(n)=\\sum_{\\tau=-\\inf}^{inf}f(\\tau)g(n-\\tau)\n$$\n\nè¿™ç©æ„çš„æ„ä¹‰...å®åœ¨æ˜¯ä¸æ€ä¹ˆæ˜æ˜¾.ä¸è¿‡å¥½åœ¨æˆ‘ä»¬åªæ˜¯æƒ³ç®—ä¸ªå¤šé¡¹å¼ä¹˜æ³•,ä¹Ÿå°±æ˜¯æŠŠå¤šé¡¹å¼çš„**ç³»æ•°**ç®—æ¥ç®—å»:\n\n$C[x^n]$ è¡¨ç¤ºå¤šé¡¹å¼$C$ä¸­$x^n$é¡¹çš„ç³»æ•°.\n\n$$\nC[x^{n}]=\\sum_{\\tau=0}^{n}A[x^\\tau]B[x^{n-\\tau}]\n$$\n\nå—¯?\n\nå¦‚æœæˆ‘ä»¬è®¾å¤šé¡¹å¼ä¸­ä¸å­˜åœ¨çš„é¡¹çš„ç³»æ•°ä¸º0çš„è¯.\n\n$$\nC[x^{n}]=\\sum_{\\tau=-\\inf}^{\\inf}A[x^\\tau]B[x^{n-\\tau}]\n$$\n\nå“ˆ,\n\n$$\nC[x^n]=(A*B)[x^n]\n$$\n### å·ç§¯å®šç†\nå·ç§¯å®šç†æŒ‡å‡º:\n\n> ä¸€ä¸ªåŸŸä¸­çš„å·ç§¯å¯¹åº”äºå¦ä¸€ä¸ªåŸŸä¸­çš„ä¹˜ç§¯.\n\nè¿™æ„å‘³ç€,ä¸Šé¢è¿™ä¸ªè®¡ç®—(å·ç§¯)å¯¹åº”ç€å¦ä¸€ä¸ªåŸŸé‡Œçš„ä¹˜ç§¯.ä¹Ÿå°±æ˜¯\n\n$$\nF(C[x^n])=F(A[x^n]) \\cdot F(B[x^n])\n$$\n\nè¿™ä¾¿æ˜¯æ·±å±‚åŸç†.å¯¹Aå’ŒBçš„å–æ ·(é¢‘åŸŸ)ç§°ä¸ºAå’ŒBçš„ç‚¹å€¼è¡¨ç¤º,æœ€ç»ˆä»¥ä¹˜ç§¯çš„æ–¹å¼å¾—åˆ°äº†Cçš„ç‚¹å€¼è¡¨ç¤º(é¢‘åŸŸ).ç”¨FFTæ¥è®¡ç®—ä¹˜æ³•çš„è¯´æ³•æ˜¯å¯¹çš„.\n\n## å‚…é‡Œå¶é€†å˜æ¢\nå¦‚ä½•ä»ä¸€ä¸ªé¢‘åŸŸä¿¡å·å†å¾—åˆ°æ—¶åŸŸä¿¡å·?\n\n$$\ng(n)=\\frac 1N\\sum_{k=0}^{N-1}e^{i\\frac{2\\pi}{N}nk} \\hat g(k)\n$$\n\n> æ³¨æ„:æ­¤å¤„çš„1/Nä¸ä¸Šé¢çš„å˜æ¢æ˜¯ç›¸åŒ¹é…çš„.\n\nè¿™ä¸ªå¼å­å¯ä»¥ç†è§£æˆå¯¹å˜æ¢åçš„å¼å­å†å˜æ¢,æ„å‘³ç€å®ƒåŒæ ·å¯ä»¥ç”¨å˜æ¢æ—¶çš„æ€æƒ³æ¥åŠ é€Ÿ.\n\n## FFTçš„C++å®ç°\nä¸€ä¸ªå€¼å¾—æ³¨æ„çš„é—®é¢˜å°±æ˜¯,å¯¹äºå•ä½æ ¹çš„è¿ç®—æ¶‰åŠåˆ°äº†ç²¾åº¦çš„é—®é¢˜.ä½†ç›®å‰è¿˜ä¸éœ€è¦è®¨è®º.\n\n### ç¿»è½¬æ“ä½œ\nå¯ä»¥è§‚å¯Ÿåˆ°,æŒ‰ç…§ä¸Šé¢çš„ç®—æ³•å®ç°,æˆ‘ä»¬éœ€è¦åœ¨æ¯æ¬¡é€’å½’æŒ‰ç…§å¥‡å’Œå¶å°†å–æ ·åˆ†ç»„.ä¸”æ¯æ¬¡é€’å½’éƒ½ä¼šåˆ†ç»„.æ¯æ¬¡åˆ†ç»„éƒ½ä¼šæ¶‰åŠåˆ°æ•°ç»„çš„å¤åˆ¶,å¸¸æ•°è¾ƒå¤§.\n\nè§‚å¯Ÿåˆ†ç»„æ“ä½œä¸­ä¸‹æ ‡çš„å˜åŒ–.\n\n```\n(è¡¨ç¤ºä¸‹æ ‡)\n0 1 2 3 4 5 6 7\n0 2 4 6 | 1 3 5 7\n0 4 | 2 6 | 1 5 | 3 7\n```\n\nå°†å…¶è½¬æ¢ä¸ºäºŒè¿›åˆ¶\n```\n000 001 010 011 100 101 110 111\n000 100 010 110 001 101 011 111\n```\n\nå¯ä»¥å‘ç°,æœ€ç»ˆçš„åˆ†ç»„ç»“æœå°±æ˜¯å°†åŸä¸‹æ ‡äºŒè¿›åˆ¶ç¿»è½¬.æ‰€ä»¥å¯ä»¥ç›´æ¥ä¸€æ¬¡å®Œæˆåˆ†ç»„.\n\næ³¨æ„,**è¿™è¦æ±‚å–æ ·ä¸º2çš„å¹‚æ¬¡**.\n\n### ğŸ¦‹è´è¶æ“ä½œ\nè§£å†³äº†é€’å½’ä¸­ç”±é¡¶è‡³åº•çš„åˆ†ç»„å,æ¥ä¸‹æ¥ä¼˜åŒ–å­é—®é¢˜åˆå¹¶æ—¶çš„æ•°ç»„å¤åˆ¶.\n\nè§‚å¯ŸåŸæ¥çš„åˆå¹¶å¼å­\n\n$$\n\\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\næŒ‰ç…§ç®—æ³•ä¸­çš„å®ç°æ–¹æ³•,å…¶ä¸º\n\n$$\n\\hat g(k)=\\hat g(k)+\\omega_{N,k} \\hat g(k+\\frac N2) \\\\\n\\hat g(k+\\frac N2)=\\hat g(k)-\\omega_{N,k} \\hat g(k+\\frac N2)\n$$\n\næƒ³è¦çœç•¥æ•°ç»„å¤åˆ¶,è¿›è¡ŒåŸåœ°åˆå¹¶,é—®é¢˜å‡ºåœ¨æ–°æ•°å€¼å¤ªæ—©åœ°æ›¿æ¢æ‰äº†æˆ‘ä»¬éœ€è¦çš„æ•°å€¼.\n\nå–è¾…åŠ©å˜é‡,ä¿®æ”¹åŸå¼\n\n$$\nt=\\omega_{N,k} \\hat g(k+\\frac N2)\\\\\n\\hat g(k+\\frac N2)=\\hat g(k)-t\\\\\n\\hat g(k)=\\hat g(k)+t\n$$\n\nè¿™ä¸ªæ“ä½œè¢«ç§°ä¸º\"è´è¶æ“ä½œ\",åå­—å¾ˆæœ‰æ„æ€.\n\n### ä»£ç \nåœ¨è¿™æ®µä»£ç ä¸­åŒæ—¶å»æ‰äº†é€’å½’.\n\n```cpp\nconst double PI=acos(-1);\n\ninline complex<double> gomega(int n,int k,bool rev=false){\n    complex<double> res(cos(2*PI/n*k),sin(2*PI/n*k));\n    if(rev)return conj(res);\n    else return res;\n}\nconst int MAXN=10;\nstruct FFT{\n    complex<double> omega[MAXN],omegaI[MAXN];\n\n    FFT(int n){\n        for(int i=0;i<n;i++){\n            omega[i]=gomega(n,i);\n            omegaI[i]=gomega(n,i,1);\n        }\n    }\n    void transform(complex<double> *a,int n,const complex<double> *omega){\n        for(int i=0,j=0;i<n;i++){\n            if(i>j)swap(a[i],a[j]);\n            //äºŒè¿›åˆ¶æ¢ä½\n            for(int l=n/2;(j^=l)<l;l>>=1);\n        }\n        for(int l=2;l<=n;l<<=1){\n            int m=l/2;\n            for(complex<double> *p=a;p!=a+n;p+=l){\n                for(int i=0;i<m;i++){\n                //è´è¶æ“ä½œ\n                    complex<double> t=omega[n/l*i]*p[m+i];\n                    p[m+i]=p[i]-t;\n                    p[i]+=t;\n                }\n            }\n        }\n    }\n    void dft(complex<double> *a,int n){\n        transform(a,n,omega);\n    }\n    void idft(complex<double> *a,int n){\n        transform(a,n,omegaI);\n        for(int i=0;i<n;i++)a[i]/=n;\n    }\n};\n```\n\nå¦‚æœæƒ³è¦å®ç°å¿«é€Ÿä¹˜æ³•,åªè¦å°†2ä¸ªå¤šé¡¹å¼çš„ç³»æ•°å‡½æ•°ä¼ å…¥è¿›è¡Œå˜æ¢,å˜æ¢ç»“æœç›¸ä¹˜å¹¶é€†å˜æ¢å³å¯.\n\n#### åº”ç”¨\n\n##### å¿«é€Ÿä¹˜æ³•\næŒ‡å¿«é€Ÿå¤§æ•°ä¹˜æ³•ã€‚\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN=300000;\nconst double PI=acos(-1);\n\ninline complex<double> gomega(int n,int k,bool rev=false){\n    complex<double> res(cos(2*PI/n*k),sin(2*PI/n*k));\n    if(rev)return conj(res);\n    else return res;\n}\nstruct FFT{\n    complex<double> omega[MAXN],omegaI[MAXN];\n\n    FFT(){\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            omega[i]=gomega(n,i);\n            omegaI[i]=gomega(n,i,1);\n        }\n    }\n\n    void transform(complex<double> *a,int n,const complex<double> *omega){\n        for(int i=0,j=0;i<n;i++){\n            if(i>j)swap(a[i],a[j]);\n            //äºŒè¿›åˆ¶æ¢ä½\n            for(int l=n/2;(j^=l)<l;l>>=1);\n        }\n        for(int l=2;l<=n;l<<=1){\n            int m=l/2;\n            for(complex<double> *p=a;p!=a+n;p+=l){\n                for(int i=0;i<m;i++){\n                    //è´è¶æ“ä½œ\n                    complex<double> t=omega[n/l*i]*p[m+i];\n                    p[m+i]=p[i]-t;\n                    p[i]+=t;\n                }\n            }\n        }\n    }\n    void dft(complex<double> *a,int n){\n        transform(a,n,omega);\n    }\n    void idft(complex<double> *a,int n){\n        transform(a,n,omegaI);\n        for(int i=0;i<n;i++)a[i]/=n;\n    }\n};\n\ncomplex<double> a[2][MAXN];\nint ans[MAXN];\nFFT fft;\nint main(){\n\n    int nlen;cin>>nlen;\n    int n=1;\n    //æ ¹æ®åŸç†ï¼Œ\b\bnå¿…é¡»å–å¤§äº2nlençš„æ•°ï¼Œæ‰èƒ½æ»¡è¶³å–æ ·è¦æ±‚å’Œåè½¬æ“ä½œè¦æ±‚\n    while(n<2*nlen)n*=2;\n    fft.init(n);\n\n\n    for(int i=0;i<2;i++){\n        string inp;cin>>inp;\n        for(int j=0,k=inp.size()-1;j<inp.size();j++,k--){\n            a[i][j]=complex<double>(inp[j]-'0',0);\n        }\n        fft.dft(a[i],n);\n    }\n    for(int i=0;i<n;i++)a[0][i]=a[0][i]*a[1][i];\n    fft.idft(a[0],n);\n    int reslen=nlen+nlen-1;\n    for(int i=reslen-1,k=0;i>=0;i--,k++)\n        ans[k]=(int)floor(a[0][i].real()+0.5);\n    /*\n    for(int i=0;i<reslen;i++)cout<<ans[i]<<\" \";\n    cout<<endl;\n    */\n    for(int i=0;i<MAXN;i++){\n        ans[i+1]+=ans[i]/10;\n        ans[i]%=10;\n    }\n    int ptr=MAXN-1;\n    while(ans[ptr]==0)ptr--;\n    for(;ptr>=0;ptr--)cout<<ans[ptr];\n    cout<<endl;\n\n    return 0;\n}\n```","categories":["study"]},{"title":"did-i-write-qsort-right","url":"%2F2019%2F07%2F12%2Fdid-i-write-qsort-right%2F","content":"ä¼—æ‰€å‘¨çŸ¥ï¼Œå¿«é€Ÿæ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n\\lg n)$çš„ã€‚ç„¶è€Œå› ä¸ºæˆ‘å¤ªèœï¼Œå†™å‡ºæ¥çš„å¿«é€Ÿæ’åºä¸€ä¸å°å¿ƒå°±æˆäº†$O(n^2)$...\n\n<!--more-->\n\n## è¿™ä¸ªè¾£é¸¡é—®é¢˜\nè¿™ä¸ªåº”è¯¥éƒ½çŸ¥é“ï¼Œå½“å¾…æ’åºæ•°ç»„å·²ç»æœ‰åºæ—¶ï¼Œå›ºå®šé€‰æ‹©æŸä¸€ä¸ªä½ç½®çš„æ•°å­—å½“å“¨å…µçš„å¿«æ’ä¼šå˜æˆ$O(n^2)$ã€‚ä¸€ä¸ªè§£å†³æ–¹æ³•å°±æ˜¯éšæœºé€‰æ‹©å“¨å…µï¼Œæˆ–è€…å¹²è„†å°†è¾“å…¥çš„æ•°ç»„æ‰“ä¹±åå†æ’åºã€‚\n\nç„¶è€Œï¼Œå¦‚æœè¾“å…¥çš„æ•°ç»„æ•°å­—å…¨éƒ¨ç›¸åŒå‘¢ï¼Ÿ\n\nå½“ç„¶è¿™åœ¨å®é™…ä¸­å¾ˆå°‘è§ï¼Œä½†æ˜¯åœ¨å®ç°çš„æ—¶å€™å°±è¦å°å¿ƒã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‰€å®ç°çš„å¿«æ’å¿…é¡»å¯¹äºç›¸åŒæ•°å­—ä¹Ÿäº¤æ¢ä½ç½®ï¼Œå¦åˆ™å°±ä¼šé€€åŒ–ä¸º$O(n^2)$ã€‚\n\næ¯”å¦‚è¯´ï¼Œè¿™ä¸ª\n```cpp\n    void quicksort(int left,int right)\n    {\n    int i,j,t,temp;\n    if(left>right)\n       return;\n\n    temp=a[left]; //tempä¸­å­˜çš„å°±æ˜¯åŸºå‡†æ•°\n    i=left;\n    j=right;\n    while(i!=j)\n    {\n       //é¡ºåºå¾ˆé‡è¦ï¼Œè¦å…ˆä»å³è¾¹å¼€å§‹æ‰¾\n       while(a[j]>=temp && i<j)\n    j--;\n       //å†æ‰¾å³è¾¹çš„\n       while(a[i]<=temp && i<j)\n    i++;\n       //äº¤æ¢ä¸¤ä¸ªæ•°åœ¨æ•°ç»„ä¸­çš„ä½ç½®\n       if(i<j)\n       {\n    t=a[i];\n    a[i]=a[j];\n    a[j]=t;\n       }\n    }\n    //æœ€ç»ˆå°†åŸºå‡†æ•°å½’ä½\n    a[left]=a[i];\n    a[i]=temp;\n\n    quicksort(left,i-1);//ç»§ç»­å¤„ç†å·¦è¾¹çš„ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹\n    quicksort(i+1,right);//ç»§ç»­å¤„ç†å³è¾¹çš„ ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹\n    }\n```\nè¿˜æœ‰è¿™ä¸ªï¼Œ\n```cpp\nvoid quick_sort(int s[], int l, int r)\n{\n    if (l < r)\n    {\n\t\t//Swap(s[l], s[(l + r) / 2]); //å°†ä¸­é—´çš„è¿™ä¸ªæ•°å’Œç¬¬ä¸€ä¸ªæ•°äº¤æ¢ å‚è§æ³¨1\n        int i = l, j = r, x = s[l];\n        while (i < j)\n        {\n            while(i < j && s[j] >= x) // ä»å³å‘å·¦æ‰¾ç¬¬ä¸€ä¸ªå°äºxçš„æ•°\n\t\t\t\tj--;  \n            if(i < j) \n\t\t\t\ts[i++] = s[j];\n\t\t\t\n            while(i < j && s[i] < x) // ä»å·¦å‘å³æ‰¾ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„æ•°\n\t\t\t\ti++;  \n            if(i < j) \n\t\t\t\ts[j--] = s[i];\n        }\n        s[i] = x;\n        quick_sort(s, l, i - 1); // é€’å½’è°ƒç”¨ \n        quick_sort(s, i + 1, r);\n    }\n}\n\n```\nå®ƒä»¬éƒ½ä¼šè·³è¿‡ç›¸åŒçš„æ•°å­—ï¼Œæ¯æ¬¡æ’åºåå“¨å…µæ€»ä¼šåœ¨è¾¹ç•Œä¸Šï¼Œå¯¼è‡´ç®—æ³•åŠ£åŒ–åˆ°$O(n^2)$ã€‚\n\nå¤§æ¦‚å°±æ˜¯è¿™å›äº‹ï¼Œæ²¡åˆ«çš„äº†ã€‚è¿™ç§æƒ…å†µå½“ç„¶æœ‰æ”¹è¿›çš„å¿«é€Ÿæ’åºå¯ä»¥ç›´æ¥é¿å…è¿™ç§ç½•è§çš„æƒ…å†µï¼Œåœ¨ä¸å¤§å¹…åº¦æ”¹åŠ¨ç®—æ³•çš„å‰æä¸‹ï¼Œå°±è¦å¯¹ç›¸åŒçš„å…ƒç´ ä¹Ÿè¿›è¡Œæ¢ä½æ‰å¯ä»¥ï¼Œå³ä½¿ä¼šå¢åŠ äº¤æ¢æ¬¡æ•°ã€‚","tags":["æ’åº"],"categories":["é—²æ‰¯"]},{"title":"åŸºäºPBDSçš„splay","url":"%2F2019%2F07%2F12%2Fimplment-of-splay-based-on-PBDS%2F","content":"\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntree<int,null_type,greater<int>,rb_tree_tag,tree_order_statistics_node_update> bbt;\nmap<int,string> ef;\nint main(){\n    int n;cin>>n;\n    while(n--){\n        int op;\n        cin>>op;\n        if(op==1){\n            string name;\n            int value;\n            cin>>name>>value;\n            ef[value]=name;\n            bbt.insert(value);\n        }else if(op==2){\n            int v;cin>>v;\n            if(!bbt.erase(v))cout<<\"NO\"<<endl;\n            else cout<<ef[v]<<endl;\n        }else if(op==3){\n            int v;cin>>v;\n            if(bbt.find(v)==bbt.end())cout<<\"NO\"<<endl;\n            else cout<<bbt.order_of_key(v)+1<<endl;\n        }else if(op==4){\n            int r;cin>>r;\n            r--;\n            auto it=bbt.find_by_order(r);\n            if(it!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }else if(op==5){\n            int v;cin>>v;\n            auto it=bbt.find(v);\n            if(it!=bbt.end() && (--it)!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }else if(op==6){\n            int v;cin>>v;\n            auto it=bbt.find(v);\n            if(it!=bbt.end() &&(++it)!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }\n    }\n    return 0;\n}\n\n```","tags":["splay"]}]