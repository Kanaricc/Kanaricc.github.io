[{"title":"数位DP","url":"%2F2019%2F11%2F06%2Fdigit-dp-1%2F","content":"\n## 例题-4 HDU2089 不要62\n统计数位中没有出现4和62的数字个数。\n\n### 分析\n不要4，可以在4时直接不转移。对于62，可以维护一个上一个数字填了啥，就可以像4一样判断了。\n\n<!--more-->\n\n### 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconstexpr int MAXN=20;\nll cache[MAXN][MAXN];\nint digits[20];\nll solve(int pos,int last,int lim){\n    if(pos==0)return 1;\n    if(!lim && ~cache[pos][last])return cache[pos][last];\n\n    int maxd=9;\n    if(lim)maxd=digits[pos];\n    ll res=0;\n    for(int i=0;i<=maxd;i++){\n        if(last*10+i==62 || i==4)continue;\n        res+=solve(pos-1,i,lim && i==maxd);\n    }\n    if(!lim)cache[pos][last]=res;\n    return res;\n}\n\nll SOLVE(ll x){\n    int ptr=0;\n    while(x){\n        digits[++ptr]=x%10;\n        x/=10;\n    }\n\n    return solve(ptr,0,true);\n}\n\n\n\nint main(){\n    ll l,r;\n    memset(cache,-1,sizeof(cache));\n    while(cin>>l>>r){\n        if(l==0 && r==0)break;\n        cout<<SOLVE(r)-SOLVE(l-1)<<endl;\n    }\n    return 0;\n}\n```\n\n## 例题-3 HDU3555\n统计所有出现过49的数字的个数。\n\n### 分析\n统计所有没出现过49的数字，就和上一道一样了。\n\n### 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50;\n\nint digits[MAXN];\nll f[MAXN][MAXN];\n\nll solve(int pos,int last,int lim){\n    if(pos==0)return 1;\n    if(!lim && ~f[pos][last])return f[pos][last];\n\n    int maxd=9;\n    if(lim)maxd=digits[pos];\n    ll res=0;\n    for(int i=0;i<=maxd;i++){\n        if(last*10+i==49)continue;\n        res+=solve(pos-1,i,lim && i==maxd);\n    }\n\n    if(!lim)f[pos][last]=res;\n    return res;\n}\n\ninline ll SOLVE(ll x){\n    int ptr=0;\n    while(x){\n        digits[++ptr]=x%10;\n        x/=10;\n    }\n\n    return solve(ptr,0,true);\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    memset(f,-1,sizeof(f));\n    while(kase--){\n        ll r;cin>>r;\n        cout<<r-SOLVE(r)+1<<endl;\n    }\n    return 0;\n}\n```\n\n## 例题-2 POJ3252\nThe cows, as you know, have no fingers or thumbs and thus are unable to play Scissors, Paper, Stone' (also known as 'Rock, Paper, Scissors', 'Ro, Sham, Bo', and a host of other names) in order to make arbitrary decisions such as who gets to be milked first. They can't even flip a coin because it's so hard to toss using hooves.\n\nThey have thus resorted to \"round number\" matching. The first cow picks an integer less than two billion. The second cow does the same. If the numbers are both \"round numbers\", the first cow wins,\notherwise the second cow wins.\n\nA positive integer N is said to be a \"round number\" if the binary representation of N has as many or more zeroes than it has ones. For example, the integer 9, when written in binary form, is 1001. 1001 has two zeroes and two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since it has two zeroes and three ones, it is not a round number.\n\nObviously, it takes cows a while to convert numbers to binary, so the winner takes a while to determine. Bessie wants to cheat and thinks she can do that if she knows how many \"round numbers\" are in a given range.\n\nHelp her by writing a program that tells how many round numbers appear in the inclusive range given by the input (1 ≤ Start < Finish ≤ 2,000,000,000).\n\n### 分析\n\n这道题目将上界拆解为二进制数位。\n\n### 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=50;\n\nint digits[MAXN];\nll f[MAXN][MAXN][MAXN];\nint len=0;\n\nll solve(int pos,int one,int first, int lim){\n    if(pos==0){\n        //cout<<first<<\" \"<<one<<endl;\n        if(first==0)return 0;\n        if(first-one>=one)return 1;\n        return 0;\n    }\n    if(!lim && ~f[pos][one][first])return f[pos][one][first];\n\n    int maxd=1;\n    if(lim)maxd=digits[pos];\n    ll res=0;\n    for(int i=0;i<=maxd;i++){\n        res+=solve(pos-1,one+(i==1),(i==1 && !first? pos : first),lim && i==maxd);\n    }\n\n    if(!lim)f[pos][one][first]=res;\n    return res;\n}\n\ninline ll SOLVE(ll x){\n    int ptr=0;\n    while(x){\n        digits[++ptr]=x%2;\n        x/=2;\n    }\n\n    return solve(ptr,0,0,true);\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    memset(f,-1,sizeof(f));\n    ll l,r;cin>>l>>r;\n    cout<<SOLVE(r)-SOLVE(l-1)<<endl;\n\n    return 0;\n}\n```\n\n## 例题-1 HDU3652\nA wqb-number, or B-number for short, is a non-negative integer whose decimal form contains the sub- string \"13\" and can be divided by 13. For example, 130 and 2613 are wqb-numbers, but 143 and 2639 are not. Your task is to calculate how many wqb-numbers from 1 to n for a given integer n.\n\n### 分析\n\n维护额外2个状态，一个状态记录模13的余数，另一个进行编码：1为上一位为1，3为已经出现过13，0为其他。之后将转移条件描述清楚就可以了。\n\n### 代码\n```cpp\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=20;\n\nint num[MAXN];\nll f[MAXN][5][20];\nll dfs(int ptr,int last,int mod,bool lim){\n\t//cout<<\"arrive\"<<ptr<<\" \"<<last<<\" \"<<mod<<\" \"<<lim<<endl;\n\tif(ptr<=0){\n\t\tif(last==3 && mod==0)return 1;\n\t\telse return 0;\n\t}\n\tif(!lim && ~f[ptr][last][mod])return f[ptr][last][mod];\n\n\tint maxx=lim?num[ptr]:9;\n\tll res=0;\n\tfor(int i=0;i<=maxx;i++){\n\t\tif(last==3)res+=dfs(ptr-1,3,(mod*10+i)%13,lim && i==maxx);\n\t\telse if(last==1 && i==3)res+=dfs(ptr-1,3,(mod*10+i)%13,lim && i==maxx);\n\t\telse if(i==1)res+=dfs(ptr-1,1,(mod*10+i)%13,lim&&i==maxx);\n\t\telse res+=dfs(ptr-1,0,(mod*10+i)%13,lim&&i==maxx);\n\t}\n\tif(!lim)f[ptr][last][mod]=res;\n\treturn res;\n}\nll solve(ll r){\n\tint ptr=0;\n\twhile(r){\n\t\tnum[++ptr]=r%10;\n\t\tr/=10;\n\t}\n\treturn dfs(ptr,0,0,1);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tmemset(f,-1,sizeof(f));\n\tll r;\n\twhile(cin>>r){\n\t\tcout<<solve(r)<<endl;\n\t}\n\n\treturn 0;\n}\n```\n\n\n## 例题0 HDU3709\nA balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 4*2 + 1*1 = 9 and 9*1 = 9, for left part and right part, respectively. It's your job to calculate the number of balanced numbers in a given range [x, y].\n\n### 分析\n这题有点麻烦……\n\n将杠杆在哪与题目分离出来，枚举杠杆定在何处。再维护是否平衡。平衡与否还是挺好考虑的，以杠杆为0，左右各赋值正与负的权值，当到达边接后全杆重量为0时即为平衡。\n\n> 有一个小坑，就是0。如果这个数字全tm填0的时候，不管杠杆定在哪，它都平衡……你当然可以维护一个前导零标志，将所有0都去掉最后再加上。还有一种办法就是最后再将重复的0减去，相比起来更加简单。\n\n### 代码\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\n\nint num[20];\nll f[20][20][2010];\n\nll dfs(int ptr,bool lim,int piv,int l){\n\tif(ptr<=0)return l==0;\n\tif(l<0)return 0;\n\tif(!lim && ~f[ptr][piv][l])return f[ptr][piv][l];\n\n\tint maxx=lim?num[ptr]:9;\n\n\tll res=0;\n\tfor(int i=0;i<=maxx;i++){\n\t\tres+=dfs(ptr-1,lim && i==maxx,piv,l+i*(ptr-piv));\n\t}\n\n\tif(!lim)f[ptr][piv][l]=res;\n\treturn res;\n}\n\nll solve(ll r){\n\tint ptr=0;\n\twhile(r){\n\t\tnum[++ptr]=r%10;\n\t\tr/=10;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=ptr;i++){\n\t\tans+=dfs(ptr,1,i,0);\n\t}\n\treturn ans-ptr+1;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\tint kase;cin>>kase;\n\twhile(kase--){\n\t\tmemset(f,-1,sizeof(f));\n\t\tll l,r;cin>>l>>r;\n\t\tcout<<solve(r)+(l?-solve(l-1):0)<<'\\n';\n\t}\n\n\treturn 0;\n}\n```\n\n## 例题1 CF55D\nVolodya is an odd boy and his taste is strange as well. It seems to him that a positive integer number is beautiful if and only if it is divisible by each of its nonzero digits. We will not argue with this and just count the quantity of beautiful numbers in given ranges.\n\n### 分析\n维护数字对0-9每个数字的模，但是这样还需要维护某些数字是否出现，继续考虑。当数字能同时被$a$和$b$整除，等价为其能够被它俩的最小公倍数整除。\n\n那么我们的问题可以稍微简化一下了。维护已经填写的数位的最小公倍数，并维护数字和。到达边界时，只有满足条件才计数。\n\n> 这道题还有一点麻烦，就是内存它不够用。按照分析，至少需要开$2520\\times 2520$，还要再加上个数位长度。内存就炸了。实际上，最小公倍数仅有了了几个，可以事先求出并先编码，就能降低一维状态。\n\n### 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\nusing namespace std;\nusing ll = long long;\nconst int MAXN = 2620;\nconst int MAX_LCM = 2520;\n//pos位数余rest模·10·的方案\nll cache[20][MAXN][50];\nint digits[20];\n\nint idx = 0;\nint lcmref[MAXN];\n\nll gcd(ll a, ll b)\n{\n    return !b ? a : gcd(b, a % b);\n}\nll lcm(ll a, ll b)\n{\n    return a / gcd(a, b) * b;\n}\nvoid init_lcm()\n{\n    for (int i = 0; i < (1 << 10); i++)\n    {\n        int temp = 1;\n        for (int j = 1; j < 10; j++)\n        {\n            if ((i >> j) & 1)\n            {\n                temp = lcm(temp, j);\n            }\n        }\n        if (!lcmref[temp])\n        {\n            //cout << temp << endl;\n            lcmref[temp]=++idx;\n        }\n    }\n}\nll solve(int pos, int rest, int l, bool lim)\n{\n    if (pos == 0)\n    {\n        if (rest % l == 0)\n            return 1;\n        return 0;\n    }\n    if (!lim && ~cache[pos][rest][lcmref[l]])\n        return cache[pos][rest][lcmref[l]];\n\n    ll res = 0;\n    int maxd = 9;\n    if (lim)\n        maxd = digits[pos];\n    for (int i = 0; i <= maxd; i++)\n    {\n        res += solve(pos - 1, (rest * 10 + i) % MAX_LCM, i == 0 ? l : lcm(l, i), lim && (i == maxd));\n    }\n    if (!lim)\n        cache[pos][rest][lcmref[l]] = res;\n    return res;\n}\n\nll SOLVE(ll x)\n{\n    int ptr = 0;\n    while (x)\n    {\n        digits[++ptr] = x % 10;\n        x /= 10;\n    }\n    return solve(ptr, 0, 1, true);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    init_lcm();\n    int kase;\n    cin >> kase;\n    memset(cache, -1, sizeof(cache));\n    while (kase--)\n    {\n        ll l, r;\n        cin >> l >> r;\n        cout << SOLVE(r) - SOLVE(l - 1) << endl;\n    }\n\n    return 0;\n}\n```\n\n## 例题2 \n求$[l,r]$区间内的所有满足以下要求的数的平方和。\n\n1. 数位上没有$7$\n2. 不是$7$的倍数\n3. 数位和不是$7$的倍数\n\n区间为$10^{18}$级别，请对答案取模$10^{9}+7$。\n\n### 分析\n这题挺狠的……首先看如何判断上面的3个条件。\n\n* 数位上没有$7$，可以直接在枚举填数时跳过$7$。\n* 非 * 的倍数，可以维护已填数字的取模。取模为$0$则为倍数。\n* 数位和，仍然可以直接维护。\n\n这样就可以正确的判断某个数是不是满足条件。接下来是平方和。\n\n当以数位来考虑平方和时，问题就稍微变得复杂了。假设我们已经知道了下一个状态的平方和为$x_n$，如何得到当前位$x$的平方和。\n\n假设当前位$ptr$填了$i$。其数位所表达的意义是$10^{p}i$，那么以该位与下一状态的平方和，需要下一状态的**和**，定为$s_n$。可以得到\n\n$$\n(10^p i+s_n)^2=10^{2p}i^2+2 \\cdot 10^pis_n+s_n^2\n$$\n\n另外，当前位的出现次数在实际计算时需要考虑进去。那么，还需要维护下一状态的**个数**，记$cnt$。那么，上式需要修改\n\n$$\n10^{2p}i^2 \\cdot cnt_n+2 \\cdot 10^pis_n+s_n^2\n$$\n\n后两项不乘以$cnt$是因为它们本身就已经是包括了下一状态的所有计数。这样，我们就得到了以数位为角度的平方和维护办法。\n\n### 代码\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=22;\nconst ll MOD=1e9+7;\n\nstruct Status{\n\tll cnt;\n\tll sum,sqsum;\n\tStatus(ll cnt=-1,ll sum=0,ll sqsum=0):cnt(cnt),sum(sum),sqsum(sqsum){}\n} f[MAXN][9*20][10];\nint num[MAXN];\n\nll qpow(ll a,ll b){\n\tll res=1;\n\tfor(;b;b>>=1,a=a*a%MOD){\n\t\tif(b&1)res=res*a%MOD;\n\t}\n\treturn res;\n}\n\nStatus dfs(int ptr,int sum,int mod,bool lim){\n\tif(ptr<=0){\n\t\treturn Status(sum%7!=0 && mod!=0);\n\t}\n\n\tif(!lim && ~f[ptr][sum][mod].cnt)return f[ptr][sum][mod];\n\n\tint maxx=lim?num[ptr]:9;\n\tStatus res(0);\n\tfor(int i=0;i<=maxx;i++){\n\t\tif(i==7)continue;\n\t\tStatus nex=dfs(ptr-1,sum+i,(mod*10+i)%7,lim&&i==maxx);\n\t\tres.cnt+=nex.cnt;\n\t\tres.cnt%=MOD;\n\t\tres.sum=(res.sum%MOD+qpow(10,ptr-1)*i%MOD*nex.cnt%MOD)%MOD;\n\t\tres.sum=(res.sum+nex.sum)%MOD;\n\t\tres.sqsum=(res.sqsum+nex.cnt%MOD*qpow(10,2*(ptr-1))%MOD*i%MOD*i%MOD)%MOD;\n\t\tres.sqsum=((res.sqsum+nex.sqsum)%MOD+2*qpow(10,ptr-1)%MOD*i%MOD*nex.sum%MOD)%MOD;\n\t}\n\tif(!lim)f[ptr][sum][mod]=res;\n\treturn res;\n}\n\n\nll solve(ll n){\n\tint ptr=0;\n\twhile(n){\n\t\tnum[++ptr]=n%10;\n\t\tn/=10;\n\t}\n\treturn dfs(ptr,0,0,1).sqsum%MOD;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint kase;cin>>kase;\n\twhile(kase--){\n\t\tll l,r;cin>>l>>r;\n\t\tcout<<((solve(r)-(l?solve(l-1):0))%MOD+MOD)%MOD<<endl;\n\t}\n\treturn 0;\n}\n```\n\n## 数位DP\n上面这道题目大概算是暴露了数位DP中需要考虑的事情。数位DP能够主要能够统计某2个数字区间内满足某些条件的数字的信息，比如个数、和、平方和……\n\n首先数位DP不是单独考虑每一个数字，而是以数位为单位的考虑。这样在考虑条件满足和各类信息的维护时，就需要转一转。\n\n先来看记忆化搜索。比较直观（\n\n### 计数基础\n初始化的值从何而来。当数位DP到达了边界，就是要考虑初始化的位置。一般为满足条件置$1$。\n\n### 满足条件\n这是我们需要考虑的状态。例如上面提到的。\n\n* 数位没有某数：直接不转移。\n* 数位和：直接维护一维数位和。\n* 倍数关系：以递推方式维护取模。\n* 数字出现次数：使用状压来对次数编码。例如，对每一种数字维护空间为3的状态（0，奇数，偶数）。\n\n其实还可能有很多，主要考虑的问题是该状态经过编码后能不能保存下来，两个状态之间能不能递推过去。\n\n### 计数\n必须考虑$n-1$到$n$**位**之间的转移关系。首先一定会维护满足性质的数字个数，之后每一个位的计算都需要考虑下一状态的个数。","tags":["动态规划"],"categories":["coding"]},{"title":"Liaoning Ship’s Voyage","url":"%2F2019%2F10%2F27%2Fproblem-liaoning-ships-voyage%2F","content":"Liaoning ship, which named after a province of China, is the first aircraft carrier commissioned into the People's Liberation Army Navy. It was bought from Ukraine as a stripped hulk and was rebuilt by China as an important part of China’s blue water Navy plan. Liaoning ship has sailed far into the Pacific Ocean for serval times, which shows the power and resolve of China to defend her integrity of territory.\n\nNow Liaoning ship is on a new voyage to the Atlantic Ocean for a maneuver! The vast maneuver region on the ocean can be seen as an n×n grid which has n×n crosspoints. Each crosspoint stands for a check point of the maneuver region. Liaoning starts from the bottom-left check point whose coordinate is (0,0), and its destination is the upper-right checkpoint whose coordinate is (n-1,n-1). The positive side of the x axis points to the right, and the positive side of the y axis points up. All check points’ coordinates are integral. During each move, Liaoning can go from one check point to its adjacent 8 check points along a straight line, and each move takes Liaoning one day. Some check points are not available to go due to the bad weather. And, as you know, on the Atlantic Ocean, there is a Bermuda Triangle in which many ships and planes were missing. Liaoning can’t take risk to go into that triangle. Of course, Liaoning can’t go outside the maneuver region. Please figure out a route for Liaoning to reach its destination as soon as possible.\n\n## 分析\n\n实际上本体是个Dijkstra，但是两点是否相连需要使用到计算几何的东西。重点就在于如何判断行进过程是否穿过了百慕大三角。\n\n<!--more-->\n\n然后就WA了8发。\n\n实际判断时会有很多问题。例如从边上经过，从外界到边，从边到边，从边到外界，从外界到点，从点到外界，从边穿过点……如果一开始选择的判断方法有锅的话，之后就改不出来了，只能WA……\n\n最终想出来的解决办法是拿到行进线段与三角形三边的交点，连接交点构造新线段后，判断线段中点是否在三角形内；并同时判断起点终点是否在三角形内。这样就能避免掉复杂的讨论。\n\n其次，顺便把已经在三角形内的整点全部标记了不能访问。\n\n这样就过了。\n\n## 代码\n\n板子判点在线段部分有问题，要改。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\nconst int MAXN=30;\n\n\nbool fuck=false;\nconst double EPS=1e-7;\nconst double PI=acos(-1);\nint sgn(double x){\n    return (x>-EPS)-(x<EPS);\n}\nstruct Vec{\n    double x,y;//never change it yourself unless you dont need polar angle.\n    double _polar;// make cache to accumulate speed as atan is too slow.\n\n    Vec(){\n        x=y=0;\n    }\n    Vec(double x,double y):x(x),y(y){\n        _polar=atan2(y,x);\n    }\n    double dot(const Vec &b)const{\n        return x*b.x+y*b.y;\n    }\n    double cross(const Vec &b)const{\n        return x*b.y-b.x*y;\n    }\n    double len(){\n        return sqrt(sqlen());\n    }\n    double sqlen(){\n        return x*x+y*y;\n    }\n    Vec normalize(){\n        double l=len();\n        return Vec(x/l,y/l);\n    }\n    Vec rotate(double angle){\n        return Vec(x*cos(angle)-y*sin(angle),x*sin(angle)+y*cos(angle));\n    }\n    Vec operator * (double factor)const{\n        return Vec(x*factor,y*factor);\n    }\n    double operator * (const Vec &b)const{\n        return cross(b);\n    }\n    Vec operator - (const Vec &b)const{\n        return Vec(x-b.x,y-b.y);\n    }\n    Vec operator +(const Vec &b)const{\n        return Vec(x+b.x,y+b.y);\n    }\n    double polar()const{\n        return _polar;\n    }\n    bool leftby(const Vec &b)const{\n        return sgn(b.cross(*this))>0;\n    }\n    bool samed(const Vec &b)const{\n        return sgn(this->cross(b))==0 && sgn(this->dot(b))>0;\n    }\n    bool operator<(const Vec &b)const{\n        return this->polar()<b.polar();\n    }\n    \n    bool operator==(const Vec &b)const{\n\t\treturn sgn(b.x-this->x)==0 &&sgn(b.y-this->y)==0;\n\t}\n};\nostream& operator<<(ostream& out,const Vec &b){\n    out<<\"(\"<<b.x<<\",\"<<b.y<<\")\";\n    return out;\n}\ntypedef Vec Point;\nstruct Line{\n    Point pos;\n    Vec dirc;\n    Line(Point pos=Point(0,0),Vec dirc=Vec(0,0)):pos(pos),dirc(dirc){}\n    static Line fromPoints(Point a,Point b){\n        return Line(a,b-a);\n    }\n    double getarea(const Line &b)const{\n        return abs(dirc.cross(b.dirc));\n    }\n    // 获得垂线\n    Line getppd(){\n        return Line(pos+dirc*0.5,dirc.rotate(PI/2));\n    }\n\n    //TODO: what will happen if they have no intersection,-nan\n    Point getintersection(const Line &b)const{\n        Vec down=this->pos-b.pos;\n        double aa=b.dirc.cross(down);\n        double bb=this->dirc.cross(b.dirc);\n        return this->pos+this->dirc*(aa/bb);\n    }\n\n    bool point_on_line(Point point){\n        if(!dirc.samed(point-pos))\n            return false;\n        if(sgn((point-pos).sqlen()-dirc.sqlen())>0)\n            return false;\n        return true;\n    }\n\n    bool on_ver(Point point){\n        if(sgn(point.x-pos.x)==0 && sgn(point.y-pos.y)==0)return true;\n        if(sgn(point.x-(pos.x+dirc.x))==0 && sgn(point.y-(pos.y+dirc.y))==0)return true;\n        return false;\n    }\n\n    double get_distance(Point point){\n        Line ppd=getppd();\n        ppd.pos=point;\n\n        Point intersection=getintersection(ppd);\n\n        ppd.dirc=intersection-point;\n        Vec v=intersection-pos;\n\n        return abs(v.cross(point-pos)/v.len());\n    }\n\n    double get_distance(Line line){\n        return get_distance(line.pos);\n    }\n};\n\nPoint points[3];\nLine triangle[3];\n\nchar game[MAXN][MAXN];\n\ndouble get_area(vector<Point> &points){\n    if(points.size()<3){\n        return -1;\n    }\n    sort(points.begin(),points.end(),[](const Point &a,const Point &b){\n        return a.polar()<b.polar();\n    });\n    Point base(0,0);\n    Point last=points[0];\n    double res=0;\n    for(int i=1;i<points.size();i++){\n        Vec a=last-base,b=points[i]-base;\n        res+=a.cross(b)/2;\n\n        last=points[i];\n    }\n    //add the last point(also the first point)\n    Vec a=last-base,b=points[0]-base;\n    res+=a.cross(b)/2;\n\n    return fabs(res);\n}\n\nbool in_triangle(Point p){\n    if(fuck)return false;\n\n    for(int i=0;i<3;i++){\n        if(Line::fromPoints(points[i%3],points[(i+1)%3]).point_on_line(p))return false;\n    }\n\n    double areas=0;\n    for(int i=0;i<3;i++){\n        vector<Point> ps;\n        ps.push_back(points[i%3]);\n        ps.push_back(points[(i+1)%3]);\n        ps.push_back(p);\n        areas+=get_area(ps);\n    }\n\n    vector<Point> ps;\n    for(int i=0;i<3;i++)ps.push_back(points[i]);\n    return sgn(areas-get_area(ps))==0;\n}\n\nbool has_intersetct(Line line){\n    if(fuck)return false;\n    int cnt=0; \n    Point p[3];\n    bool flg[3]={0,0,0};\n    for(int i=0;i<3;i++){\n        if(sgn(line.dirc.cross(triangle[i].dirc))==0)continue;\n        p[i]=line.getintersection(triangle[i]);\n        if(line.point_on_line(p[i])||p[i]==line.pos) flg[i]=1;\n    }\n    if(in_triangle(line.pos)) return true;\n    if(in_triangle(line.pos+line.dirc)) return true;\n    Line l;\n    if(flg[0]&&flg[1])\n    {\n\t\tl=Line::fromPoints(p[0],p[1]);\n\t    if(in_triangle(l.pos+l.dirc*0.5)) return true;\n    }\n    if(flg[2]&&flg[1])\n    {\n\t\tl=Line::fromPoints(p[2],p[1]);\n\t    if(in_triangle(l.pos+l.dirc*0.5)) return true;\n    }\n    if(flg[0]&&flg[2])\n    {\n\t\tl=Line::fromPoints(p[0],p[2]);\n\t    if(in_triangle(l.pos+l.dirc*0.5)) return true;\n    }\n    return false;\n}\n\nstruct v4q{\n    int i,j,step;\n    v4q(int i,int j,int step):i(i),j(j),step(step){}\n\n    bool operator<(const v4q &other)const{\n        return step>other.step;\n    }\n};\nint nlen;\nint dist[MAXN][MAXN];\nbool vis[MAXN][MAXN];\nint solve(){\n    priority_queue<v4q> pq;\n    pq.push(v4q(1,1,0));\n    memset(dist,0x3f,sizeof(dist));\n    memset(vis,0,sizeof(vis));\n    dist[1][1]=0;\n    while(!pq.empty()){\n        v4q cur=pq.top();pq.pop();\n\n        if(vis[cur.i][cur.j])continue;\n        vis[cur.i][cur.j]=1;\n\t\t//printf(\"now:%d %d\\n\",cur.i,cur.j);\n        for(int i=max(1,cur.i-1);i<=min(nlen,cur.i+1);i++){\n            for(int j=max(1,cur.j-1);j<=min(nlen,cur.j+1);j++){\n                if(i==cur.i && j==cur.j)continue;\n                if(game[i][j]=='#')continue;\n                if(has_intersetct(Line::fromPoints(Point(j-1,i-1),Point(cur.j-1,cur.i-1))))continue;\n               //cout<<\"arrive \"<<i<<\",\"<<j;\n                if(dist[i][j]>dist[cur.i][cur.j]+1){\n                    dist[i][j]=dist[cur.i][cur.j]+1;\n                    //cout<<\" and update it to \"<<dist[i][j];\n                    pq.push(v4q(i,j,dist[i][j]));\n                }\n                //cout<<endl;\n            }\n        }\n    }\n    return dist[nlen][nlen];\n}\n\n\nint main(){\n//\tfreopen(\"in.txt\",\"r\",stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n    while(cin>>nlen){\n    \tfuck=0;\n        for(int i=0;i<3;i++){\n            Point &p=points[i];\n            cin>>p.x>>p.y;\n        }\n\n        for(int i=0;i<3;i++){\n            triangle[i]=Line::fromPoints(points[i%3],points[(i+1)%3]);\n        }\n\n        for(int i=0;i<3;i++){\n            if(sgn(triangle[i%3].dirc.cross(triangle[(i+1)%3].dirc))==0){\n                fuck=1;\n            }\n        }\n\n        for(int i=nlen;i>=1;i--){\n            for(int j=1;j<=nlen;j++){\n                cin>>game[i][j];\n            }\n        }\n\n        //solve triangle\n        \n        for(int i=1;i<=nlen;i++){\n            for(int j=1;j<=nlen;j++){\n                if(in_triangle(Point(j-1,i-1)))game[i][j]='#';\n            }\n        }\n        \n        /*\n        for(int i=nlen;i>=1;i--){\n            for(int j=1;j<=nlen;j++){\n                cout<<game[i][j];\n            }\n            cout<<endl;\n        }\n        */\n        \n        \n\n        int ans=solve();\n        if(ans!=0x3f3f3f3f)cout<<ans<<\"\\n\";\n        else cout<<\"-1\\n\";\n    }\n\n    return 0;\n}\n```\n","tags":["计算几何"],"categories":["coding"]},{"title":"[CCPC2017杭州] Heathrock","url":"%2F2019%2F10%2F23%2Fproblem-hearthrock%2F","content":"这题意太长了，我懒得复制。\n\n## 分析\n\n额……其实就是爆搜模拟。但是状态比较多，需要记双方生命值，3个随从的生命，当前场数，魔力，体力，以及一些玄学优化。\n\n* 自选目标的牌一定会放在回合的较后出，因为其不会累加魔力。\n* 如果剩下的牌全踢脸也踢不死，直接返回。\n\n之后就能跑得飞快。\n\n<!--more-->\n\n{% asset_img \"1.png\" %}\n\n\n## 代码\n\n一开始输出了\"YES\"，淦。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\nusing namespace std;\nconst int MAXN=10;\nstruct Card{\n    int type;\n    int damage;\n    int cost;\n    int power;\n\n    Card(){}\n    Card(int type,int damage,int cost,int power):type(type),damage(damage),cost(cost),power(power){}\n} cards[MAXN];\nbool used[MAXN];\nint nlen;\nint md1,md2,md3;\nint mx1,mx2,mx3;\n\nstack<int> ans_cards,ans_target;\nbool dfs(int stone,int power,int bl_me,int bl_en,int m1,int m2,int m3,int depth,bool nearend=false){\n    if(stone<0)return false;\n    if(depth>=3)return false;\n    if(bl_en<=0)return true;\n\n    if(depth>=1 && stone==10){\n        if(m1>0)bl_me-=md1;\n        if(m2>0)bl_me-=md2;\n        if(m3>0)bl_me-=md3;\n\n        if(m1<=0)m1=mx1;\n        if(m2<=0)m2=mx2;\n        if(m3<=0)m3=mx3;\n    }\n    if(bl_me<=0)return false;\n\n    //full attacking to owner cannot kill it.\n    int fullattack=0;\n    int fakepower=power;\n    int unusd_lian=0;\n    for(int i=0;i<nlen;i++){\n        if(used[i])continue;\n        fakepower+=cards[i].power;\n        if(cards[i].type==1)continue;\n        unusd_lian++;\n        fullattack+=cards[i].damage;\n    }\n    if(fullattack+fakepower*(unusd_lian)<bl_en)return false;\n    \n\n    for(int i=0;i<nlen;i++){\n        if(used[i])continue;\n        const Card &card=cards[i];\n        int reald=card.damage+power;\n\n        if(card.cost>stone)continue;\n\n        used[i]=1;\n        if(!nearend && card.type==1){\n            if(stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1-reald,m2-reald,m3-reald,depth)){\n                ans_cards.push(i+1);\n                ans_target.push(-1);\n                return true;\n            }\n        }\n        if(!nearend && card.type==2){\n            if(stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en-reald,m1,m2,m3,depth)){\n                ans_cards.push(i+1);\n                ans_target.push(-1);\n                return true;\n            }\n        }\n        if(card.type==3){\n            if(stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en-reald,m1,m2,m3,depth,1)){\n                ans_cards.push(i+1);\n                ans_target.push(0);\n                return true;\n            }\n\n            if(m1>0 && stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1-reald,m2,m3,depth,1)){\n                ans_cards.push(i+1);\n                ans_target.push(1);\n                return true;\n            }\n\n            if(m2>0 && stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1,m2-reald,m3,depth,1)){\n                ans_cards.push(i+1);\n                ans_target.push(2);\n                return true;\n            }\n\n            if(m3>0 && stone-card.cost>=0 && dfs(stone-card.cost,power+card.power,bl_me,bl_en,m1,m2,m3-reald,depth,1)){\n                ans_cards.push(i+1);\n                ans_target.push(3);\n                return true;\n            }\n        }\n        used[i]=0;\n    }\n\n    if(dfs(10,0,bl_me,bl_en,m1,m2,m3,depth+1)){\n        ans_cards.push(-1);\n        ans_target.push(-1);\n        return true;\n    }\n\n    return false;\n}\nint mc1,mc2,mc3;\nint bl_me,bl_en;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);cout.tie(0);\n    int kase;cin>>kase;\n    while(kase--){\n        memset(used,0,sizeof(used));\n        while(!ans_cards.empty())ans_cards.pop();\n        while(!ans_target.empty())ans_target.pop();\n\n        cin>>nlen;\n        cin>>bl_me>>bl_en;\n\n        cin>>md1>>mc1>>mx1;\n        cin>>md2>>mc2>>mx2;\n        cin>>md3>>mc3>>mx3;\n        for(int i=0;i<nlen;i++){\n            cards[i].cost=cards[i].damage=cards[i].power=cards[i].type=0;\n            int type;cin>>type;\n            if(type==1 || type==2){\n                int cost,x,y;\n                cin>>cost>>x>>y;\n                cards[i].type=type;\n                cards[i].cost=cost;\n                cards[i].damage=x;\n                cards[i].power=y;\n            }else{\n                int cost,x;\n                cin>>cost>>x;\n                cards[i].type=type;\n                cards[i].cost=cost;\n                cards[i].damage=x;\n            }\n        }\n        ans_cards.push(-1);\n        ans_target.push(-1);\n        if(dfs(10,0,bl_me,bl_en,mc1,mc2,mc3,0)){\n            cout<<\"Yes\\n\";\n        }else{\n            cout<<\"No\\n\";\n            continue;\n        }\n        \n        int block=0;\n        while(!ans_cards.empty()){\n            queue<int> pack_ans,pack_target;\n            while(!ans_cards.empty() && ans_cards.top()!=-1){\n                pack_ans.push(ans_cards.top());\n                ans_cards.pop();\n                pack_target.push(ans_target.top());\n                ans_target.pop();\n            }\n\n            if(!ans_cards.empty()){\n                ans_cards.pop();\n                ans_target.pop();\n            }\n\n            if(pack_ans.empty())continue;\n\n            cout<<pack_ans.size()<<\"\\n\";\n            while(!pack_ans.empty()){\n                cout<<pack_ans.front()<<\" \";\n                pack_ans.pop();\n            }\n            cout<<\"\\n\";\n            while(!pack_target.empty()){\n                cout<<pack_target.front()<<\" \";\n                pack_target.pop();\n            }\n            cout<<\"\\n\";\n            block++;            \n        }\n        while(block<3){\n            cout<<\"0\\n\";\n            block++;\n        }\n    }\n\n    return 0;\n}\n```","tags":["模拟"],"categories":["coding"]},{"title":"[CCPC 2017] Master of Sequence","url":"%2F2019%2F10%2F21%2Fproblem-master-of-sequence%2F","content":"给出2个数列，$\\{a_i\\},\\{b_i\\}$.要求支持以下操作\n\n1. 修改数列a的第i个为x\n2. 修改数列b的第i个为x\n3. 给出k，求最小的t，满足$\\sum \\lfloor \\frac {t-b_i}{a_i} \\rfloor \\ge k$\n\n操作数不多于100000，操作3不多于1000；数列长度不多于10000，**a的值域不大于1000**。\n\n## 分析\n将$\\lfloor \\frac {t-b_i}{a_i} \\rfloor$拆开，观察前后可能出现的差。\n\n$$\n\\lfloor \\frac {t}{a_i} \\rfloor - \\lfloor \\frac {b_i}{a_i} \\rfloor\n$$\n\n设$t=k_1a_i+c_1,b_i=k_2a_i+c_2$，代入观察。\n\n$$\n\\begin{aligned}\n\\lfloor \\frac {t-b_i}{a_i} \\rfloor&=\\lfloor \\frac {(k_1-k_2)a_i+c_1-c_2}{a_i} \\rfloor \\\\\n\\end{aligned}\n$$\n\n可以发现，当把式子拆开时，有2种情况。\n\n* $c_1 > c_2$，啥事没有。\n* $c_1 < c_2$，拆开后会多统计一个1。\n\n事先统计$\\{b_i\\}$模$a$的余数，那么有$t$后就能快速数出第2种情况的数量。\n\n## 代码\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXA=1010,MAXB=100010;\n\nint nlen,mlen;\nint a[MAXB],acnt[MAXA];\nint b[MAXB];\n\nint fts[MAXA][MAXA];\nint pre[MAXA][MAXA];\n\nvoid force(int i){\n\tpre[i][0]=fts[i][0];\n\tfor(int j=1;j<MAXA;j++){\n\t\tpre[i][j]=pre[i][j-1]+fts[i][j];\n\t}\n}\n\nll base=0;\n\nbool check(ll k,ll t){\n\tll res=-base;\n\tfor(int i=1;i<=1000;i++){\n\t\tres+=(t/i)*acnt[i];\n\t\tint c=t%i;\n\t\tll offset=pre[i][1000]-pre[i][c];\n\t\tres-=offset;\n\t}\n\treturn res>=k;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\tint kase;cin>>kase;\n\twhile(kase--){\n\t\tmemset(acnt,0,sizeof(acnt));\n\t\tmemset(a,0,sizeof(a));\n\t\tbase=0;\n\t\tmemset(fts,0,sizeof(fts));\n\t\t\n\t\tcin>>nlen>>mlen;\n\t\tfor(int i=1;i<=nlen;i++){\n\t\t\tcin>>a[i];\n\t\t\tacnt[a[i]]+=1;\n\t\t}\n\t\tfor(int i=1;i<=nlen;i++){\n\t\t\tcin>>b[i];\n\t\t\tfts[a[i]][b[i]%a[i]]++;\n\t\t\tbase+=b[i]/a[i];\n\t\t}\n\t\tfor(int i=1;i<=1000;i++){\n\t\t\tforce(i);\n\t\t}\n\n\t\tfor(int i=1;i<=mlen;i++){\n\t\t\tint opt;\n\t\t\tcin>>opt;\n\t\t\tif(opt==1){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\n\t\t\t\tacnt[a[x]]--;\n\t\t\t\tfts[a[x]][b[x]%a[x]]--;\n\t\t\t\tbase-=b[x]/a[x];\n\t\t\t\tforce(a[x]);\n\n\t\t\t\ta[x]=y;\n\t\t\t\tfts[a[x]][b[x]%a[x]]++;\n\t\t\t\tacnt[a[x]]++;\n\t\t\t\tbase+=b[x]/a[x];\n\t\t\t\tforce(a[x]);\n\n\t\t\t\t\n\t\t\t}else if(opt==2){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\n\t\t\t\tfts[a[x]][b[x]%a[x]]--;\n\t\t\t\tbase-=b[x]/a[x];\n\t\t\t\tforce(a[x]);\n\n\t\t\t\tb[x]=y;\n\n\t\t\t\tfts[a[x]][b[x]%a[x]]++;\n\t\t\t\tforce(a[x]);\n\t\t\t\tbase+=b[x]/a[x];\n\t\t\t}else if(opt==3){\n\t\t\t\tint qk;cin>>qk;\n\t\t\t\tll l=0,r=1e13;\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tll mid=(l+r)/2;\n\t\t\t\t\tif(check(qk,mid)){\n\t\t\t\t\t\tr=mid;\n\t\t\t\t\t}else l=mid+1;\n\t\t\t\t}\n\t\t\t\tfor(ll i=l;i<=r;i++){\n\t\t\t\t\tif(check(qk,i)){\n\t\t\t\t\t\tcout<<i<<\"\\n\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```","categories":["coding"]},{"title":"玩一玩网络封包","url":"%2F2019%2F10%2F14%2Fdo-something-with-network-packets%2F","content":"这篇文章是为了在英语课presentation上口胡https准备的。打算在现场演示一次简易的网络攻击，顺便把时间水一水。所以在这时来先简单了解一下网络封包的样子。\n\n## OSI模型\n\n标准化的计算机通信模型，试图使各种计算机在世界范围内互连为网络的标准框架。\n\n简单的来说，就是将一次网络通信在不同层级上的抽象，并在不同层上实现功能，完成整个通信系统的构建。虽然看起来虚幻飘渺，我甚至还没学，但接下来的攻击是必须要弄清其是在哪一层面上的，要不然无从下手。\n\n> 待补充\n\n## ARP 污染\n\n这是这次主要开刀的对象，实现较为方便，演示效果也不错。\n\n在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。然而IP协议并不关心MAC地址，所以有必须再有一个底层的协议去将IP和MAC bind起来。ARP协议就是用来做这个的。\n\n当两个节点不在相同局域网时，则需要有网关中转，此时bind的MAC地址为网关MAC。ARP攻击的原理就是将自己伪装成网关，从而劫持整个局域网内的流量。而一旦拿到明文流量后，截取消息、获取密码、修改返回数据，都是可以的。\n\n## BetterCap\n\n新一代的“EtterCap”。本来我有点想那scapy来自己写一个工具来着，但是我的重点并不在这，相对现在来说有些耽误时间。\n\n第2个大版本的BetterCap为模块化设计，为了实现我们的目标，需要开启arp，net与proxy模块。arp负责进行投毒，net负责嗅探封包，我们使用proxy来获取修改封包的hook。搭配自己的js脚本就能快速达到目的。\n\n","categories":["闲扯"]},{"title":"[CFEDU74 E] Keyboard Purchase","url":"%2F2019%2F10%2F09%2Fproblem-keyboard-purchase%2F","content":"当在使用一指禅键入一个字符串的时候，你需要不停的移动手指。比如说输入“af”，手指需要跨过3个键（包括终点）输入“a”和“f”。\n\n针对一个经常输入的字符串，你可以定制一个长条键盘，使得在这个键盘上输入字符串需要移动的距离最短。\n\n给出字符串长度$n$与字典大小$k$（小写字母的前$k$个），给出最优情况下手指需要移动的距离。\n\n## 分析\n\n这道题和之前那道marbles很像……或者说状压都挺像的。\n\n<!--more-->\n\n题目即依次决定键盘的下一个按键装啥，并在原字符串里计算需要移动的次数。设$f(S)$表示已经考虑了集合$S$里所有的按键。不过仔细思考一下发现这个代价需要知道先前安装的按键的顺序，而这个顺序显然不能加入到状态里，这是无法接受的。必须要通过别的方式来计算。\n\n然后我又卡了。\n\n这是没见过的转移方式……考虑本轮没有排入键A，那么一定就**排入了别的键B**，那么，这次对于事件“排A”的**一次delay**会导致原串里A和相邻**在键盘上已确定位置的**字母间的转移多**一个**代价。\n\n有种模糊的感觉。之前那个题目是计算当前元素和已有元素之间的代价；这个是计算已有元素和未有元素之间的累进式代价。搞不太清楚这个$f(S)$现在代表的是什么了…不知可否有人指导。\n\n## 代码\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\nusing namespace std;\nusing ll=long long;\nconst int MAXK=21;\nint nlen,klen;\nstring inp;\n \nint cost[MAXK][MAXK];\nll dp[1<<20];\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin>>nlen>>klen;\n    cin>>inp;\n \n    for(int i=1;i<nlen;i++){\n        cost[inp[i-1]-'a'][inp[i]-'a']++;\n        cost[inp[i]-'a'][inp[i-1]-'a']++;\n    }\n \n \n    memset(dp,0x3f,sizeof(dp));\n    dp[0]=0;\n \n    for(int i=0;i<(1<<klen);i++){\n        ll scost=0;\n        for(int j=0;j<klen;j++){\n            if(!((i>>j)&1))continue;\n            for(int k=0;k<klen;k++){\n                if((i>>k)&1)continue;\n                scost+=cost[j][k];\n            }\n        }\n        for(int j=0;j<klen;j++){\n            if((i>>j)&1)continue;\n            dp[i|(1<<j)]=min(dp[i|(1<<j)],dp[i]+scost);\n        }\n    }\n \n    cout<<dp[(1<<klen)-1]<<endl;\n \n    \n \n    return 0;\n}\n```\n\n","tags":["动态规划"],"categories":["coding"]},{"title":"[CF EDU72D] Coloring Edges","url":"%2F2019%2F10%2F06%2Fproblem-coloring-edges%2F","content":"You are given a directed graph with n vertices and m directed edges without self-loops or multiple edges.\n\nLet's denote the k-coloring of a digraph as following: you color each edge in one of k colors. The k-coloring is good if and only if there no cycle formed by edges of same color.\n\nFind a good k-coloring of given digraph with minimum possible k.\n\n## 分析\n\n对我这个菜鸡来说，去染色返祖边的操作并不怎么显然……算了……\n\n没能坚持只有2种颜色的猜想。挂城墙。\n\n没必要挂代码。","tags":["瞎做"],"categories":["coding"]},{"title":"[CF585E] Marbles","url":"%2F2019%2F10%2F05%2Fproblem-marbles%2F","content":"Monocarp has arranged n colored marbles in a row. The color of the i-th marble is ai. Monocarp likes ordered things, so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment (and there is only one such segment for each color).\n\nIn other words, Monocarp wants to rearrange marbles so that, for every color j, if the leftmost marble of color j is l-th in the row, and the rightmost marble of this color has position r in the row, then every marble from l to r has color j.\n\nTo achieve his goal, Monocarp can do the following operation any number of times: choose two neighbouring marbles, and swap them.\n\nYou have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles. Note that the order of segments of marbles having equal color does not matter, it is only required that, for every color, all the marbles of this color form exactly one contiguous segment.\n\n## 分析\n\n这道题的翻译就是“重新确定每个颜色的权值，使得逆序对最少”。\n\n然后我就卡了，现在我也不是特别清楚为啥可以dp，只是知道能dp。\n\n选择状态$f(S)$表示集合$S$已经全部分配权值时产生的最少逆序对。枚举下一个颜色，给予下一个（较小）权值，并计算代价。\n\n$$\nf(S+\\{i\\})=min\\{f(S)+w\\}\n$$\n\n接下来是w的处理。我们需要的是在当前颜色的所有点前的**已经拥有新权值**的点数目，这可以事先预处理。预处理颜色i前颜色j的pair数即可。\n\n## 代码\n不小心把ptr扔到了里层循环里T了发…\n\n明明第一步完事都很直白了，就是非得被卡一下。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <stack>\n#include <cstring>\n#include <string>\nusing namespace std;\nusing ll=long long;\nconst int MAXN = 400010;\nconst int MAXC=21;\n \nint nlen;\nint num[MAXN];\nvector<int> pos[MAXC];\nll cnt[MAXC][MAXC];\nint tick=0;\nint newColor[MAXN];\n \nll dp[1<<MAXC];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n \n    cin>>nlen;\n    for(int i=0;i<nlen;i++){\n        cin>>num[i];\n    }\n    memset(newColor,-1,sizeof(newColor));\n    for(int i=0;i<nlen;i++){\n        if(newColor[num[i]]==-1)newColor[num[i]]=tick++;\n        pos[newColor[num[i]]].push_back(i);\n    }\n \n    for(int i=0;i<tick;i++){\n        for(int j=0;j<tick;j++){\n            if(i==j)continue;\n            int ptr=0;\n            for(int k=0;k<pos[i].size();k++){\n                if(ptr<0)ptr=0;\n                while(ptr<pos[j].size() && pos[j][ptr]<pos[i][k])ptr++;\n                ptr--;\n                if(ptr>=0 && pos[j][ptr]<pos[i][k]){\n                    cnt[i][j]+=ptr+1;\n                }\n            }\n        }\n    }\n \n \n    memset(dp,0x3f,sizeof(dp));\n    dp[0]=0;\n    for(int i=0;i<(1<<tick);i++){\n        for(int j=0;j<tick;j++){\n            if((i>>j)&1)continue;\n            ll diff=0;\n            for(int k=0;k<tick;k++){\n                if((i>>k)&1)diff+=cnt[j][k];\n            }\n            dp[i|(1<<j)]=min(dp[i|(1<<j)],dp[i]+diff);\n        }\n    }\n \n    cout<<dp[(1<<tick)-1]<<endl;\n \n    return 0;\n}\n```","tags":["动态规划"],"categories":["coding"]},{"title":"[CF585D] Ticket Game","url":"%2F2019%2F10%2F05%2Fproblem-ticket-game%2F","content":"Monocarp and Bicarp live in Berland, where every bus ticket consists of n digits (n is an even number). During the evening walk Monocarp and Bicarp found a ticket where some of the digits have been erased. The number of digits that have been erased is even.\n\nMonocarp and Bicarp have decided to play a game with this ticket. Monocarp hates happy tickets, while Bicarp collects them. A ticket is considered happy if the sum of the first $\\frac n2$ digits of this ticket is equal to the sum of the last $\\frac n2$ digits.\n\nMonocarp and Bicarp take turns (and Monocarp performs the first of them). During each turn, the current player must replace any erased digit with any digit from 0 to 9. The game ends when there are no erased digits in the ticket.\n\nIf the ticket is happy after all erased digits are replaced with decimal digits, then Bicarp wins. Otherwise, Monocarp wins. You have to determine who will win if both players play optimally.\n\n## 分析\n\n在做这道题的时候，我发现了实际上影响答案的只和两边的 已知数的和 以及未知位的数目有关，发现了获胜的根本是前后两部分和的差值大小，发现了先手的目的是**扩大差值**使得后手无法通过某种方式追赶。\n\n但是到这我就卡住了。淦，为什么我这么菜。\n\n接下来要考虑的是**优势**，在这道题里优势就是差值。先手的目的是扩大优势，在大的一边增大会加大优势，而在小的一边置0不会扩大优势；后手要**减小优势**，同样的办法就是在小的一侧置数来追赶另一侧，在大的一侧置0不会更好。\n\n那么，又可以得出先手扩大优势最好的办法是置9（最大）。那么游戏最开始的几步，就是双方在两侧填写9。直到某侧不再有空位。\n\n此时，如果空位在大的一侧，先手必赢。如果空位在小的一侧，继续讨论如下\n\n$$\nx_1+x_2+\\cdots+x_n=C\n$$\n\n首先$2|n$显然。\n\n当C不是9的倍数时，先手总有办法让最终结果偏离。因此该情况只有当$\\frac n2 \\times 9 = n$时后手才能获胜。\n\n## 代码\n\n嫖了队友的…我瞎xx搞的结论WA23了…\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nchar s[200005];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tint cnt=0;\n\tint sum=0;\n\tfor(int i=1;i<=n/2;i++)\n\t{\n\t\tif(s[i]=='?') cnt++;\n\t\telse sum+=s[i]-'0';\n\t}\n\tfor(int i=n/2+1;i<=n;i++)\n\t{\n\t\tif(s[i]=='?') cnt--;\n\t\telse sum-=s[i]-'0';\n\t}\n\t//cout<<cnt<<\" \"<<sum<<endl;\n\tif(sum*2==-cnt*9) puts(\"Bicarp\");\n\telse puts(\"Monocarp\");\n}\n```","tags":["博弈"],"categories":["coding"]},{"title":"后缀自动机","url":"%2F2019%2F10%2F04%2Fsuffix-automation%2F","content":"如你所见，后缀自动机。\n\n> 然而就nm看不懂，先看不懂它的图是啥，又看不懂它的边是啥，现在还是看不懂它的边是咋找出来的。可是咱不想搞不清楚它是干嘛的就直接用啊靠。\n\n后缀自动机首先是自动机。一个字符串S的后缀自动机能接受S的所有后缀。基于它的这个性质，它能够做到：\n\n* 查询子串是否出现：这显然跑一次，能在自动机上跑完就是出现过。\n* 统计不同子串的数量：自动机上每条不同的路径对应一个不同的子串。定义$d(x)$为以x为起点的路径数目，递推即可。\n* 计算所有不同子串的长度总和：得到上面的$d$。以x为起点，每条路径都会让子串**总**长度增加**路径个**。依然是递推。\n* 字典序第k小子串：当你有路径数了，只需要按照字典序对节点排序，然后像编码一样找。\n* 最小循环移位：指将原字符串首尾相接移位，找到字典序最小的一个。将字符串$S$断环成链$SS$，然后建立SAM，贪心找最小直到长度达到$|S|$即可。\n* 多组子串出现次数：dfs预处理每个节点的终点集合大小。在自动机上查找串$P$对应的节点,存在则答案为该节点的终点集合大小；不存在答案为$0$.\n* 所有出现位置：遍历树，一旦发现终点直接输出。\n\n## 建立\n\n最暴力的方式是建立一个O(n^2)级别的自动机，不过那个复杂度就没什么意义了。后缀自动机需要满足状态数最少，为线性级别，且转移（边）也为线性级别。\n\n然后，我们可以开始折腾了。\n\n定义串S的$endpos(x)$为一个集合，元素为x在其内出现的所有位置的结尾下标。\n\n## 资料\n\n* [参考资料](https://saisumit.wordpress.com/2016/01/26/suffix-automaton/)\n* 2015年国家集训队论文\n\n### 子串第一次出现的位置\n对SAM中所有状态预处理firstpos（第一次出现该状态的末端位置，也就是endpos集合的最小元素）。\n\n扩展源函数为`sam_extend()`。创建新状态`cur`时，令\n\n$$\nfirstpos(cur)=len(cur)-1\n$$\n\n当`q`复制到`clone`时，令\n\n$$\nfirstpos(clone)=firstpos(q)\n$$\n\n需要的答案就是$firstpos(t)-|P|+1$，$t$为字符串$P$的状态。每次查询需要$O(|P|)$\n\n### 最短未出现字符串\n动态规划。\n\n让$d_v$为节点$v$的答案。如果不存在使用字符集中至少一个字符的转移，那么$d_v=1$，否则\n\n$$\nd_v=1+\\min_{w:(v,w,c) \\in SAM} d_w\n$$\n\n字符串可以由转移推回去。\n\n","tags":["后缀自动机"],"categories":["study"]},{"title":"[CF589C] primes and multiplication","url":"%2F2019%2F09%2F30%2Fproblem-primes-and-multiplication%2F","content":"\n设$primes(x)$为x的质因数的集合。\n\n设$g(x,p)$表示可以整除x的最大的$p^k$。\n\n设$f(x,y)$表示将x作分解后对每个质因子作用到1到y上求$g$的乘积。\n\n求$f(x,n)$\n\n## 分析\n\n……最后你会发现，这题就是求阶乘质因子的乘积。\n\n## 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst int MAXN=1010;\nusing ll=long long;\nconst ll P=1e9+7;\n \nvector<ll> primes;\n \nvoid unpack(ll x){\n    ll b=x;\n    for(int i=2;i<=sqrt(b)+1;i++){\n        if(x%i==0)primes.push_back(i);\n        while(x%i==0)x/=i;\n    }\n    if(x!=1)primes.push_back(x);\n}\nll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(;b;b>>=1,a=a*a%p){\n        if(b&1)res=res*a%p;\n    }\n    return res;\n}\nll get(ll n,ll num){\n    ll res=0;\n    while(n){\n        res=(res+n/num)%(P-1);\n        n/=num;\n    }\n    return res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    ll x,n;cin>>x>>n;\n    unpack(x);\n \n    ll ans=1;\n    for(ll item:primes){\n        ans=ans*qpow(item,get(n,item),P)%P;\n    }\n    cout<<ans%P<<endl;\n \n    return 0;\n}\n```","tags":["数论"],"categories":["coding"]},{"title":"[CCPC2019 秦皇岛] Angel Beats","url":"%2F2019%2F09%2F29%2Fproblem-angel-beats%2F","content":"\n给出一些点，询问对于点$(x,y)$，求其能和已知点形成多少个直角三角形。\n\n## 分析\n\n首先，对于询问的点，直接加入集合离线操作就可以。这道题就变成了单纯的求三角形。一开始我跟求锐角三角形那道题一样做，然后写得又恶心又不知道哪里出了bug改不出来。\n\n后来，实际上可以事先直接枚举2点按照斜率统计边数，对每个查询$lg(n^2)$查询，会省很多事。\n\n之后的就是很显然的：查询点作为直角扫一遍，查询点作为非直角扫一遍。\n\n## 代码\n\n淦。\n\n```cpp\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\nconst int MAXN = 2010;\n\nstruct Point\n{\n    ll x, y;\n    Point(ll x, ll y) : x(x), y(y){};\n    Point(){}\n\n    Point normalize() const\n    {\n        if (x < 0 || (x == 0 && y < 0))\n            return Point(-x, -y);\n        return *this;\n    }\n\n    Point operator-(const Point &other) const\n    {\n        return Point(x - other.x, y - other.y);\n    }\n    bool operator<(const Point &other) const\n    {\n        //将线按照斜率排序，以在map中统计到一起。\n        Point a = normalize(), b = other.normalize();\n        return a.y * b.x < b.y * a.x;\n    }\n};\nusing Vec = Point;\n\nPoint origin[MAXN],queries[MAXN];\nint ans[MAXN];\nmap<Vec,int> mp;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int nlen, qlen;\n    while (cin >> nlen >> qlen)\n    {\n        memset(ans,0,sizeof(ans));\n        for (int i = 0; i < nlen; i++)\n        {\n            cin>>origin[i].x>>origin[i].y;\n        }\n        for (int i = 0; i < qlen; i++)\n        {\n            cin>>queries[i].x>>queries[i].y;\n        }\n\n        for (int i = 0; i < nlen; i++)\n        {\n            mp.clear();\n            for (int j = 0; j < nlen; j++)\n            {\n                if (i == j)\n                    continue;\n                Vec temp = origin[j] - origin[i];\n                mp[temp]++;\n            }\n            for (int j = 0; j < qlen; j++)\n            {\n                Vec temp = queries[j] - origin[i];\n                ans[j] += mp[Vec(-temp.y, temp.x)];\n            }\n        }\n        /*\n        cout<<\"====not====\"<<endl;\n        for(int i=0;i<qlen;i++){\n            cout<<ans[i]<<\"\\t\";\n        }\n        cout<<endl<<\"====not====\"<<endl;\n        */\n\n        for (int i = 0; i < qlen; i++)\n        {\n            mp.clear();\n            for (int j = 0; j < nlen; j++)\n            {\n                Vec temp = origin[j] - queries[i];\n                ans[i] += mp[Vec(-temp.y, temp.x)];\n                mp[temp]++;\n            }\n        }\n\n        for (int i = 0; i < qlen; i++)\n        {\n            cout << ans[i] << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n```\n","tags":["计算几何"],"categories":["coding"]},{"title":"音乐盒测试","url":"%2F2019%2F09%2F27%2Ftest-music-player%2F","content":"\n我还没搞明白为什么在首页上没法加载，看起来是插件内部有bug。\n\n就拿东方的同人BGM来做个测试吧。\n\n{% aplayer \"万年置き傘にご注意を\" \"k-waves LAB\" \"k-waves.m4a\" \"music.jpg\" %}","categories":["闲扯"]},{"title":"Rust学习记录","url":"%2F2019%2F09%2F24%2Flearning-rust%2F","content":"\n基于对Rust的浅薄理解，它一定是未来一门重要的语言。因此，为了进一步了解这哥们，对Rust的学习将逐步展开。\n\n## 参考资料\n\n1. [Rust The Book学习心得](https://rustlang-cn.org/users/book-exp/)\n2. [Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/index.html)\n3. Rust编程之道（实体书）\n\n第一个资源来自国内一dalao，偏读书笔记；第二个则有些有趣，它在使用rust完成一系类列表的过程中进行rust的教学。\n\n*目前进度：慢速阅读第二项中*\n\n## 内存模型\n\n梳理一下现存的内存管理模型。大致上分为两种：\n\n1. GC，例如Java与C#\n2. 自行管理，例如c++\n\n这两种技术各有利弊。Rust提供了一种不同于以上两种办法的内存模型，所属权模型。一个内存有它的归属，对某个变量的读写需要涉及“借出”“还回”，又由此诞生“生命周期”的概念。通过这套系统，Rust实现了**安全且无代价的内存管理办法**。\n\n### 所有权\n\n* Rust中变量默认不可变。\n\n变量在rust中，还有着所有权的概念。\n\n* 当变量以传值方式传播，那么原有的所有权将会**移动**给新的变量名，原有变量名作废。\n* 变量可以创建只读引用，并用于传递。只读引用可以有多个。\n* 变量可以创建读写引用。只能有一个。\n* 只读与读写引用不可同时存在。\n\n这样就从根源上解决了一些问题，例如多线程读写可能出现的各种问题。不过还是不是很清楚这种情况下要如何实现原本的功能。\n\n### 生命周期\n\n想象这样一种情况，“创建一个链表的迭代器”。一个必要的问题是确保使用迭代器时**其所指向的链表没有出现问题**（例如被销毁）。\n\n在function的层级中，rustc能够自动推导出变量的传递关系与其*最小*生命周期。而程序上升到结构、架构、API上后，继续推导生命周期就不是很好做到，可能会耗费大量编译时间与资源。此时，让使用者主动标记生命周期会更有效率。尽管此时可能无法达到*最小*的目标。\n","tags":["rust"],"categories":["study"]},{"title":"[CF1221F] Choose a Sequence","url":"%2F2019%2F09%2F23%2Fproblem-choose-a-sequence%2F","content":"\nPetya recently found a game \"Choose a Square\". In this game, there are nn points numbered from 11 to nn on an infinite field. The ii-th point has coordinates (xi,yi) and cost ci.\n\nYou have to choose a square such that its sides are parallel to coordinate axes, the lower left and upper right corners belong to the line y=x, and all corners have integer coordinates.\n\nThe score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square. Note that the length of the side can be zero.\n\nPetya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square.\n\n{% asset_img a.png %}\n\n## 分析\n\n这道题其实和多校的Snowy Smile（题文无关）挺像的。\n\n<!--more-->\n\n需要转化条件。正方形全部位于坐标系第一象限的平分线上，可以表示为$(l,r)$这种形式。一个在正方形内的点$(x,y)$(假设$x < y$,由于这个题目的特性，不满足时可以直接调换)满足的条件为\n\n$$l \\leq x \\leq y \\leq r$$\n\n由此，这道题就变成了二维偏序。本来的本来，上个长得像树状数组一类的东西就解决了。\n\n将点按照第一维排序，从大到小枚举，在数据结构中维护结尾到r的前缀和最大值，并查询，更新全局答案。不过这个题目还要求权值要减去正方形边长w。\n\n$$f(r)-(r-l)=l+[f(r)-r]$$\n\n维护最大值，y分开，只在pushup时合在一起。\n\n然后还要离散化……\n\n## 代码\n\n这题给我整自闭了，我想用线段树单点修改来魔幻维护我需要的数据，加加减减。结果发现2种维护方式都有无法解决的问题。最后只能打tag。\n\n线段树维护$f(n)$为到$n$为止的前缀和。每次加点以$x$为组，对已有点减去新增线段的长度，再加上新点的影响。那么在线段树上维护的就是答案。取出最大值即可。\n\n代码写得又长又丑，不过过了。\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=500010*4;\n\nll tag[MAXN];\nll dMax[MAXN];\nint dy[MAXN];\nint lc[MAXN],rc[MAXN],idx=0;\nvoid build(int &n,int l,int r){\n    if(!n)n=++idx;\n    dy[n]=r;\n    if(l>=r){\n        tag[n]=0;\n        return;\n    }\n\n    int mid=(l+r)/2;\n    build(lc[n],l,mid);\n    build(rc[n],mid+1,r);\n}\nvoid pushdown(int n,int l,int r){\n    if(!tag[n])return;\n    tag[lc[n]]+=tag[n];\n    tag[rc[n]]+=tag[n];\n    dMax[lc[n]]+=tag[n];\n    dMax[rc[n]]+=tag[n];\n\n    tag[n]=0;\n}\nvoid collect(int n){\n    if(dMax[lc[n]]>dMax[rc[n]]){\n        dMax[n]=dMax[lc[n]];\n        dy[n]=dy[lc[n]];\n    }else{\n        dMax[n]=dMax[rc[n]];\n        dy[n]=dy[rc[n]];\n    }\n}\nvoid modify(int l,int r,int x,int L,int R,int n){\n    if(l<=L && R<=r){\n        tag[n]+=x;\n        dMax[n]+=x;\n        return;\n    }\n    pushdown(n,L,R);\n\n    int mid=(L+R)/2;\n    if(l<=mid)modify(l,r,x,L,mid,lc[n]);\n    if(mid<r)modify(l,r,x,mid+1,R,rc[n]);\n    collect(n);\n}\n\nbool operator<(const pair<ll,int> &a,const pair<ll,int> &b){\n    return a.first<b.first;\n}\n\npair<ll,int> query(int l,int r,int L,int R,int n){\n    if(l<=L && R<=r){\n        return make_pair(dMax[n],dy[n]);\n    }\n    pushdown(n,L,R);\n    \n    int mid=(L+R)/2;\n    pair<ll,int> res=make_pair(-0x3f3f3f3f,0);\n    if(l<=mid)res=max(res,query(l,r,L,mid,lc[n]));\n    if(mid<r)res=max(res,query(l,r,mid+1,R,rc[n]));\n\n    return res;\n}\nstruct Point{\n    int x,y,w;\n} points[MAXN];\nvector<int> nums;\nint root=0;\nint main(){\n    /*\n    build(root,1,10);\n    int opt;\n    while(cin>>opt){\n        if(opt==1){\n            int l,r,x;cin>>l>>r>>x;\n            modify(l,r,x,1,10,root);\n        }\n        if(opt==2){\n            int l,r;cin>>l>>r;\n            cout<<query(l,r,1,10,root).first<<\" \"<<query(l,r,1,10,root).second<<endl;\n        }\n    }\n    */\n    \n\n    int nlen;cin>>nlen;\n\n    for(int i=1;i<=nlen;i++){\n        Point &p=points[i];\n        cin>>p.x>>p.y>>p.w;\n        if(p.x>p.y)swap(p.x,p.y);\n        nums.push_back(p.y);\n        nums.push_back(p.x);\n    }\n    sort(nums.begin(),nums.end());\n    auto rit=unique(nums.begin(),nums.end());\n    for(int i=1;i<=nlen;i++){\n        points[i].x=lower_bound(nums.begin(),rit,points[i].x)-nums.begin();\n        points[i].y=lower_bound(nums.begin(),rit,points[i].y)-nums.begin();\n    }\n\n    sort(points+1,points+1+nlen,[](const Point &a,const Point &b){\n        if(a.x!=b.x)return a.x>b.x;\n        return a.y<b.y;\n    });\n\n    int len=rit-nums.begin()-1;\n    build(root,0,len);\n    vector<int>::iterator lastit=rit-1;\n    pair<ll,int> ans=make_pair(-0x3f3f3f3f,0);\n    int pairl=-0x3f3f3f3f;\n    for(int i=1;i<=nlen;i++){\n        int thisx=points[i].x;\n        //auto it=lower_bound(nums.begin(),rit,points[i].x);\n        auto it=nums.begin()+thisx;\n        for(;lastit!=it;lastit--){\n            modify(lastit-nums.begin(),len,*(lastit-1)-*lastit,0,len,root);\n            //cout<<\"cost \"<<*(lastit-1)-*lastit<<\" from \"<<lastit-nums.begin()<<\" to \"<<len<<endl;\n        }\n        /*\n        for(int j=0;j<=len;j++){\n            cout<<query(j,j,0,len,root).first<<\"\\t\";\n        }\n        cout<<endl;\n        */\n        while(i<=nlen && points[i].x==thisx){\n            const Point &p=points[i];\n            modify(p.y,len,p.w,0,len,root);\n            //cout<<\"add \"<<p.w<<\" from \"<<p.y<<\" to \"<<len<<endl;\n            i++;\n        }\n        i--;\n        /*\n        for(int j=0;j<=len;j++){\n            auto temp2=query(j,j,0,len,root);\n            cout<<temp2.first<<\",\"<<temp2.second<<\"\\t\";\n        }\n        cout<<endl;\n        */\n\n        pair<ll,int> temp=query(0,len,0,len,root);\n        if(ans<=temp){\n            ans=temp;\n            pairl=nums[thisx];\n        }\n    }\n\n    if(ans.first>0){\n        cout<<ans.first<<endl;\n        cout<<pairl<<\" \"<<pairl<<\" \"<<nums[ans.second]<<\" \"<<nums[ans.second]<<endl;\n    }else{\n        cout<<0<<endl;\n        cout<<*nums.rbegin()+1<<\" \"<<*nums.rbegin()+1<<\" \"<<*nums.rbegin()+1<<\" \"<<*nums.rbegin()+1<<endl;\n    }\n    return 0;\n}\n```","tags":["线段树"],"categories":["coding"]},{"title":"来康康Gatsby.js","url":"%2F2019%2F09%2F21%2Fstarting-gatsbyjs%2F","content":"\n昨天发现notion用学生邮箱可以免费领personal plan，所以非常开心的玩了一会。东西确实挺不错的。\n\n* 完善的附件管理，包括图片，pdf，excel等\n* 并不太喜欢的block编辑方式，还是更喜欢markdown\n* 不错的风格\n* 强大的database\n* 不错的内容链接\n* 各种embed\n* 垃圾数学公式编辑，为啥编辑框不能换行\n\n既然排版效果很好……这玩意，能不能做成个人博客。\n\n去github上搜了一发，居然真的有，名字叫gine-blog。\n\n## 已有项目初探\n研究了这个小巧的项目之后，有些激动。它使用了目前很新的几个技术（相比Hexo等传统生成器）。\n\n* webpack\n* react\n* graphql\n\n实际上，这些主要都来自另一个项目`Gatsby.js`，意在使用新技术快速构建网站。它能够汇总数据，使用graphql为react提供内容，并将内容固化，产生能够离开后端运行的纯网页。\n\n非常适合作为个人博客生成使用。\n\n之后我便忘了最开始的目的。\n\n## 好像少了些什么\n生成的方式似乎没有什么问题了，不过好像少了些什么。\n\ngine-blog项目从notion拉取脏数据经过复杂处理填充到react中……作者实现了一个爬虫去从notion的网页上爬取源码…\n\n\n\n我部署试了一下这个blog，效果还可以，也有些bug。比如bookmark丢失url，作者的文档新旧有些分不清楚。还是继续坚持hexo。\n\n~~不过，这个`gatsby.js`有一些意思，可以研究一下。~~\n\n## 关于blog\n\n仔细思考了一下，相比于选择什么主题，选择什么模板，选择什么技术，这些都是次要的事情。最重要的是填充在里面的内容。所以这个事情就先这么放下了，如果要开始的话，有一系列的东西都需要学习，和我现在要干的事情有些冲突。\n\n听说学长们在搞新的oj，给我的锅实际上很小，不需要负多大责任。那么oj也可以暂时放一放了。\n\nblog继续维持使用hexo。\n\n也许未来的哪天，会回来尝试一下使用rust+那时候的前端技术来构造一个不知道是什么的项目。","tags":["gatsby"],"categories":["闲扯"]},{"title":"使用Mathematica绘制股票相关曲线","url":"%2F2019%2F09%2F20%2Fstock-with-mathematica%2F","content":"\nMathematica是个好东西。虽然早有耳闻功能强大，但是没想到强大到这种地步。\n\n原本因为课程原因，研究了一下如何在Mathematica里绘制股票数据。不过现在**停止**，只完成了一小部分。剩下的……想折腾的话，按照已经有的代码，能容易改出来其他功能。\n\n## 数据来源\n\n首先要说的是，Mathematica中**自行提供**了非权威的金融数据。这对我们很方便。\n\n使用命令`FinancialData`,就可以获取大量需要的数据。具体可以查看文档。不过问题是，不知何种原因，该函数对深沪股票支持很差，所以在实际使用时，并不能直接使用该函数，比较可惜……\n\n我们需要实现自己的数据处理。\n\n经过一番寻找后，我发现了一个基于Python的证券数据平台`baostock`。经过简单的封装后，Mathematica就可以使用Python从平台上拉取数据了。\n\n这个例子只能拉取日K。\n\n```mathematica\n\nBeginPackage[\"StockLink`\"]\n\nStockLink::usage=\"StockLink\";\nCloseLink::usage=\"CloseLink\";\n\nDailyKLine::usage=\"Get KLine data\";\n\nCandlestickData::usage=\"adjust KLine data to fit Candlestick Chart\";\nTradingChartData::usage=\"adjust KLine data to fit Trading Chart\";\n\nBegin[\"`Private`\"]\n\nStockLink[]:=Module[{conn},\nconn=StartExternalSession[\"Python\"];\nExternalEvaluate[conn,\"\nimport baostock as bs\nlg=bs.login()\n\"];\nconn\n];\n\nCloseLink[conn_]:=Module[{},\nExternalEvaluate[conn,\"\nbs.logout()\n\"];\nDeleteObject[conn];\n];\n\nMMAListToPythonList[list_]:=StringReplace[ToString[list,InputForm],{\"\\\" \"->\"'\",\"{\"->\"[\",\"}\"->\"]\"}];\nDateObjectToStr[date_]:=DateString[date,\"ISODate\"];\n\nDailyKLine[conn_,code_,startDate_,endDate_]:=Module[{},\nraw=ExternalEvaluate[conn,\nStringTemplate[\"\nrs = bs.query_history_k_data_plus('``',\n    'date,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,isST',\n    start_date='``', end_date='``',\n    frequency='d', adjustflag='3')\ndata_list = {}\nwhile (rs.error_code == '0') & rs.next():\n    temp=rs.get_row_data()\n    data_list[temp[0]]=temp[1:];\ndata_list\"][code,DateObjectToStr[startDate],DateObjectToStr[endDate]]];\nToExpression[#]& /@ raw\n];\n\nCandlestickData[raw_]:=Table[{DateObject[key],raw[key][[1;;4]]},{key,Keys[raw]}];\nTradingChartData[raw_]:=Table[{DateObject[key],raw[key][[1;;5]]},{key,Keys[raw]}];\n\nEnd[]\n\nEndPackage[]\n```\n\n## 图表绘制\n\n在实际使用时，首先需要导入该库，并且初始化链接后，灵活组合各部分功能即可。\n\n```mathematica\n<< (NotebookDirectory[] <> \"StockLink.wl\");\nconn = StockLink[];\n\n(:例如获取某个日期区间内的数据并转化，绘制交互图标:)\nDailyKLine[conn, \"ss.000001\", Today, Today] // TradingChartData // InteractiveTradingChart\n```\n\n输入日期时，可以直接按`ctrl+=`，在框中描述时间，比较方便。\n\n## 可能遇到的问题\n\n如果python配置不对的话，可能会出现Mathematica找不到python。问题的解决方法在官方文档上非常清晰。\n\n不过我不折腾股票，就这样了。","tags":["mathematica"],"categories":["闲扯"]},{"title":"一些筛法的题","url":"%2F2019%2F09%2F05%2Fsome-sieves%2F","content":"\n\n## 技巧\n\n### 自然溢出\n\n* 自然溢出不会影响低位数据,所以有的时候你不需要取模,而是一个unsigned.\n\n### 除法取模\n对于式子\n\n$$\n\\frac {a \\times b}{c} \\mod p \\equiv \\frac{a \\times b \\mod cp}{c}\n$$\n\n\n\n## 细节\n* 注意数据类型,例如`6*(ll)(1<<30)`是要出问题的\n* 注意函数在$f(1)$位置的取值,不要忘记初始化\n\n## Divisor\n\nGiven $n$ and $m$ ($1 \\leq n,m \\leq 5 \\times 10^4$),  please calculate\n\n<!--more-->\n\n### 分析\n下面所有的除法都是舍去小数的整除.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) &= \\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}[p \\perp q] \\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d|(p,q)}\\mu(d) \\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{p|i}\\sum_{q|j}\\sum_{d}\\mu(d)[d|p][d|q] \\\\\n&=\\sum_d \\mu(d)\\sum_{i=1}^n\\sum_{j=1}^m \\sum_{pd} \\sum_{qd}[pd|i][qd|j] \\\\\n&=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd}\\sum_{i=1}^{n/pd}\\sum_{j=1}^{m/qd} \\\\\n&=\\sum_d \\mu(d) \\sum_{pd} \\sum_{qd} \\frac n {pd}\\frac m {qd} \\\\\n&=\\sum_d \\mu(d) \\sum_p^{n/d} \\frac n {pd} \\sum_q^{m/d} \\frac m {qd} \\\\\n\\end{aligned}\n$$\n\n设$S(n)=\\sum_{1\\leq i \\leq n} \\frac n i$\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^m \\sigma_0(ij) &=\\sum_d \\mu(d)S(n/d)S(m/d)\n\\end{aligned}\n$$\n\n$n/d$的取值在一个区间中是相同的,因此可以把这个求和公式分块计算.(在分块后,需要获知该段区域内$\\mu$的和,所以需要求前缀和)由于$n/d$的取值为$O(\\sqrt n)$的级别,因此在知道$S$的值的情况下,每个询问可以这个复杂度中计算出来.\n\n对于$\\mu$,使用筛法,并求出其前缀和.\n\n对于$S$,直接暴力计算.\n\n### 代码\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50010;\n\nbool isn_p[MAXN];\nvector<int> primes;\nint mu[MAXN];\nint premu[MAXN];\nvoid init_prime(int len){\n    isn_p[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=len;i++){\n        if(!isn_p[i]){\n            primes.push_back(i);\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=len;j++){\n            isn_p[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n    premu[0]=0;\n    for(int i=1;i<=len;i++)premu[i]=premu[i-1]+mu[i];\n}\n\n\nll S[MAXN];\nvoid init_S(int len){\n    for(int i=1;i<=len;i++){\n        for(int l=1,r;l<=i;l=r+1){\n\t        //remember this line\n            r=i/(i/l);\n            S[i]+=(ll)(r-l+1)*(i/l);\n        }\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    init_prime(50000);\n    init_S(50000);\n    int kase;cin>>kase;\n    while(kase--){\n        int n,m;cin>>n>>m;\n        ll ans=0;\n        // the minimum one will fastly approach to 0, leading the extra parts of bigger one do nothing to the answer.\n        int minn=min(n,m);\n        for(int l=1,r;l<=minn;l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ans+=S[n/l]*S[m/l]*(premu[r]-premu[l-1]);\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n```\n\n## table\n给出多组$n,m,a$,求\n\n$$\n\\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j))[\\sigma_1((i,j)) \\geq a]\n$$\n\n### 分析\n> 这道题让谁都能看出来重点是如何处理条件\n>\n> $$[\\sigma_1((i,j)) \\geq a]$$\n\n可是这我显然不知道该怎么做.\n\n对询问作以$a$从小到大离线处理,询问前先处理新增$a$的影响.\n\n在已经满足条件的前提下对公式作化简.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1((i,j)) &= \\sum_d \\sum_{i=1}^n \\sum_{j=1}^m \\sigma_1(d)[(i,j)=d] \\\\\n&=\\sum_d \\sum_{i\\leq \\frac nd}\\sum_{j\\leq \\frac md}\\sigma_1(d)[(i,j)=1] \\\\\n&=\\sum_d \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}}\\sigma_1(d) \\sum_t \\mu(t) \\\\\n&=\\sum_d \\sum_t \\mu(t) \\sigma_1(d)  \\sum_{i\\leq \\frac n{td}}\\sum_{j\\leq \\frac m{td}} 1 \\\\\n&=\\sum_T \\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor \\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)\n\\end{aligned}\n$$\n\n可以看到还是套路,引入d,引入$\\mu$,之后胡乱化简.\n\n按照这个式子,需要计算的就是$g(x)=\\sum_{d|T}\\mu(t)\\sigma_1(\\frac Td)$的前缀和.\n\n接下来是如何处理条件...\n\n当$a$每扩大一点,就有一部分$\\mu(t)\\sigma_1(\\frac Td)$被加入到函数$g$的各个部分.使用一种数据结构来维护$g$的前缀和,例如树状数组.$a$最大到,每次受到影响的就是$d$的倍数,以此可以计算出总的时间复杂度为\n\n$$\nWTF\n$$\n\n至此,问题就解决了.\n\n### 代码\n又丑又长.\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cassert>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=100010;\nconst int MAXQ=100010;\nconst int MAXFT=400010;\nconst ll P=(ll)1<<31;\n\n\nll FT[MAXFT];\nll lowbit(int x){\n    return x&-x;\n}\nvoid ftadd(int pos,ll x){\n    for(int i=pos;i<MAXN;i+=lowbit(i)){\n        FT[i]=(FT[i]+x);\n    }\n}\nll ftget(int pos){\n    ll res=0;\n    for(int i=pos;i;i-=lowbit(i)){\n        res=(res+FT[i]);\n    }\n    return res;\n}\n\nll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(b;b;b>>=1,a=(a*a)%p){\n        if(b&1)res=(res*a)%p;\n    }\n    return res;\n}\nll qpow(ll a,ll b){\n    ll res=1;\n    for(b;b;b>>=1,a=(a*a)){\n        if(b&1)res=(res*a);\n    }\n    return res;\n}\n\nbool is_np[MAXN];\nll sigma[MAXN],mu[MAXN];\nint t[MAXN];\nvector<int> primes;\nstruct Sig{\n    ll sigma;\n    int x;\n    Sig(){}\n    Sig(int x,ll sigma):x(x),sigma(sigma){}\n};\nvector<Sig> sigma_vec;\n\nvoid init(int n){\n    is_np[1]=1;\n    sigma[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=n;i++){\n        if(!is_np[i]){\n            primes.push_back(i);\n            sigma[i]=i+1;\n            t[i]=1;\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            is_np[i*primes[j]]=1;\n            sigma[i*primes[j]]=sigma[i]*sigma[primes[j]];\n            t[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                t[i*primes[j]]=t[i]+1;\n                sigma[i*primes[j]]=sigma[i/qpow(primes[j],t[i])]*((ll)1-qpow(primes[j],(t[i]+1)+1))/(1-primes[j]);\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++){\n        sigma_vec.push_back(Sig(i,sigma[i]));\n    }\n}\n\nstruct Q{\n    int n,m,a;\n    int i;\n    ll ans;\n    bool operator<(const Q &b)const{\n        return a<b.a;\n    }\n} qs[MAXQ];\n\nll f(int n){\n    return ftget(n);\n}\n\nint curidx=0;\nvoid mergea(int newa){\n    for(;curidx<sigma_vec.size();curidx++){\n        Sig &sig=sigma_vec[curidx];\n        if(sig.sigma>newa)break;\n        for(int i=sig.x;i<MAXN;i+=sig.x){\n            ftadd(i,mu[i/sig.x]*sig.sigma%P);\n        }\n    }\n}\n\nint main(){\n    init(100000);\n    sort(sigma_vec.begin(),sigma_vec.end(),[](Sig &a,Sig &b){\n        return a.sigma<b.sigma;\n    });\n\n    int qlen;cin>>qlen;\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        scanf(\"%d%d%d\",&q.n,&q.m,&q.a);\n        q.i=i;\n    }\n    sort(qs,qs+qlen,[](Q &a,Q &b){\n        return a.a<b.a;\n    });\n\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        int n=q.n,m=q.m,a=q.a;\n        ll &ans=q.ans=0;\n        mergea(a);\n        for(int l=1,r;l<=min(n,m);l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ans=ans+(n/l)*(m/l)*(f(r)-f(l-1));\n        }\n        \n    }\n    sort(qs,qs+qlen,[](Q &a,Q &b){\n        return a.i<b.i;\n    });\n    for(int i=0;i<qlen;i++){\n        printf(\"%lld\\n\",qs[i].ans%P);\n    }\n    return 0;\n}\n```\n\n## product\n定义斐波纳妾(?)(linux这输入法够魔性)函数$f(x)$\n\n求\n\n$$\n\\prod_{i=1}^n \\prod_{j=1}^m f((i,j))\n$$\n\n### 分析\n首先,先引个$d$是没错了.\n\n但是\n\n这道题,我又不会.我不知道该怎么处理$\\prod$...蔡就完事了.\n\n现在来看,当引入一个$d$后,在该求积公式里出现了相同项相乘.将该部分的计算调整为幂,剩下的就又都一样了.\n\n$$\n\\begin{aligned}\n\\prod_{i=1}^n \\prod_{j=1}^m f((i,j)) &= \\prod_d f(d)^{\\sum_{i\\leq n} \\sum_{j \\leq m} [(i,j)=d]} \\\\\n&=\\prod_d f(d)^{\\sum_{i\\leq \\frac nd} \\sum_{j \\leq \\frac md} [(i,j)=1]} \\\\\n&=\\prod_d f(d)^{\\sum_t \\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\\n&=\\prod_d \\prod_t f(d)^{\\mu(t) \\sum_{i\\leq \\frac n{td}} \\sum_{j \\leq \\frac m{td}} 1 } \\\\\n&=\\prod_T (\\prod_{d|T}  f(d)^{\\mu(\\frac Tt)})^{\\lfloor \\frac nT \\rfloor \\lfloor \\frac mT \\rfloor }\n\\end{aligned}\n$$\n\n设$g(x)=\\prod_{d|T}  f(d)^{\\mu(\\frac Tt)}$,求前缀和就完事了.\n\n> 这道题需要使用**欧拉定理**来优化求幂的速度.\n\n### 欧拉定理\n当$(a,p)=1$,有以下式子\n\n$$\na^b \\equiv a^{b \\mod \\phi(p)} \\pmod p\n$$\n\n当$(a,p)\\neq 1$,有扩展欧拉定理\n\n$$\na^b \\equiv a^{b \\mod \\phi(p)+ \\phi(p)} \\pmod p\n$$\n\n根据这2个式子,可以在快速降幂,来加快运算.\n\n### 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=1000010;\nconst ll P=1e9+7;\n\ninline ll qpow(ll a,ll b,ll p){\n    ll res=1;\n    for(;b;b>>=1,a=a*a%p){\n        if(b&1)res=res*a%p;\n    }\n    return res;\n}\n\ninline ll get_inv(ll a,ll p){\n    return qpow(a,p-2,p);\n}\n\nbool is_np[MAXN];\nvector<int> primes;\nll f[MAXN], g[MAXN];\nll inv_f[MAXN];\nll preg[MAXN],inv_pg[MAXN];\nll mu[MAXN];\nvoid init(int n){\n    is_np[1]=1;\n    mu[1]=1;\n    for(int i=2;i<=n;i++){\n        if(!is_np[i]){\n            primes.push_back(i);\n            mu[i]=-1;\n        }\n\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            is_np[i*primes[j]]=1;\n            mu[i*primes[j]]=mu[i]*-1;\n\n            if(i%primes[j]==0){\n                mu[i*primes[j]]=0;\n                break;\n            }\n        }\n    }\n\n    f[1]=f[2]=1;\n    for(int i=3;i<=n;i++){\n        f[i]=(f[i-1]+f[i-2])%P;\n    }\n    for(int i=1;i<=n;i++){\n        inv_f[i]=get_inv(f[i],P);\n    }\n\n    for(int i=1;i<=n;i++)g[i]=1;\n    for(int i=1;i<=n;i++){\n        for(int j=i;j<=n;j+=i){\n            if(mu[j/i]==-1)g[j]=(g[j]*inv_f[i])%P;\n            else if(mu[j/i]==1)g[j]=(g[j]*f[i])%P;\n            //when mu==0,nothing happens\n        }\n    }\n    preg[0]=1;\n    for(int i=1;i<=n;i++)preg[i]=preg[i-1]*g[i]%P;\n    inv_pg[0]=1;\n    for(int i=1;i<=n;i++)inv_pg[i]=get_inv(preg[i],P)%P;\n}\n\nint main(){\n    init(1000000);\n    //cout<<\"done\"<<endl;\n    /*\n    \n    for(auto i:primes){\n        cout<<i<<\" \";\n    }\n    cout<<endl;\n    \n    for(int i=1;i<=20;i++){\n        cout<<g[i]<<\" \";\n    }\n    cout<<endl;\n    */\n    \n\n    int kase;\n    scanf(\"%d\",&kase);\n    while(kase--){\n        ll n,m;\n        scanf(\"%d%d\",&n,&m);\n        if(n>m)swap(n,m);\n\n        ll ans=1;\n        for(ll l=1,r;l<=n;l=r+1){\n            r=min(n/(n/l),m/(m/l));\n            ll sum=preg[r]*inv_pg[l-1]%P;\n            ans=ans*qpow(sum,(n/l)*(m/l)%(P-1),P)%P;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n## phi3\n给出$n$,求\n\n$$\n(\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n \\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)} \\phi((i,j,k))) \\mod 2^{30}\n$$\n\n### 分析\n这道题重点在于\n\n$$\\frac {\\phi(i)\\phi(j^2)\\phi(k^3)}{\\phi(i)\\phi(j)\\phi(k)}$$\n\n这堆东西的化简.很显然,我又不会.\n\n观察$\\phi(n)$的公式\n\n$$\n\\phi(n)=n\\prod_i(1-\\frac 1{\\phi(i)})\n$$\n\n可以得出上面那一堆等于$jk^2$.剩下的就又都一样了.\n\n$$\n\\begin{aligned}\n\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi((i,j,k)) &=\\sum_d\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n jk^2 \\phi(d)[(i,j,k)=d] \\\\\n&=\\sum_d \\sum_{t} \\phi(d) \\mu(t) t^3d^3 \\sum_{i\\leq \\frac n{td}}\\sum_{j \\leq \\frac n{td}}\\sum_{k \\leq \\frac n{td}} jk^2 \\\\\n&=\\sum_T \\sum_{i\\leq \\frac nT}\\sum_{j \\leq \\frac nT} j\\sum_{k \\leq \\frac nT}k^2 (T^3 \\sum_{d|T} \\phi(d) \\mu(\\frac Td))\n\\end{aligned} \n$$\n\n设$g(n)=\\sum_{d|T} \\phi(d) \\mu(\\frac Td)$,直接筛.最后计算前缀和的时候再乘上$n^3$就可以了.\n\n> 这道题的取模还有这种处理方法: 直接取数组为`unsigned`并自然溢出.**二进制后30位**不会受到影响.\n\n### 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\nusing ull=unsigned long long;\nusing ll=long long;\nconst int MAXN=10000010;\nconst unsigned P=1<<30;\n\nbool isnp[MAXN];\nvector<int> primes;\nint t[MAXN],M[MAXN];\nunsigned Mt[MAXN];\nunsigned g[MAXN];\nll preg[MAXN];\n\nvoid init(int n){\n    isnp[1]=1;\n    g[1]=1;\n\n    for(int i=2;i<=n;i++){\n        if(!isnp[i]){\n            primes.push_back(i);\n            g[i]=i-1-1;\n\n            t[i]=1;\n            M[i]=Mt[i]=i;\n        }\n        for(int j=0;j<primes.size() && i*primes[j]<=n;j++){\n            int newone=i*primes[j];\n            isnp[newone]=1;\n            g[newone]=g[i]*g[primes[j]]%P;\n            t[newone]=1;\n            M[newone]=Mt[newone]=primes[j];\n            if(i%primes[j]==0){\n                t[newone]=t[i]+1;\n                Mt[newone]=Mt[i]*primes[j]%P;\n                \n                g[newone]=g[i/Mt[i]]*(Mt[newone]+Mt[i]/primes[j]-2*Mt[i])%P;\n                break;\n            }\n        }\n    }\n\n    for(int i=1;i<=n;i++){\n        preg[i]=preg[i-1]+(ll)i*i%P*i%P*g[i]%P;\n        preg[i]%=P;\n    }\n}\n\nint main(){\n    init(10000000);\n\n    int kase;\n    scanf(\"%d\",&kase);\n    while(kase--){\n        int n;\n        scanf(\"%d\",&n);\n        ll ans=0;\n        for(int l=1,r;l<=n;l=r+1){\n            r=n/(n/l);\n            ull lim=n/l;\n            ull sum1=lim*(lim+1)%(2*P)/2;\n            ull sum2=lim*(lim+1)%(6*P)*(2*lim+1)%(6*P)/6;\n            ans=ans+lim*sum1%P*sum2%P*(preg[r]-preg[l-1])%P;\n        }\n        printf(\"%lld\\n\",ans%P);\n    }\n    return 0;\n}\n```","tags":["筛法"]},{"title":"[HDU 6704] Kth Occurrence","url":"%2F2019%2F08%2F25%2Fproblem-kth-occurrence%2F","content":"\n\nYou are given a string S consisting of only lowercase english letters and some queries.\n\nFor each query (l,r,k), please output the starting position of the k-th occurence of the substring SlSl+1...Sr in S.\n\n## 分析\n第一个问题是快速找出所有出现的子串的位置,可以使用后缀数组.这些字串出现在sa的一个连续的区间中.\n\n<!--more-->\n\n第二个问题是找出这些出现位置中的第k大,可以使用主席树,以sa建树.\n\n\n## 代码\n思路清晰,但这代码它不好写\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\nconst int MAXN=100060;\nusing ull=unsigned long long;\n\nint n;\nint sa[MAXN], x[MAXN], c[MAXN], y[MAXN];\nchar a[MAXN];\n\ninline void SA()\n{\n    int m = 128;\n    for (int i = 0; i <= m; i++)\n        c[i] = 0;\n    for (int i = 1; i <= n; i++)\n        c[x[i]]++;\n    for (int i = 1; i <= m; i++)\n        c[i] += c[i - 1];\n    for (int i = n; i; i--)\n        sa[c[x[i]]--] = i;\n\n    for (int k = 1, p; k <= n; k <<= 1)\n    {\n        p = 0;\n        for (int i = n; i > n - k; i--)\n            y[++p] = i;\n        for (int i = 1; i <= n; i++)\n            if (sa[i] > k)\n                y[++p] = sa[i] - k;\n\n        for (int i = 0; i <= m; i++)\n            c[i] = 0;\n        for (int i = 1; i <= n; i++)\n            c[x[i]]++;\n        for (int i = 1; i <= m; i++)\n            c[i] += c[i - 1];\n        for (int i = n; i; i--)\n            sa[c[x[y[i]]]--] = y[i];\n\n        p = y[sa[1]] = 1;\n        for (int i = 2, a, b; i <= n; i++)\n        {\n            a = sa[i] + k > n ? -1 : x[sa[i] + k];\n            b = sa[i - 1] + k > n ? -1 : x[sa[i - 1] + k];\n            y[sa[i]] = (x[sa[i]] == x[sa[i - 1]]) && (a == b) ? p : ++p;\n        }\n        swap(x, y);\n        m = p;\n    }\n}\n\nint tot;\nint sum[(MAXN << 5) + 10], rt[MAXN + 10], ls[(MAXN << 5) + 10],\n    rs[(MAXN << 5) + 10];\n\nint build(int l, int r) //建树\n{\n    int root = ++tot;\n    if (l == r)\n        return root;\n    int mid = l + r >> 1;\n    ls[root] = build(l, mid);\n    rs[root] = build(mid + 1, r);\n    return root; //返回该子树的根节点\n}\nint update(int k, int l, int r, int root) //插入操作\n{\n    int dir = ++tot;\n    ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + 1;\n    if (l == r)\n        return dir;\n    int mid = l + r >> 1;\n    if (k <= mid)\n        ls[dir] = update(k, l, mid, ls[dir]);\n    else\n        rs[dir] = update(k, mid + 1, r, rs[dir]);\n    return dir;\n}\n//left root, right root, querying l,r, the k-th\nint query(int u, int v, int l, int r, int k) //查询操作\n{\n    int mid = l + r >> 1,\n        x = sum[ls[v]] - sum[ls[u]]; //通过区间减法得到左儿子的信息\n    if (l == r){\n        return l;\n    }\n    if (k <= x) //说明在左儿子中\n        return query(ls[u], ls[v], l, mid, k);\n    else //说明在右儿子中\n        return query(rs[u], rs[v], mid + 1, r, k - x);\n}\n\nint height[MAXN];\nint st[20][MAXN];\ninline void get_height() {\n    int k = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (x[i] == 1) continue;\n        if (k) --k;\n        int j = sa[x[i] - 1];\n        while (j + k <= n && i + k <= n && a[i + k] == a[j + k]) ++k;\n        height[x[i]] = k;\n    }\n}\nvoid build_st() {\n    for (int i = 1; i <= n; i++) st[0][i] = height[i];\n    for (int k = 1; k <= 19; k++) {\n        for (int i = 1; i + (1 << k) - 1 <= n; i++) {\n            st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 << k - 1)]);\n        }\n    }\n}\nint lcp(int ll, int rr) {\n    int l = x[ll], r = x[rr];\n    if (l > r) swap(l, r);\n    if (l == r) return n - sa[l]+1;\n    int t = log2(r - l);\n    return min(st[t][l + 1], st[t][r - (1 << t) + 1]);\n}\n\nint main(){\n    int kase;cin>>kase;\n    while(kase--){\n        int nlen,qlen;cin>>nlen>>qlen;\n        scanf(\"%s\",a+1);\n        for(int i=0;i<MAXN;i++)x[i]=a[i];\n        n=nlen;\n        SA();\n        n=nlen;\n\n        get_height();\n        build_st();\n        \n        /*\n        for(int i=1;i<=nlen;i++)cout<<sa[i]<<\" \";\n        cout<<endl;\n        for(int i=1;i<=nlen;i++)cout<<x[i]<<\" \";\n        cout<<endl;\n        */\n\n        tot=0;\n        memset(sum,0,sizeof(sum));\n        rt[0] = build(1, nlen);\n        for (int i = 1; i <= n; ++i)\n            rt[i] = update(sa[i], 1, nlen, rt[i - 1]);\n\n        while(qlen--){\n            int ql,qr,qk;\n            scanf(\"%d%d%d\",&ql,&qr,&qk);\n            int sublen=qr-ql+1;\n\n            int ex_l,ex_r;\n            //binary search\n            {\n                int l=1,r=x[ql];\n                while(r-l>1){\n                    int mid=(l+r)/2;\n                    if(lcp(sa[mid], ql) >= sublen){\n                        r=mid;\n                    }else l=mid+1;\n                }\n                for(l;l<=r;l++){\n                    if(lcp(sa[l], ql) >= sublen){\n                        ex_l=l;\n                        break;\n                    }\n                }\n            }\n            {\n                int l=x[ql],r=nlen;\n                while(r-l>1){\n                    int mid=(l+r)/2;\n                    if(lcp(sa[mid], ql) >= sublen){\n                        l=mid;\n                    }else r=mid-1;\n                }\n                for(r;r>=l;r--){\n                    if(lcp(sa[r], ql) >= sublen){\n                        ex_r=r;\n                        break;\n                    }\n                }\n            }\n            //cout<<ex_l<<\" \"<<ex_r<<endl;\n            if(ex_r-ex_l+1<qk){\n                cout<<-1<<endl;\n            } else cout<<query(rt[ex_l - 1], rt[ex_r], 1, nlen, qk)<<endl;\n        }\n    }\n\n    return 0;\n}\n```\n\n\n","tags":["RMQ"],"categories":["coding"]},{"title":"记一个bug (HDU 6703)","url":"%2F2019%2F08%2F24%2Fa-wonderful-bug%2F","content":"\nYou are given an array a1,a2,...,an(∀i∈[1,n],1≤ai≤n). Initially, each element of the array is **unique**. \n\nMoreover, there are m instructions. \n\nEach instruction is in one of the following two formats: \n\n1. (1,pos),indicating to change the value of apos to apos+10,000,000; \n2. (2,r,k),indicating to ask the minimum value which is **not equal** to any ai ( 1≤i≤r ) and **not less ** than k. \n\nPlease print all results of the instructions in format 2. \n\n## 分析\n这题强制在线.首先1操作相当于删除了这个数.\n\ndalao自闭了一会get到了它的正确做法,我就直接拿来用了.\n\n维护一权值线段树,位置i存其在a中出现的位置.那么当1到r区间内出现位置的最大值超过了r,根据鸽巢原理,至少有一个数未被限制.\n\n加上不小于k的条件,就是k到r中,找到最小的一个r,使得它满足上面的条件,输出这个r.\n\n## 代码\n一个奇葩的bug...\n\n当使用了fread这种先读完缓冲区再处理的快速读入而删漏了cin时...会显而易见的遇到bug.\n\n但是,因为缓冲区的存在,**小范围数据被快乐的读入了缓冲区,cin并不会实际影响什么**.一旦遇到大范围数据,cin提前读入了接下来的数据,导致第一个缓冲区之外的数据全部出错...\n\n艹.\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst int MAXN = 400000;\n\nnamespace IO\n{\nconst int MAXSIZE = 1 << 20;\nchar buf[MAXSIZE], *p1, *p2;\n#define gc()                                                                 \\\n    (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\\n         ? EOF                                                               \\\n         : *p1++)\ninline int rd()\n{\n    int x = 0, f = 1;\n    char c = gc();\n    while (!isdigit(c))\n    {\n        if (c == '-')\n            f = -1;\n        c = gc();\n    }\n    while (isdigit(c))\n        x = x * 10 + (c ^ 48), c = gc();\n    return x * f;\n}\nchar pbuf[1 << 20], *pp = pbuf;\ninline void push(const char &c)\n{\n    if (pp - pbuf == 1 << 20)\n        fwrite(pbuf, 1, 1 << 20, stdout), pp = pbuf;\n    *pp++ = c;\n}\ninline void write(int x)\n{\n    static int sta[35];\n    int top = 0;\n    do\n    {\n        sta[top++] = x % 10, x /= 10;\n    } while (x);\n    while (top)\n        push(sta[--top] + '0');\n}\n} // namespace IO\n///////////////////////////////////////////////////////////////////////////////////////\n\nint dat[MAXN];\nint a[MAXN];\nint lc[MAXN], rc[MAXN], idx = 0;\n\ninline int imax(int a,int b){\n    if(a>b)return a;\n    return b;\n}\nvoid collect(int n)\n{\n    dat[n] = max(dat[lc[n]], dat[rc[n]]);\n}\n\nint build(int &n, int l, int r)\n{\n    if (!n)\n        n = ++idx;\n    dat[n] = a[l];\n    if (l == r)\n        return dat[n];\n    int mid = (l + r) / 2;\n    return dat[n] = imax(build(lc[n], l, mid), build(rc[n], mid + 1, r));\n}\n\nvoid modify(int x, int l, int r, int L, int R, int n)\n{\n    if (l <= L && R <= r)\n    {\n        dat[n] = x;\n        return;\n    }\n    int mid = (L + R) / 2;\n    if (l <= mid)\n        modify(x, l, r, L, mid, lc[n]);\n    if (mid < r)\n        modify(x, l, r, mid + 1, R, rc[n]);\n\n    collect(n);\n}\n\nint query(int l, int r,int target, int L, int R, int n)\n{\n    if(L>r || R<l || dat[n]<=target)return -1;\n    if(L==R)return L;\n\n    int mid = (L + R) / 2;\n    int res=query(l,r,target,L,mid,lc[n]);\n    return ~res?res:query(l,r,target,mid+1,R,rc[n]);\n}\nint root;\nint num[MAXN];\nint main()\n{\n    int kase=IO::rd();\n    while (kase--)\n    {\n        int nlen, qlen;\n        nlen=IO::rd();\n        qlen=IO::rd();\n        for (int i = 1; i <= nlen; i++)\n        {\n            num[i] = IO::rd();\n            a[num[i]] = i;\n        }\n        build(root, 1, nlen);\n        int lastans = 0;\n        while (qlen--)\n        {\n            int opt=IO::rd();\n            if (opt == 1)\n            {\n                int pos=IO::rd();\n                pos ^= lastans;\n                if(num[pos]==0 || num[pos]>nlen)continue;\n                modify(0x3f3f3f3f, num[pos], num[pos], 1, nlen, root);\n            }\n            else\n            {\n                int t2, t3;\n                t2=IO::rd();\n                t3=IO::rd();\n                //cin >> t2 >> t3;\n                int r = t2 ^ lastans, k = t3 ^ lastans;\n\n                int t=query(k,nlen,r,1,nlen,root);\n                cout<<(lastans=(~t?t:nlen+1))<<endl;\n            }\n        }\n    }\n    return 0;\n}\n```","tags":["线段树"],"categories":["coding"]},{"title":"OJ的后端","url":"%2F2019%2F08%2F22%2Fsandbox-reef%2F","content":"\n内容有复制和参考。\n\n这篇文章主要用于记录在探索评测系统Reef期间我所学的东西,以便之后查阅.\n\nReef预计主要支持远程评测\n\n加一点本地评测.....\n\n<!--more-->\n\n结果主要的东西都特么是本地评测的.\n\n## 总体架构\nReef预计将采用seccomp作为第一道安全关卡,使用多线程检测程序耗时/内存等信息.\n\n在外层使用docker封装并再次限制资源,接入队列以能够方便的横向扩展.\n\n## seccomp\nseccomp为linux系统上才有的安全技术,因此必须使用linux.在安装必要的安装包后\n\n```bash\n$ sudo apt install libseccomp2 libseccomp-dev seccomp\n```\n\n即可使用.\n\n当然,在windows下的Jobs似乎也可以利用,但是我不太懂,微软文档写得也奇怪,而且还得是服务器版本的windows才能用.\n\n### 基本使用\nseccomp需要由程序主动加载.其使用方法基本为下\n\n```cpp\n//g++ -g test.c -o o -lseccomp\n#include <unistd.h>\n#include <seccomp.h>\n#include <linux/seccomp.h>\n\nint main(void){\n\t//初始化筛选器\n\tscmp_filter_ctx ctx;\n\tctx = seccomp_init(SCMP_ACT_ALLOW);//flag指明默认通过\n\t//添加拦截,并指明一旦拦截就将程序kill掉.\n\tseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);\n\t//将规则加载注入.\n\tseccomp_load(ctx);\n\n\tchar * filename = \"/bin/sh\";\n\tchar * argv[] = {\"/bin/sh\",NULL};\n\tchar * envp[] = {NULL};\n\twrite(1,\"i will give you a shell\\n\",24);\n\t//程序将会在此行崩溃.\n\tsyscall(59,filename,argv,envp);//execve\n\treturn 0;\n}\n```\n\nseccomp_init是初始化的过滤状态,这里用的是SCMP_ACT_ALLOW,表示默认允许所有的syscacll.如果初始化状态为SCMP_ACT_KILL,则表示默认不允许所有的syscall.\n\n```cpp\n/**\n * Kill the process\n */\n#define SCMP_ACT_KILL\t\t0x00000000U\n/**\n * Throw a SIGSYS signal\n */\n#define SCMP_ACT_TRAP\t\t0x00030000U\n/**\n * Return the specified error code\n */\n#define SCMP_ACT_ERRNO(x)\t(0x00050000U | ((x) & 0x0000ffffU))\n/**\n * Notify a tracing process with the specified value\n */\n#define SCMP_ACT_TRACE(x)\t(0x7ff00000U | ((x) & 0x0000ffffU))\n/**\n * Allow the syscall to be executed after the action has been logged\n */\n#define SCMP_ACT_LOG\t\t0x7ffc0000U\n/**\n * Allow the syscall to be executed\n */\n#define SCMP_ACT_ALLOW\t\t0x7fff0000U\n```\n\n规则添加\n```cpp\n/**\n * Add a new rule to the filter\n * @param ctx the filter context\n * @param action the filter action\n * @param syscall the syscall number\n * @param arg_cnt the number of argument filters in the argument filter chain\n * @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended)\n *\n * This function adds a series of new argument/value checks to the seccomp\n * filter for the given syscall; multiple argument/value checks can be\n * specified and they will be chained together (AND'd together) in the filter.\n * If the specified rule needs to be adjusted due to architecture specifics it\n * will be adjusted without notification.  Returns zero on success, negative\n * values on failure.\n *\n */\nint seccomp_rule_add(scmp_filter_ctx ctx,\n\t\t     uint32_t action, int syscall, unsigned int arg_cnt, ...);\n```\n\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);,arg_cnt为0,表示直接限制execve,不管他什么参数.\n\n如果arg_cnt不为0,那arg_cnt表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截syscall.\n\n```\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write),1,SCMP_A2(SCMP_CMP_EQ,0x10));//第2(从0)个参数等于0x10\n```\n\n```cpp\n/**\n * Specify an argument comparison struct for use in declaring rules\n * @param arg the argument number, starting at 0\n * @param op the comparison operator, e.g. SCMP_CMP_*\n * @param datum_a dependent on comparison\n * @param datum_b dependent on comparison, optional\n */\n#define SCMP_CMP(...)\t\t((struct scmp_arg_cmp){__VA_ARGS__})\n\n/**\n * Specify an argument comparison struct for argument 0\n */\n#define SCMP_A0(...)\t\tSCMP_CMP(0, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 1\n */\n#define SCMP_A1(...)\t\tSCMP_CMP(1, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 2\n */\n#define SCMP_A2(...)\t\tSCMP_CMP(2, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 3\n */\n#define SCMP_A3(...)\t\tSCMP_CMP(3, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 4\n */\n#define SCMP_A4(...)\t\tSCMP_CMP(4, __VA_ARGS__)\n\n/**\n * Specify an argument comparison struct for argument 5\n */\n#define SCMP_A5(...)\t\tSCMP_CMP(5, __VA_ARGS__)\n\n\n\n/**\n * Comparison operators\n */\nenum scmp_compare {\n\t_SCMP_CMP_MIN = 0,\n\tSCMP_CMP_NE = 1,\t\t/**< not equal */\n\tSCMP_CMP_LT = 2,\t\t/**< less than */\n\tSCMP_CMP_LE = 3,\t\t/**< less than or equal */\n\tSCMP_CMP_EQ = 4,\t\t/**< equal */\n\tSCMP_CMP_GE = 5,\t\t/**< greater than or equal */\n\tSCMP_CMP_GT = 6,\t\t/**< greater than */\n\tSCMP_CMP_MASKED_EQ = 7,\t\t/**< masked equality */\n\t_SCMP_CMP_MAX,\n};\n\n/**\n * Argument datum\n */\ntypedef uint64_t scmp_datum_t;\n\n/**\n * Argument / Value comparison definition\n */\nstruct scmp_arg_cmp {\n\tunsigned int arg;\t/**< argument number, starting at 0 */\n\tenum scmp_compare op;\t/**< the comparison op, e.g. SCMP_CMP_* */\n\tscmp_datum_t datum_a;\n\tscmp_datum_t datum_b;\n};\n```\n\nctx的内容可以使用函数dump出来,之后可以直接使用prctl命令相关直接载入,方便使用?\n\n### seccomp调试\n\n使用如下命令导出所有可能的命令\n```bash\nfile=syscall-names.h\necho \"static const char *syscall_names[] = {\" > $file\necho \"#include <sys/syscall.h>\" | cpp -dM | grep '^#define __NR_' | LC_ALL=C sed -r -n -e 's/^\\#define[ \\t]+__NR_([a-z0-9_]+)[ \\t]+([0-9]+)(.*)/ [\\2] = \"\\1\",/p' >> $file\necho \"};\" >> $file\n```\n\n使用如下代码导出一段代码所需要的权限.遵循最小权限原则,试验代码运行所需要的最少权限.\n```cpp\n#define __USE_GNU 1\n#define _GNU_SOURCE 1\n#include <signal.h>\n#include <sys/prctl.h>\n#include <linux/types.h>\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n#include <seccomp.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"syscall-names.h\"\n#if defined(__i386__)\n#define REG_RESULT\tREG_EAX\n#define REG_SYSCALL\tREG_EAX\n#define REG_ARG0\tREG_EBX\n#define REG_ARG1\tREG_ECX\n#define REG_ARG2\tREG_EDX\n#define REG_ARG3\tREG_ESI\n#define REG_ARG4\tREG_EDI\n#define REG_ARG5\tREG_EBP\n#elif defined(__x86_64__)\n#define REG_RESULT\tREG_RAX\n#define REG_SYSCALL\tREG_RAX\n#define REG_ARG0\tREG_RDI\n#define REG_ARG1\tREG_RSI\n#define REG_ARG2\tREG_RDX\n#define REG_ARG3\tREG_R10\n#define REG_ARG4\tREG_R8\n#define REG_ARG5\tREG_R9\n#endif\n#ifndef SYS_SECCOMP\n#define SYS_SECCOMP 1\n#endif\n\nconst char *const msg=\"system call invalid: \";\n\nstatic void write_uint(char *buf, unsigned int val)\n{\n    int width = 0;\n    unsigned int tens;\n    if (val == 0) {\n        strcpy(buf, \"0\");\n        return;\n    }\n    for (tens = val; tens; tens /= 10)\n        ++ width;\n    buf[width] = '\\0';\n    for (tens = val; tens; tens /= 10)\n        buf[--width] = (char) ('0' + (tens % 10));\n}\nstatic void helper(int nr, siginfo_t *info, void *void_context) {\n    char buf[255];\n    ucontext_t *ctx = (ucontext_t *)(void_context);\n    unsigned int syscall;\n    if (info->si_code != SYS_SECCOMP)\n        return;\n    if (!ctx)\n        return;\n    syscall = (unsigned int) ctx->uc_mcontext.gregs[REG_SYSCALL];\n    strcpy(buf, msg);\n    if (syscall < sizeof(syscall_names)) {\n        strcat(buf, syscall_names[syscall]);\n        strcat(buf, \"(\");\n    }\n    write_uint(buf + strlen(buf), syscall);\n    if (syscall < sizeof(syscall_names))\n        strcat(buf, \")\");\n    strcat(buf, \"\\n\");\n    write(STDOUT_FILENO, buf, strlen(buf));\n    _exit(1);\n}\nstatic int install_helper() {\n    struct sigaction act;\n    sigset_t mask;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGSYS);\n    act.sa_sigaction = &helper;\n    act.sa_flags = SA_SIGINFO;\n    if (sigaction(SIGSYS, &act, NULL) < 0) {\n        perror(\"sigaction\");\n        return -1;\n    }\n    if (sigprocmask(SIG_UNBLOCK, &mask, NULL)) {\n        perror(\"sigprocmask\");\n        return -1;\n    }\n    return 0;\n}\n\n#include <stdio.h>\nint main(){\n\tif(install_helper()){\n\t\tprintf(\"install helper failed\");\n\t\treturn 1;\n\t}\n\n\tscmp_filter_ctx ctx = NULL;\n\tctx = seccomp_init(SCMP_ACT_ALLOW);\n\n\tseccomp_rule_add(ctx, SCMP_ACT_TRAP, SCMP_SYS(execve), 0);\n\tseccomp_load(ctx);\n\tseccomp_release(ctx);\n\tfprintf(stdout, \"something to stdout\\n\");\n\tchar * filename = \"/bin/sh\";\n\tchar * argv[] = {\"/bin/sh\",NULL};\n\tchar * envp[] = {NULL};\n\twrite(1,\"i will give you a shell\\n\",24);\n\tsyscall(59,filename,argv,envp);//execve\n\n\treturn 0;\n}\n```\n\n### 注入程序\n刚刚提到了seccomp必须由程序主动加载,因此需要有一个办法将代码注入到用户的代码中.\n\n> 等待完成\n\n### 其他语言\n这玩意貌似至少能方便的用在c系语言,java和python上.\n\n## Docker\n准备使用Docker重构整个OJ\n\n### 多阶段构建\n使用Docker,将OJ分解为多个阶段来构建.\n\n1. 前端构建\n2. 后端构建\n3. 运行环境构建与代码整合\n4. nginx构建\n\n#### 命令\n```Dockerfile\n#...\n\n# 使用php作为基础,指明该构建阶段为codeisland\nFROM php:alpine as codeisland\n# 在容器打包阶段安装数据库驱动\nRUN docker-php-ext-install pdo pdo_pgsql\n\nARG PATH=/app/laravel\n\n# 从其他阶段复制代码到本阶段\nCOPY --from=DELETED /app/ ${PATH}\n\n# 执行其他初始化命令\n# [DELETED]\n\n# 指明容器的工作路径\nWORKDIR ${PATH}\n\n#...\n```\n\n### 容器协调\n使用Docker-compose来协调各个容器的关系.\n\n* 数据库容器\n* redis容器\n* 网站后端容器\n* 评测器容器\n* 评测代理容器\n* nginx容器\n\n限制评测器容器的资源消耗的例子\n\n```yml\ndeploy:\n  resources:\n    limits:\n      cpus: '0.50'\n      memory: 1024M\n```\n\n### 网络\n...学校网关的登录状态根本没法维持,卡死.\n","tags":["code island"],"categories":["闲扯"]},{"title":"[FZU 2204]Seven","url":"%2F2019%2F08%2F10%2Fproblem-seven%2F","content":"\nn个有标号的球围成一个圈。每个球有两种颜色可以选择黑或白染色。问有多少种方案使得没有出现连续白球7个或连续黑球7个。\n\n对方案数mod 2015，球最多有100000个。\n\n# 分析\n考虑对于非环状球的答案计算，可以设$sum(i,k)$表示第i个球为k色时的方案数。其计算非常显然\n\n$$\nsum(i,k)=\\sum_{1\\leq j \\leq 6}{sum(i-j,1-k)}\n$$\n\n接下来考虑收尾相接后需要排除的情况，即收尾同色球长度相加超过6的情况，这可以直接枚举。\n\n首取i个末取j个同色，从答案中删除此时剩下球的方案数，注意剩下的球的首末球颜色**不能**和已经枚举的颜色同色。鉴于这种要求，我们退回到sum的递推公式处，决定sum的边界条件为首个球固定为黑色，这样就能很方便的确定球的颜色，且根据对称性答案可以直接x2得到。\n\n题就做完了。\n\n# 代码\n> 淦，为什么当时没写。\n\n```cpp\n#include <iostream>\nusing namespace std;\nconst int MAXN=100010;\nconst int P=2015;\n\nint sum[MAXN][2];\nint main(){\n    int kase;cin>>kase;\n    sum[0][1]=1;\n    for(int i=1;i<=100000;i++){\n        for(int j=1;j<=min(i,6);j++){\n            (sum[i][1]+=sum[i-j][0])%=P;\n            (sum[i][0]+=sum[i-j][1])%=P;\n        }\n    }\n    sum[0][1]=0;\n    int cnt=0;\n    while(kase--){\n        int nlen;cin>>nlen;\n        int ans=(sum[nlen][0]+sum[nlen][1])%P;\n        if(nlen>=7)\n            for(int i=1;i<=6;i++)\n                for(int j=1;j<=6;j++)\n                    if(i+j>=7 && nlen-i-j>=0)\n                        ans=(ans-sum[nlen-i-j][0])%P;\n        cout<<\"Case #\"<<++cnt<<\": \"<<((ans*2)%P+2015)%P<<endl;\n    }\n    return 0;\n}\n```\n","tags":["计数"],"categories":["coding"]},{"title":"[HDU6638] Snowy Smile","url":"%2F2019%2F08%2F07%2Fproblem-snowy-smile%2F","content":"\nThere are n pirate chests buried in Byteland, labeled by 1,2,…,n. The i-th chest's location is (xi,yi), and its value is wi, wi can be negative since the pirate can add some poisonous gases into the chest. When you open the i-th pirate chest, you will get wi value.\n\nYou want to make money from these pirate chests. You can select a rectangle, the sides of which are all paralleled to the axes, and then all the chests inside it or on its border will be opened. Note that you must open all the chests within that range regardless of their values are positive or negative. But you can choose a rectangle with nothing in it to get a zero sum.\n\nPlease write a program to find the best rectangle with maximum total value.\n\nThe first line of the input contains an integer T(1≤T≤100), denoting the number of test cases.\n\nIn each test case, there is one integer n(1≤n≤2000) in the first line, denoting the number of pirate chests.\n\nFor the next n lines, each line contains three integers xi,yi,wi(−109≤xi,yi,wi≤109), denoting each pirate chest.\n\nIt is guaranteed that ∑n≤10000.\n\n\n## 分析\n首先，我没做出来。\n\n<!--more-->\n\n这道题实际上就是在要求你用小于$O(N^3)$的复杂度求出最大和子矩阵。注意到该题的点**稀疏**，所以以点为考虑对象。\n\n三方的做法，枚举矩阵的上边界和下边界，维护纵向上的和，求最大字段和。当以点考虑时，上下边界就可以直接由**排序后**的点决定。之后，使用线段树维护最大子段和。\n\n## 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconstexpr int MAXN=400010;\n\nll d_sub[MAXN],d_pre[MAXN],d_suf[MAXN];\nll d_sum[MAXN];\nint lc[MAXN],rc[MAXN];\nint idx=0;\nvoid build(int &n,int l,int r){\n    if(!n)n=++idx;\n    d_sum[n]=d_sub[n]=d_pre[n]=d_suf[n]=0;\n    if(l==r){\n        return;\n    }\n    int mid=(l+r)/2;\n    build(lc[n],l,mid);\n    build(rc[n],mid+1,r);\n    //combine data\n}\nvoid collect(int node){\n    d_sum[node]=d_sum[lc[node]]+d_sum[rc[node]];\n\n    d_pre[node]=max(d_pre[lc[node]],d_sum[lc[node]]+d_pre[rc[node]]);\n    d_suf[node]=max(d_suf[rc[node]],d_sum[rc[node]]+d_suf[lc[node]]);\n\n    d_sub[node]=max(max(d_sub[lc[node]],d_sub[rc[node]]),d_suf[lc[node]]+d_pre[rc[node]]);\n}\n\nvoid modify(int x,int l,int r,int L,int R,int node){\n    if(l<=L && R<=r){\n        //only single point to modify\n        d_sub[node]=d_sub[node]+x;\n        d_pre[node]=d_pre[node]+x;\n        d_suf[node]=d_suf[node]+x;\n        d_sum[node]+=x;\n        return;\n    }\n    int mid=(L+R)/2;\n    if(l<=mid)modify(x,l,r,L,mid,lc[node]);\n    if(mid<r)modify(x,l,r,mid+1,R,rc[node]);\n\n    collect(node);\n}\nint root;\nll query_all(){\n    return d_sub[root];\n}\n\nstruct Chest{\n    int x,y,v;\n    bool operator<(const Chest &other)const{\n        if(x==other.x)return y<other.y;\n        return x<other.x;\n    }\n} chests[MAXN];\n\nvector<int> refy;\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    while(kase--){\n        int nlen;cin>>nlen;\n        refy.clear();\n        for(int i=0;i<nlen;i++){\n            Chest &chest=chests[i];\n            cin>>chest.x>>chest.y>>chest.v;\n            refy.push_back(chest.y);\n        }\n        sort(chests,chests+nlen);\n\n        sort(refy.begin(),refy.end());\n        auto refyend=unique(refy.begin(),refy.end());\n        int maxy=0;\n        for(int i=0;i<nlen;i++){\n            chests[i].y=lower_bound(refy.begin(),refyend,chests[i].y)-refy.begin()+1;\n            maxy=max(maxy,chests[i].y);\n        }\n\n        int lastx=0;\n        ll ans=0;\n\n        for(int i=0;i<nlen;i++){\n            if(lastx==chests[i].x)continue;\n            lastx=chests[i].x;\n            //cout<<\"start from \"<<lastx<<endl;\n\n            build(root,1,maxy);\n            int nextx=chests[i].x;\n            for(int j=i;j<nlen;j++){\n                if(chests[j].x!=nextx){\n                    nextx=chests[j].x;\n                    ans=max(ans,query_all());\n                }\n                modify(chests[j].v,chests[j].y,chests[j].y,1,maxy,root);\n            }\n            ans=max(ans,query_all());\n        }\n        cout<<max(0ll,ans)<<endl;\n    }\n\n    return 0;\n}\n```\n\n\n","tags":["线段树"],"categories":["coding"]},{"title":"莫队算法","url":"%2F2019%2F08%2F03%2Fmo-s-algorithm%2F","content":"\n对于可以离线的区间询问问题，莫队算法提出了一种可以在$O(n\\sqrt n)$(无修改)，$n^{3/5}$(带修改)内得出答案的方法。\n\n主要的思路是对询问离线并分块，利用在2个区间间答案的**快速转移**（如果无法找到快速转移的方法，就没法用了）降低复杂度。\n\n<!--more-->\n\n## 无修改莫队\n以$B=\\sqrt{n}$，按照$(l/B,r)$对询问排序。\n\n之后枚举每一个询问，将答案在相邻询问区间间暴力的+1-1转移。\n\n### Problem: 小Y的袜子\n没有在针对哪个人。\n\n作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……\n\n具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。\n\n你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。\n\n袜子的数量最多为50000（是真的🐂🍺）\n\n#### 分析\n这似乎是莫队的例题（\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=50010,MAXQ=50010;\n\nll gcd(ll a,ll b){\n    return !b?a:gcd(b,a%b);\n}\nll c2(ll n){\n    if(n<2)return 0;\n    return n*(n-1)/2;\n}\nint a[MAXN];\nint block=0;\nstruct Q{\n    int l,r;\n    int i;\n    ll ansu,ansd;\n    bool operator<(const Q &b)const{\n        if(l/block!=b.l/block)return l/block<b.l/block;\n        return r<b.r;\n    }\n}qs[MAXQ];\n\nint cnt[MAXN];\nll cup=0,cdown=0;\nvoid remove(int ptr){\n    cup-=c2(cnt[a[ptr]]);\n    cnt[a[ptr]]--;\n    cdown--;\n    cup+=c2(cnt[a[ptr]]);\n}\nvoid add(int ptr){\n    cup-=c2(cnt[a[ptr]]);\n    cnt[a[ptr]]++;\n    cdown++;\n    cup+=c2(cnt[a[ptr]]);\n}\nint main(){\n    int nlen,qlen;cin>>nlen>>qlen;\n    for(int i=1;i<=nlen;i++)cin>>a[i];\n    for(int i=0;i<qlen;i++)cin>>qs[i].l>>qs[i].r;\n    for(int i=0;i<qlen;i++)qs[i].i=i;\n    block=sqrt(nlen);\n    sort(qs,qs+qlen);\n    /*\n    cout<<\"current queries:\"<<endl;\n    for(auto q:qs){\n        cout<<q.l<<\" \"<<q.r<<endl;\n    }\n    cout<<\"=====\"<<endl;\n*/\n    int l=1,r=1;\n    add(1);\n    for(int i=0;i<qlen;i++){\n        Q &q=qs[i];\n        if(q.l==q.r){\n            q.ansu=0;q.ansd=1;\n            continue;\n        }\n        while(q.l<l)add(--l);\n        while(r<q.r)add(++r);\n        while(l<q.l)remove(l++);\n        while(q.r<r)remove(r--);\n\n        q.ansu=cup;\n        q.ansd=cdown;\n        //cout<<cup/c2(cdown)<<endl;\n    }\n    sort(qs,qs+qlen,[](const Q &a,const Q &b){\n            return a.i<b.i;\n            });\n    for(int i=0;i<qlen;i++){\n        if(qs[i].ansd<2){\n            cout<<\"0/1\"<<endl;\n            continue;\n        }\n        ll u=qs[i].ansu;\n        ll d=c2(qs[i].ansd);\n        ll g=gcd(u,d);\n        if(g!=0)u/=g,d/=g;\n        cout<<u<<\"/\"<<d<<endl;\n    }\n\n\n    return 0;\n}\n```\n\n## 带修改莫队\n> 一切都是石x门的选择！\n\n将修改操作平铺在时间线上，计算每次询问所处的时间点，以$B=\\sqrt{n}$，按照$(l/B,r/B,time)$对询问排序。\n\n之后枚举每一个询问，将答案在不同时间线间暴力+1-1跳转，再暴力在相邻询问的区间间+1-1转移。\n\n~~听起来有点中二的意思。~~\n\n### Problem: Game\nAgain Alice and Bob is playing a game with stones. There are N piles of stones labelled from 1 to N, the i th pile has ai stones. \n\nFirst Alice will choose piles of stones with consecutive labels, whose leftmost is labelled with L and the rightmost one is R. After, Bob will choose another consecutive piles labelled from l to r (L≤l≤r≤R). Then they're going to play game within these piles.\n\nHere's the rules of the game: Alice takes first and the two will take turn to make a move: choose one pile with nonegetive stones and take at least one stone and at most all away. One who cant make a move will lose.\n\nBob thinks this game is not so intersting because Alice always take first. So they add a new rule, which is that Bob can swap the number of two adjacent piles' stones whenever he want before a new round. That is to say, if the i th and i+1 pile have ai and ai+1 stones respectively, after this swapping there will be ai+1 and ai.\n\nBefore today's game with Bob, Alice wants to know, if both they play game optimally when she choose the piles from L to R, there are how many pairs (l, r) chosed by Bob that will make Alice *win*.\n\n#### 分析\nnim游戏输赢就是看异或和，异或和可以看前缀异或和内有多少个值相同的点。所以它就是在问一个区间里有多少个相同点对。\n\n带单点修改的区间点对计数。\n\n#### 代码\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=100010,MAXQ=100010;\nconst int MAXPOS=2e6+11;\n\nint nlen,qlen;\nint game[MAXN];\nint pre[MAXN];\nint modified[MAXQ],midx=0,belong[MAXN];\nint block=0;\nstruct Q{\n    int i;\n    int l,r;\n    int tick;\n\n    bool operator<(const Q &b)const{\n //       if(l/block!=b.l/block)return l/block<b.l/block;\n   //     if(r/block!=b.r/block)return r/block<b.r/block;\n        if(belong[l]!=belong[b.l])\n            return belong[l]<belong[b.l];\n        if(belong[r]!=belong[b.r])\n            return belong[r]<belong[b.r];\n        return  tick<b.tick;\n    }\n}q[MAXQ];\nint qidx=0;\nll cache=0;\nint cnt[MAXPOS];\n\ninline void add(int pos){\n    int &c=cnt[pre[pos]];\n    cache-=(ll)c*(c-1)/2;\n    c++;\n    cache+=(ll)c*(c-1)/2;\n}\ninline void rm(int pos){\n    int &c=cnt[pre[pos]];\n    cache-=(ll)c*(c-1)/2;\n    c--;\n    cache+=(ll)c*(c-1)/2;\n}\n\nint l=1,r=1,curt=0;\ninline void jumpup(int tim){\n    if(tim==0)return;\n    int pos=modified[tim];\n    int a=game[pos];\n    int b=game[pos+1];\n    swap(game[pos],game[pos+1]);\n    if(l<=pos && pos<=r){\n        rm(pos);\n    }\n    pre[pos]^=a;\n    pre[pos]^=b;\n    if(l<=pos && pos<=r){\n        add(pos);\n    }\n}\ninline void jumpdown(int tim){\n    jumpup(tim);\n}\n\nll qans[MAXQ];\n\nint main(){\n    //freopen(\"00.in\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&nlen,&qlen)){\n        block=pow(nlen,2.0/3);\n        for(int i=1;i<=nlen;i++){\n            scanf(\"%d\",&game[i]);\n            belong[i]=(i-1)/block;\n        }\n        pre[0]=0;\n        for(int i=1;i<=nlen;i++)pre[i]=pre[i-1]^game[i];\n\n        qidx=0,midx=0;\n        for(int i=1;i<=qlen;i++){\n            int opt;\n            scanf(\"%d\",&opt);\n            if(opt==1){\n                int l,r;\n                scanf(\"%d%d\",&l,&r);\n                q[qidx].i=qidx;\n                q[qidx].l=l;\n                q[qidx].l--;\n                q[qidx].r=r;\n                q[qidx].tick=midx;\n                qidx++;\n            }else if(opt==2){\n                scanf(\"%d\",&modified[++midx]);\n            }\n        }\n        sort(q,q+qidx);\n\n        memset(cnt,0,sizeof(cnt));\n        cache=0;\n        l=r=1;curt=0;\n        add(1);\n        for(int i=0;i<qidx;i++){\n            if(q[i].r-q[i].l+1<2){\n                qans[q[i].i]=0;\n                continue;\n            }\n            while(curt<q[i].tick)jumpup(++curt);\n            while(q[i].tick<curt)jumpdown(curt--);\n\n            while(q[i].l<l)add(--l);\n            while(r<q[i].r)add(++r);\n            while(l<q[i].l)rm(l++);\n            while(q[i].r<r)rm(r--);\n \n            //qans[q[i].i]=cache;\n            ll len=r-l+1;\n            qans[q[i].i]=len*(len-1)/2-cache;\n        }\n        for(int i=0;i<qidx;i++){\n            printf(\"%lld\\n\",qans[i]);\n        }\n    }\n    return 0;\n}\n```\n\n## 注意\n* 关于记录当前问题的区间的开闭问题，需要谨慎安排。\n* 在确认了区间开闭后，关于最初始的状态，需要谨慎安排。","tags":["莫队"],"categories":["study"]},{"title":"Distribution of Books","url":"%2F2019%2F08%2F01%2Fproblem-distribution-of-books%2F","content":"zz6d likes reading very much, so he bought a lot of books. One day, zz6d brought n books to a classroom in school. The books of zz6d is so popular that K students in the classroom want to borrow his books to read. Every book of zz6d has a number i (1<=i<=n). Every student in the classroom wants to get a continuous number books. Every book has a pleasure value, which can be 0 or even negative (causing discomfort). Now zz6d needs to distribute these books to K students. The pleasure value of each student is defined as the sum of the pleasure values of all the books he obtains.Zz6d didn't want his classmates to be too happy, so he wanted to minimize the maximum pleasure of the K classmates. zz6d can hide some last numbered books and not distribute them,which means he can just split the first x books into k parts and ignore the rest books, every part is consecutive and no two parts intersect with each other.However,every classmate must get at least one book.Now he wonders how small can the maximum pleasure of the K classmates be.\n\n1<=T<=10\n\n1<=n<=2*105 \n\n1<=k<=n \n\n-109<=ai<=109\n\n# 分析\n最大值最小，考虑二分答案。思考题目是否具有单调性：当最大值极大时，书可以随便分，当最大值极小时，可能会出现无法凑齐的状况，目测满足。\n\n题目要求分书时必须连续分，可以使用动态规划来做。假设二分的答案为lim\n\n$$f(i)=\\max \\{ f(j) | \\sum_{k=j+1}^i a_k \\leq lim  \\}+1$$\n\n将求和改为前缀和，$pre(i)$。\n\n$$f(i)=\\max \\{ f(j) | pre(i)-pre(j-1) \\leq lim  \\}+1$$\n\n动态规划的复杂度为$O(n^2)$，太慢，考虑优化。\n\n每次转移都从先前已经出现的满足要求的f中转移。限制条件转一下，就是\n\n$$pre(i)-lim \\leq pre(?)$$\n\n* 当有2个f对应的前缀和相同，我们选择更大的那个\n\n所以可以直接维护已经出现的每种前缀和所对应的最大f。可以离散化后使用权值线段树。复杂度变为$O(n\\lg n)$\n\n总复杂度为$O(n\\lg n \\lg n)$。\n\n# 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nusing ll=long long;\nconst int MAXN=900010;\n\nll dat[MAXN];\nint lc[MAXN],rc[MAXN];\nint idx=0;\nint build(int &n,int l,int r){\n    if(!n)n=++idx;\n    dat[n]=-0x3f3f3f3f;\n    if(l>=r)return dat[n];\n\n    int mid=(l+r)/2;\n    dat[n]=max(build(lc[n],l,mid),build(rc[n],mid+1,r));\n    return dat[n];\n}\nvoid collectchild(int node){\n    dat[node]=max(dat[lc[node]],dat[rc[node]]);\n}\n\nint query_n(int l,int r,int L,int R,int node){\n    if(l<=L && R<=r)return dat[node];\n    int mid=(L+R)/2;\n    int res=-0x3f3f3f3f;\n    if(l<=mid)res=max(res,query_n(l,r,L,mid,lc[node]));\n    if(mid<r)res=max(res,query_n(l,r,mid+1,R,rc[node]));\n    return res;\n}\n\nvoid modify(int l,int r,ll x,int L,int R,int node){\n    if(L>=R){\n        dat[node]=max(dat[node],x);\n        return;\n    }\n    int mid=(L+R)/2;\n    if(l<=mid)modify(l,r,x,L,mid,lc[node]);\n    if(mid<r)modify(l,r,x,mid+1,R,rc[node]);\n    collectchild(node);\n}\nll prefix[MAXN];\nll bprefix[MAXN];\nll num[MAXN];\n\nint nlen,sel;\nint rlen;\nint root;\nbool check(ll x){\n    build(root,0,rlen-1);\n\n    int zero=lower_bound(bprefix,bprefix+rlen,0)-bprefix;\n    modify(zero,zero,0,0,rlen-1,root);\n\n    for(int i=1;i<=nlen;i++){\n        int start=lower_bound(bprefix,bprefix+rlen,bprefix[prefix[i]]-x)-bprefix;\n        int dp=query_n(start,rlen-1,0,rlen-1,root)+1;\n        if(dp>=sel)return true;\n        modify(prefix[i],prefix[i],dp,0,rlen-1,root);\n    }\n    return false;\n}\n\n\nint main(){\n    //debug\n    /*\n    int opt;\n    build(root,0,10-1);\n    while(cin>>opt){\n        if(opt==1){\n            int pos,x;cin>>pos>>x;\n            modify(pos,pos,x,0,10-1,root);\n        }else{\n            int l,r;cin>>l>>r;\n            cout<<query_n(l,r,0,10-1,root)<<endl;\n        }\n    }\n    */\n\n    int kase;cin>>kase;\n    while(kase--){\n        cin>>nlen>>sel;\n        for(int i=1;i<=nlen;i++){\n            cin>>num[i];\n        }\n        bprefix[0]=prefix[0]=0;\n        for(int i=1;i<=nlen;i++)bprefix[i]=prefix[i]=prefix[i-1]+num[i];\n        //discrete\n        sort(bprefix,bprefix+nlen+1);\n        rlen=unique(bprefix,bprefix+nlen+1)-bprefix;\n        for(int i=0;i<=nlen;i++)prefix[i]=lower_bound(bprefix,bprefix+rlen,prefix[i])-bprefix;\n\n        \n\n\n        //binary\n        ll l=-1e15,r=1e15;\n        while(l+1<r){\n            ll mid=(l+r)/2;\n            if(check(mid)){\n                r=mid;\n            }else l=mid;\n        }\n        for(ll i=l;i<=r;i++){\n            if(check(i)){\n                cout<<i<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n多组询问没有清理干净数组，WA了好几发。","tags":["离散化"],"categories":["coding"]},{"title":"Fansblog","url":"%2F2019%2F08%2F01%2FFansblog%2F","content":"Farmer John keeps a website called ‘FansBlog’ .Everyday , there are many people visited this blog.One day, he find the visits has reached P , which is a prime number.He thinks it is a interesting fact.And he remembers that the visits had reached another prime number.He try to find out the largest prime number Q ( Q < P ) ,and get the answer of Q! Module P.But he is too busy to find out the answer. So he ask you for help. ( Q! is the product of all positive integers less than or equal to n: n! = n * (n-1) * (n-2) * (n-3) *… * 3 * 2 * 1 . For example, 4! = 4 * 3 * 2 * 1 = 24 )\n\n\nFirst line contains an number T(1<=T<=10) indicating the number of testcases.\nThen T line follows, each contains a positive prime number P (1e9≤p≤1e14)\n\n<!--more-->\n\n\n# 分析\n这题得知道2个结论，然而我都不知道。\n\n## 威尔逊定理\n当P为质数时，$(P-1)! \\equiv -1 \\pmod P$.\n\n注意这里$!$是阶乘，不是取反的意思。\n\n## 素数分布\n当范围变大时，素数的出现频率增高，寻找一素数的相邻素数复杂度逐渐趋近于线性。\n\n所以，寻找素数P的前一个素数可以直接暴力找。找到之后利用$(P-1)! \\equiv -1 \\pmod P$即可快速由$P-1$的阶乘通过逆元转到$Q$的阶乘，这题就做完了。\n\n因为在计算逆元时会爆ll，使用快速乘法来避免，复杂度符合要求。\n\n# 代码\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nusing ll=long long;\ninline ll qmul(ll x,ll y,ll q){\n    ll res=0;\n    for(;y;y>>=1,x=(x+x)%q){\n        if(y&1)res=(res+x)%q;\n    }\n    return res;\n}\n\n\ninline ll qpow(ll x,ll a,ll q){\n    ll res=1;\n    for(a;a;a>>=1,x=qmul(x,x,q)){\n        if(a&1)res=qmul(res,x,q);\n    }\n    return res;\n}\n\ninline ll get_rev(ll x,ll q){\n    return qpow(x,q-2,q);\n}\n\ninline bool is_prime(ll x){\n    for(ll i=2;i<=sqrt(x);i++){\n        if(x%i==0)return false;\n    }\n    return true;\n}\n\ninline ll factor(ll l,ll r,ll q){\n    ll res=1;\n    for(ll i=l;i<=r;i++)res=qmul(res,i,q);\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    int kase;cin>>kase;\n    while(kase--){\n        ll x;cin>>x;\n        ll prex=x-1;\n        while(!is_prime(prex))prex--;\n\n        ll ans=qmul(x-1,get_rev(factor(prex+1,x-1,x),x),x);\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n```","tags":["威尔逊定理"],"categories":["coding"]},{"title":"咸鱼数论","url":"%2F2019%2F07%2F22%2Fnumeric-water%2F","content":"\n## 一些结论\n* $N!$的质因数分解中某质数的指数为$\\sum_{r=1}^{\\inf}n/p^r $\n* 约数个数为质因数指数+1的乘积，和为质因数枚举指数次和的乘积。\n* 费马小定理要求p是质数\n\n## 欧拉函数\n小于x且与其互质的数的个数\n$$\n\\phi(x)=x\\prod_{k=1}^n(1-\\frac{1}{p_k})\n$$\n\n* $phi(1)=1$\n* $phi(p)=p-1$,当p为质数\n* $phi(2n)=phi(n)$\n* $phi(phi(phi...))))=1$\n\n对于任意积性函数$f(xy)=f(x)f(y)$，可以筛。欧拉函数非完全积性函数。\n\n* $phi(xy)=phi(x)(y-1)$,当x与y互质\n* $phi(xy)=phi(x)y$,当x与y不互质\n\n```cpp\nfor(int i=2;i<=n;i++){\n    if(!no[i]){\n        p[++cnt]=i;\n        phi[i]=i-1;\n    }\n    for(int j=1;j<=cnt&&p[j]*i<=n;j++){\n        no[p[j]*i]=1;\n        if(i%p[j]==0){\n            phi[p[j]*i]=phi[i]*p[j];\n            break;\n        }\n        phi[p[j]*i]=phi[i]*(p[j]-1);\n    }\n}\n```\n\n## 扩展欧几里得\n* 存在x，y使得ax+by=gcd（a，b）\n* 求逆元，要求x与模数互质\n\n```cpp\nvoid exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){\n        x=1,y=0;\n    }else{\n        exgcd(b,a%b,y,x);\n        y-=(a/b)*x;\n    }\n}\n```\n\n## 递推逆元\ninv(i) = inv(mod % i) * (mod-mod/i) % mod;\n\n* 阶乘的逆元：inv(i)=inv(i+1)*(i+1)\n","tags":["数论"],"categories":["study"]},{"title":"水的合集 1","url":"%2F2019%2F07%2F22%2Fwaterful-summary-1%2F","content":"\n\n## 集合挑选\n从给定的N个集合中各挑出一个数并求和，求出前$K$大的$K$个和。\n\n考虑如何从2个集合$A$,$B$中选出前$K$大。降序排序后$a_1$和$b_1$显然是最大，第二大则是$(a_1,b_2)$或者$(a_2,b_1)$。不妨以$(a_1,b_2)$来讲，那么第三大竞争者除$(a_2,b_1)$还有$(a_1,b_3)$，$(a_2,b_3)$……每对组合都能找到直接小于它的2个组合，而这种后继关系显然取遍了所有组合。仅需要前K大的我们按需扩展这一棵树即可。2个集合的前K大可与第3个集合执行相同的操作，从而得到最终答案。实际编写时，按照一定顺序限制扩展方向来保证每个方案仅访问一次，使用优先队列维护，复杂度为$O(\\sum^N{K\\log n_k}) \\leq O(KN)$\n\n## LIS优化\n$$f(i)=max\\{f(j)| j < i, a(j) < a(i) \\}+1$$\n\n可以发现，一旦有$a(k) < a(j), f(k) \\geq f(j)$，j这个位置就没有用了。按照该规律维护一个单调栈记录，以长度单调（则数字a结尾的LIS自然单调）。此后转移\n","categories":["study"]},{"title":"明日方舟工具","url":"%2F2019%2F07%2F20%2Farknights-tools%2F","content":"\n{% asset_img img.jpg Penguin Logistics %}\n\n虽然类型完全不一样，但明日方舟大概是我继玩爆Minecraft之后另一个喜欢的游戏了。\n\n<!--more-->\n\nta的设定、剧情、美术、塔防玩法都很对我口味，庞大的世界观以及复杂的人物关系也值得称赞。而且我认为这个游戏很出众的一点是ta的故事不以玩家为中心，一切自有其发展。\n\n## 掉落统计\n已经有非常完善的轮子了……掉落统计改为掉落识别统计，收归到辅助工具内。\n\n## 资源规划\n已经有非常完善的轮子了……\n\n初步设想为基于线性规划的关卡规划安排。正在思考是否有更好的方法或者改进。\n\n## 辅助工具\n这个辅助工具绝不可破坏掉“我认为”的有乐趣的部分，它的开发也会一直坚持这个想法。\n\n独断而带有偏见的思考后，它的功能目前规划为：\n\n1. 单一关卡的重复性战斗代理\n2. 掉落物品自动统计与上传\n\n### 物品识别\n工具目前可以在关卡结束时自动识别屏内的掉落物品和掉落数量，但不稳定。\n\n掉落检测从灰度匹配改为基于特征点的匹配。首先能够自动将掉落物品图片进行突出特征的处理后拆分生成物品特征图，并使用SIFT从特征图中取出不受图像缩放与色差影响的特征点。\n\n此后再次使用时，与预设特征点比较从而找到对应的掉落物品编码，从数据库中提取出名称。\n\n掉落数量是对切分出来的数字图片调用`tesseract`进行OCR识别，然而这个准确率实在堪忧。对图片的预处理似乎效果并不怎么好，之后（也许）会想办法再改改。\n\n物品掉落的统计信息未来也许能够实现向已有的数据库对接。\n\n## 关卡压力分析\n进攻重放与防守压力的分析工具。\n\n## ？\n非常远期的目标：\n\n* 研究能够研究关卡过法的算法大概率有乐趣","tags":["小工具"],"categories":["projects"]},{"title":"[BUPT WARMUP|CF] 珍珠奶茶","url":"%2F2019%2F07%2F20%2Fproblem-bupt-milk-tea%2F","content":"\n\n给出一个$N \\times N$的非负整数矩阵，要求找到一条从左上角数字到右下角数字的路线，且\n\n* 只能向右或者下走。\n* 将经过数字相乘后得到的结果，使其末尾的“0”最少。\n\n$$\nN \\leq 1000\n$$\n\n<!--more-->\n\n## 分析\n大概是因为末尾的0长得像珍珠。\n\n思考0是怎么出现的，可以发现结果中因数10的指数越小越好，即，使得经过的路上凑出的因数10最少即可。10的质因数分解为$2 \\times 5$，以矩阵中每个数所含因数2和5的数目分别DP一遍求路径，再在两次DP的结果中取小。\n\n一个特殊情况是数字里有0，那么经过0的路的末尾0一定是1个……一开始脑袋抽了以为是0个。如果其他情况的路径末尾0都多于1个的话，就特判走0。\n\n## 代码 \n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconstexpr int MAXN=1010;\n\nint game[MAXN][MAXN];\nint num[2][MAXN][MAXN];\nint cal(int x,int fac){\n    if(x==0)return 0;\n    int res=0;\n    while(x%fac==0){\n        x/=fac;\n        res++;\n    }\n    return res;\n}\nint n;\nint dp[MAXN][MAXN];\nint from[MAXN][MAXN];\nvoid dodp(int fac){\n    for(int i=0;i<MAXN;i++){\n        for(int j=0;j<MAXN;j++){\n            dp[i][j]=0x3f3f3f3f;\n        }\n    }\n    dp[0][1]=dp[1][0]=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(dp[i-1][j]<dp[i][j-1]){\n                from[i][j]=2;\n                dp[i][j]=dp[i-1][j];\n            }else{\n                from[i][j]=1;\n                dp[i][j]=dp[i][j-1];\n            }\n            dp[i][j]+=num[fac][i][j];\n        }\n    }\n}\nstring genpath(){\n    string res=\"\";\n    int i=n,j=n;\n    for(int p=from[i][j];i!=1 || j!=1 ;p=from[i][j]){\n        if(p==2){\n            res+=\"D\";\n            i--;\n        }else{\n            res+=\"R\";\n            j--;\n        }\n    }\n    reverse(res.begin(),res.end());\n    return res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin>>n;\n    bool haszero=false;\n    int zeroi,zeroj;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            cin>>game[i][j];\n            if(game[i][j]==0){\n                haszero=1;\n                zeroi=i,zeroj=j;\n            }\n        }\n    }\n    \n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            num[0][i][j]=cal(game[i][j],2);\n            num[1][i][j]=cal(game[i][j],5);\n        }\n    }\n    int ans=0x7f7f7f7f;\n    dodp(0);\n    string P;\n    if(ans>dp[n][n]){\n        ans=dp[n][n];\n        P=genpath();\n    }\n    dodp(1);\n    if(ans>dp[n][n]){\n        ans=dp[n][n];\n        P=genpath();\n    }\n\n    if(haszero && ans>1){\n        cout<<1<<endl;\n        for(int i=1;i<zeroi;i++)cout<<\"D\";\n        for(int j=1;j<zeroj;j++)cout<<\"R\";\n        for(int i=zeroi+1;i<=n;i++)cout<<\"D\";\n        for(int j=zeroj+1;j<=n;j++)cout<<\"R\";\n        cout<<endl;\n        return 0;\n    }\n\n    cout<<ans<<endl;\n    cout<<P<<endl;\n\n    return 0;\n}\n```\n","tags":["数论"],"categories":["coding"]},{"title":"blog迁移","url":"%2F2019%2F07%2F13%2Fblog-upgrade%2F","content":"\n{% asset_img girl.jpg %}\n\n又回到了静态blog😀.果然这样才是最吼的.\n\n## 静态blog编译器\n现在流行的静态blog编译器大概有这么几种\n\n* `Node.js`的`Hexo`\n* `Python`的`Pelican`\n* `Ruby`的`Jekyll`\n* `Golang`的`Hugo`\n\n<!--more-->\n\n## 使用Github pages\nGithub为用户准备了免费的pages服务,能够展示静态页面,满足我们的要求.\n\n为了使用Github pages,需要新建项目`<username>.github.io`,将文件push上去后,访问相应的域名`https://<username>.github.io`就能看到.\n\n使用github提供的域名也可以,一般来说为了~~装逼~~达到更好的展示效果,会将pages再和自己的域名绑定.\n\n### 域名解析过程\n当访问一个网站时,经过了这么几个过程.\n\n1. 用户访问域名`DOMAIN`\n2. 系统向DNS服务器询问`DOMAIN`所对应的IP(或者其他域名)地址.\n3. 浏览器向该IP地址发送请求.\n4. 浏览器将该IP返回的数据渲染为网页.\n\n因此为了让自己的域名指向pages服务,需要这么几步.\n\n#### 在DNS服务器配置记录\n对DNS服务器说明域名所指向的地址.在此,我们将域名指向pages的域名`<username>.github.io`.该类记录的类型为`CNAME`,按照页面相关提示填写即可.\n\n#### 在Github配置接收来源\n之后,要告诉github当其接收到标注自我们的域名的请求时,要做出对应的相应.\n\n在项目中添加文件`CNAME`,内写一行,为我们的域名.\n\n## 启用SSL\n启用SSL治疗各种劫持.\n\n因为pages不原生支持SSL,可以使用cloudflare的服务来启用SSL.\n\n注册cloudflare后,按照指示,将域名的解析服务器改为cloudflare,一段时间后解析生效即可开启SSL.\n\n你还可以加一条Rule,强制把HTTP转到HTTPS,治疗一下剥离攻击."},{"title":"Colorful Tree","url":"%2F2019%2F07%2F12%2Fcolorful-tree%2F","content":"\n\nThere is a tree having n nodes, the i-th node of which has a type of color, denoted by an integer $c_i$\n\nThe path between every two nodes is unique, of which we define the value is the number of distinct types of colors appearing on it.\n\nCalculate the sum of values of all possible paths, $\\frac{n(n-1)}{2}$ in total, between two different nodes on the tree.\n\n## 输入范围\n多组数据,约50;节点数$2 \\times 10^5$.\n\n# 分析\n没想出来该怎么做.统计路径颜色的答案没有什么合并的好方法,同时也不能按照每种颜色单独考虑.\n\n后来经过dalao点拨,该题中的\"统计一条路径上颜色种类\"的要求可以转化为求其**反面**\"没有某种颜色的路径有多少种\".\n\n如此,对于每一种颜色就可以使用$n(n-1)/2-size$来求其对答案的贡献了.So,来解决这个问题.\n\n原图是一棵树,如果某点$N$为颜色$c$,那么经过$N$的子树任意点跨越$N$的路径都有该颜色.所有不包括该颜色$c$的路径只**能**出现在以$N$为切点的其他2部分.考虑其中一个部分,任意选中其中2个节点即可构建一条路径,但还是必须满足刚刚的条件(不能跨越颜色$c$的节点).以dfs递归进去即可.\n\n考虑能否递归合并已有答案.能够得到的数据有*子节点中2部分的节点数目*,显然能够合并出以当前节点为界划分的2部分中的一部分,自然可以在递归返回后推出另一部分.\n\n# 代码\n```cpp\n#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXV=200010;\nvector<int> g[MAXV];\ninline void adde(int u,int v){\n    g[u].push_back(v);\n}\nint color[MAXV];\nll sz[MAXV];\nll gsz;\nll res=0;\nvoid dfs(int u,int fa){\n    gsz++;\n    for(auto v:g[u]){\n        if(v==fa)continue;\n        ll b_gsz=gsz;\n        ll b_sz=sz[color[u]];\n        dfs(v,u);\n\n        ll d=(gsz-b_gsz)-(sz[color[u]]-b_sz);\n        res+=d*(d-1)/2;\n        sz[color[u]]+=d;\n    }\n    sz[color[u]]++;\n}\nint flag[MAXV];\nint main(){\n    ios::sync_with_stdio(false);\n    int n;\n    int kase=0;\n    while(cin>>n){\n        for(int i=1;i<=n;i++)g[i].clear();\n        memset(sz,0,sizeof(sz));\n        gsz=0;\n        res=0;\n\n        vector<int> discol;\n        for(int i=1;i<=n;i++){\n            cin>>color[i];\n            flag[color[i]]=1;\n        }\n        for(int i=1;i<=n;i++){\n            if(flag[i])discol.push_back(i);\n        }\n        for(int i=0;i<n-1;i++){\n            int u,v;cin>>u>>v;\n            adde(u,v);\n            adde(v,u);\n        }\n\n        int disnum=discol.size();\n        dfs(1,0);\n        ll ans=(ll)disnum*n*(n-1)/2;\n        for(auto i:discol){\n            ll t=n-sz[i];\n            ans-=t*(t-1)/2;\n        }\n        cout<<\"Case #\"<<++kase<<\": \"<<ans-res<<endl;\n    }\n\n    return 0;\n}\n```","categories":["coding"]},{"title":"快速傅里叶变换","url":"%2F2019%2F07%2F12%2Ffft%2F","content":"\n> 写代码是不可能写代码的,今下午是不想写代码的.不想写代码,又不想咸鱼,就只能靠学点新东西来假装自己在工作的样子,心里才能好受些.\n>\n> > 窃格码拉\n\n把2年前就听过但是没学的FFT这次看看吧.\n\n几乎可以肯定,下面的内容肯定会出锅.\n\n<!--more-->\n\n## 傅里叶变换的实际意义\n### 从电压说起\n被模电折磨的同学都知道,有种东西叫做傅里叶级数,可以将成周期性变化的电压分解为数个三角函数波的叠加.\n\n在这里,我们提出另一个问题,如果不知道周期,该如何将这些叠加在一起的信号拆分为单纯的三角波?\n\n> 三角波叠加图象周期并不那么显然,也许你可以试一试.\n\n### 一种缠绕机\n有一种奇特的方法,我们将一段`时域图象`在笛卡尔坐标系上以原点为圆心**绕**起来,一圈一圈缠起来,然后调整源图象缠绕的速率(几秒一圈),观察整个图形的**质心**变化.\n\n这个质心会随着图象缠绕的频率而发生位移.取质心的x坐标为y轴,以缠绕的频率为横轴,作出图象`B`.在这个图象上,会观测到一个现象:(假设我们已知原图像的分解三角波频率)当缠绕频率接近某个源三角波的频率时,缠绕图象出现**重合**,质心相对原点出现较大位移,图象出现一个**峰值**.\n\n继续调整缠绕频率,峰值消失,图象回归到小范围波动.\n\n通过观察图象`B`,可以认为,出现峰值的频率对应着一个频率的源三角波.如此,就将叠加图象还原了回去.\n\n## 傅里叶变换的数学实现\n现在,考虑如何通过的数学的方法来实现这个缠绕.\n\n### 如何缠绕\n将$g(t)$的图象缠绕到圆上听起来挺奇怪的,有这样的数学方法吗.\n\n有一个东西,叫做$y=e^{ix}$.当其图象画在复平面时,就出现了有趣的事情:一个圆.对这个公式做一些加工.\n\n$$\ny=g(t)e^{-2\\pi i ft}\n$$\n\n如此,就能够将$g(t)$以$f$频率缠绕.\n\n### 关于质心\n上文我们取质心的x坐标作图,现在需要稍微修改一下.\n\n实际上,我们关心的是质心相对于原点的偏移**距离**.同样,以复平面的方式来表示质心位置就能够同时保留x和y坐标信息.\n\n关于如何求取质心,其实也很直观.选取缠绕图象上的数个点,取平均,就是质心的大约位置.当点的数目达到极限,求和公式化为积分,所求即为质心.\n\n$$\n\\hat g(f)=\\frac{1}{t_2-t_1} \\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}}\n$$\n\n### ?\n目前为止,这几乎已经是傅里叶变换了.在数学应用时,傅里叶变换会去掉取均值,即\n\n$$\n\\hat g(f)=\\int_{t_1}^{t_2}{g(t)e^{-2\\pi i ft}}\n$$\n\n也就是说,取样的时域信号越长,该质心的偏移倾向越大,这和我们想要的效果一致.\n\n这就是傅里叶变换,实现了`时域信号`到`频域信号`的转换.\n\n此外,还有方法将频域信号再次逆变换为时域信号的方法.\n\n## 应用\n傅里叶变换在很多领域都有重要作用.只要问题能转换为时域频域之间的变化,就有傅里叶变换的用武之处.\n\n比如,在音频处理软件中,常常有一个功能叫做`消除人声`.基于傅里叶变换我们可以设计一个(至少理论上有用)的算法.\n\n首先,任何声音都是相应频率的波对气压变化引起的,也就是不同**频率**的波在**时间**上叠加在一起,产生了声音.将源波使用傅里叶变换拆分到多个三角波上去.**删除人声所在的频域**,再将频域信号逆变换为时域信号.人声便消失了.\n\n## 离散傅里叶变换\n连续意义下的傅里叶变换先到此为止.在计算机中所处理的数据一般都是离散的.我们需要的是离散傅里叶变换.\n\n离散意义下的时域信号和频域信号就都变成了点集.当从连续向离散过渡时,可以这样思考:\n\n> 在连续的图象上以一定间隔**取样**得到离散点集.使用该点集进行傅里叶变换.\n\n这也是我们一开始采取的质心求解方法,只不过,这次我们从缠绕时就取样.(质点依然是真正的质点)\n对于点集$g(0\\leq n < N)$,它的傅里叶变化就是\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\n简单粗暴.\n\n## 快速傅里叶变换\n在了解了关于傅里叶变换的一系列背景与一个应用后,我们再回来解决一些重要的问题.\n\n根据傅里叶变换的公式定义\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\n其朴素算法的时间复杂度为$O(N^2)$ 这个复杂度还不够优秀.一种快速傅里叶变换算法利用$e^{ix}$的性质,将复杂度降低到了$O(N\\lg N)$.\n\n### 单位根\n给$e^{ix}$个名字.\n\n在数学上, $n$次**单位根**是 $n$次幂为1的复数.它们位于复平面的单位圆上,构成正n边形的顶点,其中一个顶点是1.\n\n记\n\n$$\n\\omega_{n,k}=-e^{i\\frac{2\\pi}{n}k}\n$$\n\n其几何意义为单位圆上的n等分点的顺时针第k个.\n\n> 一般来说,单位根取逆时针,不过这里为了方便,取顺时针.\n\n如同三角函数一样,单位根存在一些显然的定理.\n\n**折半:**$\\omega_{2n,2k}=\\omega_{n,k}$\n\n**化简:**$\\omega_{n,k+\\frac 2n}=-\\omega_{n,k}$\n\n#### 修改公式\n来看原本的离散傅里叶变换公式\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}g(n)e^{-i\\frac {2\\pi}{N}nk}\n$$\n\n使用单位根来替换一下\n\n$$\n\\hat g(k)=\\sum_{n=0}^{N-1}\\omega_{N,nk} g(n)\n$$\n\n按照~~神~~化简公式的指引,将求和公式按照单位根奇偶拆分为2部分.\n\n​                                                                                                              \n$$\n\\begin{aligned}\n\\hat g(k) &= \\sum_{n=0}^{N-1}\\omega_{N,nk} g(n) \\\\\n&= \\sum_{0 \\leq n < N}\\omega_{N,nk} g(n) \\\\\n&= \\sum_{0 \\leq 2n < N}\\omega_{N,2nk} g(2n) + \\sum_{0 \\leq 2n+1 < N}\\omega_{N,(2n+1)k} g(2n+1) \\\\\n&=\\sum_{0 \\leq 2n < N}\\omega_{N,2nk} g(2n) + \\sum_{0 \\leq 2n+1 < N}\\omega_{N,2nk+k} g(2n+1) \\\\\n&=\\sum_{0 \\leq 2n < N}\\omega_{\\frac N2,nk} g(2n) + \\omega_{N,k}\\sum_{0 \\leq 2n+1 < N}\\omega_{\\frac N2,nk} g(2n+1) \\\\\n&=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k)\n\\end{aligned}\n$$\n\n注意到不管是$\\hat g_{even}(k)$还是$\\hat g_{even}(k)$,它们都以$N/2$为周期.接下来,应用化简定理\n\n$$\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\n将这2个式子放在一起\n\n$$\n\\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\n当k取遍原问题规模的一半时,可以直接由第二个式子得到另一半.问题的规模减半.递归求解,最终的复杂度就降到了$O(N \\lg N)$.\n\n这就是`Cooley-Turkey`快速傅里叶变换算法.\n\n## 快速乘法\n定义多项式$A(x)=\\sum_k a_kx^{k+1}$,$B(x)$同理,求解$C(x)=A(x)B(x)$.\n\n很容易看出,朴素算法的复杂度为$O(N^2)$.\n\n现在,来看如何使用FFT快速计算.\n\n### 点值表示\n> 对于一个次数为$n-1$的多项式,其图象上互不相同的$n$个点可以唯一确定该多项式.\n> ...\n> 如同确定混合在一起的几个波一样.\n\n至于为什么是对的,大可在Google上搜索一番.\n\n取$x$为数个单位根,在$A(x)$和$B(x)$上利用单位根的性质得到$A$和$B$的点值表示,将点值相乘得到$C$的点值表示.之后,将$C$的点值表示再转换为系数表示.\n\n嗯?FFT在哪?\n\n其实在这里,\n\n$$\n\\hat g(\\omega)=A(\\omega)=\\sum_{n}\\omega A[x^{n+1}]\n$$\n\n### 离散卷积\n有一种**数学运算**,叫做**卷积**.现在只讨论它的离散情况.\n\n$$\n(f * g)(n)=\\sum_{\\tau=-\\inf}^{inf}f(\\tau)g(n-\\tau)\n$$\n\n这玩意的意义...实在是不怎么明显.不过好在我们只是想算个多项式乘法,也就是把多项式的**系数**算来算去:\n\n$C[x^n]$ 表示多项式$C$中$x^n$项的系数.\n\n$$\nC[x^{n}]=\\sum_{\\tau=0}^{n}A[x^\\tau]B[x^{n-\\tau}]\n$$\n\n嗯?\n\n如果我们设多项式中不存在的项的系数为0的话.\n\n$$\nC[x^{n}]=\\sum_{\\tau=-\\inf}^{\\inf}A[x^\\tau]B[x^{n-\\tau}]\n$$\n\n哈,\n\n$$\nC[x^n]=(A*B)[x^n]\n$$\n### 卷积定理\n卷积定理指出:\n\n> 一个域中的卷积对应于另一个域中的乘积.\n\n这意味着,上面这个计算(卷积)对应着另一个域里的乘积.也就是\n\n$$\nF(C[x^n])=F(A[x^n]) \\cdot F(B[x^n])\n$$\n\n这便是深层原理.对A和B的取样(频域)称为A和B的点值表示,最终以乘积的方式得到了C的点值表示(频域).用FFT来计算乘法的说法是对的.\n\n## 傅里叶逆变换\n如何从一个频域信号再得到时域信号?\n\n$$\ng(n)=\\frac 1N\\sum_{k=0}^{N-1}e^{i\\frac{2\\pi}{N}nk} \\hat g(k)\n$$\n\n> 注意:此处的1/N与上面的变换是相匹配的.\n\n这个式子可以理解成对变换后的式子再变换,意味着它同样可以用变换时的思想来加速.\n\n## FFT的C++实现\n一个值得注意的问题就是,对于单位根的运算涉及到了精度的问题.但目前还不需要讨论.\n\n### 翻转操作\n可以观察到,按照上面的算法实现,我们需要在每次递归按照奇和偶将取样分组.且每次递归都会分组.每次分组都会涉及到数组的复制,常数较大.\n\n观察分组操作中下标的变化.\n\n```\n(表示下标)\n0 1 2 3 4 5 6 7\n0 2 4 6 | 1 3 5 7\n0 4 | 2 6 | 1 5 | 3 7\n```\n\n将其转换为二进制\n```\n000 001 010 011 100 101 110 111\n000 100 010 110 001 101 011 111\n```\n\n可以发现,最终的分组结果就是将原下标二进制翻转.所以可以直接一次完成分组.\n\n注意,**这要求取样为2的幂次**.\n\n### 🦋蝴蝶操作\n解决了递归中由顶至底的分组后,接下来优化子问题合并时的数组复制.\n\n观察原来的合并式子\n\n$$\n\\hat g(k)=\\hat g_{even}(k)+\\omega_{N,k} \\hat g_{odd}(k) \\\\\n\\hat g(k+\\frac N2)=\\hat g_{even}(k)-\\omega_{N,k} \\hat g_{odd}(k)\n$$\n\n按照算法中的实现方法,其为\n\n$$\n\\hat g(k)=\\hat g(k)+\\omega_{N,k} \\hat g(k+\\frac N2) \\\\\n\\hat g(k+\\frac N2)=\\hat g(k)-\\omega_{N,k} \\hat g(k+\\frac N2)\n$$\n\n想要省略数组复制,进行原地合并,问题出在新数值太早地替换掉了我们需要的数值.\n\n取辅助变量,修改原式\n\n$$\nt=\\omega_{N,k} \\hat g(k+\\frac N2)\\\\\n\\hat g(k+\\frac N2)=\\hat g(k)-t\\\\\n\\hat g(k)=\\hat g(k)+t\n$$\n\n这个操作被称为\"蝴蝶操作\",名字很有意思.\n\n### 代码\n在这段代码中同时去掉了递归.\n\n```cpp\nconst double PI=acos(-1);\n\ninline complex<double> gomega(int n,int k,bool rev=false){\n    complex<double> res(cos(2*PI/n*k),sin(2*PI/n*k));\n    if(rev)return conj(res);\n    else return res;\n}\nconst int MAXN=10;\nstruct FFT{\n    complex<double> omega[MAXN],omegaI[MAXN];\n\n    FFT(int n){\n        for(int i=0;i<n;i++){\n            omega[i]=gomega(n,i);\n            omegaI[i]=gomega(n,i,1);\n        }\n    }\n    void transform(complex<double> *a,int n,const complex<double> *omega){\n        for(int i=0,j=0;i<n;i++){\n            if(i>j)swap(a[i],a[j]);\n            //二进制换位\n            for(int l=n/2;(j^=l)<l;l>>=1);\n        }\n        for(int l=2;l<=n;l<<=1){\n            int m=l/2;\n            for(complex<double> *p=a;p!=a+n;p+=l){\n                for(int i=0;i<m;i++){\n                //蝴蝶操作\n                    complex<double> t=omega[n/l*i]*p[m+i];\n                    p[m+i]=p[i]-t;\n                    p[i]+=t;\n                }\n            }\n        }\n    }\n    void dft(complex<double> *a,int n){\n        transform(a,n,omega);\n    }\n    void idft(complex<double> *a,int n){\n        transform(a,n,omegaI);\n        for(int i=0;i<n;i++)a[i]/=n;\n    }\n};\n```\n\n如果想要实现快速乘法,只要将2个多项式的系数函数传入进行变换,变换结果相乘并逆变换即可.\n\n#### 应用\n\n##### 快速乘法\n指快速大数乘法。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN=300000;\nconst double PI=acos(-1);\n\ninline complex<double> gomega(int n,int k,bool rev=false){\n    complex<double> res(cos(2*PI/n*k),sin(2*PI/n*k));\n    if(rev)return conj(res);\n    else return res;\n}\nstruct FFT{\n    complex<double> omega[MAXN],omegaI[MAXN];\n\n    FFT(){\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            omega[i]=gomega(n,i);\n            omegaI[i]=gomega(n,i,1);\n        }\n    }\n\n    void transform(complex<double> *a,int n,const complex<double> *omega){\n        for(int i=0,j=0;i<n;i++){\n            if(i>j)swap(a[i],a[j]);\n            //二进制换位\n            for(int l=n/2;(j^=l)<l;l>>=1);\n        }\n        for(int l=2;l<=n;l<<=1){\n            int m=l/2;\n            for(complex<double> *p=a;p!=a+n;p+=l){\n                for(int i=0;i<m;i++){\n                    //蝴蝶操作\n                    complex<double> t=omega[n/l*i]*p[m+i];\n                    p[m+i]=p[i]-t;\n                    p[i]+=t;\n                }\n            }\n        }\n    }\n    void dft(complex<double> *a,int n){\n        transform(a,n,omega);\n    }\n    void idft(complex<double> *a,int n){\n        transform(a,n,omegaI);\n        for(int i=0;i<n;i++)a[i]/=n;\n    }\n};\n\ncomplex<double> a[2][MAXN];\nint ans[MAXN];\nFFT fft;\nint main(){\n\n    int nlen;cin>>nlen;\n    int n=1;\n    //根据原理，\b\bn必须取大于2nlen的数，才能满足取样要求和反转操作要求\n    while(n<2*nlen)n*=2;\n    fft.init(n);\n\n\n    for(int i=0;i<2;i++){\n        string inp;cin>>inp;\n        for(int j=0,k=inp.size()-1;j<inp.size();j++,k--){\n            a[i][j]=complex<double>(inp[j]-'0',0);\n        }\n        fft.dft(a[i],n);\n    }\n    for(int i=0;i<n;i++)a[0][i]=a[0][i]*a[1][i];\n    fft.idft(a[0],n);\n    int reslen=nlen+nlen-1;\n    for(int i=reslen-1,k=0;i>=0;i--,k++)\n        ans[k]=(int)floor(a[0][i].real()+0.5);\n    /*\n    for(int i=0;i<reslen;i++)cout<<ans[i]<<\" \";\n    cout<<endl;\n    */\n    for(int i=0;i<MAXN;i++){\n        ans[i+1]+=ans[i]/10;\n        ans[i]%=10;\n    }\n    int ptr=MAXN-1;\n    while(ans[ptr]==0)ptr--;\n    for(;ptr>=0;ptr--)cout<<ans[ptr];\n    cout<<endl;\n\n    return 0;\n}\n```","categories":["study"]},{"title":"did-i-write-qsort-right","url":"%2F2019%2F07%2F12%2Fdid-i-write-qsort-right%2F","content":"众所周知，快速排序的时间复杂度是$O(n\\lg n)$的。然而因为我太菜，写出来的快速排序一不小心就成了$O(n^2)$...\n\n<!--more-->\n\n## 这个辣鸡问题\n这个应该都知道，当待排序数组已经有序时，固定选择某一个位置的数字当哨兵的快排会变成$O(n^2)$。一个解决方法就是随机选择哨兵，或者干脆将输入的数组打乱后再排序。\n\n然而，如果输入的数组数字全部相同呢？\n\n当然这在实际中很少见，但是在实现的时候就要小心。在这种情况下，所实现的快排必须对于相同数字也交换位置，否则就会退化为$O(n^2)$。\n\n比如说，这个\n```cpp\n    void quicksort(int left,int right)\n    {\n    int i,j,t,temp;\n    if(left>right)\n       return;\n\n    temp=a[left]; //temp中存的就是基准数\n    i=left;\n    j=right;\n    while(i!=j)\n    {\n       //顺序很重要，要先从右边开始找\n       while(a[j]>=temp && i<j)\n    j--;\n       //再找右边的\n       while(a[i]<=temp && i<j)\n    i++;\n       //交换两个数在数组中的位置\n       if(i<j)\n       {\n    t=a[i];\n    a[i]=a[j];\n    a[j]=t;\n       }\n    }\n    //最终将基准数归位\n    a[left]=a[i];\n    a[i]=temp;\n\n    quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程\n    quicksort(i+1,right);//继续处理右边的 ，这里是一个递归的过程\n    }\n```\n还有这个，\n```cpp\nvoid quick_sort(int s[], int l, int r)\n{\n    if (l < r)\n    {\n\t\t//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1\n        int i = l, j = r, x = s[l];\n        while (i < j)\n        {\n            while(i < j && s[j] >= x) // 从右向左找第一个小于x的数\n\t\t\t\tj--;  \n            if(i < j) \n\t\t\t\ts[i++] = s[j];\n\t\t\t\n            while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数\n\t\t\t\ti++;  \n            if(i < j) \n\t\t\t\ts[j--] = s[i];\n        }\n        s[i] = x;\n        quick_sort(s, l, i - 1); // 递归调用 \n        quick_sort(s, i + 1, r);\n    }\n}\n\n```\n它们都会跳过相同的数字，每次排序后哨兵总会在边界上，导致算法劣化到$O(n^2)$。\n\n大概就是这回事，没别的了。这种情况当然有改进的快速排序可以直接避免这种罕见的情况，在不大幅度改动算法的前提下，就要对相同的元素也进行换位才可以，即使会增加交换次数。","tags":["排序"],"categories":["闲扯"]},{"title":"基于PBDS的splay","url":"%2F2019%2F07%2F12%2Fimplment-of-splay-based-on-PBDS%2F","content":"\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntree<int,null_type,greater<int>,rb_tree_tag,tree_order_statistics_node_update> bbt;\nmap<int,string> ef;\nint main(){\n    int n;cin>>n;\n    while(n--){\n        int op;\n        cin>>op;\n        if(op==1){\n            string name;\n            int value;\n            cin>>name>>value;\n            ef[value]=name;\n            bbt.insert(value);\n        }else if(op==2){\n            int v;cin>>v;\n            if(!bbt.erase(v))cout<<\"NO\"<<endl;\n            else cout<<ef[v]<<endl;\n        }else if(op==3){\n            int v;cin>>v;\n            if(bbt.find(v)==bbt.end())cout<<\"NO\"<<endl;\n            else cout<<bbt.order_of_key(v)+1<<endl;\n        }else if(op==4){\n            int r;cin>>r;\n            r--;\n            auto it=bbt.find_by_order(r);\n            if(it!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }else if(op==5){\n            int v;cin>>v;\n            auto it=bbt.find(v);\n            if(it!=bbt.end() && (--it)!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }else if(op==6){\n            int v;cin>>v;\n            auto it=bbt.find(v);\n            if(it!=bbt.end() &&(++it)!=bbt.end())cout<<ef[*it]<<endl;\n            else cout<<\"NO\"<<endl;\n        }\n    }\n    return 0;\n}\n\n```","tags":["splay"]}]